{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dj-stripe - Django + Stripe Made Easy Stripe Models for Django. Introduction dj-stripe implements all of the Stripe models, for Django. Set up your webhook endpoint and start receiving model updates. You will then have a copy of all the Stripe models available in Django models, as soon as they are updated! The full documentation is available on Read the Docs . Features Stripe Core Stripe Billing Stripe Cards (JS v2) and Sources (JS v3) Payment Methods and Payment Intents (SCA support) Support for multiple accounts and API keys Stripe Connect (partial support) Tested with Stripe API 2020-08-27 (see API versions ) Requirements Django 2.2+ Python 3.6+ PostgreSQL engine (recommended) 9.5+ MySQL engine: MariaDB 10.2+ or MySQL 5.7+ SQLite: Not recommended in production. Version 3.26+ required. Installation Get the distribution Install dj-stripe with pip: pip install dj-stripe Or with Poetry (recommended): poetry add dj-stripe Configuration Add djstripe to your INSTALLED_APPS : INSTALLED_APPS =( ... \"djstripe\" , ... ) Add to urls.py: path ( \"stripe/\" , include ( \"djstripe.urls\" , namespace = \"djstripe\" )) , Tell Stripe about the webhook (Stripe webhook docs can be found here ) using the full URL of your endpoint from the urls.py step above (e.g. https://example.com/stripe/webhook ). Add your Stripe keys and set the operating mode: STRIPE_LIVE_SECRET_KEY = os.environ.get ( \"STRIPE_LIVE_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_TEST_SECRET_KEY = os.environ.get ( \"STRIPE_TEST_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_LIVE_MODE = False # Change to True in production DJSTRIPE_WEBHOOK_SECRET = \"whsec_xxx\" # Get it from the section in the Stripe dashboard where you added the webhook endpoint DJSTRIPE_USE_NATIVE_JSONFIELD = True # We recommend setting to True for new installations DJSTRIPE_FOREIGN_KEY_TO_FIELD = \"id\" Note djstripe expects STRIPE_LIVE_MODE to be a Boolean Type. In case you use Bash env vars or equivalent to inject its value, make sure to convert it to a Boolean type. We highly recommended the library django-environ Add some payment plans via the Stripe.com dashboard. Run the commands: python manage.py migrate python manage.py djstripe_sync_models See here for notes about usage of the Stripe Elements frontend JS library. Running Tests Assuming the tests are run against PostgreSQL: createdb djstripe pip install tox tox Changelog See release notes on Read the Docs . Funding and Support You can now become a sponsor to dj-stripe with GitHub Sponsors . We've been bringing dj-stripe to the world for over 7 years and are excited to be able to start dedicating some real resources to the project. Your sponsorship helps us keep a team of maintainers actively working to improve dj-stripe and ensure it stays up-to-date with the latest Stripe changes. If you use dj-stripe commercially, we would encourage you to invest in its continued development by signing up for a paid plan . Corporate sponsors receive priority support and development time . All contributions through GitHub sponsors flow into our Open Collective , which holds our funds and keeps an open ledger on how donations are spent. Our Gold sponsors img[alt=\"Stripe Logo\"] { max-width: 250px; } Similar libraries dj-paypal ( PayPal ) dj-paddle ( Paddle )","title":"Home"},{"location":"#dj-stripe-django-stripe-made-easy","text":"Stripe Models for Django.","title":"dj-stripe - Django + Stripe Made Easy"},{"location":"#introduction","text":"dj-stripe implements all of the Stripe models, for Django. Set up your webhook endpoint and start receiving model updates. You will then have a copy of all the Stripe models available in Django models, as soon as they are updated! The full documentation is available on Read the Docs .","title":"Introduction"},{"location":"#features","text":"Stripe Core Stripe Billing Stripe Cards (JS v2) and Sources (JS v3) Payment Methods and Payment Intents (SCA support) Support for multiple accounts and API keys Stripe Connect (partial support) Tested with Stripe API 2020-08-27 (see API versions )","title":"Features"},{"location":"#requirements","text":"Django 2.2+ Python 3.6+ PostgreSQL engine (recommended) 9.5+ MySQL engine: MariaDB 10.2+ or MySQL 5.7+ SQLite: Not recommended in production. Version 3.26+ required.","title":"Requirements"},{"location":"#installation","text":"","title":"Installation"},{"location":"#get-the-distribution","text":"Install dj-stripe with pip: pip install dj-stripe Or with Poetry (recommended): poetry add dj-stripe","title":"Get the distribution"},{"location":"#configuration","text":"Add djstripe to your INSTALLED_APPS : INSTALLED_APPS =( ... \"djstripe\" , ... ) Add to urls.py: path ( \"stripe/\" , include ( \"djstripe.urls\" , namespace = \"djstripe\" )) , Tell Stripe about the webhook (Stripe webhook docs can be found here ) using the full URL of your endpoint from the urls.py step above (e.g. https://example.com/stripe/webhook ). Add your Stripe keys and set the operating mode: STRIPE_LIVE_SECRET_KEY = os.environ.get ( \"STRIPE_LIVE_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_TEST_SECRET_KEY = os.environ.get ( \"STRIPE_TEST_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_LIVE_MODE = False # Change to True in production DJSTRIPE_WEBHOOK_SECRET = \"whsec_xxx\" # Get it from the section in the Stripe dashboard where you added the webhook endpoint DJSTRIPE_USE_NATIVE_JSONFIELD = True # We recommend setting to True for new installations DJSTRIPE_FOREIGN_KEY_TO_FIELD = \"id\" Note djstripe expects STRIPE_LIVE_MODE to be a Boolean Type. In case you use Bash env vars or equivalent to inject its value, make sure to convert it to a Boolean type. We highly recommended the library django-environ Add some payment plans via the Stripe.com dashboard. Run the commands: python manage.py migrate python manage.py djstripe_sync_models See here for notes about usage of the Stripe Elements frontend JS library.","title":"Configuration"},{"location":"#running-tests","text":"Assuming the tests are run against PostgreSQL: createdb djstripe pip install tox tox","title":"Running Tests"},{"location":"#changelog","text":"See release notes on Read the Docs .","title":"Changelog"},{"location":"#funding-and-support","text":"You can now become a sponsor to dj-stripe with GitHub Sponsors . We've been bringing dj-stripe to the world for over 7 years and are excited to be able to start dedicating some real resources to the project. Your sponsorship helps us keep a team of maintainers actively working to improve dj-stripe and ensure it stays up-to-date with the latest Stripe changes. If you use dj-stripe commercially, we would encourage you to invest in its continued development by signing up for a paid plan . Corporate sponsors receive priority support and development time . All contributions through GitHub sponsors flow into our Open Collective , which holds our funds and keeps an open ledger on how donations are spent.","title":"Funding and Support"},{"location":"#our-gold-sponsors","text":"img[alt=\"Stripe Logo\"] { max-width: 250px; }","title":"Our Gold sponsors"},{"location":"#similar-libraries","text":"dj-paypal ( PayPal ) dj-paddle ( Paddle )","title":"Similar libraries"},{"location":"CONTRIBUTING/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it. Write Documentation dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install -E docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder. Submit Feedback The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Contributor Discussion For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc . Get Started! Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us. Preferred Django Model Field Types When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models). Strings Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\") Enumerations Fields that have a defined set of values can be implemented using StripeEnumField . Hash (dictionaries) Use the JSONField in djstripe.fields , see also the DJSTRIPE_USE_NATIVE_JSONFIELD setting. Currency amounts Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField . Dates and Datetimes The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField . Django Migration Policy Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model. Avoid new migrations with non-schema changes If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087 Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install black and isort with pip install black isort and run black .; isort -y at the dj-stripe root to keep a consistent style.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"CONTRIBUTING/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"CONTRIBUTING/#report-bugs","text":"Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"CONTRIBUTING/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"CONTRIBUTING/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"CONTRIBUTING/#write-documentation","text":"dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install -E docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder.","title":"Write Documentation"},{"location":"CONTRIBUTING/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"CONTRIBUTING/#contributor-discussion","text":"For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc .","title":"Contributor Discussion"},{"location":"CONTRIBUTING/#get-started","text":"Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us.","title":"Get Started!"},{"location":"CONTRIBUTING/#preferred-django-model-field-types","text":"When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models).","title":"Preferred Django Model Field Types"},{"location":"CONTRIBUTING/#strings","text":"Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\")","title":"Strings"},{"location":"CONTRIBUTING/#enumerations","text":"Fields that have a defined set of values can be implemented using StripeEnumField .","title":"Enumerations"},{"location":"CONTRIBUTING/#hash-dictionaries","text":"Use the JSONField in djstripe.fields , see also the DJSTRIPE_USE_NATIVE_JSONFIELD setting.","title":"Hash (dictionaries)"},{"location":"CONTRIBUTING/#currency-amounts","text":"Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField .","title":"Currency amounts"},{"location":"CONTRIBUTING/#dates-and-datetimes","text":"The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField .","title":"Dates and Datetimes"},{"location":"CONTRIBUTING/#django-migration-policy","text":"Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model.","title":"Django Migration Policy"},{"location":"CONTRIBUTING/#avoid-new-migrations-with-non-schema-changes","text":"If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087","title":"Avoid new migrations with non-schema changes"},{"location":"CONTRIBUTING/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install black and isort with pip install black isort and run black .; isort -y at the dj-stripe root to keep a consistent style.","title":"Pull Request Guidelines"},{"location":"api_keys/","text":"Managing Stripe API keys Stripe API keys are stored in the database, and editable from the Django admin. Important Note By default, keys are visible by anyone who has access to the dj-stripe administration. Adding new API keys You may add new API keys via the Dj-Stripe \"API key\" administration. The only required value is the key's \"secret\" value itself. Example: Once saved, Dj-Stripe will automatically detect whether the key is a public, restricted or secret key, and whether it's for live or test mode. If it's a secret key, the matching Account object will automatically be fetched as well and the key will be associated with it, so that it can be used to communicate with the Stripe API when dealing with objects belonging to that Account. Updating the API keys When expiring or rolling new secret keys, you should create the new API key in Stripe, then add it from the Django administration. Whenever you are ready, you may delete the old key. (It is safe to keep it around, as long as it hasn't expired. Keeping expired keys in the database may result in errors during usage). FAQ Why store them in the database? As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway. Isn't that insecure? Please do keep your billing database encrypted. There's a copy of all your customers' billing data on it! You may also instead create a read-only restricted key with all-read permissions for dj-stripe. There is no added risk there, given that dj-stripe holds a copy of all your data regardless. I'm using environment variables. Do I need to change anything? Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity. What about public keys? Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated in 2.5.0. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys).","title":"Managing Stripe API Keys"},{"location":"api_keys/#managing-stripe-api-keys","text":"Stripe API keys are stored in the database, and editable from the Django admin. Important Note By default, keys are visible by anyone who has access to the dj-stripe administration.","title":"Managing Stripe API keys"},{"location":"api_keys/#adding-new-api-keys","text":"You may add new API keys via the Dj-Stripe \"API key\" administration. The only required value is the key's \"secret\" value itself. Example: Once saved, Dj-Stripe will automatically detect whether the key is a public, restricted or secret key, and whether it's for live or test mode. If it's a secret key, the matching Account object will automatically be fetched as well and the key will be associated with it, so that it can be used to communicate with the Stripe API when dealing with objects belonging to that Account.","title":"Adding new API keys"},{"location":"api_keys/#updating-the-api-keys","text":"When expiring or rolling new secret keys, you should create the new API key in Stripe, then add it from the Django administration. Whenever you are ready, you may delete the old key. (It is safe to keep it around, as long as it hasn't expired. Keeping expired keys in the database may result in errors during usage).","title":"Updating the API keys"},{"location":"api_keys/#faq","text":"","title":"FAQ"},{"location":"api_keys/#why-store-them-in-the-database","text":"As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway.","title":"Why store them in the database?"},{"location":"api_keys/#isnt-that-insecure","text":"Please do keep your billing database encrypted. There's a copy of all your customers' billing data on it! You may also instead create a read-only restricted key with all-read permissions for dj-stripe. There is no added risk there, given that dj-stripe holds a copy of all your data regardless.","title":"Isn't that insecure?"},{"location":"api_keys/#im-using-environment-variables-do-i-need-to-change-anything","text":"Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity.","title":"I'm using environment variables. Do I need to change anything?"},{"location":"api_keys/#what-about-public-keys","text":"Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated in 2.5.0. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys).","title":"What about public keys?"},{"location":"api_versions/","text":"A note on Stripe API versions A point that can cause confusion to new users of dj-stripe is that there are several different Stripe API versions in play at once. Attention Don't touch the STRIPE_API_VERSION setting, but don't worry, it doesn't need to match your Stripe account api version. See also Stripe API Versioning Your Stripe account's API version You can find this on your Stripe dashboard labelled \" default \" For new accounts this will be the latest Stripe version. When upgrading version Stripe only allows you to upgrade to the latest version. Tip Checkout Stripe Version Upgrade Documentation for Upgrading Stripe API version Note This is the version used by Stripe when sending webhook data to you (though during webhook processing, dj-stripe re-fetches the data with its preferred version). It's also the default version used by the Stripe API, but dj-stripe overrides the API version when talking to stripe (this override is triggered on import of djstripe.models ). As a result your Stripe account API version is mostly irrelevant, though from time to time we will increase the minimum supported API version, and it's good practise to regularly upgrade to the latest version with appropriate testing. Stripe's current latest API version You can find this on your Stripe dashboard labelled \" latest \" or in [Stripe's API documentation] (https://stripe.com/docs/upgrades#api-changelog) This is the version used by new accounts and it's also \" true \" internal version of Stripe's API Tip Checkout Stripe API Versioning Dj-stripe API version This is the Stripe API version used by dj-stripe in all communication with Stripe, including when processing webhooks (though webhook data is sent to you by Stripe with your API version, we re-fetch the data with dj-stripe's API version), this is because the API schema needs to match dj-stripe's Django model schema. This is defined by djstripe.settings.DEFAULT_STRIPE_API_VERSION and can be overridden by the function, djstripe.settings.set_stripe_api_version , though see the warning about doing this. Dj-stripe Latest Tested Version This is the most recent Stripe account API version used by the maintainers during testing, more recent versions account versions are probably fine though.","title":"A note on Stripe API Versions"},{"location":"api_versions/#a-note-on-stripe-api-versions","text":"A point that can cause confusion to new users of dj-stripe is that there are several different Stripe API versions in play at once. Attention Don't touch the STRIPE_API_VERSION setting, but don't worry, it doesn't need to match your Stripe account api version. See also Stripe API Versioning","title":"A note on Stripe API versions"},{"location":"api_versions/#your-stripe-accounts-api-version","text":"You can find this on your Stripe dashboard labelled \" default \" For new accounts this will be the latest Stripe version. When upgrading version Stripe only allows you to upgrade to the latest version. Tip Checkout Stripe Version Upgrade Documentation for Upgrading Stripe API version Note This is the version used by Stripe when sending webhook data to you (though during webhook processing, dj-stripe re-fetches the data with its preferred version). It's also the default version used by the Stripe API, but dj-stripe overrides the API version when talking to stripe (this override is triggered on import of djstripe.models ). As a result your Stripe account API version is mostly irrelevant, though from time to time we will increase the minimum supported API version, and it's good practise to regularly upgrade to the latest version with appropriate testing.","title":"Your Stripe account's API version"},{"location":"api_versions/#stripes-current-latest-api-version","text":"You can find this on your Stripe dashboard labelled \" latest \" or in [Stripe's API documentation] (https://stripe.com/docs/upgrades#api-changelog) This is the version used by new accounts and it's also \" true \" internal version of Stripe's API Tip Checkout Stripe API Versioning","title":"Stripe's current latest API version"},{"location":"api_versions/#dj-stripe-api-version","text":"This is the Stripe API version used by dj-stripe in all communication with Stripe, including when processing webhooks (though webhook data is sent to you by Stripe with your API version, we re-fetch the data with dj-stripe's API version), this is because the API schema needs to match dj-stripe's Django model schema. This is defined by djstripe.settings.DEFAULT_STRIPE_API_VERSION and can be overridden by the function, djstripe.settings.set_stripe_api_version , though see the warning about doing this.","title":"Dj-stripe API version"},{"location":"api_versions/#dj-stripe-latest-tested-version","text":"This is the most recent Stripe account API version used by the maintainers during testing, more recent versions account versions are probably fine though.","title":"Dj-stripe Latest Tested Version"},{"location":"installation/","text":"Installation Get the distribution Install dj-stripe with pip: pip install dj-stripe Or with Poetry (recommended): poetry add dj-stripe Configuration Add djstripe to your INSTALLED_APPS : INSTALLED_APPS =( ... \"djstripe\" , ... ) Add to urls.py: path ( \"stripe/\" , include ( \"djstripe.urls\" , namespace = \"djstripe\" )) , Tell Stripe about the webhook (Stripe webhook docs can be found here ) using the full URL of your endpoint from the urls.py step above (e.g. https://example.com/stripe/webhook ). Add your Stripe keys and set the operating mode: STRIPE_LIVE_SECRET_KEY = os.environ.get ( \"STRIPE_LIVE_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_TEST_SECRET_KEY = os.environ.get ( \"STRIPE_TEST_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_LIVE_MODE = False # Change to True in production DJSTRIPE_WEBHOOK_SECRET = \"whsec_xxx\" # Get it from the section in the Stripe dashboard where you added the webhook endpoint DJSTRIPE_USE_NATIVE_JSONFIELD = True # We recommend setting to True for new installations DJSTRIPE_FOREIGN_KEY_TO_FIELD = \"id\" Note djstripe expects STRIPE_LIVE_MODE to be a Boolean Type. In case you use Bash env vars or equivalent to inject its value, make sure to convert it to a Boolean type. We highly recommended the library django-environ Add some payment plans via the Stripe.com dashboard. Run the commands: python manage.py migrate python manage.py djstripe_sync_models See here for notes about usage of the Stripe Elements frontend JS library. Running Tests Assuming the tests are run against PostgreSQL: createdb djstripe pip install tox tox","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#get-the-distribution","text":"Install dj-stripe with pip: pip install dj-stripe Or with Poetry (recommended): poetry add dj-stripe","title":"Get the distribution"},{"location":"installation/#configuration","text":"Add djstripe to your INSTALLED_APPS : INSTALLED_APPS =( ... \"djstripe\" , ... ) Add to urls.py: path ( \"stripe/\" , include ( \"djstripe.urls\" , namespace = \"djstripe\" )) , Tell Stripe about the webhook (Stripe webhook docs can be found here ) using the full URL of your endpoint from the urls.py step above (e.g. https://example.com/stripe/webhook ). Add your Stripe keys and set the operating mode: STRIPE_LIVE_SECRET_KEY = os.environ.get ( \"STRIPE_LIVE_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_TEST_SECRET_KEY = os.environ.get ( \"STRIPE_TEST_SECRET_KEY\" , \"<your secret key>\" ) STRIPE_LIVE_MODE = False # Change to True in production DJSTRIPE_WEBHOOK_SECRET = \"whsec_xxx\" # Get it from the section in the Stripe dashboard where you added the webhook endpoint DJSTRIPE_USE_NATIVE_JSONFIELD = True # We recommend setting to True for new installations DJSTRIPE_FOREIGN_KEY_TO_FIELD = \"id\" Note djstripe expects STRIPE_LIVE_MODE to be a Boolean Type. In case you use Bash env vars or equivalent to inject its value, make sure to convert it to a Boolean type. We highly recommended the library django-environ Add some payment plans via the Stripe.com dashboard. Run the commands: python manage.py migrate python manage.py djstripe_sync_models See here for notes about usage of the Stripe Elements frontend JS library.","title":"Configuration"},{"location":"installation/#running-tests","text":"Assuming the tests are run against PostgreSQL: createdb djstripe pip install tox tox","title":"Running Tests"},{"location":"stripe_elements_js/","text":"Integrating Stripe Elements (JS SDK) Tip TLDR: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() over stripe.createToken() for better compatibility with PaymentMethods. Attention A point that can cause confusion when integrating Stripe on the web is that there are multiple generations of frontend JS APIs that use Stripe Elements with stripe js v3. In descending order of preference these are: Payment Intents (SCA compliant) The newest and preferred way of handling payments, which supports SCA compliance (3D secure etc). Charges using stripe.createSource() This creates Source objects within Stripe, and can be used for various different methods of payment (including, but not limited to cards), but isn't SCA compliant. The Card Elements Quickstart JS example can be used, except use stripe.createSource instead of stripe.createToken and the result.source instead of result.token . Checkout a working example of this Charges using stripe.createToken() This predates stripe.createSource , and creates legacy Card objects within Stripe, which have some compatibility issues with Payment Methods. If you're using stripe.createToken , see if you can upgrade to stripe.createSource or ideally to Payment Intents . Tip Checkout Card Elements Quickstart JS","title":"Integrating Stripe Elements"},{"location":"stripe_elements_js/#integrating-stripe-elements-js-sdk","text":"Tip TLDR: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() over stripe.createToken() for better compatibility with PaymentMethods. Attention A point that can cause confusion when integrating Stripe on the web is that there are multiple generations of frontend JS APIs that use Stripe Elements with stripe js v3.","title":"Integrating Stripe Elements (JS SDK)"},{"location":"stripe_elements_js/#in-descending-order-of-preference-these-are","text":"","title":"In descending order of preference these are:"},{"location":"stripe_elements_js/#payment-intents-sca-compliant","text":"The newest and preferred way of handling payments, which supports SCA compliance (3D secure etc).","title":"Payment Intents (SCA compliant)"},{"location":"stripe_elements_js/#charges-using-stripecreatesource","text":"This creates Source objects within Stripe, and can be used for various different methods of payment (including, but not limited to cards), but isn't SCA compliant. The Card Elements Quickstart JS example can be used, except use stripe.createSource instead of stripe.createToken and the result.source instead of result.token . Checkout a working example of this","title":"Charges using stripe.createSource()"},{"location":"stripe_elements_js/#charges-using-stripecreatetoken","text":"This predates stripe.createSource , and creates legacy Card objects within Stripe, which have some compatibility issues with Payment Methods. If you're using stripe.createToken , see if you can upgrade to stripe.createSource or ideally to Payment Intents . Tip Checkout Card Elements Quickstart JS","title":"Charges using stripe.createToken()"},{"location":"history/0_x/","text":"dj-stripe 0.x release notes 0.8.0 (2015-12-30) better plan ordering documentation (Thanks @cjrh) added a confirmation page when choosing a subscription (Thanks @chrissmejia, @areski) setup.py reverse dependency fix (#258/#268) (Thanks @ticosax) Dropped official support for Django 1.7 (no code changes were made) Python 3.5 support, Django 1.9.1 support Migration improvements (Thanks @michi88) Fixed \"Invoice matching query does not exist\" bug (#263) (Thanks @mthornhill) Fixed duplicate content in account view (Thanks @areski) 0.7.0 (2015-09-22) dj-stripe now responds to the invoice.created event (Thanks @wahuneke) dj-stripe now cancels subscriptions and purges customers during sync if they were deleted from the stripe dashboard (Thanks @unformatt) dj-stripe now checks for an active stripe subscription in the update_plan_quantity call (Thanks @ctrengove) Event processing is now handled by \"event handlers\" - functions outside of models that respond to various event types and subtypes. Documentation on how to tie into the event handler system coming soon. (Thanks @wahuneke) Experimental Python 3.5 support Support for Django 1.6 and lower is now officially gone. Much, much more! 0.6.0 (2015-07-12) Support for Django 1.6 and lower is now deprecated. Improved test harness now tests coverage and pep8 SubscribeFormView and ChangePlanView no longer populate self.error with form errors InvoiceItems.plan can now be null (as it is with individual charges), resolving #140 (Thanks @awechsler and @MichelleGlauser for help troubleshooting) Email templates are now packaged during distribution. sync_plans now takes an optional api_key 100% test coverage Stripe ID is now returned as part of each model's str method (Thanks @areski) Customer model now stores card expiration month and year (Thanks @jpadilla) Ability to extend subscriptions (Thanks @TigerDX) Support for plan heirarchies (Thanks @chrissmejia) Rest API endpoints for Subscriptions [contrib] (Thanks @philippeluickx) Admin interface search by email funtionality is removed (#221) (Thanks @jpadilla) 0.5.0 (2015-05-25) Began deprecation of support for Django 1.6 and lower. Added formal support for Django 1.8. Removed the StripeSubscriptionSignupForm Removed djstripe.safe_settings . Settings are now all located in djstripe.settings DJSTRIPE_TRIAL_PERIOD_FOR_SUBSCRIBER_CALLBACK can no longer be a module string The sync_subscriber argument has been renamed from subscriber_model to subscriber Moved available currencies to the DJSTRIPE_CURRENCIES setting (Thanks @martinhill) Allow passing of extra parameters to stripe Charge API (Thanks @mthornhill) Support for all available arguments when syncing plans (Thanks @jamesbrobb) charge.refund() now returns the refunded charge object (Thanks @mthornhill) Charge model now has captured field and a capture method (Thanks @mthornhill) Subscription deleted webhook bugfix South migrations are now up to date (Thanks @Tyrdall) 0.4.0 (2015-04-05) Formal Python 3.3+/Django 1.7 Support (including migrations) Removed Python 2.6 from Travis CI build. (Thanks @audreyr) Dropped Django 1.4 support. (Thanks @audreyr) Deprecated the djstripe.forms.StripeSubscriptionSignupForm . Making this form work easily with both dj-stripe and django-allauth required too much abstraction. It will be removed in the 0.5.0 release. Add the ability to add invoice items for a customer (Thanks @kavdev) Add the ability to use a custom customer model (Thanks @kavdev) Added setting to disable Invoice receipt emails (Thanks Chris Halpert) Enable proration when customer upgrades plan, and pass proration policy and cancellation at period end for upgrades in settings. (Thanks Yasmine Charif) Removed the redundant context processor. (Thanks @kavdev) Fixed create a token call in change_card.html (Thanks @dollydagr) Fix charge.dispute.closed typo. (Thanks @ipmb) Fix contributing docs formatting. (Thanks @audreyr) Fix subscription canceled_at_period_end field sync on plan upgrade (Thanks @nigma) Remove \"account\" bug in Middleware (Thanks @sromero84) Fix correct plan selection on subscription in subscribe_form template. (Thanks Yasmine Charif) Fix subscription status in account, _subscription_status, and cancel_subscription templates. (Thanks Yasmine Charif) Now using user.get_username() instead of user.username , to support custom User models. (Thanks @shvechikov) Update remaining DOM Ids for Bootstrap 3. (Thanks Yasmine Charif) Update publish command in setup.py. (Thanks @pydanny) Explicitly specify tox's virtual environment names. (Thanks @audreyr) Manually call django.setup() to populate apps registry. (Thanks @audreyr) 0.3.5 (2014-05-01) Fixed djstripe_init_customers management command so it works with custom user models. 0.3.4 (2014-05-01) Clarify documentation for redirects on app_name. If settings.DEBUG is True, then django-debug-toolbar is exempt from redirect to subscription form. Use collections.OrderedDict to ensure that plans are listed in order of price. Add ordereddict library to support Python 2.6 users. Switch from __unicode__ to __str__ methods on models to better support Python 3. Add python_2_unicode_compatible decorator to Models. Check for PY3 so the unicode(self.user) in models.Customer doesn't blow up in Python 3. 0.3.3 (2014-04-24) Increased the extendability of the views by removing as many hard-coded URLs as possible and replacing them with success_url and other attributes/methods. Added single unit purchasing to the cookbook 0.3.2 (2014-01-16) Made Yasmine Charif a core committer Take into account trial days in a subscription plan (Thanks Yasmine Charif) Correct invoice period end value (Thanks Yasmine Charif) Make plan cancellation and plan change consistently not prorating (Thanks Yasmine Charif) Fix circular import when ACCOUNT_SIGNUP_FORM_CLASS is defined (Thanks Dustin Farris) Add send e-mail receipt action in charges admin panel (Thanks Buddy Lindsay) Add created field to all ModelAdmins to help with internal auditing (Thanks Kulbir Singh) 0.3.1 (2013-11-14) Cancellation fix (Thanks Yasmine Charif) Add setup.cfg for wheel generation (Thanks Charlie Denton) 0.3.0 (2013-11-12) Fully tested against Django 1.6, 1.5, and 1.4 Fix boolean default issue in models (from now on they are all default to False ). Replace duplicated code with djstripe.utils.user_has_active_subscription . 0.2.9 (2013-09-06) Cancellation added to views. Support for kwargs on charge and invoice fetching. def charge() now supports send_receipt flag, default to True. Fixed templates to work with Bootstrap 3.0.0 column design. 0.2.8 (2013-09-02) Improved usage documentation. Corrected order of fields in StripeSubscriptionSignupForm. Corrected transaction history template layout. Updated models to take into account when settings.USE_TZ is disabled. 0.2.7 (2013-08-24) Add handy rest_framework permission class. Fixing attribution for django-stripe-payments. Add new status to Invoice model. 0.2.6 (2013-08-20) Changed name of division tag to djdiv. Added safe_setting.py module to handle edge cases when working with custom user models. Added cookbook page in the documentation. 0.2.5 (2013-08-18) Fixed bug in initial checkout You can't purchase the same plan that you currently have. 0.2.4 (2013-08-18) Recursive package finding. 0.2.3 (2013-08-16) Fix packaging so all submodules are loaded 0.2.2 (2013-08-15) Added Registration + Subscription form 0.2.1 (2013-08-12) Fixed a bug on CurrentSubscription tests Improved usage documentation Added to migration from other tools documentation 0.2.0 (2013-08-12) Cancellation of plans now works. Upgrades and downgrades of plans now work. Changing of cards now works. Added breadcrumbs to improve navigation. Improved installation instructions. Consolidation of test instructions. Minor improvement to django-stripe-payments documentation Added coverage.py to test process. Added south migrations. Fixed the subscription_payment_required function-based view decorator. Removed unnecessary django-crispy-forms 0.1.7 (2013-08-08) Middleware excepts all of the djstripe namespaced URLs. This way people can pay. 0.1.6 (2013-08-08) Fixed a couple template paths Fixed the manifest so we include html, images. 0.1.5 (2013-08-08) Fixed the manifest so we include html, css, js, images. 0.1.4 (2013-08-08) Change PaymentRequiredMixin to SubscriptionPaymentRequiredMixin Add subscription_payment_required function-based view decorator Added SubscriptionPaymentRedirectMiddleware Much nicer accounts view display Much improved subscription form display Payment plans can have decimals Payment plans can have custom images 0.1.3 (2013-08-7) Added account view Added Customer.get_or_create method Added djstripe_sync_customers management command sync file for all code that keeps things in sync with stripe Use client-side JavaScript to get history data asynchronously More user friendly action views 0.1.2 (2013-08-6) Admin working Better publish statement Fix dependencies 0.1.1 (2013-08-6) Ported internals from django-stripe-payments Began writing the views Travis-CI All tests passing on Python 2.7 and 3.3 All tests passing on Django 1.4 and 1.5 Began model cleanup Better form Provide better response from management commands 0.1.0 (2013-08-5) First release on PyPI.","title":"dj-stripe 0.x release notes"},{"location":"history/0_x/#dj-stripe-0x-release-notes","text":"","title":"dj-stripe 0.x release notes"},{"location":"history/0_x/#080-2015-12-30","text":"better plan ordering documentation (Thanks @cjrh) added a confirmation page when choosing a subscription (Thanks @chrissmejia, @areski) setup.py reverse dependency fix (#258/#268) (Thanks @ticosax) Dropped official support for Django 1.7 (no code changes were made) Python 3.5 support, Django 1.9.1 support Migration improvements (Thanks @michi88) Fixed \"Invoice matching query does not exist\" bug (#263) (Thanks @mthornhill) Fixed duplicate content in account view (Thanks @areski)","title":"0.8.0 (2015-12-30)"},{"location":"history/0_x/#070-2015-09-22","text":"dj-stripe now responds to the invoice.created event (Thanks @wahuneke) dj-stripe now cancels subscriptions and purges customers during sync if they were deleted from the stripe dashboard (Thanks @unformatt) dj-stripe now checks for an active stripe subscription in the update_plan_quantity call (Thanks @ctrengove) Event processing is now handled by \"event handlers\" - functions outside of models that respond to various event types and subtypes. Documentation on how to tie into the event handler system coming soon. (Thanks @wahuneke) Experimental Python 3.5 support Support for Django 1.6 and lower is now officially gone. Much, much more!","title":"0.7.0 (2015-09-22)"},{"location":"history/0_x/#060-2015-07-12","text":"Support for Django 1.6 and lower is now deprecated. Improved test harness now tests coverage and pep8 SubscribeFormView and ChangePlanView no longer populate self.error with form errors InvoiceItems.plan can now be null (as it is with individual charges), resolving #140 (Thanks @awechsler and @MichelleGlauser for help troubleshooting) Email templates are now packaged during distribution. sync_plans now takes an optional api_key 100% test coverage Stripe ID is now returned as part of each model's str method (Thanks @areski) Customer model now stores card expiration month and year (Thanks @jpadilla) Ability to extend subscriptions (Thanks @TigerDX) Support for plan heirarchies (Thanks @chrissmejia) Rest API endpoints for Subscriptions [contrib] (Thanks @philippeluickx) Admin interface search by email funtionality is removed (#221) (Thanks @jpadilla)","title":"0.6.0 (2015-07-12)"},{"location":"history/0_x/#050-2015-05-25","text":"Began deprecation of support for Django 1.6 and lower. Added formal support for Django 1.8. Removed the StripeSubscriptionSignupForm Removed djstripe.safe_settings . Settings are now all located in djstripe.settings DJSTRIPE_TRIAL_PERIOD_FOR_SUBSCRIBER_CALLBACK can no longer be a module string The sync_subscriber argument has been renamed from subscriber_model to subscriber Moved available currencies to the DJSTRIPE_CURRENCIES setting (Thanks @martinhill) Allow passing of extra parameters to stripe Charge API (Thanks @mthornhill) Support for all available arguments when syncing plans (Thanks @jamesbrobb) charge.refund() now returns the refunded charge object (Thanks @mthornhill) Charge model now has captured field and a capture method (Thanks @mthornhill) Subscription deleted webhook bugfix South migrations are now up to date (Thanks @Tyrdall)","title":"0.5.0 (2015-05-25)"},{"location":"history/0_x/#040-2015-04-05","text":"Formal Python 3.3+/Django 1.7 Support (including migrations) Removed Python 2.6 from Travis CI build. (Thanks @audreyr) Dropped Django 1.4 support. (Thanks @audreyr) Deprecated the djstripe.forms.StripeSubscriptionSignupForm . Making this form work easily with both dj-stripe and django-allauth required too much abstraction. It will be removed in the 0.5.0 release. Add the ability to add invoice items for a customer (Thanks @kavdev) Add the ability to use a custom customer model (Thanks @kavdev) Added setting to disable Invoice receipt emails (Thanks Chris Halpert) Enable proration when customer upgrades plan, and pass proration policy and cancellation at period end for upgrades in settings. (Thanks Yasmine Charif) Removed the redundant context processor. (Thanks @kavdev) Fixed create a token call in change_card.html (Thanks @dollydagr) Fix charge.dispute.closed typo. (Thanks @ipmb) Fix contributing docs formatting. (Thanks @audreyr) Fix subscription canceled_at_period_end field sync on plan upgrade (Thanks @nigma) Remove \"account\" bug in Middleware (Thanks @sromero84) Fix correct plan selection on subscription in subscribe_form template. (Thanks Yasmine Charif) Fix subscription status in account, _subscription_status, and cancel_subscription templates. (Thanks Yasmine Charif) Now using user.get_username() instead of user.username , to support custom User models. (Thanks @shvechikov) Update remaining DOM Ids for Bootstrap 3. (Thanks Yasmine Charif) Update publish command in setup.py. (Thanks @pydanny) Explicitly specify tox's virtual environment names. (Thanks @audreyr) Manually call django.setup() to populate apps registry. (Thanks @audreyr)","title":"0.4.0 (2015-04-05)"},{"location":"history/0_x/#035-2014-05-01","text":"Fixed djstripe_init_customers management command so it works with custom user models.","title":"0.3.5 (2014-05-01)"},{"location":"history/0_x/#034-2014-05-01","text":"Clarify documentation for redirects on app_name. If settings.DEBUG is True, then django-debug-toolbar is exempt from redirect to subscription form. Use collections.OrderedDict to ensure that plans are listed in order of price. Add ordereddict library to support Python 2.6 users. Switch from __unicode__ to __str__ methods on models to better support Python 3. Add python_2_unicode_compatible decorator to Models. Check for PY3 so the unicode(self.user) in models.Customer doesn't blow up in Python 3.","title":"0.3.4 (2014-05-01)"},{"location":"history/0_x/#033-2014-04-24","text":"Increased the extendability of the views by removing as many hard-coded URLs as possible and replacing them with success_url and other attributes/methods. Added single unit purchasing to the cookbook","title":"0.3.3 (2014-04-24)"},{"location":"history/0_x/#032-2014-01-16","text":"Made Yasmine Charif a core committer Take into account trial days in a subscription plan (Thanks Yasmine Charif) Correct invoice period end value (Thanks Yasmine Charif) Make plan cancellation and plan change consistently not prorating (Thanks Yasmine Charif) Fix circular import when ACCOUNT_SIGNUP_FORM_CLASS is defined (Thanks Dustin Farris) Add send e-mail receipt action in charges admin panel (Thanks Buddy Lindsay) Add created field to all ModelAdmins to help with internal auditing (Thanks Kulbir Singh)","title":"0.3.2 (2014-01-16)"},{"location":"history/0_x/#031-2013-11-14","text":"Cancellation fix (Thanks Yasmine Charif) Add setup.cfg for wheel generation (Thanks Charlie Denton)","title":"0.3.1 (2013-11-14)"},{"location":"history/0_x/#030-2013-11-12","text":"Fully tested against Django 1.6, 1.5, and 1.4 Fix boolean default issue in models (from now on they are all default to False ). Replace duplicated code with djstripe.utils.user_has_active_subscription .","title":"0.3.0 (2013-11-12)"},{"location":"history/0_x/#029-2013-09-06","text":"Cancellation added to views. Support for kwargs on charge and invoice fetching. def charge() now supports send_receipt flag, default to True. Fixed templates to work with Bootstrap 3.0.0 column design.","title":"0.2.9 (2013-09-06)"},{"location":"history/0_x/#028-2013-09-02","text":"Improved usage documentation. Corrected order of fields in StripeSubscriptionSignupForm. Corrected transaction history template layout. Updated models to take into account when settings.USE_TZ is disabled.","title":"0.2.8 (2013-09-02)"},{"location":"history/0_x/#027-2013-08-24","text":"Add handy rest_framework permission class. Fixing attribution for django-stripe-payments. Add new status to Invoice model.","title":"0.2.7 (2013-08-24)"},{"location":"history/0_x/#026-2013-08-20","text":"Changed name of division tag to djdiv. Added safe_setting.py module to handle edge cases when working with custom user models. Added cookbook page in the documentation.","title":"0.2.6 (2013-08-20)"},{"location":"history/0_x/#025-2013-08-18","text":"Fixed bug in initial checkout You can't purchase the same plan that you currently have.","title":"0.2.5 (2013-08-18)"},{"location":"history/0_x/#024-2013-08-18","text":"Recursive package finding.","title":"0.2.4 (2013-08-18)"},{"location":"history/0_x/#023-2013-08-16","text":"Fix packaging so all submodules are loaded","title":"0.2.3 (2013-08-16)"},{"location":"history/0_x/#022-2013-08-15","text":"Added Registration + Subscription form","title":"0.2.2 (2013-08-15)"},{"location":"history/0_x/#021-2013-08-12","text":"Fixed a bug on CurrentSubscription tests Improved usage documentation Added to migration from other tools documentation","title":"0.2.1 (2013-08-12)"},{"location":"history/0_x/#020-2013-08-12","text":"Cancellation of plans now works. Upgrades and downgrades of plans now work. Changing of cards now works. Added breadcrumbs to improve navigation. Improved installation instructions. Consolidation of test instructions. Minor improvement to django-stripe-payments documentation Added coverage.py to test process. Added south migrations. Fixed the subscription_payment_required function-based view decorator. Removed unnecessary django-crispy-forms","title":"0.2.0 (2013-08-12)"},{"location":"history/0_x/#017-2013-08-08","text":"Middleware excepts all of the djstripe namespaced URLs. This way people can pay.","title":"0.1.7 (2013-08-08)"},{"location":"history/0_x/#016-2013-08-08","text":"Fixed a couple template paths Fixed the manifest so we include html, images.","title":"0.1.6 (2013-08-08)"},{"location":"history/0_x/#015-2013-08-08","text":"Fixed the manifest so we include html, css, js, images.","title":"0.1.5 (2013-08-08)"},{"location":"history/0_x/#014-2013-08-08","text":"Change PaymentRequiredMixin to SubscriptionPaymentRequiredMixin Add subscription_payment_required function-based view decorator Added SubscriptionPaymentRedirectMiddleware Much nicer accounts view display Much improved subscription form display Payment plans can have decimals Payment plans can have custom images","title":"0.1.4 (2013-08-08)"},{"location":"history/0_x/#013-2013-08-7","text":"Added account view Added Customer.get_or_create method Added djstripe_sync_customers management command sync file for all code that keeps things in sync with stripe Use client-side JavaScript to get history data asynchronously More user friendly action views","title":"0.1.3 (2013-08-7)"},{"location":"history/0_x/#012-2013-08-6","text":"Admin working Better publish statement Fix dependencies","title":"0.1.2 (2013-08-6)"},{"location":"history/0_x/#011-2013-08-6","text":"Ported internals from django-stripe-payments Began writing the views Travis-CI All tests passing on Python 2.7 and 3.3 All tests passing on Django 1.4 and 1.5 Began model cleanup Better form Provide better response from management commands","title":"0.1.1 (2013-08-6)"},{"location":"history/0_x/#010-2013-08-5","text":"First release on PyPI.","title":"0.1.0 (2013-08-5)"},{"location":"history/1_x/","text":"dj-stripe 1.x release notes 1.2.4 (2019-02-27) This is a bugfix-only version: Allow billing_cycle_anchor argument when creating a subscription (#814) Fixup plan amount null with tier plans (#781) Update Cancel subscription view tests to match backport in f64af57 Implement Invoice._manipulate_stripe_object_hook for compatability with API 2018-11-08 (#771) Fix product webhook for type=\"good\" (#724) Add trial_from_plan, trial_period_days args to Customer.subscribe() (#709) 1.2.3 (2018-10-13) This is a bugfix-only version: Updated Subscription.cancel() for compatibility with Stripe 2018-08-23 (#723) 1.2.2 (2018-08-11) This is a bugfix-only version: Fixed an error with request.urlconf in some setups (#562) Always save text-type fields as empty strings in db instead of null (#713) Fix support for DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (#707) Fix reactivate() with Stripe API 2018-02-28 and above 1.2.1 (2018-07-18) This is a bugfix-only version: Fixed various Python 2.7 compatibility issues Fixed issues with max_length of receipt_number Fixed various fields incorrectly marked as required Handle product webhook calls Fix compatibility with stripe-python 2.0.0 1.2.0 (2018-06-11) The dj-stripe 1.2.0 release resets all migrations. Do not upgrade to 1.2.0 directly from 1.0.1 or below. You must upgrade to 1.1.0 first. Please read the 1.1.0 release notes below for more information. 1.1.0 (2018-06-11) In dj-stripe 1.1.0, we made a lot of changes to models in order to bring the dj-stripe model state much closer to the upstream API objects. If you are a current user of dj-stripe, you will most likely have to make changes in order to upgrade. Please read the full changelog below. If you are having trouble upgrading, you may ask for help by filing an issue on GitHub . Migration reset The next version of dj-stripe, 1.2.0 , will reset all the migrations to 0001_initial . Migrations are currently in an unmaintainable state. What this means is you will not be able to upgrade directly to dj-stripe 1.2.0. You must go through 1.1.0 first, run ``manage.py migrate djstripe``, then upgrade to 1.2.0. Python 2.7 end-of-life dj-stripe 1.1.0 drops support for Django 1.10 and adds support for Django 2.0. Django 1.11+ and Python 2.7+ or 3.4+ are required. Support for Python versions older than 3.5, and Django versions older than 2.0, will be dropped in dj-stripe 2.0.0. Backwards-incompatible changes and deprecations Removal of polymorphic models The model architecture of dj-stripe has been simplified. Polymorphic models have been dropped and the old base StripeCustomer, StripeCharge, StripeInvoice, etc models have all been merged into the top-level Customer, Charge, Invoice, etc models. Importing those legacy models from djstripe.stripe_objects will yield the new ones. This is deprecated and support for this will be dropped in dj-stripe 2.0.0. Full support for Stripe Sources (Support for v3 stripe.js) Stripe sources ( src_XXXX ) are objects that can arbitrarily reference any of the payment method types that Stripe supports. However, the legacy Card object (with object IDs like card_XXXX or cc_XXXX ) is not a Source object, and cannot be turned into a Source object at this time. In order to support both Card and Source objects in ForeignKeys, a new model PaymentMethod has been devised (renamed to DjstripePaymentMethod in 2.0). That model can resolve into a Card, a Source, or a BankAccount object. The ``default_source`` attribute on ``Customer`` now refers to a ``PaymentMethod`` object . You will need to call .resolve() on it to get the Card or Source in question. References to Customer.sources expecting a queryset of Card objects should be updated to Customer.legacy_cards . The legacy StripeSource name refers to the Card model. This will be removed in dj-stripe 2.0.0. Update your references to either Card or Source . enums.SourceType has been renamed to enums.LegacySourceType . enums.SourceType now refers to the actual Stripe Source types enum. Core fields renamed The numeric id field has been renamed to djstripe_id . This avoids a clash with the upstream stripe id. Accessing .id is deprecated and **will reference the upstream stripe_id in dj-stripe 2.0.0 1.0.0 (2017-08-12) It's finally here! We've made significant changes to the codebase and are now compliant with stripe API version 2017-06-05 . I want to give a huge thanks to all of our contributors for their help in making this happen, especially Bill Huneke (@wahuneke) for his impressive design work and @jleclanche for really pushing this release along. I also want to welcome onboard two more maintainers, @jleclanche and @lskillen. They've stepped up and have graciously dedicated their resources to making dj-stripe such an amazing package. Almost all methods now mimic the parameters of those same methods in the stripe API. Note that some methods do not have some parameters implemented. This is intentional. That being said, expect all method signatures to be different than those in previous versions of dj-stripe. Finally, please note that there is still a bit of work ahead of us. Not everything in the Stripe API is currently supported by dj-stripe -- we're working on it. That said, v1.0.0 has been thoroughly tested and is verified stable in production applications. A few things to get excited for Multiple subscription support (finally) Multiple sources support (currently limited to Cards) Idempotency support (See #455, #460 for discussion -- big thanks to @jleclanche) Full model documentation Objects that come through webhooks are now tied to the API version set in dj-stripe. No more errors if dj-stripe falls behind the newest stripe API version. Any create/update action on an object automatically syncs the object. Concurrent LIVE and TEST mode support (Thanks to @jleclanche). Note that you'll run into issues if livemode isn't set on your existing customer objects. All choices are now enum-based (Thanks @jleclanche, See #520). Access them from the new djstripe.enums module. The ability to check against model property based choices will be deprecated in 1.1 Support for the Coupon model, and coupons on Customer objects. Support for the Payout/Transfer split from api version 2017-04-06 . What still needs to be done (in v1.1.0) Documentation . Our original documentation was not very helpful, but it covered the important bits. It will be very out of date after this update and will need to be rewritten. If you feel like helping, we could use all the help we can get to get this pushed out asap. Master sync re-write . This sounds scary, but really isn't. The current management methods run sync methods on Customer that aren't very helpful and are due for removal. My plan is to write something that first updates local data (via api_retrieve and sync_from_stripe_data ) and then pulls all objects from Stripe and populates the local database with any records that don't already exist there. You might be wondering, \"Why are they releasing this if there are only a few things left?\" Well, that thinking turned this into a two year release... Trust me, this is a good thing. Significant changes (mostly backwards-incompatible) Idempotency . #460 introduces idempotency keys and implements idempotency for Customer.get_or_create() . Idempotency will be enabled for all calls that need it. Improved Admin Interface . This is almost complete. See #451 and #452. Drop non-trivial endpoint views . We're dropping everything except the webhook endpoint and the subscription cancel endpoint. See #428. Drop support for sending receipts . Stripe now handles this for you. See #478. Drop support for plans as settings , including custom plan hierarchy (if you want this, write something custom) and the dynamic trial callback. We've decided to gut having plans as settings. Stripe should be your source of truth; create your plans there and sync them down manually. If you need to create plans locally for testing, etc., simply use the ORM to create Plan models. The sync rewrite will make this drop less annoying. Orphan Customer Sync . We will now sync Customer objects from Stripe even if they aren't linked to local subscriber objects. You can link up subscribers to those Customers manually. Concurrent Live and Test Mode . dj-stripe now supports test-mode and live-mode Customer objects concurrently. As a result, the User.customer One-to-One reverse-relationship is now the User.djstripe_customers RelatedManager. (Thanks @jleclanche) #440. You'll run into some dj-stripe check issues if you don't update your KEY settings accordingly. Check our GitHub issue tracker for help on this. SETTINGS The PLAN_CHOICES , PLAN_LIST , and PAYMENT_PLANS objects are removed. Use Plan.objects.all() instead. The plan_from_stripe_id function is removed. Use Plan.objects.get(stripe_id=) SYNCING sync_plans no longer takes an api_key sync methods no longer take a cu parameter All sync methods are now private. We're in the process of building a better syncing mechanism. UTILITIES dj-stripe decorators now take a plan argument. If you're passing in a custom test function to subscriber_passes_pay_test , be sure to account for this new argument. MIXINS The context provided by dj-stripe's mixins has changed. PaymentsContextMixin now provides STRIPE_PUBLIC_KEY and plans (changed to Plan.objects.all() ). SubscriptionMixin now provides customer and is_plans_plural . We've removed the SubscriptionPaymentRequiredMixin. Use @method_decorator(\"dispatch\", subscription_payment_required ) instead. MIDDLEWARE dj-stripe middleware doesn't support multiple subscriptions. SIGNALS Local custom signals are deprecated in favor of Stripe webhooks: cancelled -> WEBHOOK_SIGNALS[\"customer.subscription.deleted\"] card_changed -> WEBHOOK_SIGNALS[\"customer.source.updated\"] subscription_made -> WEBHOOK_SIGNALS[\"customer.subscription.created\"] WEBHOOK EVENTS The Event Handlers designed by @wahuneke are the new way to handle events that come through webhooks. Definitely take a look at event_handlers.py and webhooks.py . EXCEPTIONS SubscriptionUpdateFailure and SubscriptionCancellationFailure exceptions are removed. There should no longer be a case where they would have been useful. Catch native stripe errors in their place instead. MODELS CHARGE Charge.charge_created -> Charge.stripe_timestamp Charge.card_last_4 and Charge.card_kind are removed. Use Charge.source.last4 and Charge.source.brand (if the source is a Card) Charge.invoice is no longer a foreign key to the Invoice model. Invoice now has a OneToOne relationship with Charge . ( Charge.invoice will still work, but will no longer be represented in the database). CUSTOMER dj-stripe now supports test mode and live mode Customer objects concurrently (See #440). As a result, the <subscriber_model>.customer OneToOne reverse relationship is no longer a thing. You should now instead add a customer property to your subscriber model that checks whether you're in live or test mode (see djstripe.settings.STRIPE_LIVE_MODE as an example) and grabs the customer from <subscriber_model>.djstripe_customers with a simple livemode= filter. Customer no longer has a current_subscription property. We've added a subscription property that should suit your needs. With the advent of multiple subscriptions, the behavior of Customer.subscribe() has changed. Before, calling subscribe() when a customer was already subscribed to a plan would switch the customer to the new plan with an option to prorate. Now calling subscribe() simply subscribes that customer to a new plan in addition to it's current subsription. Use Subscription.update() to change a subscription's plan instead. Customer.cancel_subscription() is removed. Use Subscription.cancel() instead. The Customer.update_plan_quantity() method is removed. Use Subscription.update() instead. CustomerManager is now SubscriptionManager and works on the Subscription model instead of the Customer model. Customer.has_valid_card() is now Customer.has_valid_source() . Customer.update_card() now takes an id. If the id is not supplied, the default source is updated. Customer.stripe_customer property is removed. Use Customer.api_retrieve() instead. The at_period_end parameter of Customer.cancel_subscription() now actually follows the DJSTRIPE_PRORATION_POLICY setting. Customer.card_fingerprint , Customer.card_last_4 , Customer.card_kind , Customer.card_exp_month , Customer.card_exp_year are all removed. Check Customer.default_source (if it's a Card) or one of the sources in Customer.sources (again, if it's a Card) instead. The invoice_id parameter of Customer.add_invoice_item is now named invoice and can be either an Invoice object or the stripe_id of an Invoice. EVENT Event.kind -> Event.type Removed Event.validated_message . Just check if the event is valid no need to double check (we do that for you) TRANSFER Removed Transfer.update_status() Removed Transfer.event TransferChargeFee is removed. It hasn't been used in a while due to a broken API version. Use Transfer.fee_details instead. Any fields that were in Transfer.summary no longer exist and are therefore deprecated (unused but not removed from the database). Because of this, TransferManager now only aggregates total_sum INVOICE Invoice.attempts -> Invoice.attempt_count InvoiceItems are no longer created when Invoices are synced. You must now sync InvoiceItems directly. INVOICEITEM Removed InvoiceItem.line_type PLAN Plan no longer has a stripe_plan property. Use api_retrieve() instead. Plan.currency no longer uses choices. Use the get_supported_currency_choices() utility and create your own custom choices list instead. Plan interval choices are now in Plan.INTERVAL_TYPE_CHOICES SUBSCRIPTION Subscription.is_period_current() now checks for a current trial end if the current period has ended. This change means subscriptions extended with Subscription.extend() will now be seen as valid. MIGRATIONS We'll sync your current records with Stripe in a migration. It will take a while, but it's the only way we can ensure data integrity. There were some fields for which we needed to temporarily add placeholder defaults, so just make sure you have a customer with ID 1 and a plan with ID 1 and you shouldn't run into any issues (create dummy values for these if need be and delete them after the migration). BIG HUGE NOTE - DON'T OVERLOOK THIS Warning Subscription and InvoiceItem migration is not possible because old records don't have Stripe IDs (so we can't sync them). Our approach is to delete all local subscription and invoiceitem objects and re-sync them from Stripe. We 100% recommend you create a backup of your database before performing this upgrade. Other changes Postgres users now have access to the DJSTRIPE_USE_NATIVE_JSONFIELD setting. (Thanks @jleclanche) #517, #523 Charge receipts now take DJSTRIPE_SEND_INVOICE_RECEIPT_EMAILS into account (Thanks @r0fls) Clarified/modified installation documentation (Thanks @pydanny) Corrected and revised ANONYMOUS_USER_ERROR_MSG (Thanks @pydanny) Added fnmatching to SubscriptionPaymentMiddleware (Thanks @pydanny) SubscriptionPaymentMiddleware.process_request() functionality broken up into multiple methods, making local customizations easier (Thanks @pydanny) Fully qualified events are now supported by event handlers as strings e.g. 'customer.subscription.deleted' (Thanks @lskillen) #316 runtests now accepts positional arguments for declaring which tests to run (Thanks @lskillen) #317 It is now possible to reprocess events in both code and the admin interface (Thanks @lskillen) #318 The confirm page now checks that a valid card exists. (Thanks @scream4ik) #325 Added support for viewing upcoming invoices (Thanks @lskillen) #320 Event handler improvements and bugfixes (Thanks @lskillen) #321 API list() method bugfixes (Thanks @lskillen) #322 Added support for a custom webhook event handler (Thanks @lskillen) #323 Django REST Framework contrib package improvements (Thanks @aleccool213) #334 Added tax_percent to CreateSubscriptionSerializer (Thanks @aleccool213) #349 Fixed incorrectly assigned application_fee in Charge calls (Thanks @kronok) #382 Fixed bug caused by API change (Thanks @jessamynsmith) #353 Added inline documentation to pretty much everything and enforced docsytle via flake8 (Thanks @aleccool213) Fixed outdated method call in template (Thanks @kandoio) #391 Customer is correctly purged when subscriber is deleted, regardless of how the deletion happened (Thanks @lskillen) #396 Test webhooks are now properly captured and logged. No more bounced requests to Stripe! (Thanks @jameshiew) #408 CancelSubscriptionView redirect is now more flexible (Thanks @jleclanche) #418 Customer.sync_cards() (Thanks @jleclanche) #438 Many stability fixes, bugfixes, and code cleanup (Thanks @jleclanche) Support syncing canceled subscriptions (Thanks @jleclanche) #443 Improved admin interface (Thanks @jleclanche with @jameshiew) #451 Support concurrent TEST + LIVE API keys (Fix webhook event processing for both modes) (Thanks @jleclanche) #461 Added Stripe Dashboard link to admin change panel (Thanks @jleclanche) #465 Implemented Plan.amount_in_cents (Thanks @jleclanche) #466 Implemented Subscription.reactivate() (Thanks @jleclanche) #470 Added Plan.human_readable_price (Thanks @jleclanche) #498 (Re)attach the Subscriber when we find it's id attached to a customer on Customer sync (Thanks @jleclanche) #500 Made API version configurable (with dj-stripe recommended default) (Thanks @lskillen) #504","title":"dj-stripe 1.x release notes"},{"location":"history/1_x/#dj-stripe-1x-release-notes","text":"","title":"dj-stripe 1.x release notes"},{"location":"history/1_x/#124-2019-02-27","text":"This is a bugfix-only version: Allow billing_cycle_anchor argument when creating a subscription (#814) Fixup plan amount null with tier plans (#781) Update Cancel subscription view tests to match backport in f64af57 Implement Invoice._manipulate_stripe_object_hook for compatability with API 2018-11-08 (#771) Fix product webhook for type=\"good\" (#724) Add trial_from_plan, trial_period_days args to Customer.subscribe() (#709)","title":"1.2.4 (2019-02-27)"},{"location":"history/1_x/#123-2018-10-13","text":"This is a bugfix-only version: Updated Subscription.cancel() for compatibility with Stripe 2018-08-23 (#723)","title":"1.2.3 (2018-10-13)"},{"location":"history/1_x/#122-2018-08-11","text":"This is a bugfix-only version: Fixed an error with request.urlconf in some setups (#562) Always save text-type fields as empty strings in db instead of null (#713) Fix support for DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (#707) Fix reactivate() with Stripe API 2018-02-28 and above","title":"1.2.2 (2018-08-11)"},{"location":"history/1_x/#121-2018-07-18","text":"This is a bugfix-only version: Fixed various Python 2.7 compatibility issues Fixed issues with max_length of receipt_number Fixed various fields incorrectly marked as required Handle product webhook calls Fix compatibility with stripe-python 2.0.0","title":"1.2.1 (2018-07-18)"},{"location":"history/1_x/#120-2018-06-11","text":"The dj-stripe 1.2.0 release resets all migrations. Do not upgrade to 1.2.0 directly from 1.0.1 or below. You must upgrade to 1.1.0 first. Please read the 1.1.0 release notes below for more information.","title":"1.2.0 (2018-06-11)"},{"location":"history/1_x/#110-2018-06-11","text":"In dj-stripe 1.1.0, we made a lot of changes to models in order to bring the dj-stripe model state much closer to the upstream API objects. If you are a current user of dj-stripe, you will most likely have to make changes in order to upgrade. Please read the full changelog below. If you are having trouble upgrading, you may ask for help by filing an issue on GitHub .","title":"1.1.0 (2018-06-11)"},{"location":"history/1_x/#migration-reset","text":"The next version of dj-stripe, 1.2.0 , will reset all the migrations to 0001_initial . Migrations are currently in an unmaintainable state. What this means is you will not be able to upgrade directly to dj-stripe 1.2.0. You must go through 1.1.0 first, run ``manage.py migrate djstripe``, then upgrade to 1.2.0.","title":"Migration reset"},{"location":"history/1_x/#python-27-end-of-life","text":"dj-stripe 1.1.0 drops support for Django 1.10 and adds support for Django 2.0. Django 1.11+ and Python 2.7+ or 3.4+ are required. Support for Python versions older than 3.5, and Django versions older than 2.0, will be dropped in dj-stripe 2.0.0.","title":"Python 2.7 end-of-life"},{"location":"history/1_x/#backwards-incompatible-changes-and-deprecations","text":"","title":"Backwards-incompatible changes and deprecations"},{"location":"history/1_x/#removal-of-polymorphic-models","text":"The model architecture of dj-stripe has been simplified. Polymorphic models have been dropped and the old base StripeCustomer, StripeCharge, StripeInvoice, etc models have all been merged into the top-level Customer, Charge, Invoice, etc models. Importing those legacy models from djstripe.stripe_objects will yield the new ones. This is deprecated and support for this will be dropped in dj-stripe 2.0.0.","title":"Removal of polymorphic models"},{"location":"history/1_x/#full-support-for-stripe-sources-support-for-v3-stripejs","text":"Stripe sources ( src_XXXX ) are objects that can arbitrarily reference any of the payment method types that Stripe supports. However, the legacy Card object (with object IDs like card_XXXX or cc_XXXX ) is not a Source object, and cannot be turned into a Source object at this time. In order to support both Card and Source objects in ForeignKeys, a new model PaymentMethod has been devised (renamed to DjstripePaymentMethod in 2.0). That model can resolve into a Card, a Source, or a BankAccount object. The ``default_source`` attribute on ``Customer`` now refers to a ``PaymentMethod`` object . You will need to call .resolve() on it to get the Card or Source in question. References to Customer.sources expecting a queryset of Card objects should be updated to Customer.legacy_cards . The legacy StripeSource name refers to the Card model. This will be removed in dj-stripe 2.0.0. Update your references to either Card or Source . enums.SourceType has been renamed to enums.LegacySourceType . enums.SourceType now refers to the actual Stripe Source types enum.","title":"Full support for Stripe Sources (Support for v3 stripe.js)"},{"location":"history/1_x/#core-fields-renamed","text":"The numeric id field has been renamed to djstripe_id . This avoids a clash with the upstream stripe id. Accessing .id is deprecated and **will reference the upstream stripe_id in dj-stripe 2.0.0","title":"Core fields renamed"},{"location":"history/1_x/#100-2017-08-12","text":"It's finally here! We've made significant changes to the codebase and are now compliant with stripe API version 2017-06-05 . I want to give a huge thanks to all of our contributors for their help in making this happen, especially Bill Huneke (@wahuneke) for his impressive design work and @jleclanche for really pushing this release along. I also want to welcome onboard two more maintainers, @jleclanche and @lskillen. They've stepped up and have graciously dedicated their resources to making dj-stripe such an amazing package. Almost all methods now mimic the parameters of those same methods in the stripe API. Note that some methods do not have some parameters implemented. This is intentional. That being said, expect all method signatures to be different than those in previous versions of dj-stripe. Finally, please note that there is still a bit of work ahead of us. Not everything in the Stripe API is currently supported by dj-stripe -- we're working on it. That said, v1.0.0 has been thoroughly tested and is verified stable in production applications.","title":"1.0.0 (2017-08-12)"},{"location":"history/1_x/#a-few-things-to-get-excited-for","text":"Multiple subscription support (finally) Multiple sources support (currently limited to Cards) Idempotency support (See #455, #460 for discussion -- big thanks to @jleclanche) Full model documentation Objects that come through webhooks are now tied to the API version set in dj-stripe. No more errors if dj-stripe falls behind the newest stripe API version. Any create/update action on an object automatically syncs the object. Concurrent LIVE and TEST mode support (Thanks to @jleclanche). Note that you'll run into issues if livemode isn't set on your existing customer objects. All choices are now enum-based (Thanks @jleclanche, See #520). Access them from the new djstripe.enums module. The ability to check against model property based choices will be deprecated in 1.1 Support for the Coupon model, and coupons on Customer objects. Support for the Payout/Transfer split from api version 2017-04-06 .","title":"A few things to get excited for"},{"location":"history/1_x/#what-still-needs-to-be-done-in-v110","text":"Documentation . Our original documentation was not very helpful, but it covered the important bits. It will be very out of date after this update and will need to be rewritten. If you feel like helping, we could use all the help we can get to get this pushed out asap. Master sync re-write . This sounds scary, but really isn't. The current management methods run sync methods on Customer that aren't very helpful and are due for removal. My plan is to write something that first updates local data (via api_retrieve and sync_from_stripe_data ) and then pulls all objects from Stripe and populates the local database with any records that don't already exist there. You might be wondering, \"Why are they releasing this if there are only a few things left?\" Well, that thinking turned this into a two year release... Trust me, this is a good thing.","title":"What still needs to be done (in v1.1.0)"},{"location":"history/1_x/#significant-changes-mostly-backwards-incompatible","text":"Idempotency . #460 introduces idempotency keys and implements idempotency for Customer.get_or_create() . Idempotency will be enabled for all calls that need it. Improved Admin Interface . This is almost complete. See #451 and #452. Drop non-trivial endpoint views . We're dropping everything except the webhook endpoint and the subscription cancel endpoint. See #428. Drop support for sending receipts . Stripe now handles this for you. See #478. Drop support for plans as settings , including custom plan hierarchy (if you want this, write something custom) and the dynamic trial callback. We've decided to gut having plans as settings. Stripe should be your source of truth; create your plans there and sync them down manually. If you need to create plans locally for testing, etc., simply use the ORM to create Plan models. The sync rewrite will make this drop less annoying. Orphan Customer Sync . We will now sync Customer objects from Stripe even if they aren't linked to local subscriber objects. You can link up subscribers to those Customers manually. Concurrent Live and Test Mode . dj-stripe now supports test-mode and live-mode Customer objects concurrently. As a result, the User.customer One-to-One reverse-relationship is now the User.djstripe_customers RelatedManager. (Thanks @jleclanche) #440. You'll run into some dj-stripe check issues if you don't update your KEY settings accordingly. Check our GitHub issue tracker for help on this.","title":"Significant changes (mostly backwards-incompatible)"},{"location":"history/1_x/#settings","text":"The PLAN_CHOICES , PLAN_LIST , and PAYMENT_PLANS objects are removed. Use Plan.objects.all() instead. The plan_from_stripe_id function is removed. Use Plan.objects.get(stripe_id=)","title":"SETTINGS"},{"location":"history/1_x/#syncing","text":"sync_plans no longer takes an api_key sync methods no longer take a cu parameter All sync methods are now private. We're in the process of building a better syncing mechanism.","title":"SYNCING"},{"location":"history/1_x/#utilities","text":"dj-stripe decorators now take a plan argument. If you're passing in a custom test function to subscriber_passes_pay_test , be sure to account for this new argument.","title":"UTILITIES"},{"location":"history/1_x/#mixins","text":"The context provided by dj-stripe's mixins has changed. PaymentsContextMixin now provides STRIPE_PUBLIC_KEY and plans (changed to Plan.objects.all() ). SubscriptionMixin now provides customer and is_plans_plural . We've removed the SubscriptionPaymentRequiredMixin. Use @method_decorator(\"dispatch\", subscription_payment_required ) instead.","title":"MIXINS"},{"location":"history/1_x/#middleware","text":"dj-stripe middleware doesn't support multiple subscriptions.","title":"MIDDLEWARE"},{"location":"history/1_x/#signals","text":"Local custom signals are deprecated in favor of Stripe webhooks: cancelled -> WEBHOOK_SIGNALS[\"customer.subscription.deleted\"] card_changed -> WEBHOOK_SIGNALS[\"customer.source.updated\"] subscription_made -> WEBHOOK_SIGNALS[\"customer.subscription.created\"]","title":"SIGNALS"},{"location":"history/1_x/#webhook-events","text":"The Event Handlers designed by @wahuneke are the new way to handle events that come through webhooks. Definitely take a look at event_handlers.py and webhooks.py .","title":"WEBHOOK EVENTS"},{"location":"history/1_x/#exceptions","text":"SubscriptionUpdateFailure and SubscriptionCancellationFailure exceptions are removed. There should no longer be a case where they would have been useful. Catch native stripe errors in their place instead.","title":"EXCEPTIONS"},{"location":"history/1_x/#models","text":"CHARGE Charge.charge_created -> Charge.stripe_timestamp Charge.card_last_4 and Charge.card_kind are removed. Use Charge.source.last4 and Charge.source.brand (if the source is a Card) Charge.invoice is no longer a foreign key to the Invoice model. Invoice now has a OneToOne relationship with Charge . ( Charge.invoice will still work, but will no longer be represented in the database). CUSTOMER dj-stripe now supports test mode and live mode Customer objects concurrently (See #440). As a result, the <subscriber_model>.customer OneToOne reverse relationship is no longer a thing. You should now instead add a customer property to your subscriber model that checks whether you're in live or test mode (see djstripe.settings.STRIPE_LIVE_MODE as an example) and grabs the customer from <subscriber_model>.djstripe_customers with a simple livemode= filter. Customer no longer has a current_subscription property. We've added a subscription property that should suit your needs. With the advent of multiple subscriptions, the behavior of Customer.subscribe() has changed. Before, calling subscribe() when a customer was already subscribed to a plan would switch the customer to the new plan with an option to prorate. Now calling subscribe() simply subscribes that customer to a new plan in addition to it's current subsription. Use Subscription.update() to change a subscription's plan instead. Customer.cancel_subscription() is removed. Use Subscription.cancel() instead. The Customer.update_plan_quantity() method is removed. Use Subscription.update() instead. CustomerManager is now SubscriptionManager and works on the Subscription model instead of the Customer model. Customer.has_valid_card() is now Customer.has_valid_source() . Customer.update_card() now takes an id. If the id is not supplied, the default source is updated. Customer.stripe_customer property is removed. Use Customer.api_retrieve() instead. The at_period_end parameter of Customer.cancel_subscription() now actually follows the DJSTRIPE_PRORATION_POLICY setting. Customer.card_fingerprint , Customer.card_last_4 , Customer.card_kind , Customer.card_exp_month , Customer.card_exp_year are all removed. Check Customer.default_source (if it's a Card) or one of the sources in Customer.sources (again, if it's a Card) instead. The invoice_id parameter of Customer.add_invoice_item is now named invoice and can be either an Invoice object or the stripe_id of an Invoice. EVENT Event.kind -> Event.type Removed Event.validated_message . Just check if the event is valid no need to double check (we do that for you) TRANSFER Removed Transfer.update_status() Removed Transfer.event TransferChargeFee is removed. It hasn't been used in a while due to a broken API version. Use Transfer.fee_details instead. Any fields that were in Transfer.summary no longer exist and are therefore deprecated (unused but not removed from the database). Because of this, TransferManager now only aggregates total_sum INVOICE Invoice.attempts -> Invoice.attempt_count InvoiceItems are no longer created when Invoices are synced. You must now sync InvoiceItems directly. INVOICEITEM Removed InvoiceItem.line_type PLAN Plan no longer has a stripe_plan property. Use api_retrieve() instead. Plan.currency no longer uses choices. Use the get_supported_currency_choices() utility and create your own custom choices list instead. Plan interval choices are now in Plan.INTERVAL_TYPE_CHOICES SUBSCRIPTION Subscription.is_period_current() now checks for a current trial end if the current period has ended. This change means subscriptions extended with Subscription.extend() will now be seen as valid.","title":"MODELS"},{"location":"history/1_x/#migrations","text":"We'll sync your current records with Stripe in a migration. It will take a while, but it's the only way we can ensure data integrity. There were some fields for which we needed to temporarily add placeholder defaults, so just make sure you have a customer with ID 1 and a plan with ID 1 and you shouldn't run into any issues (create dummy values for these if need be and delete them after the migration).","title":"MIGRATIONS"},{"location":"history/1_x/#big-huge-note-dont-overlook-this","text":"Warning Subscription and InvoiceItem migration is not possible because old records don't have Stripe IDs (so we can't sync them). Our approach is to delete all local subscription and invoiceitem objects and re-sync them from Stripe. We 100% recommend you create a backup of your database before performing this upgrade.","title":"BIG HUGE NOTE - DON'T OVERLOOK THIS"},{"location":"history/1_x/#other-changes","text":"Postgres users now have access to the DJSTRIPE_USE_NATIVE_JSONFIELD setting. (Thanks @jleclanche) #517, #523 Charge receipts now take DJSTRIPE_SEND_INVOICE_RECEIPT_EMAILS into account (Thanks @r0fls) Clarified/modified installation documentation (Thanks @pydanny) Corrected and revised ANONYMOUS_USER_ERROR_MSG (Thanks @pydanny) Added fnmatching to SubscriptionPaymentMiddleware (Thanks @pydanny) SubscriptionPaymentMiddleware.process_request() functionality broken up into multiple methods, making local customizations easier (Thanks @pydanny) Fully qualified events are now supported by event handlers as strings e.g. 'customer.subscription.deleted' (Thanks @lskillen) #316 runtests now accepts positional arguments for declaring which tests to run (Thanks @lskillen) #317 It is now possible to reprocess events in both code and the admin interface (Thanks @lskillen) #318 The confirm page now checks that a valid card exists. (Thanks @scream4ik) #325 Added support for viewing upcoming invoices (Thanks @lskillen) #320 Event handler improvements and bugfixes (Thanks @lskillen) #321 API list() method bugfixes (Thanks @lskillen) #322 Added support for a custom webhook event handler (Thanks @lskillen) #323 Django REST Framework contrib package improvements (Thanks @aleccool213) #334 Added tax_percent to CreateSubscriptionSerializer (Thanks @aleccool213) #349 Fixed incorrectly assigned application_fee in Charge calls (Thanks @kronok) #382 Fixed bug caused by API change (Thanks @jessamynsmith) #353 Added inline documentation to pretty much everything and enforced docsytle via flake8 (Thanks @aleccool213) Fixed outdated method call in template (Thanks @kandoio) #391 Customer is correctly purged when subscriber is deleted, regardless of how the deletion happened (Thanks @lskillen) #396 Test webhooks are now properly captured and logged. No more bounced requests to Stripe! (Thanks @jameshiew) #408 CancelSubscriptionView redirect is now more flexible (Thanks @jleclanche) #418 Customer.sync_cards() (Thanks @jleclanche) #438 Many stability fixes, bugfixes, and code cleanup (Thanks @jleclanche) Support syncing canceled subscriptions (Thanks @jleclanche) #443 Improved admin interface (Thanks @jleclanche with @jameshiew) #451 Support concurrent TEST + LIVE API keys (Fix webhook event processing for both modes) (Thanks @jleclanche) #461 Added Stripe Dashboard link to admin change panel (Thanks @jleclanche) #465 Implemented Plan.amount_in_cents (Thanks @jleclanche) #466 Implemented Subscription.reactivate() (Thanks @jleclanche) #470 Added Plan.human_readable_price (Thanks @jleclanche) #498 (Re)attach the Subscriber when we find it's id attached to a customer on Customer sync (Thanks @jleclanche) #500 Made API version configurable (with dj-stripe recommended default) (Thanks @lskillen) #504","title":"Other changes"},{"location":"history/2_4_0/","text":"dj-stripe 2.4.0 release notes (2020-11-19) Attention To upgrade to 2.4.0 from older versions of dj-stripe, scroll down to the Upgrade Guide . Introducing sponsorships and our first sponsor We're excited to introduce our Sponsorship tiers . Individuals may back dj-stripe to assist with development. Larger backers may choose one the paid support plans available to receive support on top of ensuring the long-term viability of the project! And this release was made possible by none other than\u2026 Stripe ! Our very first Gold sponsor. Their financial backing has allowed us to pour a lot of work that could not have otherwise happened. Release notes Support for Django 3.1 and Python 3.8. Minimum stripe-python version is now 2.48.0. Default Stripe API version is now 2020-08-27 . First-class support for the Price model, replacing Plans. Support multi-item subscriptions. Support for API keys in the database (see Managing Stripe API keys ). Support for syncing objects for multiple, different Stripe accounts. Use Django 3.1 native JSONField when available. The field djstripe_owner_account has been added to all Stripe models, and is automatically populated with the Account that owns the API key used to retrieve it. Support for subscription schedules (#899). Add support for Reporting categories and TaxIds Update many models to match latest version of the Stripe API. Fixed Account.get_default_account() for Restricted API Keys. Allow passing arbitrary arguments (any valid SDK argument) to the following methods: Customer.charge() Customer.subscribe() , Charge.capture() Subscription.update() New management command: djstripe_update_invoiceitem_ids . This command migrates InvoiceItems using Stripe's old IDs to the new ones. Hundreds of other bugfixes. New feature: in-database Stripe API keys Stripe API keys are now stored in the database, and are now editable in the admin. Warning By default, all keys are visible by anyone who has access to the dj-stripe administration. Why? As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway. In the next release, we are planning to make WebhookEndpoints (and thus webhook secrets) manageable via the database as well. Do I need to change anything? Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity. What about public keys? Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated next release. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys). Deprecated features Nobody likes features being removed. However, the last few releases we have had to remove features that were not core to what dj-stripe does, or simply poorly-maintained. To keep up with the trend, we are making three major deprecations this release: Creating Plans from the Django Admin is no longer supported The Plan model was special cased in various places, including being the only one which supported being created from the Django administration. This is no longer supported. We have plans to allow creating arbitrary Stripe objects from the Django Admin, but until it can be done consistently, we have decided to remove the feature for Plans (which are deprecated by Stripe anyway). The only object type you should be dealing with from the admin is the new APIKey model. Along with this, we are also deprecating the djstripe_sync_plans_from_stripe management command. You can instead use the djstripe_sync_models management command, which supports arbitrary models. Deprecating the REST API We are dropping all support for the REST API and will be fully removing it in 2.5.0. We're doing this because we wish to keep such an API separate from dj-stripe. Work has already started on a new project, and we will be sharing more details about it soon. If you're interested in helping out, please reach out on Github ! Deprecating djstripe.middleware.SubscriptionPaymentMiddleware Large parts of dj-stripe, including this middleware, were designed before Stripe's major revamps of the old Plan model into Prices, Products, and multi-plan subscriptions. The functionality offered by the middleware is no longer adequate, and building on top of it would not be particularly robust. We may bring similar functionality back in the future, but the middleware as it is is going away (as well as the undocumented djstripe.utils.subscriber_has_active_subscription utility function). If you want to keep the functionality for your project, you may wish to copy the latest version of the middleware . Deprecating djstripe.mixins This is being deprecated for similar reasons as the SubscriptionPaymentMiddleware. However, the mixins module was undocumented and never officially supported. Other deprecations The account field on Charge has been renamed to on_behalf_of , to be consistent with Stripe's upstream model. Note that this field is separate from djstripe_owner_account , which is set by dj-stripe itself to match the account of the API key used. Account.get_connected_account_from_token() is deprecated in favour of Account.get_or_retrieve_for_api_key() , which supports more than just Connect accounts. Customer.has_active_subscription() is deprecated in favour of Customer.is_subscribed_to() . Note that the former takes a plan as argument, whereas the latter takes a product as argument. The tax_percent attribute of Invoice is no longer populated and will be removed in 2.5.0. You may want to use Invoice.default_tax_rates instead, which uses the new TaxId functionality. Customer.business_vat_id is being deprecated in favour of using TaxId models directly. Breaking changes Rename PlanBillingScheme to BillingScheme. Remove Plan.update_name() and these previously-deprecated fields: Customer.business_vat_id Subscription.start Subscription.billing Upgrade Guide Before you upgrade to dj-stripe 2.4.0, we recommend upgrading to dj-stripe 2.3.0. Upgrading one major release at a time minimizes the risk of issues arising. Upgrading directly to 2.4.0 from dj-stripe versions older than 2.2.0 is unsupported. To upgrade dj-stripe, run pip install --upgrade dj-stripe==2.4.0 . Once installed, you can run manage.py migrate djstripe to migrate the database models. Attention If you are doing multiple major dj-stripe upgrades in a row, remember to run the migrate command after every upgrade. Skipping this step WILL cause errors. Note Migrating the database models may take a long time on databases with large amounts of customers. Settings changes A new mandatory setting DJSTRIPE_FOREIGN_KEY_TO_FIELD has been added. If you are upgrading from an older version, you need to set it to \"djstripe_id\" . Setting it to \"id\" will make dj-stripe use the Stripe IDs as foreign keys. Although this is recommended for new installations, there is currently no migration available for going from \"djstripe_id\" to \"id\" . For more information on this setting, see Settings .","title":"dj-stripe 2.4 release notes"},{"location":"history/2_4_0/#dj-stripe-240-release-notes-2020-11-19","text":"Attention To upgrade to 2.4.0 from older versions of dj-stripe, scroll down to the Upgrade Guide .","title":"dj-stripe 2.4.0 release notes (2020-11-19)"},{"location":"history/2_4_0/#introducing-sponsorships-and-our-first-sponsor","text":"We're excited to introduce our Sponsorship tiers . Individuals may back dj-stripe to assist with development. Larger backers may choose one the paid support plans available to receive support on top of ensuring the long-term viability of the project! And this release was made possible by none other than\u2026 Stripe ! Our very first Gold sponsor. Their financial backing has allowed us to pour a lot of work that could not have otherwise happened.","title":"Introducing sponsorships and our first sponsor"},{"location":"history/2_4_0/#release-notes","text":"Support for Django 3.1 and Python 3.8. Minimum stripe-python version is now 2.48.0. Default Stripe API version is now 2020-08-27 . First-class support for the Price model, replacing Plans. Support multi-item subscriptions. Support for API keys in the database (see Managing Stripe API keys ). Support for syncing objects for multiple, different Stripe accounts. Use Django 3.1 native JSONField when available. The field djstripe_owner_account has been added to all Stripe models, and is automatically populated with the Account that owns the API key used to retrieve it. Support for subscription schedules (#899). Add support for Reporting categories and TaxIds Update many models to match latest version of the Stripe API. Fixed Account.get_default_account() for Restricted API Keys. Allow passing arbitrary arguments (any valid SDK argument) to the following methods: Customer.charge() Customer.subscribe() , Charge.capture() Subscription.update() New management command: djstripe_update_invoiceitem_ids . This command migrates InvoiceItems using Stripe's old IDs to the new ones. Hundreds of other bugfixes.","title":"Release notes"},{"location":"history/2_4_0/#new-feature-in-database-stripe-api-keys","text":"Stripe API keys are now stored in the database, and are now editable in the admin. Warning By default, all keys are visible by anyone who has access to the dj-stripe administration.","title":"New feature: in-database Stripe API keys"},{"location":"history/2_4_0/#why","text":"As we work on supporting multiple Stripe accounts per instance, it is vital for dj-stripe to have a mechanism to store more than one Stripe API key. It also became obvious that we may want proper programmatic access to create and delete keys. Furthermore, API keys are a legitimate upstream Stripe object, and it is not unlikely the API may allow access to listing other API keys in the future, in which case we will want to move them to the database anyway. In the next release, we are planning to make WebhookEndpoints (and thus webhook secrets) manageable via the database as well.","title":"Why?"},{"location":"history/2_4_0/#do-i-need-to-change-anything","text":"Not at this time. The settings STRIPE_LIVE_SECRET_KEY and STRIPE_TEST_SECRET_KEY can still be used. Their values will however be automatically saved to the database at the earliest opportunity.","title":"Do I need to change anything?"},{"location":"history/2_4_0/#what-about-public-keys","text":"Setting STRIPE_LIVE_PUBLIC_KEY and STRIPE_TEST_PUBLIC_KEY will be deprecated next release. You do not risk anything by leaving them in your settings: They are not used by Dj-Stripe outside of the Dj-Stripe mixins, which are now themselves deprecated. So you can safely leave them in your settings, or you can move them to the database as well (Keys beginning in pk_test_ and pk_live_ will be detected as publishable keys).","title":"What about public keys?"},{"location":"history/2_4_0/#deprecated-features","text":"Nobody likes features being removed. However, the last few releases we have had to remove features that were not core to what dj-stripe does, or simply poorly-maintained. To keep up with the trend, we are making three major deprecations this release:","title":"Deprecated features"},{"location":"history/2_4_0/#creating-plans-from-the-django-admin-is-no-longer-supported","text":"The Plan model was special cased in various places, including being the only one which supported being created from the Django administration. This is no longer supported. We have plans to allow creating arbitrary Stripe objects from the Django Admin, but until it can be done consistently, we have decided to remove the feature for Plans (which are deprecated by Stripe anyway). The only object type you should be dealing with from the admin is the new APIKey model. Along with this, we are also deprecating the djstripe_sync_plans_from_stripe management command. You can instead use the djstripe_sync_models management command, which supports arbitrary models.","title":"Creating Plans from the Django Admin is no longer supported"},{"location":"history/2_4_0/#deprecating-the-rest-api","text":"We are dropping all support for the REST API and will be fully removing it in 2.5.0. We're doing this because we wish to keep such an API separate from dj-stripe. Work has already started on a new project, and we will be sharing more details about it soon. If you're interested in helping out, please reach out on Github !","title":"Deprecating the REST API"},{"location":"history/2_4_0/#deprecating-djstripemiddlewaresubscriptionpaymentmiddleware","text":"Large parts of dj-stripe, including this middleware, were designed before Stripe's major revamps of the old Plan model into Prices, Products, and multi-plan subscriptions. The functionality offered by the middleware is no longer adequate, and building on top of it would not be particularly robust. We may bring similar functionality back in the future, but the middleware as it is is going away (as well as the undocumented djstripe.utils.subscriber_has_active_subscription utility function). If you want to keep the functionality for your project, you may wish to copy the latest version of the middleware .","title":"Deprecating djstripe.middleware.SubscriptionPaymentMiddleware"},{"location":"history/2_4_0/#deprecating-djstripemixins","text":"This is being deprecated for similar reasons as the SubscriptionPaymentMiddleware. However, the mixins module was undocumented and never officially supported.","title":"Deprecating djstripe.mixins"},{"location":"history/2_4_0/#other-deprecations","text":"The account field on Charge has been renamed to on_behalf_of , to be consistent with Stripe's upstream model. Note that this field is separate from djstripe_owner_account , which is set by dj-stripe itself to match the account of the API key used. Account.get_connected_account_from_token() is deprecated in favour of Account.get_or_retrieve_for_api_key() , which supports more than just Connect accounts. Customer.has_active_subscription() is deprecated in favour of Customer.is_subscribed_to() . Note that the former takes a plan as argument, whereas the latter takes a product as argument. The tax_percent attribute of Invoice is no longer populated and will be removed in 2.5.0. You may want to use Invoice.default_tax_rates instead, which uses the new TaxId functionality. Customer.business_vat_id is being deprecated in favour of using TaxId models directly.","title":"Other deprecations"},{"location":"history/2_4_0/#breaking-changes","text":"Rename PlanBillingScheme to BillingScheme. Remove Plan.update_name() and these previously-deprecated fields: Customer.business_vat_id Subscription.start Subscription.billing","title":"Breaking changes"},{"location":"history/2_4_0/#upgrade-guide","text":"Before you upgrade to dj-stripe 2.4.0, we recommend upgrading to dj-stripe 2.3.0. Upgrading one major release at a time minimizes the risk of issues arising. Upgrading directly to 2.4.0 from dj-stripe versions older than 2.2.0 is unsupported. To upgrade dj-stripe, run pip install --upgrade dj-stripe==2.4.0 . Once installed, you can run manage.py migrate djstripe to migrate the database models. Attention If you are doing multiple major dj-stripe upgrades in a row, remember to run the migrate command after every upgrade. Skipping this step WILL cause errors. Note Migrating the database models may take a long time on databases with large amounts of customers.","title":"Upgrade Guide"},{"location":"history/2_4_0/#settings-changes","text":"A new mandatory setting DJSTRIPE_FOREIGN_KEY_TO_FIELD has been added. If you are upgrading from an older version, you need to set it to \"djstripe_id\" . Setting it to \"id\" will make dj-stripe use the Stripe IDs as foreign keys. Although this is recommended for new installations, there is currently no migration available for going from \"djstripe_id\" to \"id\" . For more information on this setting, see Settings .","title":"Settings changes"},{"location":"history/2_4_x/","text":"dj-stripe 2.4.4 release notes (2021-05-22) Fix syncing of tax IDs in management commands Set default_auto_field in migrations to prevent creation of extra migrations Misc test and documentation fixes dj-stripe 2.4.3 release notes (2021-02-08) Fix webhook error when processing events that contain a reference to a deleted payment method (such as a refund on a payment whose card has been detached or removed) Fix a couple of regressions in djstripe_sync_models management command. dj-stripe 2.4.2 release notes (2021-01-24) Release notes Fix error in Customer.add_card() due to Stripe's sources deprecation. (#1293) Fix Subscription.update() usage of the deprecated Stripe prorate argument. dj-stripe now explicitly uses proration_behavior , setting it to \"none\" when prorate is False , and \"create_prorations\" when prorate is True . dj-stripe 2.4.1 release notes (2020-11-29) Release notes Upgrade default Stripe API version to 2020-08-27 . Although we documented doing so in 2.4.0, it was not correctly set as such. This has been fixed for consistency. The Price model was incorrectly released with an amount_in_cents property, matching that of the Plan model. However, Price amounts are already in cent. The property has been removed, use unit_amount instead. Fix Price.human_readable_price calculation Fix non-blank nullable Charge fields Fix Price.tiers not being synced correctly with djstripe_sync_models (#1284) Fix sync model recursion loop (see #1288)","title":"dj-stripe 2.4.1 release notes"},{"location":"history/2_4_x/#dj-stripe-244-release-notes-2021-05-22","text":"Fix syncing of tax IDs in management commands Set default_auto_field in migrations to prevent creation of extra migrations Misc test and documentation fixes","title":"dj-stripe 2.4.4 release notes (2021-05-22)"},{"location":"history/2_4_x/#dj-stripe-243-release-notes-2021-02-08","text":"Fix webhook error when processing events that contain a reference to a deleted payment method (such as a refund on a payment whose card has been detached or removed) Fix a couple of regressions in djstripe_sync_models management command.","title":"dj-stripe 2.4.3 release notes (2021-02-08)"},{"location":"history/2_4_x/#dj-stripe-242-release-notes-2021-01-24","text":"","title":"dj-stripe 2.4.2 release notes (2021-01-24)"},{"location":"history/2_4_x/#release-notes","text":"Fix error in Customer.add_card() due to Stripe's sources deprecation. (#1293) Fix Subscription.update() usage of the deprecated Stripe prorate argument. dj-stripe now explicitly uses proration_behavior , setting it to \"none\" when prorate is False , and \"create_prorations\" when prorate is True .","title":"Release notes"},{"location":"history/2_4_x/#dj-stripe-241-release-notes-2020-11-29","text":"","title":"dj-stripe 2.4.1 release notes (2020-11-29)"},{"location":"history/2_4_x/#release-notes_1","text":"Upgrade default Stripe API version to 2020-08-27 . Although we documented doing so in 2.4.0, it was not correctly set as such. This has been fixed for consistency. The Price model was incorrectly released with an amount_in_cents property, matching that of the Plan model. However, Price amounts are already in cent. The property has been removed, use unit_amount instead. Fix Price.human_readable_price calculation Fix non-blank nullable Charge fields Fix Price.tiers not being synced correctly with djstripe_sync_models (#1284) Fix sync model recursion loop (see #1288)","title":"Release notes"},{"location":"history/2_x/","text":"dj-stripe 2.0 ~ 2.3 release notes 2.3.0 (2020-04-19) The minimum version of Django is now 2.1, and Python 3.6. Changed JSONField dependency back to jsonfield from jsonfield2 (see Warning about safe uninstall of jsonfield2 on upgrade ). Fixed handling of TaxRate events (#1094). Fixed pagination issue in Invoice.sync_from_stripe_data (#1052). Fixed pagination issues in Subscription & Charge .sync_from_stripe_data (#1054). Tidyup _stripe_object_set_total_tax_amounts unique handling (#1139). Dropped previously-deprecated Invoice fields (see https://stripe.com/docs/upgrades#2018-11-08 ): .closed .forgiven .billing (renamed to .collection_method ) Dropped previously-deprecated enums.InvoiceStatus (#1020). Deprecated the following fields - will be removed in 2.4 (#1087): Subscription.billing (use .collection_method instead) Subscription.start (use .start_date instead) Subscription.tax_percent (use .default_tax_rates instead) Added Invoice.status and enums.InvoiceStatus (#1020). Added new Invoice fields (#1020, #1087): .discount .default_source .status Added new Subscription fields (#1087): .default_payment_method .default_source .next_pending_invoice_item_invoice .pending_invoice_item_interval .pending_update .start_date Warning about safe uninstall of jsonfield2 on upgrade Both jsonfield and jsonfield2 use the same import path, so if upgrading from dj-stripe\\~=2.2.0 in an existing virtualenv, be sure to uninstall jsonfield2 first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield2 -y && pip install \"dj-stripe>=2.3.0dev\" Otherwise, pip uninstall jsonfield2 will remove jsonfield's jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.3.0\" Note that this is only necessary if upgrading from dj-stripe 2.2.x, which temporarily depended on jsonfield2. This process is not necessary if upgrading from an earlier version of dj-stripe. 2.2.2 (2020-01-20) This is a bugfix-only version: Fixed handling of TaxRate events (#1094). 2.2.1 (2020-01-14) This is a bugfix-only version: Fixed bad package build. 2.2.0 (2020-01-13) Changed JSONField dependency package from jsonfield to jsonfield2 , for Django 3 compatibility (see Warning about safe uninstall of jsonfield on upgrade ). Note that Django 2.1 requires jsonfield<3.1. Added support for Django 3.0 (requires jsonfield2>=3.0.3). Added support for python 3.8. Refactored UpcomingInvoice , so it's no longer a subclass of Invoice (to allow Invoice to use ManyToManyFields ). Dropped previously-deprecated Account fields (see https://stripe.com/docs/upgrades#2019-02-19 ): .business_name .business_primary_color .business_url (changed to a property) .debit_negative_balances .decline_charge_on .display_name .legal_entity .payout_schedule .payout_statement_descriptor .statement_descriptor .support_email .support_phone .support_url .timezone .verification Dropped previously-deprecated Account.business_logo property (renamed to .branding_icon ) Dropped previously-deprecated Customer.account_balance property (renamed to .balance ) Dropped previously-deprecated properties Invoice.application_fee , Invoice.date Dropped previously-deprecated enum PaymentMethodType (use DjstripePaymentMethodType instead) Renamed Invoice.billing to .collection_method (added deprecated property for the old name). Updated Invoice model to add missing fields. Added TaxRate model, and Invoice.default_tax_rates , InvoiceItem.tax_rates , Invoice.total_tax_amounts , Subscription.default_tax_rates , SubscriptionItem.tax_rates (#1027). Change urls.py to use the new style urls. Update forward relation fields in the admin to be raw id fields. Updated StripeQuantumCurrencyAmountField and StripeDecimalCurrencyAmountField to support Stripe Large Charges (#1045). Update event handling so customer.subscription.deleted updates subscriptions to status=\"canceled\" instead of deleting it from our database, to match Stripe's behaviour (#599). Added missing Refund.reason value, increases field width (#1075). Fixed Refund.status definition, reduces field width (#1076). Deprecated non-standard Invoice.status (renamed to Invoice.legacy_status ) to make way for the Stripe field (preparation for #1020). Warning about safe uninstall of jsonfield on upgrade Both jsonfield and jsonfield2 use the same import path, so if upgrading to dj-stripe>=2.2 in an existing virtualenv, be sure to uninstall jsonfield first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield -y && pip install \"dj-stripe>=2.2.0\" Otherwise, pip uninstall jsonfield will remove jsonfield2\u2019s jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.2.0\" Note on usage of Stripe Elements JS See Integrating Stripe Elements for notes about usage of the Stripe Elements frontend JS library. In summary: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() to stripe.createToken() . 2.1.1 (2019-10-01) This is a bugfix-only release: Updated webhook signals list (#1000). Fixed issue syncing PaymentIntent with destination charge (#960). Fixed Customer.subscription and .valid_subscriptions() to ignore status=incomplete_expired (#1006). Fixed error on paymentmethod.detached event with card_xxx payment methods (#967). Added PaymentMethod.detach() (#943). Updated help_text on all currency fields to make it clear if they're holding integer cents ( StripeQuantumCurrencyAmountField ) or decimal dollar (or euro, pound etc) ( StripeDecimalCurrencyAmountField ) (#999) Documented our preferred Django model field types (#986) Upcoming migration of currency fields (storage as cents instead of dollars) Please be aware that we're looking at standardising our currency storage fields as integer quanta (cents) instead of Decimal (dollar) values, to match stripe. This is intended to be part of the 3.0 release, since it will involve some breaking changes. See #955 for details and discussion. 2.1.0 (2019-09-12) Dropped Django 2.0 support The Python stripe library minimum version is now 2.32.0 , also 2.36.0 is excluded due to a regression (#991). Dropped previously-deprecated Charge.fee_details property. Dropped previously-deprecated Transfer.fee_details property. Dropped previously-deprecated field_name parameter to sync_from_stripe_data Dropped previously-deprecated alias StripeObject of StripeModel Dropped previously-deprecated alias PaymentMethod of DjstripePaymentMethod Dropped previously-deprecated properties Charge.source_type and Charge.source_stripe_id enums.PaymentMethodType has been deprecated, use enums.DjstripePaymentMethodType Made SubscriptionItem.quantity nullable as per Plans with usage_type=\"metered\" (follow-up to #865) Added manage commands djstripe_sync_models and djstripe_process_events (#727, #89) Fixed issue with re-creating a customer after Customer.purge() (#916) Fixed sync of Customer Bank Accounts (#829) Fixed Subscription.is_status_temporarily_current() (#852) New models Payment Intent Setup Intent Payment Method Session Added fields to Customer model: address , invoice_prefix , invoice_settings , phone , preferred_locales , tax_exempt Changes from API 2018-11-08: Added Invoice.auto_advance , deprecated Invoice.closed and Invoice.forgiven , see https://stripe.com/docs/billing/migration/invoice-states#upgrade-checklist Changes from API 2019-02-19: Major changes to Account fields, see https://stripe.com/docs/upgrades#2019-02-19 , updated Account fields to match API 2019-02-19: Added Account.business_profile , .business_type , .company , .individual , .requirements , .settings Deprecated the existing fields, to be removed in 2.2 Special handling of the icon and logo fields: > - Renamed Account.business_logo to Account.branding_icon > (note that in Stripe's API Account.business_logo was renamed > to Account.settings.branding_icon , and > Account.business_logo_large (which we didn't have a field > for) was renamed to Account.settings.branding_logo ) > - Added deprecated property for Account.business_logo > - Added Account.branding_logo as a ForeignKey > - Populate Account.branding_icon and .branding_logo from the > new Account.settings.branding.icon and .logo Changes from API 2019-03-14: Renamed Invoice.application_fee to Invoice.application_fee_amount (added deprecated property for the old name) Removed Invoice.date , in place of Invoice.created (added deprecated property for the old name) Added Invoice.status_transitions Renamed Customer.account_balance to Customer.balance (added deprecated property for the old name) Renamed Customer.payment_methods to Customer.customer_payment_methods Added new SubscriptionStatus.incomplete and SubscriptionStatus.incomplete_expired statuses (#974) Added new BalanceTransactionType values (#983) Squashed dev migrations As per our migration policy , unreleased migrations on the master branch have been squashed. If you have been using the 2.1.0dev branch from master, you'll need to run the squashed migrations migrations before upgrading to >=2.1.0. The simplest way to do this is to pip install dj-stripe==2.1.0rc0 and migrate, alternatively check out the 2.1.0rc0 git tag. 2.0.5 (2019-09-12) This is a bugfix-only version: Avoid stripe==2.36.0 due to regression (#991) 2.0.4 (2019-09-09) This is a bugfix-only version: Fixed irreversible migration (#909) 2.0.3 (2019-06-11) This is a bugfix-only version: In _get_or_create_from_stripe_object , wrap create _create_from_stripe_object in transaction, fixes TransactionManagementError on race condition in webhook processing (#877, #903). 2.0.2 (2019-06-09) This is a bugfix-only version: Don't save event objects if the webhook processing fails (#832). Fixed IntegrityError when REMOTE_ADDR is an empty string. Deprecated field_name parameter to sync_from_stripe_data 2.0.1 (2019-04-29) This is a bugfix-only version: Fixed an error on invoiceitem.updated (#848). Handle test webhook properly in recent versions of Stripe API (#779). At some point 2018 Stripe silently changed the ID used for test events and evt_00000000000000 is not used anymore. Fixed OperationalError seen in migration 0003 on postgres (#850). Fixed issue with migration 0003 not being unapplied correctly (#882). Fixed missing SubscriptionItem.quantity on metered Plans (#865). Fixed Plan.create() (#870). 2.0.0 (2019-03-01) The Python stripe library minimum version is now 2.3.0 . PaymentMethod has been renamed to DjstripePaymentMethod (#841). An alias remains but will be removed in the next version. Dropped support for Django<2.0, Python<3.4. Dropped previously-deprecated stripe_objects module. Dropped previously-deprecated stripe_timestamp field. Dropped previously-deprecated Charge.receipt_number field. Dropped previously-deprecated StripeSource alias for Card Dropped previously-deprecated SubscriptionView , CancelSubscriptionView and CancelSubscriptionForm . Removed the default value from DJSTRIPE_SUBSCRIPTION_REDIRECT . All stripe_id fields have been renamed id . Charge.source_type has been deprecated. Use Charge.source.type . Charge.source_stripe_id has been deprecated. Use Charge.source.id . All deprecated Transfer fields (Stripe API 2017-04-06 and older), have been dropped. This includes date , destination_type ( type ), failure_code , failure_message , statement_descriptor and status . Fixed IntegrityError when REMOTE_ADDR is missing (#640). New models: ApplicationFee ApplicationFeeRefund BalanceTransaction CountrySpec ScheduledQuery SubscriptionItem TransferReversal UsageRecord The fee and fee_details attributes of both the Charge and Transfer objects are no longer stored in the database. Instead, they access their respective new balance_transaction foreign key. Note that fee_details has been deprecated on both models. The fraudulent attribute on Charge is now a property that checks the fraud_details field. Object key validity is now always enforced (#503). Customer.sources no longer refers to a Card queryset, but to a Source queryset. In order to correctly transition, you should change all your references to customer.sources to customer.legacy_cards instead. The legacy_cards attribute already exists in 1.2.0. Customer.sources_v3 is now named Customer.sources . A new property Customer.payment_methods is now available, which allows you to iterate over all of a customer's payment methods (sources then cards). Card.customer is now nullable and cards are no longer deleted when their corresponding customer is deleted (#654). Webhook signature verification is now available and is preferred. Set the DJSTRIPE_WEBHOOK_SECRET setting to your secret to start using it. StripeObject has been renamed StripeModel . An alias remains but will be removed in the next version. The metadata key used in the Customer object can now be configured by changing the DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY setting. Setting this to None or an empty string now also disables the behaviour altogether. Text-type fields in dj-stripe will no longer ever be None. Instead, any falsy text field will return an empty string. Switched test runner to pytest-django StripeModel.sync_from_stripe_data() will now automatically retrieve related objects and populate foreign keys (#681) Added Coupon.name Added Transfer.balance_transaction Exceptions in webhooks are now re-raised as well as saved in the database (#833)","title":"dj-stripe 2.0 ~ 2.3 release notes"},{"location":"history/2_x/#dj-stripe-20-23-release-notes","text":"","title":"dj-stripe 2.0 ~ 2.3 release notes"},{"location":"history/2_x/#230-2020-04-19","text":"The minimum version of Django is now 2.1, and Python 3.6. Changed JSONField dependency back to jsonfield from jsonfield2 (see Warning about safe uninstall of jsonfield2 on upgrade ). Fixed handling of TaxRate events (#1094). Fixed pagination issue in Invoice.sync_from_stripe_data (#1052). Fixed pagination issues in Subscription & Charge .sync_from_stripe_data (#1054). Tidyup _stripe_object_set_total_tax_amounts unique handling (#1139). Dropped previously-deprecated Invoice fields (see https://stripe.com/docs/upgrades#2018-11-08 ): .closed .forgiven .billing (renamed to .collection_method ) Dropped previously-deprecated enums.InvoiceStatus (#1020). Deprecated the following fields - will be removed in 2.4 (#1087): Subscription.billing (use .collection_method instead) Subscription.start (use .start_date instead) Subscription.tax_percent (use .default_tax_rates instead) Added Invoice.status and enums.InvoiceStatus (#1020). Added new Invoice fields (#1020, #1087): .discount .default_source .status Added new Subscription fields (#1087): .default_payment_method .default_source .next_pending_invoice_item_invoice .pending_invoice_item_interval .pending_update .start_date","title":"2.3.0 (2020-04-19)"},{"location":"history/2_x/#warning-about-safe-uninstall-of-jsonfield2-on-upgrade","text":"Both jsonfield and jsonfield2 use the same import path, so if upgrading from dj-stripe\\~=2.2.0 in an existing virtualenv, be sure to uninstall jsonfield2 first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield2 -y && pip install \"dj-stripe>=2.3.0dev\" Otherwise, pip uninstall jsonfield2 will remove jsonfield's jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.3.0\" Note that this is only necessary if upgrading from dj-stripe 2.2.x, which temporarily depended on jsonfield2. This process is not necessary if upgrading from an earlier version of dj-stripe.","title":"Warning about safe uninstall of jsonfield2 on upgrade"},{"location":"history/2_x/#222-2020-01-20","text":"This is a bugfix-only version: Fixed handling of TaxRate events (#1094).","title":"2.2.2 (2020-01-20)"},{"location":"history/2_x/#221-2020-01-14","text":"This is a bugfix-only version: Fixed bad package build.","title":"2.2.1 (2020-01-14)"},{"location":"history/2_x/#220-2020-01-13","text":"Changed JSONField dependency package from jsonfield to jsonfield2 , for Django 3 compatibility (see Warning about safe uninstall of jsonfield on upgrade ). Note that Django 2.1 requires jsonfield<3.1. Added support for Django 3.0 (requires jsonfield2>=3.0.3). Added support for python 3.8. Refactored UpcomingInvoice , so it's no longer a subclass of Invoice (to allow Invoice to use ManyToManyFields ). Dropped previously-deprecated Account fields (see https://stripe.com/docs/upgrades#2019-02-19 ): .business_name .business_primary_color .business_url (changed to a property) .debit_negative_balances .decline_charge_on .display_name .legal_entity .payout_schedule .payout_statement_descriptor .statement_descriptor .support_email .support_phone .support_url .timezone .verification Dropped previously-deprecated Account.business_logo property (renamed to .branding_icon ) Dropped previously-deprecated Customer.account_balance property (renamed to .balance ) Dropped previously-deprecated properties Invoice.application_fee , Invoice.date Dropped previously-deprecated enum PaymentMethodType (use DjstripePaymentMethodType instead) Renamed Invoice.billing to .collection_method (added deprecated property for the old name). Updated Invoice model to add missing fields. Added TaxRate model, and Invoice.default_tax_rates , InvoiceItem.tax_rates , Invoice.total_tax_amounts , Subscription.default_tax_rates , SubscriptionItem.tax_rates (#1027). Change urls.py to use the new style urls. Update forward relation fields in the admin to be raw id fields. Updated StripeQuantumCurrencyAmountField and StripeDecimalCurrencyAmountField to support Stripe Large Charges (#1045). Update event handling so customer.subscription.deleted updates subscriptions to status=\"canceled\" instead of deleting it from our database, to match Stripe's behaviour (#599). Added missing Refund.reason value, increases field width (#1075). Fixed Refund.status definition, reduces field width (#1076). Deprecated non-standard Invoice.status (renamed to Invoice.legacy_status ) to make way for the Stripe field (preparation for #1020).","title":"2.2.0 (2020-01-13)"},{"location":"history/2_x/#warning-about-safe-uninstall-of-jsonfield-on-upgrade","text":"Both jsonfield and jsonfield2 use the same import path, so if upgrading to dj-stripe>=2.2 in an existing virtualenv, be sure to uninstall jsonfield first. eg: # ensure jsonfield is uninstalled before we install jsonfield2 pip uninstall jsonfield -y && pip install \"dj-stripe>=2.2.0\" Otherwise, pip uninstall jsonfield will remove jsonfield2\u2019s jsonfield module from site-packages , which would cause errors like ImportError: cannot import name 'JSONField' from 'jsonfield' (unknown location) If you have hit this ImportError already after upgrading, running this should resolve it: # remove both jsonfield packages before reinstall to fix ImportError: pip uninstall jsonfield jsonfield2 -y && pip install \"dj-stripe>=2.2.0\"","title":"Warning about safe uninstall of jsonfield on upgrade"},{"location":"history/2_x/#note-on-usage-of-stripe-elements-js","text":"See Integrating Stripe Elements for notes about usage of the Stripe Elements frontend JS library. In summary: If you haven't yet migrated to PaymentIntents, prefer stripe.createSource() to stripe.createToken() .","title":"Note on usage of Stripe Elements JS"},{"location":"history/2_x/#211-2019-10-01","text":"This is a bugfix-only release: Updated webhook signals list (#1000). Fixed issue syncing PaymentIntent with destination charge (#960). Fixed Customer.subscription and .valid_subscriptions() to ignore status=incomplete_expired (#1006). Fixed error on paymentmethod.detached event with card_xxx payment methods (#967). Added PaymentMethod.detach() (#943). Updated help_text on all currency fields to make it clear if they're holding integer cents ( StripeQuantumCurrencyAmountField ) or decimal dollar (or euro, pound etc) ( StripeDecimalCurrencyAmountField ) (#999) Documented our preferred Django model field types (#986)","title":"2.1.1 (2019-10-01)"},{"location":"history/2_x/#upcoming-migration-of-currency-fields-storage-as-cents-instead-of-dollars","text":"Please be aware that we're looking at standardising our currency storage fields as integer quanta (cents) instead of Decimal (dollar) values, to match stripe. This is intended to be part of the 3.0 release, since it will involve some breaking changes. See #955 for details and discussion.","title":"Upcoming migration of currency fields (storage as cents instead of dollars)"},{"location":"history/2_x/#210-2019-09-12","text":"Dropped Django 2.0 support The Python stripe library minimum version is now 2.32.0 , also 2.36.0 is excluded due to a regression (#991). Dropped previously-deprecated Charge.fee_details property. Dropped previously-deprecated Transfer.fee_details property. Dropped previously-deprecated field_name parameter to sync_from_stripe_data Dropped previously-deprecated alias StripeObject of StripeModel Dropped previously-deprecated alias PaymentMethod of DjstripePaymentMethod Dropped previously-deprecated properties Charge.source_type and Charge.source_stripe_id enums.PaymentMethodType has been deprecated, use enums.DjstripePaymentMethodType Made SubscriptionItem.quantity nullable as per Plans with usage_type=\"metered\" (follow-up to #865) Added manage commands djstripe_sync_models and djstripe_process_events (#727, #89) Fixed issue with re-creating a customer after Customer.purge() (#916) Fixed sync of Customer Bank Accounts (#829) Fixed Subscription.is_status_temporarily_current() (#852) New models Payment Intent Setup Intent Payment Method Session Added fields to Customer model: address , invoice_prefix , invoice_settings , phone , preferred_locales , tax_exempt Changes from API 2018-11-08: Added Invoice.auto_advance , deprecated Invoice.closed and Invoice.forgiven , see https://stripe.com/docs/billing/migration/invoice-states#upgrade-checklist Changes from API 2019-02-19: Major changes to Account fields, see https://stripe.com/docs/upgrades#2019-02-19 , updated Account fields to match API 2019-02-19: Added Account.business_profile , .business_type , .company , .individual , .requirements , .settings Deprecated the existing fields, to be removed in 2.2 Special handling of the icon and logo fields: > - Renamed Account.business_logo to Account.branding_icon > (note that in Stripe's API Account.business_logo was renamed > to Account.settings.branding_icon , and > Account.business_logo_large (which we didn't have a field > for) was renamed to Account.settings.branding_logo ) > - Added deprecated property for Account.business_logo > - Added Account.branding_logo as a ForeignKey > - Populate Account.branding_icon and .branding_logo from the > new Account.settings.branding.icon and .logo Changes from API 2019-03-14: Renamed Invoice.application_fee to Invoice.application_fee_amount (added deprecated property for the old name) Removed Invoice.date , in place of Invoice.created (added deprecated property for the old name) Added Invoice.status_transitions Renamed Customer.account_balance to Customer.balance (added deprecated property for the old name) Renamed Customer.payment_methods to Customer.customer_payment_methods Added new SubscriptionStatus.incomplete and SubscriptionStatus.incomplete_expired statuses (#974) Added new BalanceTransactionType values (#983)","title":"2.1.0 (2019-09-12)"},{"location":"history/2_x/#squashed-dev-migrations","text":"As per our migration policy , unreleased migrations on the master branch have been squashed. If you have been using the 2.1.0dev branch from master, you'll need to run the squashed migrations migrations before upgrading to >=2.1.0. The simplest way to do this is to pip install dj-stripe==2.1.0rc0 and migrate, alternatively check out the 2.1.0rc0 git tag.","title":"Squashed dev migrations"},{"location":"history/2_x/#205-2019-09-12","text":"This is a bugfix-only version: Avoid stripe==2.36.0 due to regression (#991)","title":"2.0.5 (2019-09-12)"},{"location":"history/2_x/#204-2019-09-09","text":"This is a bugfix-only version: Fixed irreversible migration (#909)","title":"2.0.4 (2019-09-09)"},{"location":"history/2_x/#203-2019-06-11","text":"This is a bugfix-only version: In _get_or_create_from_stripe_object , wrap create _create_from_stripe_object in transaction, fixes TransactionManagementError on race condition in webhook processing (#877, #903).","title":"2.0.3 (2019-06-11)"},{"location":"history/2_x/#202-2019-06-09","text":"This is a bugfix-only version: Don't save event objects if the webhook processing fails (#832). Fixed IntegrityError when REMOTE_ADDR is an empty string. Deprecated field_name parameter to sync_from_stripe_data","title":"2.0.2 (2019-06-09)"},{"location":"history/2_x/#201-2019-04-29","text":"This is a bugfix-only version: Fixed an error on invoiceitem.updated (#848). Handle test webhook properly in recent versions of Stripe API (#779). At some point 2018 Stripe silently changed the ID used for test events and evt_00000000000000 is not used anymore. Fixed OperationalError seen in migration 0003 on postgres (#850). Fixed issue with migration 0003 not being unapplied correctly (#882). Fixed missing SubscriptionItem.quantity on metered Plans (#865). Fixed Plan.create() (#870).","title":"2.0.1 (2019-04-29)"},{"location":"history/2_x/#200-2019-03-01","text":"The Python stripe library minimum version is now 2.3.0 . PaymentMethod has been renamed to DjstripePaymentMethod (#841). An alias remains but will be removed in the next version. Dropped support for Django<2.0, Python<3.4. Dropped previously-deprecated stripe_objects module. Dropped previously-deprecated stripe_timestamp field. Dropped previously-deprecated Charge.receipt_number field. Dropped previously-deprecated StripeSource alias for Card Dropped previously-deprecated SubscriptionView , CancelSubscriptionView and CancelSubscriptionForm . Removed the default value from DJSTRIPE_SUBSCRIPTION_REDIRECT . All stripe_id fields have been renamed id . Charge.source_type has been deprecated. Use Charge.source.type . Charge.source_stripe_id has been deprecated. Use Charge.source.id . All deprecated Transfer fields (Stripe API 2017-04-06 and older), have been dropped. This includes date , destination_type ( type ), failure_code , failure_message , statement_descriptor and status . Fixed IntegrityError when REMOTE_ADDR is missing (#640). New models: ApplicationFee ApplicationFeeRefund BalanceTransaction CountrySpec ScheduledQuery SubscriptionItem TransferReversal UsageRecord The fee and fee_details attributes of both the Charge and Transfer objects are no longer stored in the database. Instead, they access their respective new balance_transaction foreign key. Note that fee_details has been deprecated on both models. The fraudulent attribute on Charge is now a property that checks the fraud_details field. Object key validity is now always enforced (#503). Customer.sources no longer refers to a Card queryset, but to a Source queryset. In order to correctly transition, you should change all your references to customer.sources to customer.legacy_cards instead. The legacy_cards attribute already exists in 1.2.0. Customer.sources_v3 is now named Customer.sources . A new property Customer.payment_methods is now available, which allows you to iterate over all of a customer's payment methods (sources then cards). Card.customer is now nullable and cards are no longer deleted when their corresponding customer is deleted (#654). Webhook signature verification is now available and is preferred. Set the DJSTRIPE_WEBHOOK_SECRET setting to your secret to start using it. StripeObject has been renamed StripeModel . An alias remains but will be removed in the next version. The metadata key used in the Customer object can now be configured by changing the DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY setting. Setting this to None or an empty string now also disables the behaviour altogether. Text-type fields in dj-stripe will no longer ever be None. Instead, any falsy text field will return an empty string. Switched test runner to pytest-django StripeModel.sync_from_stripe_data() will now automatically retrieve related objects and populate foreign keys (#681) Added Coupon.name Added Transfer.balance_transaction Exceptions in webhooks are now re-raised as well as saved in the database (#833)","title":"2.0.0 (2019-03-01)"},{"location":"project/authors/","text":"Credits Maintainers Alexander Kavanaugh Jerome Leclanche Major Contributors John Carter Pablo Castellano Daniel Greenfeld Lee Skillen Contributors dj-stripe is brought to you by many more open source contributors. See the complete list on Github .","title":"Credits"},{"location":"project/authors/#credits","text":"","title":"Credits"},{"location":"project/authors/#maintainers","text":"Alexander Kavanaugh Jerome Leclanche","title":"Maintainers"},{"location":"project/authors/#major-contributors","text":"John Carter Pablo Castellano Daniel Greenfeld Lee Skillen","title":"Major Contributors"},{"location":"project/authors/#contributors","text":"dj-stripe is brought to you by many more open source contributors. See the complete list on Github .","title":"Contributors"},{"location":"project/contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it. Write Documentation dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install -E docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder. Submit Feedback The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Contributor Discussion For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc . Get Started! Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us. Preferred Django Model Field Types When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models). Strings Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\") Enumerations Fields that have a defined set of values can be implemented using StripeEnumField . Hash (dictionaries) Use the JSONField in djstripe.fields , see also the DJSTRIPE_USE_NATIVE_JSONFIELD setting. Currency amounts Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField . Dates and Datetimes The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField . Django Migration Policy Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model. Avoid new migrations with non-schema changes If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087 Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install black and isort with pip install black isort and run black .; isort -y at the dj-stripe root to keep a consistent style.","title":"Contributing"},{"location":"project/contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"project/contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"project/contributing/#report-bugs","text":"Report bugs at https://github.com/dj-stripe/dj-stripe/issues . If you are reporting a bug, please include: The version of python and Django you're running Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"project/contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"project/contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"project/contributing/#write-documentation","text":"dj-stripe could always use more documentation, whether as part of the official dj-stripe docs, in docstrings, or even on the web in blog posts, articles, and such. To see the project's documentation live, run the following command: mkdocs serve The documentation site will then be served on http://127.0.0.1:8000 . In case of any installation error In case you get the error that some plugin is not installed, please run: poetry install -E docs If you wish to just generate the documentation, you can replace serve with build , and the docs will be generated into the site/ folder.","title":"Write Documentation"},{"location":"project/contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/dj-stripe/dj-stripe/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"project/contributing/#contributor-discussion","text":"For questions regarding contributions to dj-stripe, another avenue is our Discord channel at https://discord.gg/UJY8fcc .","title":"Contributor Discussion"},{"location":"project/contributing/#get-started","text":"Ready to contribute? Here's how to set up local development. Fork dj-stripe on Github . Clone your fork locally: $ git clone git@github.com:your_name_here/dj-stripe.git Set up your test database. If you're running tests using PostgreSQL: $ createdb djstripe or if you want to test vs sqlite (for convenience) or MySQL, they can be selected by setting this environment variable: $ export DJSTRIPE_TEST_DB_VENDOR = sqlite # or: export DJSTRIPE_TEST_DB_VENDOR=mysql For postgres and mysql, the database host,port,username and password can be set with environment variables, see tests/settings.py Install Poetry if you do not have it already. You can set up a virtual environment with: $ poetry install You can then, at any time, open a shell into that environment with: $ poetry shell When you're done making changes, check that your changes pass the tests. A quick test run can be done as follows: $ DJSTRIPE_TEST_DB_VENDOR = sqlite pytest --reuse-db You should also check that the tests pass with other python and Django versions with tox. pytest will output both command line and html coverage statistics and will warn you if your changes caused code coverage to drop.: $ pip install tox $ tox If your changes altered the models you may need to generate Django migrations: $ DJSTRIPE_TEST_DB_VENDOR = sqlite poetry run ./manage.py makemigrations Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push Submit a pull request through the GitHub website. Congratulations, you're now a dj-stripe contributor! Have some \u2665 from us.","title":"Get Started!"},{"location":"project/contributing/#preferred-django-model-field-types","text":"When mapping from Stripe API field types to Django model fields, we try to follow Django best practises where practical. The following types should be preferred for fields that map to the Stripe API (which is almost all fields in our models).","title":"Preferred Django Model Field Types"},{"location":"project/contributing/#strings","text":"Stripe API string fields have a default maximum length of 5,000 characters . In some cases a maximum length ( maxLength ) is specified in the Stripe OpenAPI schema . We follow Django's recommendation and avoid using null on string fields (which means we store \"\" for string fields that are null in stripe). Note that is enforced in the sync logic in StripeModel._stripe_object_to_record . For long string fields (eg above 255 characters) we prefer TextField over Charfield . Therefore the default type for string fields that don't have a maxLength specified in the Stripe OpenAPI schema should usually be: str_field = TextField(max_length=5000, default=\", blank=True, help_text=\"...\")","title":"Strings"},{"location":"project/contributing/#enumerations","text":"Fields that have a defined set of values can be implemented using StripeEnumField .","title":"Enumerations"},{"location":"project/contributing/#hash-dictionaries","text":"Use the JSONField in djstripe.fields , see also the DJSTRIPE_USE_NATIVE_JSONFIELD setting.","title":"Hash (dictionaries)"},{"location":"project/contributing/#currency-amounts","text":"Stripe handles all currency amounts as integer cents, we currently have a mixture of fields as integer cents and decimal (eg dollar, euro etc) values, but we are aiming to standardise on cents (see https://github.com/dj-stripe/dj-stripe/issues/955 ). All new currency amount fields should use StripeQuantumCurrencyAmountField .","title":"Currency amounts"},{"location":"project/contributing/#dates-and-datetimes","text":"The Stripe API uses an integer timestamp (seconds since the Unix epoch) for dates and datetimes. We store this as a datetime field, using StripeDateTimeField .","title":"Dates and Datetimes"},{"location":"project/contributing/#django-migration-policy","text":"Migrations are considered a breaking change, so it's not usually not acceptable to add a migration to a stable branch, it will be a new MAJOR.MINOR.0 release. A workaround to this in the case that the Stripe API data isn't compatible with out model (eg Stripe is sending null to a non-null field) is to implement the _manipulate_stripe_object_hook classmethod on the model.","title":"Django Migration Policy"},{"location":"project/contributing/#avoid-new-migrations-with-non-schema-changes","text":"If a code change produces a migration that doesn't alter the database schema (eg changing help_text ) then instead of adding a new migration you can edit the most recent migration that affects the field in question. e.g.: https://github.com/dj-stripe/dj-stripe/commit/e2762c38918a90f00c42ecf21187a920bd3a2087","title":"Avoid new migrations with non-schema changes"},{"location":"project/contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. The pull request must not drop code coverage below the current level. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring. If the pull request makes changes to a model, include Django migrations. The pull request should work for Python 3.6+. Check Github Actions and make sure that the tests pass for all supported Python versions. Code formatting: Make sure to install black and isort with pip install black isort and run black .; isort -y at the dj-stripe root to keep a consistent style.","title":"Pull Request Guidelines"},{"location":"project/release_process/","text":"Release Process Note Before MAJOR or MINOR releases: Review deprecation notes (eg search for \"deprecated\") and remove deprecated features as appropriate Squash migrations (ONLY on unreleased migrations) - see below Squash migrations If there's more than one unreleased migration on master consider squashing them with squashmigrations , immediately before tagging the new release: Create a new squashed migration with ./manage.py squashmigrations (only squash migrations that have never been in a tagged release) Commit the squashed migration on master with a commit message like \"Squash x.y.0dev migrations\" (this will allow users who running master to safely upgrade, see note below about rc package) Then transition the squashed migration to a normal migration as per Django: Delete all the migration files it replaces Update all migrations that depend on the deleted migrations to depend on the squashed migration instead Remove the replaces attribute in the Migration class of the squashed migration (this is how Django tells that it is a squashed migration) Commit these changes to master with a message like \"Transition squashed migration to normal migration\" Then do the normal release process - bump version as another commit and tag the release See https://docs.djangoproject.com/en/dev/topics/migrations/#migration-squashing Tag + package squashed migrations as rc package (optional) As a convenience to users who are running master, an rc version can be created to package the squashed migration. To do this, immediately after the \"Squash x.y.0dev migrations\" commit, follow the steps below but with a x.y.0rc0 version to tag and package a rc version. Users who have been using the x.y.0dev code from master can then run the squashed migrations migrations before upgrading to >=x.y.0. The simplest way to do this is to pip install dj-stripe==x.y.0rc0 and migrate, or alternatively check out the x.y.0rc0 git tag and migrate. Prepare changes for the release commit Choose your version number (using https://semver.org/ ) if there's a new migration, it should be a MAJOR.0.0 or MAJOR.MINOR.0 version. Review and update HISTORY.md Add a section for this release version Set date on this release version Check that summary of feature/fixes is since the last release is up to date Update package version number in setup.cfg Review and update supported API version in README.md (this is the most recent Stripe account version tested against, not DEFAULT_STRIPE_API_VERSION ) git add to stage these changes Create signed release commit tag Note Before doing this you should have a GPG key set up on github If you don't have a GPG key already, one method is via https://keybase.io/ , and then add it to your github profile. Create a release tag with the above staged changes (where $VERSION is the version number to be released: $ git commit -m \"Release $VERSION \" $ git tag -fsm \"Release $VERSION \" $VERSION This can be expressed as a bash function as follows: git_release() { git commit -m \"Release $1\" && git tag -fsm \"Release $1\" $1; } Push the commit and tag: $ git push --follow-tags Update/create stable branch Push these changes to the appropriate stable/MAJOR.MINOR version branch (eg stable/2.0 ) if they're not already - note that this will trigger the readthedocs build Release on pypi See https://packaging.python.org/tutorials/packaging-projects/#generating-distribution-archives","title":"Release Process"},{"location":"project/release_process/#release-process","text":"Note Before MAJOR or MINOR releases: Review deprecation notes (eg search for \"deprecated\") and remove deprecated features as appropriate Squash migrations (ONLY on unreleased migrations) - see below","title":"Release Process"},{"location":"project/release_process/#squash-migrations","text":"If there's more than one unreleased migration on master consider squashing them with squashmigrations , immediately before tagging the new release: Create a new squashed migration with ./manage.py squashmigrations (only squash migrations that have never been in a tagged release) Commit the squashed migration on master with a commit message like \"Squash x.y.0dev migrations\" (this will allow users who running master to safely upgrade, see note below about rc package) Then transition the squashed migration to a normal migration as per Django: Delete all the migration files it replaces Update all migrations that depend on the deleted migrations to depend on the squashed migration instead Remove the replaces attribute in the Migration class of the squashed migration (this is how Django tells that it is a squashed migration) Commit these changes to master with a message like \"Transition squashed migration to normal migration\" Then do the normal release process - bump version as another commit and tag the release See https://docs.djangoproject.com/en/dev/topics/migrations/#migration-squashing","title":"Squash migrations"},{"location":"project/release_process/#tag-package-squashed-migrations-as-rc-package-optional","text":"As a convenience to users who are running master, an rc version can be created to package the squashed migration. To do this, immediately after the \"Squash x.y.0dev migrations\" commit, follow the steps below but with a x.y.0rc0 version to tag and package a rc version. Users who have been using the x.y.0dev code from master can then run the squashed migrations migrations before upgrading to >=x.y.0. The simplest way to do this is to pip install dj-stripe==x.y.0rc0 and migrate, or alternatively check out the x.y.0rc0 git tag and migrate.","title":"Tag + package squashed migrations as rc package (optional)"},{"location":"project/release_process/#prepare-changes-for-the-release-commit","text":"Choose your version number (using https://semver.org/ ) if there's a new migration, it should be a MAJOR.0.0 or MAJOR.MINOR.0 version. Review and update HISTORY.md Add a section for this release version Set date on this release version Check that summary of feature/fixes is since the last release is up to date Update package version number in setup.cfg Review and update supported API version in README.md (this is the most recent Stripe account version tested against, not DEFAULT_STRIPE_API_VERSION ) git add to stage these changes","title":"Prepare changes for the release commit"},{"location":"project/release_process/#create-signed-release-commit-tag","text":"Note Before doing this you should have a GPG key set up on github If you don't have a GPG key already, one method is via https://keybase.io/ , and then add it to your github profile. Create a release tag with the above staged changes (where $VERSION is the version number to be released: $ git commit -m \"Release $VERSION \" $ git tag -fsm \"Release $VERSION \" $VERSION This can be expressed as a bash function as follows: git_release() { git commit -m \"Release $1\" && git tag -fsm \"Release $1\" $1; } Push the commit and tag: $ git push --follow-tags","title":"Create signed release commit tag"},{"location":"project/release_process/#updatecreate-stable-branch","text":"Push these changes to the appropriate stable/MAJOR.MINOR version branch (eg stable/2.0 ) if they're not already - note that this will trigger the readthedocs build","title":"Update/create stable branch"},{"location":"project/release_process/#release-on-pypi","text":"See https://packaging.python.org/tutorials/packaging-projects/#generating-distribution-archives","title":"Release on pypi"},{"location":"project/sponsors/","text":"Sponsors Gold Sponsors This project is sponsored by none other than Stripe , since August 2020. We're thankful for their contribution, which has allowed us to greatly improve the project, increase QA and testing, and push forward with the dj-stripe 2.4.0 release. Silver Sponsors We do not currently have any Silver sponsors. Want to be the first?","title":"Sponsors"},{"location":"project/sponsors/#sponsors","text":"","title":"Sponsors"},{"location":"project/sponsors/#gold-sponsors","text":"This project is sponsored by none other than Stripe , since August 2020. We're thankful for their contribution, which has allowed us to greatly improve the project, increase QA and testing, and push forward with the dj-stripe 2.4.0 release.","title":"Gold Sponsors"},{"location":"project/sponsors/#silver-sponsors","text":"We do not currently have any Silver sponsors. Want to be the first?","title":"Silver Sponsors"},{"location":"project/support/","text":"Support Support plans dj-stripe offers paid support plans via Github Sponsors: https://github.com/sponsors/dj-stripe All issues and feature requests raised by corporate sponsors will be prioritized. Gold Sponsors also get a dedicated developer point of contact, to help with any questions, issues, or general inquiries relating to dj-stripe. Bug reports and feature requests Please report any issues you come across on the Github issue tracker . Do not hesitate to leave feedback and suggestions there as well. You may also ask usage questions on the issue tracker.","title":"Support"},{"location":"project/support/#support","text":"","title":"Support"},{"location":"project/support/#support-plans","text":"dj-stripe offers paid support plans via Github Sponsors: https://github.com/sponsors/dj-stripe All issues and feature requests raised by corporate sponsors will be prioritized. Gold Sponsors also get a dedicated developer point of contact, to help with any questions, issues, or general inquiries relating to dj-stripe.","title":"Support plans"},{"location":"project/support/#bug-reports-and-feature-requests","text":"Please report any issues you come across on the Github issue tracker . Do not hesitate to leave feedback and suggestions there as well. You may also ask usage questions on the issue tracker.","title":"Bug reports and feature requests"},{"location":"project/test_fixtures/","text":"Test Fixtures dj-stripe's unit tests rely on fixtures to represent Stripe API and webhook data. Rationale These fixtures are partly hand-coded and partly generated by creating objects in Stripe and then retrieved via the API. Each approach has pros and cons: Hand-coding the fixtures allows them to be crafted specifically for a test case. They can also be terse, and nested objects can be done by reference to avoid duplication. But maintaining or upgrading them is a painstaking manual process. Generating the fixtures via Stripe gives the big advantage that Stripe schema changes are automatically represented in the fixtures, which should allow us to upgrade dj-stripe's schema to match Stripe much more easily. This would be done by updating dj-stripe's targeted API version ( DEFAULT_STRIPE_API_VERSION ), regenerating the fixtures, and updating the model to match the fixture changes. The down side is it's tricky to regenerate fixture files without introducing big changes (eg to object ids) - the script does this by mapping a dummy id to various objects. Regenerating the test fixtures To regenerate the test fixtures (e.g. to populate the fixtures with new API fields from Stripe), do the following: (one time only) Create a new Stripe account called \"dj-stripe scratch\", with country set to United States. (we use US so the currency matches the existing fixtures matches, in the future it would be good to test for other countries). If you already had this account ready and want to start again from scratch, you can delete all of the test data via the button in Settings > Data https://dashboard.stripe.com/account/data Activate a virtualenv with the dj-stripe project (see Getting Started) Set the dj-stripe secret key environment variable to the secret key for this account ( export STRIPE_SECRET_KEY=sk_test_... ) Run the manage command to create the test objects in your stripe account if they don't already exist, and regenerate the local fixture files from them: $ ./manage.py regenerate_test_fixtures The command tries to avoid inconsequential changes to the fixtures (e.g the created timestamp) by restoring a whitelist of values from the existing fixtures. This functionality can be disabled by passing the parameter --update-sideeffect-fields .","title":"Test Fixtures"},{"location":"project/test_fixtures/#test-fixtures","text":"dj-stripe's unit tests rely on fixtures to represent Stripe API and webhook data.","title":"Test Fixtures"},{"location":"project/test_fixtures/#rationale","text":"These fixtures are partly hand-coded and partly generated by creating objects in Stripe and then retrieved via the API. Each approach has pros and cons: Hand-coding the fixtures allows them to be crafted specifically for a test case. They can also be terse, and nested objects can be done by reference to avoid duplication. But maintaining or upgrading them is a painstaking manual process. Generating the fixtures via Stripe gives the big advantage that Stripe schema changes are automatically represented in the fixtures, which should allow us to upgrade dj-stripe's schema to match Stripe much more easily. This would be done by updating dj-stripe's targeted API version ( DEFAULT_STRIPE_API_VERSION ), regenerating the fixtures, and updating the model to match the fixture changes. The down side is it's tricky to regenerate fixture files without introducing big changes (eg to object ids) - the script does this by mapping a dummy id to various objects.","title":"Rationale"},{"location":"project/test_fixtures/#regenerating-the-test-fixtures","text":"To regenerate the test fixtures (e.g. to populate the fixtures with new API fields from Stripe), do the following: (one time only) Create a new Stripe account called \"dj-stripe scratch\", with country set to United States. (we use US so the currency matches the existing fixtures matches, in the future it would be good to test for other countries). If you already had this account ready and want to start again from scratch, you can delete all of the test data via the button in Settings > Data https://dashboard.stripe.com/account/data Activate a virtualenv with the dj-stripe project (see Getting Started) Set the dj-stripe secret key environment variable to the secret key for this account ( export STRIPE_SECRET_KEY=sk_test_... ) Run the manage command to create the test objects in your stripe account if they don't already exist, and regenerate the local fixture files from them: $ ./manage.py regenerate_test_fixtures The command tries to avoid inconsequential changes to the fixtures (e.g the created timestamp) by restoring a whitelist of values from the existing fixtures. This functionality can be disabled by passing the parameter --update-sideeffect-fields .","title":"Regenerating the test fixtures"},{"location":"reference/context_managers/","text":"Context Managers dj-stripe Context Managers Functions djstripe . context_managers . stripe_temporary_api_version ( version , validate = True ) Temporarily replace the global api_version used in stripe API calls with the given value. The original value is restored as soon as context exits. Source code in djstripe/context_managers.py @contextmanager def stripe_temporary_api_version ( version , validate = True ): \"\"\" Temporarily replace the global api_version used in stripe API calls with the given value. The original value is restored as soon as context exits. \"\"\" from .settings import get_stripe_api_version , set_stripe_api_version old_version = get_stripe_api_version () try : set_stripe_api_version ( version , validate = validate ) yield finally : # Validation is bypassed since we're restoring a previous value. set_stripe_api_version ( old_version , validate = False )","title":"Context Managers"},{"location":"reference/context_managers/#context-managers","text":"dj-stripe Context Managers","title":"Context Managers"},{"location":"reference/context_managers/#djstripe.context_managers-functions","text":"","title":"Functions"},{"location":"reference/context_managers/#djstripe.context_managers.stripe_temporary_api_version","text":"Temporarily replace the global api_version used in stripe API calls with the given value. The original value is restored as soon as context exits. Source code in djstripe/context_managers.py @contextmanager def stripe_temporary_api_version ( version , validate = True ): \"\"\" Temporarily replace the global api_version used in stripe API calls with the given value. The original value is restored as soon as context exits. \"\"\" from .settings import get_stripe_api_version , set_stripe_api_version old_version = get_stripe_api_version () try : set_stripe_api_version ( version , validate = validate ) yield finally : # Validation is bypassed since we're restoring a previous value. set_stripe_api_version ( old_version , validate = False )","title":"stripe_temporary_api_version()"},{"location":"reference/decorators/","text":"Decorators Event Handling Decorators More documentation coming on these soon. For now, see our implementations in djstripe.event_handlers Specific Event(s) Handler Decorator that registers a function as a webhook handler. Functions can be registered for event types (e.g. 'customer') or fully qualified event sub-types (e.g. 'customer.subscription.deleted'). If an event type is specified, the handler will receive callbacks for ALL webhook events of that type. For example, if 'customer' is specified, the handler will receive events for 'customer.subscription.created', 'customer.subscription.updated', etc. :param event_types: The event type(s) that should be handled. :type event_types: str. Source code in djstripe/webhooks.py def handler ( * event_types ): \"\"\" Decorator that registers a function as a webhook handler. Functions can be registered for event types (e.g. 'customer') or fully qualified event sub-types (e.g. 'customer.subscription.deleted'). If an event type is specified, the handler will receive callbacks for ALL webhook events of that type. For example, if 'customer' is specified, the handler will receive events for 'customer.subscription.created', 'customer.subscription.updated', etc. :param event_types: The event type(s) that should be handled. :type event_types: str. \"\"\" def decorator ( func ): for event_type in event_types : registrations [ event_type ] . append ( func ) return func return decorator All Events Handler Decorator that registers a function as a webhook handler for ALL webhook events. Handles all webhooks regardless of event type or sub-type. Source code in djstripe/webhooks.py def handler_all ( func = None ): \"\"\" Decorator that registers a function as a webhook handler for ALL webhook events. Handles all webhooks regardless of event type or sub-type. \"\"\" if not func : return functools . partial ( handler_all ) registrations_global . append ( func ) return func","title":"Decorators"},{"location":"reference/decorators/#decorators","text":"","title":"Decorators"},{"location":"reference/decorators/#event-handling-decorators","text":"More documentation coming on these soon. For now, see our implementations in djstripe.event_handlers","title":"Event Handling Decorators"},{"location":"reference/decorators/#specific-events-handler","text":"Decorator that registers a function as a webhook handler. Functions can be registered for event types (e.g. 'customer') or fully qualified event sub-types (e.g. 'customer.subscription.deleted'). If an event type is specified, the handler will receive callbacks for ALL webhook events of that type. For example, if 'customer' is specified, the handler will receive events for 'customer.subscription.created', 'customer.subscription.updated', etc. :param event_types: The event type(s) that should be handled. :type event_types: str. Source code in djstripe/webhooks.py def handler ( * event_types ): \"\"\" Decorator that registers a function as a webhook handler. Functions can be registered for event types (e.g. 'customer') or fully qualified event sub-types (e.g. 'customer.subscription.deleted'). If an event type is specified, the handler will receive callbacks for ALL webhook events of that type. For example, if 'customer' is specified, the handler will receive events for 'customer.subscription.created', 'customer.subscription.updated', etc. :param event_types: The event type(s) that should be handled. :type event_types: str. \"\"\" def decorator ( func ): for event_type in event_types : registrations [ event_type ] . append ( func ) return func return decorator","title":"Specific Event(s) Handler"},{"location":"reference/decorators/#all-events-handler","text":"Decorator that registers a function as a webhook handler for ALL webhook events. Handles all webhooks regardless of event type or sub-type. Source code in djstripe/webhooks.py def handler_all ( func = None ): \"\"\" Decorator that registers a function as a webhook handler for ALL webhook events. Handles all webhooks regardless of event type or sub-type. \"\"\" if not func : return functools . partial ( handler_all ) registrations_global . append ( func ) return func","title":"All Events Handler"},{"location":"reference/enums/","text":"Enumerations Classes djstripe.enums.APIKeyType API Key Types (internal model only) djstripe . enums . APIKeyType . publishable djstripe . enums . APIKeyType . restricted djstripe . enums . APIKeyType . secret djstripe.enums.AccountType djstripe . enums . AccountType . custom djstripe . enums . AccountType . express djstripe . enums . AccountType . standard djstripe.enums.ApiErrorCode Charge failure error codes. https://stripe.com/docs/error-codes djstripe . enums . ApiErrorCode . account_already_exists djstripe . enums . ApiErrorCode . account_country_invalid_address djstripe . enums . ApiErrorCode . account_invalid djstripe . enums . ApiErrorCode . account_number_invalid djstripe . enums . ApiErrorCode . alipay_upgrade_required djstripe . enums . ApiErrorCode . amount_too_large djstripe . enums . ApiErrorCode . amount_too_small djstripe . enums . ApiErrorCode . api_key_expired djstripe . enums . ApiErrorCode . balance_insufficient djstripe . enums . ApiErrorCode . bank_account_exists djstripe . enums . ApiErrorCode . bank_account_unusable djstripe . enums . ApiErrorCode . bank_account_unverified djstripe . enums . ApiErrorCode . bitcoin_upgrade_required djstripe . enums . ApiErrorCode . card_declined djstripe . enums . ApiErrorCode . charge_already_captured djstripe . enums . ApiErrorCode . charge_already_refunded djstripe . enums . ApiErrorCode . charge_disputed djstripe . enums . ApiErrorCode . charge_exceeds_source_limit djstripe . enums . ApiErrorCode . charge_expired_for_capture djstripe . enums . ApiErrorCode . country_unsupported djstripe . enums . ApiErrorCode . coupon_expired djstripe . enums . ApiErrorCode . customer_max_subscriptions djstripe . enums . ApiErrorCode . email_invalid djstripe . enums . ApiErrorCode . expired_card djstripe . enums . ApiErrorCode . idempotency_key_in_use djstripe . enums . ApiErrorCode . incorrect_address djstripe . enums . ApiErrorCode . incorrect_cvc djstripe . enums . ApiErrorCode . incorrect_number djstripe . enums . ApiErrorCode . incorrect_zip djstripe . enums . ApiErrorCode . instant_payouts_unsupported djstripe . enums . ApiErrorCode . invalid_card_type djstripe . enums . ApiErrorCode . invalid_charge_amount djstripe . enums . ApiErrorCode . invalid_cvc djstripe . enums . ApiErrorCode . invalid_expiry_month djstripe . enums . ApiErrorCode . invalid_expiry_year djstripe . enums . ApiErrorCode . invalid_number djstripe . enums . ApiErrorCode . invalid_source_usage djstripe . enums . ApiErrorCode . invalid_swipe_data djstripe . enums . ApiErrorCode . invoice_no_customer_line_items djstripe . enums . ApiErrorCode . invoice_no_subscription_line_items djstripe . enums . ApiErrorCode . invoice_not_editable djstripe . enums . ApiErrorCode . invoice_upcoming_none djstripe . enums . ApiErrorCode . livemode_mismatch djstripe . enums . ApiErrorCode . missing djstripe . enums . ApiErrorCode . not_allowed_on_standard_account djstripe . enums . ApiErrorCode . order_creation_failed djstripe . enums . ApiErrorCode . order_required_settings djstripe . enums . ApiErrorCode . order_status_invalid djstripe . enums . ApiErrorCode . order_upstream_timeout djstripe . enums . ApiErrorCode . out_of_inventory djstripe . enums . ApiErrorCode . parameter_invalid_empty djstripe . enums . ApiErrorCode . parameter_invalid_integer djstripe . enums . ApiErrorCode . parameter_invalid_string_blank djstripe . enums . ApiErrorCode . parameter_invalid_string_empty djstripe . enums . ApiErrorCode . parameter_missing djstripe . enums . ApiErrorCode . parameter_unknown djstripe . enums . ApiErrorCode . parameters_exclusive djstripe . enums . ApiErrorCode . payment_intent_authentication_failure djstripe . enums . ApiErrorCode . payment_intent_incompatible_payment_method djstripe . enums . ApiErrorCode . payment_intent_invalid_parameter djstripe . enums . ApiErrorCode . payment_intent_payment_attempt_failed djstripe . enums . ApiErrorCode . payment_intent_unexpected_state djstripe . enums . ApiErrorCode . payment_method_unactivated djstripe . enums . ApiErrorCode . payment_method_unexpected_state djstripe . enums . ApiErrorCode . payouts_not_allowed djstripe . enums . ApiErrorCode . platform_api_key_expired djstripe . enums . ApiErrorCode . postal_code_invalid djstripe . enums . ApiErrorCode . processing_error djstripe . enums . ApiErrorCode . product_inactive djstripe . enums . ApiErrorCode . rate_limit djstripe . enums . ApiErrorCode . resource_already_exists djstripe . enums . ApiErrorCode . resource_missing djstripe . enums . ApiErrorCode . routing_number_invalid djstripe . enums . ApiErrorCode . secret_key_required djstripe . enums . ApiErrorCode . sepa_unsupported_account djstripe . enums . ApiErrorCode . shipping_calculation_failed djstripe . enums . ApiErrorCode . sku_inactive djstripe . enums . ApiErrorCode . state_unsupported djstripe . enums . ApiErrorCode . tax_id_invalid djstripe . enums . ApiErrorCode . taxes_calculation_failed djstripe . enums . ApiErrorCode . testmode_charges_only djstripe . enums . ApiErrorCode . tls_version_unsupported djstripe . enums . ApiErrorCode . token_already_used djstripe . enums . ApiErrorCode . token_in_use djstripe . enums . ApiErrorCode . transfers_not_allowed djstripe . enums . ApiErrorCode . upstream_order_creation_failed djstripe . enums . ApiErrorCode . url_invalid djstripe.enums.BalanceTransactionReportingCategory https://stripe.com/docs/reports/reporting-categories djstripe . enums . BalanceTransactionReportingCategory . advance djstripe . enums . BalanceTransactionReportingCategory . advance_funding djstripe . enums . BalanceTransactionReportingCategory . anticipation_repayment djstripe . enums . BalanceTransactionReportingCategory . charge djstripe . enums . BalanceTransactionReportingCategory . charge_failure djstripe . enums . BalanceTransactionReportingCategory . connect_collection_transfer djstripe . enums . BalanceTransactionReportingCategory . connect_reserved_funds djstripe . enums . BalanceTransactionReportingCategory . dispute djstripe . enums . BalanceTransactionReportingCategory . dispute_reversal djstripe . enums . BalanceTransactionReportingCategory . fee djstripe . enums . BalanceTransactionReportingCategory . issuing_authorization_hold djstripe . enums . BalanceTransactionReportingCategory . issuing_authorization_release djstripe . enums . BalanceTransactionReportingCategory . issuing_dispute djstripe . enums . BalanceTransactionReportingCategory . issuing_transaction djstripe . enums . BalanceTransactionReportingCategory . other_adjustment djstripe . enums . BalanceTransactionReportingCategory . partial_capture_reversal djstripe . enums . BalanceTransactionReportingCategory . payout djstripe . enums . BalanceTransactionReportingCategory . payout_reversal djstripe . enums . BalanceTransactionReportingCategory . platform_earning djstripe . enums . BalanceTransactionReportingCategory . platform_earning_refund djstripe . enums . BalanceTransactionReportingCategory . refund djstripe . enums . BalanceTransactionReportingCategory . refund_failure djstripe . enums . BalanceTransactionReportingCategory . risk_reserved_funds djstripe . enums . BalanceTransactionReportingCategory . tax djstripe . enums . BalanceTransactionReportingCategory . topup djstripe . enums . BalanceTransactionReportingCategory . topup_reversal djstripe . enums . BalanceTransactionReportingCategory . transfer djstripe . enums . BalanceTransactionReportingCategory . transfer_reversal djstripe.enums.BalanceTransactionStatus djstripe . enums . BalanceTransactionStatus . available djstripe . enums . BalanceTransactionStatus . pending djstripe.enums.BalanceTransactionType djstripe . enums . BalanceTransactionType . adjustment djstripe . enums . BalanceTransactionType . advance djstripe . enums . BalanceTransactionType . advance_funding djstripe . enums . BalanceTransactionType . anticipation_repayment djstripe . enums . BalanceTransactionType . application_fee djstripe . enums . BalanceTransactionType . application_fee_refund djstripe . enums . BalanceTransactionType . balance_transfer_inbound djstripe . enums . BalanceTransactionType . balance_transfer_outbound djstripe . enums . BalanceTransactionType . charge djstripe . enums . BalanceTransactionType . connect_collection_transfer djstripe . enums . BalanceTransactionType . contribution djstripe . enums . BalanceTransactionType . issuing_authorization_hold djstripe . enums . BalanceTransactionType . issuing_authorization_release djstripe . enums . BalanceTransactionType . issuing_dispute djstripe . enums . BalanceTransactionType . issuing_transaction djstripe . enums . BalanceTransactionType . network_cost djstripe . enums . BalanceTransactionType . payment djstripe . enums . BalanceTransactionType . payment_failure_refund djstripe . enums . BalanceTransactionType . payment_refund djstripe . enums . BalanceTransactionType . payout djstripe . enums . BalanceTransactionType . payout_cancel djstripe . enums . BalanceTransactionType . payout_failure djstripe . enums . BalanceTransactionType . refund djstripe . enums . BalanceTransactionType . refund_failure djstripe . enums . BalanceTransactionType . reserve_transaction djstripe . enums . BalanceTransactionType . reserved_funds djstripe . enums . BalanceTransactionType . stripe_fee djstripe . enums . BalanceTransactionType . stripe_fx_fee djstripe . enums . BalanceTransactionType . tax_fee djstripe . enums . BalanceTransactionType . topup djstripe . enums . BalanceTransactionType . topup_reversal djstripe . enums . BalanceTransactionType . transfer djstripe . enums . BalanceTransactionType . transfer_cancel djstripe . enums . BalanceTransactionType . transfer_failure djstripe . enums . BalanceTransactionType . transfer_refund djstripe . enums . BalanceTransactionType . validation djstripe.enums.BankAccountHolderType djstripe . enums . BankAccountHolderType . company djstripe . enums . BankAccountHolderType . individual djstripe.enums.BankAccountStatus djstripe . enums . BankAccountStatus . errored djstripe . enums . BankAccountStatus . new djstripe . enums . BankAccountStatus . validated djstripe . enums . BankAccountStatus . verification_failed djstripe . enums . BankAccountStatus . verified djstripe.enums.BillingScheme djstripe . enums . BillingScheme . per_unit djstripe . enums . BillingScheme . tiered djstripe.enums.BusinessType djstripe . enums . BusinessType . company djstripe . enums . BusinessType . individual djstripe.enums.CaptureMethod djstripe . enums . CaptureMethod . automatic djstripe . enums . CaptureMethod . manual djstripe.enums.CardBrand djstripe . enums . CardBrand . AmericanExpress djstripe . enums . CardBrand . DinersClub djstripe . enums . CardBrand . Discover djstripe . enums . CardBrand . JCB djstripe . enums . CardBrand . MasterCard djstripe . enums . CardBrand . UnionPay djstripe . enums . CardBrand . Unknown djstripe . enums . CardBrand . Visa djstripe.enums.CardCheckResult djstripe . enums . CardCheckResult . fail djstripe . enums . CardCheckResult . pass_ djstripe . enums . CardCheckResult . unavailable djstripe . enums . CardCheckResult . unchecked djstripe.enums.CardFundingType djstripe . enums . CardFundingType . credit djstripe . enums . CardFundingType . debit djstripe . enums . CardFundingType . prepaid djstripe . enums . CardFundingType . unknown djstripe.enums.CardTokenizationMethod djstripe . enums . CardTokenizationMethod . android_pay djstripe . enums . CardTokenizationMethod . apple_pay djstripe.enums.ChargeStatus djstripe . enums . ChargeStatus . failed djstripe . enums . ChargeStatus . pending djstripe . enums . ChargeStatus . succeeded djstripe.enums.ConfirmationMethod djstripe . enums . ConfirmationMethod . automatic djstripe . enums . ConfirmationMethod . manual djstripe.enums.CouponDuration djstripe . enums . CouponDuration . forever djstripe . enums . CouponDuration . once djstripe . enums . CouponDuration . repeating djstripe.enums.CustomerTaxExempt djstripe . enums . CustomerTaxExempt . exempt djstripe . enums . CustomerTaxExempt . none djstripe . enums . CustomerTaxExempt . reverse djstripe.enums.DisputeReason djstripe . enums . DisputeReason . bank_cannot_process djstripe . enums . DisputeReason . credit_not_processed djstripe . enums . DisputeReason . customer_initiated djstripe . enums . DisputeReason . debit_not_authorized djstripe . enums . DisputeReason . duplicate djstripe . enums . DisputeReason . fraudulent djstripe . enums . DisputeReason . general djstripe . enums . DisputeReason . incorrect_account_details djstripe . enums . DisputeReason . insufficient_funds djstripe . enums . DisputeReason . product_not_received djstripe . enums . DisputeReason . product_unacceptable djstripe . enums . DisputeReason . subscription_canceled djstripe . enums . DisputeReason . unrecognized djstripe.enums.DisputeStatus djstripe . enums . DisputeStatus . charge_refunded djstripe . enums . DisputeStatus . lost djstripe . enums . DisputeStatus . needs_response djstripe . enums . DisputeStatus . under_review djstripe . enums . DisputeStatus . warning_closed djstripe . enums . DisputeStatus . warning_needs_response djstripe . enums . DisputeStatus . warning_under_review djstripe . enums . DisputeStatus . won djstripe.enums.DjstripePaymentMethodType A djstripe-specific enum for the DjStripePaymentMethod model. djstripe . enums . DjstripePaymentMethodType . alipay_account djstripe . enums . DjstripePaymentMethodType . bank_account djstripe . enums . DjstripePaymentMethodType . card djstripe . enums . DjstripePaymentMethodType . source djstripe.enums.Enum djstripe.enums.EnumMetaClass Methods djstripe . enums . EnumMetaClass . __new__ ( self , name , bases , classdict ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in djstripe/enums.py def __new__ ( self , name , bases , classdict ): members = [] keys = {} choices = OrderedDict () for key , value in classdict . items (): if key . startswith ( \"__\" ): continue members . append ( key ) if isinstance ( value , tuple ): value , alias = value keys [ alias ] = key else : alias = None keys [ alias or key ] = key choices [ alias or key ] = value for k , v in keys . items (): classdict [ v ] = k classdict [ \"__choices__\" ] = choices classdict [ \"__members__\" ] = members # Note: Differences between Python 2.x and Python 3.x force us to # explicitly use unicode here, and to explicitly sort the list. In # Python 2.x, class members are unordered and so the ordering will # vary on different systems based on internal hashing. Without this # Django will continually require new no-op migrations. classdict [ \"choices\" ] = tuple ( ( str ( k ), str ( v )) for k , v in sorted ( choices . items (), key = operator . itemgetter ( 0 )) ) return type . __new__ ( self , name , bases , classdict ) djstripe . enums . EnumMetaClass . __prepare__ ( name , bases ) classmethod special prepare () -> dict used to create the namespace for the class statement Source code in djstripe/enums.py @classmethod def __prepare__ ( self , name , bases ): return OrderedDict () djstripe.enums.FileUploadPurpose djstripe . enums . FileUploadPurpose . additional_verification djstripe . enums . FileUploadPurpose . business_icon djstripe . enums . FileUploadPurpose . business_logo djstripe . enums . FileUploadPurpose . customer_signature djstripe . enums . FileUploadPurpose . dispute_evidence djstripe . enums . FileUploadPurpose . document_provider_identity_document djstripe . enums . FileUploadPurpose . finance_report_run djstripe . enums . FileUploadPurpose . identity_document djstripe . enums . FileUploadPurpose . invoice_statement djstripe . enums . FileUploadPurpose . pci_document djstripe . enums . FileUploadPurpose . sigma_scheduled_query djstripe . enums . FileUploadPurpose . tax_document_user_upload djstripe.enums.FileUploadType djstripe . enums . FileUploadType . csv djstripe . enums . FileUploadType . docx djstripe . enums . FileUploadType . jpg djstripe . enums . FileUploadType . pdf djstripe . enums . FileUploadType . png djstripe . enums . FileUploadType . xls djstripe . enums . FileUploadType . xlsx djstripe.enums.IntentStatus Status of Intents which apply both to PaymentIntents and SetupIntents. djstripe . enums . IntentStatus . canceled djstripe . enums . IntentStatus . processing djstripe . enums . IntentStatus . requires_action djstripe . enums . IntentStatus . requires_confirmation djstripe . enums . IntentStatus . requires_payment_method djstripe.enums.IntentUsage djstripe . enums . IntentUsage . off_session djstripe . enums . IntentUsage . on_session djstripe.enums.InvoiceBillingReason djstripe . enums . InvoiceBillingReason . manual djstripe . enums . InvoiceBillingReason . subscription djstripe . enums . InvoiceBillingReason . subscription_create djstripe . enums . InvoiceBillingReason . subscription_cycle djstripe . enums . InvoiceBillingReason . subscription_threshold djstripe . enums . InvoiceBillingReason . subscription_update djstripe . enums . InvoiceBillingReason . upcoming djstripe.enums.InvoiceCollectionMethod djstripe . enums . InvoiceCollectionMethod . charge_automatically djstripe . enums . InvoiceCollectionMethod . send_invoice djstripe.enums.InvoiceStatus djstripe . enums . InvoiceStatus . draft djstripe . enums . InvoiceStatus . open djstripe . enums . InvoiceStatus . paid djstripe . enums . InvoiceStatus . uncollectible djstripe . enums . InvoiceStatus . void djstripe.enums.LegacySourceType djstripe . enums . LegacySourceType . alipay_account djstripe . enums . LegacySourceType . bank_account djstripe . enums . LegacySourceType . bitcoin_receiver djstripe . enums . LegacySourceType . card djstripe.enums.PaymentIntentCancellationReason djstripe . enums . PaymentIntentCancellationReason . abandoned djstripe . enums . PaymentIntentCancellationReason . automatic djstripe . enums . PaymentIntentCancellationReason . duplicate djstripe . enums . PaymentIntentCancellationReason . failed_invoice djstripe . enums . PaymentIntentCancellationReason . fraudulent djstripe . enums . PaymentIntentCancellationReason . requested_by_customer djstripe . enums . PaymentIntentCancellationReason . void_invoice djstripe.enums.PaymentIntentStatus djstripe . enums . PaymentIntentStatus . canceled djstripe . enums . PaymentIntentStatus . processing djstripe . enums . PaymentIntentStatus . requires_action djstripe . enums . PaymentIntentStatus . requires_capture djstripe . enums . PaymentIntentStatus . requires_confirmation djstripe . enums . PaymentIntentStatus . requires_payment_method djstripe . enums . PaymentIntentStatus . succeeded djstripe.enums.PaymentMethodType djstripe . enums . PaymentMethodType . alipay djstripe . enums . PaymentMethodType . au_becs_debit djstripe . enums . PaymentMethodType . bacs_debit djstripe . enums . PaymentMethodType . bancontact djstripe . enums . PaymentMethodType . card djstripe . enums . PaymentMethodType . card_present djstripe . enums . PaymentMethodType . eps djstripe . enums . PaymentMethodType . fpx djstripe . enums . PaymentMethodType . giropay djstripe . enums . PaymentMethodType . ideal djstripe . enums . PaymentMethodType . interac_present djstripe . enums . PaymentMethodType . oxxo djstripe . enums . PaymentMethodType . p24 djstripe . enums . PaymentMethodType . sepa_debit djstripe . enums . PaymentMethodType . sofort djstripe.enums.PayoutFailureCode Payout failure error codes. https://stripe.com/docs/api#payout_failures djstripe . enums . PayoutFailureCode . account_closed djstripe . enums . PayoutFailureCode . account_frozen djstripe . enums . PayoutFailureCode . bank_account_restricted djstripe . enums . PayoutFailureCode . bank_ownership_changed djstripe . enums . PayoutFailureCode . could_not_process djstripe . enums . PayoutFailureCode . debit_not_authorized djstripe . enums . PayoutFailureCode . insufficient_funds djstripe . enums . PayoutFailureCode . invalid_account_number djstripe . enums . PayoutFailureCode . invalid_currency djstripe . enums . PayoutFailureCode . no_account djstripe . enums . PayoutFailureCode . unsupported_card djstripe.enums.PayoutMethod djstripe . enums . PayoutMethod . instant djstripe . enums . PayoutMethod . standard djstripe.enums.PayoutSourceType djstripe . enums . PayoutSourceType . bank_account djstripe . enums . PayoutSourceType . card djstripe . enums . PayoutSourceType . fpx djstripe.enums.PayoutStatus djstripe . enums . PayoutStatus . canceled djstripe . enums . PayoutStatus . failed djstripe . enums . PayoutStatus . in_transit djstripe . enums . PayoutStatus . paid djstripe . enums . PayoutStatus . pending djstripe.enums.PayoutType djstripe . enums . PayoutType . bank_account djstripe . enums . PayoutType . card djstripe.enums.PlanAggregateUsage djstripe . enums . PlanAggregateUsage . last_during_period djstripe . enums . PlanAggregateUsage . last_ever djstripe . enums . PlanAggregateUsage . max djstripe . enums . PlanAggregateUsage . sum djstripe.enums.PlanInterval djstripe . enums . PlanInterval . day djstripe . enums . PlanInterval . month djstripe . enums . PlanInterval . week djstripe . enums . PlanInterval . year djstripe.enums.PlanTiersMode djstripe . enums . PlanTiersMode . graduated djstripe . enums . PlanTiersMode . volume djstripe.enums.PlanUsageType djstripe . enums . PlanUsageType . licensed djstripe . enums . PlanUsageType . metered djstripe.enums.PriceTiersMode djstripe . enums . PriceTiersMode . graduated djstripe . enums . PriceTiersMode . volume djstripe.enums.PriceType djstripe . enums . PriceType . one_time djstripe . enums . PriceType . recurring djstripe.enums.PriceUsageType djstripe . enums . PriceUsageType . licensed djstripe . enums . PriceUsageType . metered djstripe.enums.ProductType djstripe . enums . ProductType . good djstripe . enums . ProductType . service djstripe.enums.RefundFailureReason djstripe . enums . RefundFailureReason . expired_or_canceled_card djstripe . enums . RefundFailureReason . lost_or_stolen_card djstripe . enums . RefundFailureReason . unknown djstripe.enums.RefundReason djstripe . enums . RefundReason . duplicate djstripe . enums . RefundReason . expired_uncaptured_charge djstripe . enums . RefundReason . fraudulent djstripe . enums . RefundReason . requested_by_customer djstripe.enums.RefundStatus djstripe . enums . RefundStatus . canceled djstripe . enums . RefundStatus . failed djstripe . enums . RefundStatus . pending djstripe . enums . RefundStatus . succeeded djstripe.enums.ScheduledQueryRunStatus djstripe . enums . ScheduledQueryRunStatus . canceled djstripe . enums . ScheduledQueryRunStatus . failed djstripe . enums . ScheduledQueryRunStatus . timed_out djstripe.enums.SessionBillingAddressCollection djstripe . enums . SessionBillingAddressCollection . auto djstripe . enums . SessionBillingAddressCollection . required djstripe.enums.SessionMode djstripe . enums . SessionMode . payment djstripe . enums . SessionMode . setup djstripe . enums . SessionMode . subscription djstripe.enums.SetupIntentCancellationReason djstripe . enums . SetupIntentCancellationReason . abandoned djstripe . enums . SetupIntentCancellationReason . duplicate djstripe . enums . SetupIntentCancellationReason . requested_by_customer djstripe.enums.SetupIntentStatus djstripe . enums . SetupIntentStatus . canceled djstripe . enums . SetupIntentStatus . processing djstripe . enums . SetupIntentStatus . requires_action djstripe . enums . SetupIntentStatus . requires_confirmation djstripe . enums . SetupIntentStatus . requires_payment_method djstripe . enums . SetupIntentStatus . succeeded djstripe.enums.SourceCodeVerificationStatus djstripe . enums . SourceCodeVerificationStatus . failed djstripe . enums . SourceCodeVerificationStatus . pending djstripe . enums . SourceCodeVerificationStatus . succeeded djstripe.enums.SourceFlow djstripe . enums . SourceFlow . code_verification djstripe . enums . SourceFlow . none djstripe . enums . SourceFlow . receiver djstripe . enums . SourceFlow . redirect djstripe.enums.SourceRedirectFailureReason djstripe . enums . SourceRedirectFailureReason . declined djstripe . enums . SourceRedirectFailureReason . processing_error djstripe . enums . SourceRedirectFailureReason . user_abort djstripe.enums.SourceRedirectStatus djstripe . enums . SourceRedirectStatus . failed djstripe . enums . SourceRedirectStatus . not_required djstripe . enums . SourceRedirectStatus . pending djstripe . enums . SourceRedirectStatus . succeeded djstripe.enums.SourceStatus djstripe . enums . SourceStatus . canceled djstripe . enums . SourceStatus . chargeable djstripe . enums . SourceStatus . consumed djstripe . enums . SourceStatus . failed djstripe . enums . SourceStatus . pending djstripe.enums.SourceType djstripe . enums . SourceType . ach_credit_transfer djstripe . enums . SourceType . ach_debit djstripe . enums . SourceType . acss_debit djstripe . enums . SourceType . alipay djstripe . enums . SourceType . au_becs_debit djstripe . enums . SourceType . bancontact djstripe . enums . SourceType . bitcoin djstripe . enums . SourceType . card djstripe . enums . SourceType . card_present djstripe . enums . SourceType . eps djstripe . enums . SourceType . giropay djstripe . enums . SourceType . ideal djstripe . enums . SourceType . klarna djstripe . enums . SourceType . multibanco djstripe . enums . SourceType . p24 djstripe . enums . SourceType . paper_check djstripe . enums . SourceType . sepa_credit_transfer djstripe . enums . SourceType . sepa_debit djstripe . enums . SourceType . sofort djstripe . enums . SourceType . three_d_secure djstripe . enums . SourceType . wechat djstripe.enums.SourceUsage djstripe . enums . SourceUsage . reusable djstripe . enums . SourceUsage . single_use djstripe.enums.SubmitTypeStatus djstripe . enums . SubmitTypeStatus . auto djstripe . enums . SubmitTypeStatus . book djstripe . enums . SubmitTypeStatus . donate djstripe . enums . SubmitTypeStatus . pay djstripe.enums.SubscriptionScheduleEndBehavior djstripe . enums . SubscriptionScheduleEndBehavior . cancel djstripe . enums . SubscriptionScheduleEndBehavior . release djstripe.enums.SubscriptionScheduleStatus djstripe . enums . SubscriptionScheduleStatus . active djstripe . enums . SubscriptionScheduleStatus . canceled djstripe . enums . SubscriptionScheduleStatus . completed djstripe . enums . SubscriptionScheduleStatus . not_started djstripe . enums . SubscriptionScheduleStatus . released djstripe.enums.SubscriptionStatus djstripe . enums . SubscriptionStatus . active djstripe . enums . SubscriptionStatus . canceled djstripe . enums . SubscriptionStatus . incomplete djstripe . enums . SubscriptionStatus . incomplete_expired djstripe . enums . SubscriptionStatus . past_due djstripe . enums . SubscriptionStatus . trialing djstripe . enums . SubscriptionStatus . unpaid djstripe.enums.TaxIdType djstripe . enums . TaxIdType . ae_trn djstripe . enums . TaxIdType . au_abn djstripe . enums . TaxIdType . br_cnp djstripe . enums . TaxIdType . br_cpf djstripe . enums . TaxIdType . ca_bn djstripe . enums . TaxIdType . ca_qst djstripe . enums . TaxIdType . ch_vat djstripe . enums . TaxIdType . cl_tin djstripe . enums . TaxIdType . es_cif djstripe . enums . TaxIdType . eu_vat djstripe . enums . TaxIdType . hk_br djstripe . enums . TaxIdType . id_npw djstripe . enums . TaxIdType . in_gst djstripe . enums . TaxIdType . jp_cn djstripe . enums . TaxIdType . jp_rn djstripe . enums . TaxIdType . kr_brn djstripe . enums . TaxIdType . li_uid djstripe . enums . TaxIdType . mx_rfc djstripe . enums . TaxIdType . my_frp djstripe . enums . TaxIdType . my_itn djstripe . enums . TaxIdType . my_sst djstripe . enums . TaxIdType . no_vat djstripe . enums . TaxIdType . nz_gst djstripe . enums . TaxIdType . ru_inn djstripe . enums . TaxIdType . ru_kpp djstripe . enums . TaxIdType . sa_vat djstripe . enums . TaxIdType . sg_gst djstripe . enums . TaxIdType . sg_uen djstripe . enums . TaxIdType . th_vat djstripe . enums . TaxIdType . tw_vat djstripe . enums . TaxIdType . unknown djstripe . enums . TaxIdType . us_ein djstripe . enums . TaxIdType . za_vat","title":"Enumerations"},{"location":"reference/enums/#enumerations","text":"","title":"Enumerations"},{"location":"reference/enums/#djstripe.enums-classes","text":"","title":"Classes"},{"location":"reference/enums/#djstripe.enums.APIKeyType","text":"API Key Types (internal model only)","title":"APIKeyType"},{"location":"reference/enums/#djstripe.enums.APIKeyType.publishable","text":"","title":"publishable"},{"location":"reference/enums/#djstripe.enums.APIKeyType.restricted","text":"","title":"restricted"},{"location":"reference/enums/#djstripe.enums.APIKeyType.secret","text":"","title":"secret"},{"location":"reference/enums/#djstripe.enums.AccountType","text":"","title":"AccountType"},{"location":"reference/enums/#djstripe.enums.AccountType.custom","text":"","title":"custom"},{"location":"reference/enums/#djstripe.enums.AccountType.express","text":"","title":"express"},{"location":"reference/enums/#djstripe.enums.AccountType.standard","text":"","title":"standard"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode","text":"Charge failure error codes. https://stripe.com/docs/error-codes","title":"ApiErrorCode"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_already_exists","text":"","title":"account_already_exists"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_country_invalid_address","text":"","title":"account_country_invalid_address"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_invalid","text":"","title":"account_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.account_number_invalid","text":"","title":"account_number_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.alipay_upgrade_required","text":"","title":"alipay_upgrade_required"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.amount_too_large","text":"","title":"amount_too_large"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.amount_too_small","text":"","title":"amount_too_small"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.api_key_expired","text":"","title":"api_key_expired"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.balance_insufficient","text":"","title":"balance_insufficient"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bank_account_exists","text":"","title":"bank_account_exists"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bank_account_unusable","text":"","title":"bank_account_unusable"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bank_account_unverified","text":"","title":"bank_account_unverified"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.bitcoin_upgrade_required","text":"","title":"bitcoin_upgrade_required"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.card_declined","text":"","title":"card_declined"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_already_captured","text":"","title":"charge_already_captured"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_already_refunded","text":"","title":"charge_already_refunded"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_disputed","text":"","title":"charge_disputed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_exceeds_source_limit","text":"","title":"charge_exceeds_source_limit"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.charge_expired_for_capture","text":"","title":"charge_expired_for_capture"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.country_unsupported","text":"","title":"country_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.coupon_expired","text":"","title":"coupon_expired"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.customer_max_subscriptions","text":"","title":"customer_max_subscriptions"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.email_invalid","text":"","title":"email_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.expired_card","text":"","title":"expired_card"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.idempotency_key_in_use","text":"","title":"idempotency_key_in_use"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_address","text":"","title":"incorrect_address"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_cvc","text":"","title":"incorrect_cvc"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_number","text":"","title":"incorrect_number"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.incorrect_zip","text":"","title":"incorrect_zip"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.instant_payouts_unsupported","text":"","title":"instant_payouts_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_card_type","text":"","title":"invalid_card_type"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_charge_amount","text":"","title":"invalid_charge_amount"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_cvc","text":"","title":"invalid_cvc"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_expiry_month","text":"","title":"invalid_expiry_month"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_expiry_year","text":"","title":"invalid_expiry_year"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_number","text":"","title":"invalid_number"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_source_usage","text":"","title":"invalid_source_usage"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invalid_swipe_data","text":"","title":"invalid_swipe_data"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_no_customer_line_items","text":"","title":"invoice_no_customer_line_items"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_no_subscription_line_items","text":"","title":"invoice_no_subscription_line_items"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_not_editable","text":"","title":"invoice_not_editable"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.invoice_upcoming_none","text":"","title":"invoice_upcoming_none"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.livemode_mismatch","text":"","title":"livemode_mismatch"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.missing","text":"","title":"missing"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.not_allowed_on_standard_account","text":"","title":"not_allowed_on_standard_account"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_creation_failed","text":"","title":"order_creation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_required_settings","text":"","title":"order_required_settings"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_status_invalid","text":"","title":"order_status_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.order_upstream_timeout","text":"","title":"order_upstream_timeout"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.out_of_inventory","text":"","title":"out_of_inventory"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_empty","text":"","title":"parameter_invalid_empty"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_integer","text":"","title":"parameter_invalid_integer"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_string_blank","text":"","title":"parameter_invalid_string_blank"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_invalid_string_empty","text":"","title":"parameter_invalid_string_empty"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_missing","text":"","title":"parameter_missing"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameter_unknown","text":"","title":"parameter_unknown"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.parameters_exclusive","text":"","title":"parameters_exclusive"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_authentication_failure","text":"","title":"payment_intent_authentication_failure"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_incompatible_payment_method","text":"","title":"payment_intent_incompatible_payment_method"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_invalid_parameter","text":"","title":"payment_intent_invalid_parameter"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_payment_attempt_failed","text":"","title":"payment_intent_payment_attempt_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_intent_unexpected_state","text":"","title":"payment_intent_unexpected_state"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_method_unactivated","text":"","title":"payment_method_unactivated"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payment_method_unexpected_state","text":"","title":"payment_method_unexpected_state"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.payouts_not_allowed","text":"","title":"payouts_not_allowed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.platform_api_key_expired","text":"","title":"platform_api_key_expired"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.postal_code_invalid","text":"","title":"postal_code_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.processing_error","text":"","title":"processing_error"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.product_inactive","text":"","title":"product_inactive"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.rate_limit","text":"","title":"rate_limit"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.resource_already_exists","text":"","title":"resource_already_exists"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.resource_missing","text":"","title":"resource_missing"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.routing_number_invalid","text":"","title":"routing_number_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.secret_key_required","text":"","title":"secret_key_required"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.sepa_unsupported_account","text":"","title":"sepa_unsupported_account"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.shipping_calculation_failed","text":"","title":"shipping_calculation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.sku_inactive","text":"","title":"sku_inactive"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.state_unsupported","text":"","title":"state_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.tax_id_invalid","text":"","title":"tax_id_invalid"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.taxes_calculation_failed","text":"","title":"taxes_calculation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.testmode_charges_only","text":"","title":"testmode_charges_only"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.tls_version_unsupported","text":"","title":"tls_version_unsupported"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.token_already_used","text":"","title":"token_already_used"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.token_in_use","text":"","title":"token_in_use"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.transfers_not_allowed","text":"","title":"transfers_not_allowed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.upstream_order_creation_failed","text":"","title":"upstream_order_creation_failed"},{"location":"reference/enums/#djstripe.enums.ApiErrorCode.url_invalid","text":"","title":"url_invalid"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory","text":"https://stripe.com/docs/reports/reporting-categories","title":"BalanceTransactionReportingCategory"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.advance","text":"","title":"advance"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.advance_funding","text":"","title":"advance_funding"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.anticipation_repayment","text":"","title":"anticipation_repayment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.charge","text":"","title":"charge"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.charge_failure","text":"","title":"charge_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.connect_collection_transfer","text":"","title":"connect_collection_transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.connect_reserved_funds","text":"","title":"connect_reserved_funds"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.dispute","text":"","title":"dispute"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.dispute_reversal","text":"","title":"dispute_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.fee","text":"","title":"fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_authorization_hold","text":"","title":"issuing_authorization_hold"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_authorization_release","text":"","title":"issuing_authorization_release"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_dispute","text":"","title":"issuing_dispute"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.issuing_transaction","text":"","title":"issuing_transaction"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.other_adjustment","text":"","title":"other_adjustment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.partial_capture_reversal","text":"","title":"partial_capture_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.payout","text":"","title":"payout"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.payout_reversal","text":"","title":"payout_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.platform_earning","text":"","title":"platform_earning"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.platform_earning_refund","text":"","title":"platform_earning_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.refund","text":"","title":"refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.refund_failure","text":"","title":"refund_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.risk_reserved_funds","text":"","title":"risk_reserved_funds"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.tax","text":"","title":"tax"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.topup","text":"","title":"topup"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.topup_reversal","text":"","title":"topup_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.transfer","text":"","title":"transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionReportingCategory.transfer_reversal","text":"","title":"transfer_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus","text":"","title":"BalanceTransactionStatus"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus.available","text":"","title":"available"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType","text":"","title":"BalanceTransactionType"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.adjustment","text":"","title":"adjustment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.advance","text":"","title":"advance"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.advance_funding","text":"","title":"advance_funding"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.anticipation_repayment","text":"","title":"anticipation_repayment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.application_fee","text":"","title":"application_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.application_fee_refund","text":"","title":"application_fee_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.balance_transfer_inbound","text":"","title":"balance_transfer_inbound"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.balance_transfer_outbound","text":"","title":"balance_transfer_outbound"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.charge","text":"","title":"charge"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.connect_collection_transfer","text":"","title":"connect_collection_transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.contribution","text":"","title":"contribution"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_authorization_hold","text":"","title":"issuing_authorization_hold"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_authorization_release","text":"","title":"issuing_authorization_release"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_dispute","text":"","title":"issuing_dispute"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.issuing_transaction","text":"","title":"issuing_transaction"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.network_cost","text":"","title":"network_cost"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payment","text":"","title":"payment"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payment_failure_refund","text":"","title":"payment_failure_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payment_refund","text":"","title":"payment_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payout","text":"","title":"payout"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payout_cancel","text":"","title":"payout_cancel"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.payout_failure","text":"","title":"payout_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.refund","text":"","title":"refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.refund_failure","text":"","title":"refund_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.reserve_transaction","text":"","title":"reserve_transaction"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.reserved_funds","text":"","title":"reserved_funds"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.stripe_fee","text":"","title":"stripe_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.stripe_fx_fee","text":"","title":"stripe_fx_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.tax_fee","text":"","title":"tax_fee"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.topup","text":"","title":"topup"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.topup_reversal","text":"","title":"topup_reversal"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer","text":"","title":"transfer"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer_cancel","text":"","title":"transfer_cancel"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer_failure","text":"","title":"transfer_failure"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.transfer_refund","text":"","title":"transfer_refund"},{"location":"reference/enums/#djstripe.enums.BalanceTransactionType.validation","text":"","title":"validation"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType","text":"","title":"BankAccountHolderType"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType.company","text":"","title":"company"},{"location":"reference/enums/#djstripe.enums.BankAccountHolderType.individual","text":"","title":"individual"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus","text":"","title":"BankAccountStatus"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.errored","text":"","title":"errored"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.new","text":"","title":"new"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.validated","text":"","title":"validated"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.verification_failed","text":"","title":"verification_failed"},{"location":"reference/enums/#djstripe.enums.BankAccountStatus.verified","text":"","title":"verified"},{"location":"reference/enums/#djstripe.enums.BillingScheme","text":"","title":"BillingScheme"},{"location":"reference/enums/#djstripe.enums.BillingScheme.per_unit","text":"","title":"per_unit"},{"location":"reference/enums/#djstripe.enums.BillingScheme.tiered","text":"","title":"tiered"},{"location":"reference/enums/#djstripe.enums.BusinessType","text":"","title":"BusinessType"},{"location":"reference/enums/#djstripe.enums.BusinessType.company","text":"","title":"company"},{"location":"reference/enums/#djstripe.enums.BusinessType.individual","text":"","title":"individual"},{"location":"reference/enums/#djstripe.enums.CaptureMethod","text":"","title":"CaptureMethod"},{"location":"reference/enums/#djstripe.enums.CaptureMethod.automatic","text":"","title":"automatic"},{"location":"reference/enums/#djstripe.enums.CaptureMethod.manual","text":"","title":"manual"},{"location":"reference/enums/#djstripe.enums.CardBrand","text":"","title":"CardBrand"},{"location":"reference/enums/#djstripe.enums.CardBrand.AmericanExpress","text":"","title":"AmericanExpress"},{"location":"reference/enums/#djstripe.enums.CardBrand.DinersClub","text":"","title":"DinersClub"},{"location":"reference/enums/#djstripe.enums.CardBrand.Discover","text":"","title":"Discover"},{"location":"reference/enums/#djstripe.enums.CardBrand.JCB","text":"","title":"JCB"},{"location":"reference/enums/#djstripe.enums.CardBrand.MasterCard","text":"","title":"MasterCard"},{"location":"reference/enums/#djstripe.enums.CardBrand.UnionPay","text":"","title":"UnionPay"},{"location":"reference/enums/#djstripe.enums.CardBrand.Unknown","text":"","title":"Unknown"},{"location":"reference/enums/#djstripe.enums.CardBrand.Visa","text":"","title":"Visa"},{"location":"reference/enums/#djstripe.enums.CardCheckResult","text":"","title":"CardCheckResult"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.fail","text":"","title":"fail"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.pass_","text":"","title":"pass_"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.unavailable","text":"","title":"unavailable"},{"location":"reference/enums/#djstripe.enums.CardCheckResult.unchecked","text":"","title":"unchecked"},{"location":"reference/enums/#djstripe.enums.CardFundingType","text":"","title":"CardFundingType"},{"location":"reference/enums/#djstripe.enums.CardFundingType.credit","text":"","title":"credit"},{"location":"reference/enums/#djstripe.enums.CardFundingType.debit","text":"","title":"debit"},{"location":"reference/enums/#djstripe.enums.CardFundingType.prepaid","text":"","title":"prepaid"},{"location":"reference/enums/#djstripe.enums.CardFundingType.unknown","text":"","title":"unknown"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod","text":"","title":"CardTokenizationMethod"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod.android_pay","text":"","title":"android_pay"},{"location":"reference/enums/#djstripe.enums.CardTokenizationMethod.apple_pay","text":"","title":"apple_pay"},{"location":"reference/enums/#djstripe.enums.ChargeStatus","text":"","title":"ChargeStatus"},{"location":"reference/enums/#djstripe.enums.ChargeStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.ChargeStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.ChargeStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod","text":"","title":"ConfirmationMethod"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod.automatic","text":"","title":"automatic"},{"location":"reference/enums/#djstripe.enums.ConfirmationMethod.manual","text":"","title":"manual"},{"location":"reference/enums/#djstripe.enums.CouponDuration","text":"","title":"CouponDuration"},{"location":"reference/enums/#djstripe.enums.CouponDuration.forever","text":"","title":"forever"},{"location":"reference/enums/#djstripe.enums.CouponDuration.once","text":"","title":"once"},{"location":"reference/enums/#djstripe.enums.CouponDuration.repeating","text":"","title":"repeating"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt","text":"","title":"CustomerTaxExempt"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt.exempt","text":"","title":"exempt"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt.none","text":"","title":"none"},{"location":"reference/enums/#djstripe.enums.CustomerTaxExempt.reverse","text":"","title":"reverse"},{"location":"reference/enums/#djstripe.enums.DisputeReason","text":"","title":"DisputeReason"},{"location":"reference/enums/#djstripe.enums.DisputeReason.bank_cannot_process","text":"","title":"bank_cannot_process"},{"location":"reference/enums/#djstripe.enums.DisputeReason.credit_not_processed","text":"","title":"credit_not_processed"},{"location":"reference/enums/#djstripe.enums.DisputeReason.customer_initiated","text":"","title":"customer_initiated"},{"location":"reference/enums/#djstripe.enums.DisputeReason.debit_not_authorized","text":"","title":"debit_not_authorized"},{"location":"reference/enums/#djstripe.enums.DisputeReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.DisputeReason.fraudulent","text":"","title":"fraudulent"},{"location":"reference/enums/#djstripe.enums.DisputeReason.general","text":"","title":"general"},{"location":"reference/enums/#djstripe.enums.DisputeReason.incorrect_account_details","text":"","title":"incorrect_account_details"},{"location":"reference/enums/#djstripe.enums.DisputeReason.insufficient_funds","text":"","title":"insufficient_funds"},{"location":"reference/enums/#djstripe.enums.DisputeReason.product_not_received","text":"","title":"product_not_received"},{"location":"reference/enums/#djstripe.enums.DisputeReason.product_unacceptable","text":"","title":"product_unacceptable"},{"location":"reference/enums/#djstripe.enums.DisputeReason.subscription_canceled","text":"","title":"subscription_canceled"},{"location":"reference/enums/#djstripe.enums.DisputeReason.unrecognized","text":"","title":"unrecognized"},{"location":"reference/enums/#djstripe.enums.DisputeStatus","text":"","title":"DisputeStatus"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.charge_refunded","text":"","title":"charge_refunded"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.lost","text":"","title":"lost"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.needs_response","text":"","title":"needs_response"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.under_review","text":"","title":"under_review"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.warning_closed","text":"","title":"warning_closed"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.warning_needs_response","text":"","title":"warning_needs_response"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.warning_under_review","text":"","title":"warning_under_review"},{"location":"reference/enums/#djstripe.enums.DisputeStatus.won","text":"","title":"won"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType","text":"A djstripe-specific enum for the DjStripePaymentMethod model.","title":"DjstripePaymentMethodType"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.alipay_account","text":"","title":"alipay_account"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.DjstripePaymentMethodType.source","text":"","title":"source"},{"location":"reference/enums/#djstripe.enums.Enum","text":"","title":"Enum"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass","text":"","title":"EnumMetaClass"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass-methods","text":"","title":"Methods"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in djstripe/enums.py def __new__ ( self , name , bases , classdict ): members = [] keys = {} choices = OrderedDict () for key , value in classdict . items (): if key . startswith ( \"__\" ): continue members . append ( key ) if isinstance ( value , tuple ): value , alias = value keys [ alias ] = key else : alias = None keys [ alias or key ] = key choices [ alias or key ] = value for k , v in keys . items (): classdict [ v ] = k classdict [ \"__choices__\" ] = choices classdict [ \"__members__\" ] = members # Note: Differences between Python 2.x and Python 3.x force us to # explicitly use unicode here, and to explicitly sort the list. In # Python 2.x, class members are unordered and so the ordering will # vary on different systems based on internal hashing. Without this # Django will continually require new no-op migrations. classdict [ \"choices\" ] = tuple ( ( str ( k ), str ( v )) for k , v in sorted ( choices . items (), key = operator . itemgetter ( 0 )) ) return type . __new__ ( self , name , bases , classdict )","title":"__new__()"},{"location":"reference/enums/#djstripe.enums.EnumMetaClass.__prepare__","text":"prepare () -> dict used to create the namespace for the class statement Source code in djstripe/enums.py @classmethod def __prepare__ ( self , name , bases ): return OrderedDict ()","title":"__prepare__()"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose","text":"","title":"FileUploadPurpose"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.additional_verification","text":"","title":"additional_verification"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.business_icon","text":"","title":"business_icon"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.business_logo","text":"","title":"business_logo"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.customer_signature","text":"","title":"customer_signature"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.dispute_evidence","text":"","title":"dispute_evidence"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.document_provider_identity_document","text":"","title":"document_provider_identity_document"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.finance_report_run","text":"","title":"finance_report_run"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.identity_document","text":"","title":"identity_document"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.invoice_statement","text":"","title":"invoice_statement"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.pci_document","text":"","title":"pci_document"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.sigma_scheduled_query","text":"","title":"sigma_scheduled_query"},{"location":"reference/enums/#djstripe.enums.FileUploadPurpose.tax_document_user_upload","text":"","title":"tax_document_user_upload"},{"location":"reference/enums/#djstripe.enums.FileUploadType","text":"","title":"FileUploadType"},{"location":"reference/enums/#djstripe.enums.FileUploadType.csv","text":"","title":"csv"},{"location":"reference/enums/#djstripe.enums.FileUploadType.docx","text":"","title":"docx"},{"location":"reference/enums/#djstripe.enums.FileUploadType.jpg","text":"","title":"jpg"},{"location":"reference/enums/#djstripe.enums.FileUploadType.pdf","text":"","title":"pdf"},{"location":"reference/enums/#djstripe.enums.FileUploadType.png","text":"","title":"png"},{"location":"reference/enums/#djstripe.enums.FileUploadType.xls","text":"","title":"xls"},{"location":"reference/enums/#djstripe.enums.FileUploadType.xlsx","text":"","title":"xlsx"},{"location":"reference/enums/#djstripe.enums.IntentStatus","text":"Status of Intents which apply both to PaymentIntents and SetupIntents.","title":"IntentStatus"},{"location":"reference/enums/#djstripe.enums.IntentStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.IntentStatus.processing","text":"","title":"processing"},{"location":"reference/enums/#djstripe.enums.IntentStatus.requires_action","text":"","title":"requires_action"},{"location":"reference/enums/#djstripe.enums.IntentStatus.requires_confirmation","text":"","title":"requires_confirmation"},{"location":"reference/enums/#djstripe.enums.IntentStatus.requires_payment_method","text":"","title":"requires_payment_method"},{"location":"reference/enums/#djstripe.enums.IntentUsage","text":"","title":"IntentUsage"},{"location":"reference/enums/#djstripe.enums.IntentUsage.off_session","text":"","title":"off_session"},{"location":"reference/enums/#djstripe.enums.IntentUsage.on_session","text":"","title":"on_session"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason","text":"","title":"InvoiceBillingReason"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.manual","text":"","title":"manual"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription","text":"","title":"subscription"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_create","text":"","title":"subscription_create"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_cycle","text":"","title":"subscription_cycle"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_threshold","text":"","title":"subscription_threshold"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.subscription_update","text":"","title":"subscription_update"},{"location":"reference/enums/#djstripe.enums.InvoiceBillingReason.upcoming","text":"","title":"upcoming"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod","text":"","title":"InvoiceCollectionMethod"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod.charge_automatically","text":"","title":"charge_automatically"},{"location":"reference/enums/#djstripe.enums.InvoiceCollectionMethod.send_invoice","text":"","title":"send_invoice"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus","text":"","title":"InvoiceStatus"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.draft","text":"","title":"draft"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.open","text":"","title":"open"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.paid","text":"","title":"paid"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.uncollectible","text":"","title":"uncollectible"},{"location":"reference/enums/#djstripe.enums.InvoiceStatus.void","text":"","title":"void"},{"location":"reference/enums/#djstripe.enums.LegacySourceType","text":"","title":"LegacySourceType"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.alipay_account","text":"","title":"alipay_account"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.bitcoin_receiver","text":"","title":"bitcoin_receiver"},{"location":"reference/enums/#djstripe.enums.LegacySourceType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason","text":"","title":"PaymentIntentCancellationReason"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.abandoned","text":"","title":"abandoned"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.automatic","text":"","title":"automatic"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.failed_invoice","text":"","title":"failed_invoice"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.fraudulent","text":"","title":"fraudulent"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.requested_by_customer","text":"","title":"requested_by_customer"},{"location":"reference/enums/#djstripe.enums.PaymentIntentCancellationReason.void_invoice","text":"","title":"void_invoice"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus","text":"","title":"PaymentIntentStatus"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.processing","text":"","title":"processing"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_action","text":"","title":"requires_action"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_capture","text":"","title":"requires_capture"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_confirmation","text":"","title":"requires_confirmation"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.requires_payment_method","text":"","title":"requires_payment_method"},{"location":"reference/enums/#djstripe.enums.PaymentIntentStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType","text":"","title":"PaymentMethodType"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.alipay","text":"","title":"alipay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.au_becs_debit","text":"","title":"au_becs_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.bacs_debit","text":"","title":"bacs_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.bancontact","text":"","title":"bancontact"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.card_present","text":"","title":"card_present"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.eps","text":"","title":"eps"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.fpx","text":"","title":"fpx"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.giropay","text":"","title":"giropay"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.ideal","text":"","title":"ideal"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.interac_present","text":"","title":"interac_present"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.oxxo","text":"","title":"oxxo"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.p24","text":"","title":"p24"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.sepa_debit","text":"","title":"sepa_debit"},{"location":"reference/enums/#djstripe.enums.PaymentMethodType.sofort","text":"","title":"sofort"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode","text":"Payout failure error codes. https://stripe.com/docs/api#payout_failures","title":"PayoutFailureCode"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.account_closed","text":"","title":"account_closed"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.account_frozen","text":"","title":"account_frozen"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.bank_account_restricted","text":"","title":"bank_account_restricted"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.bank_ownership_changed","text":"","title":"bank_ownership_changed"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.could_not_process","text":"","title":"could_not_process"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.debit_not_authorized","text":"","title":"debit_not_authorized"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.insufficient_funds","text":"","title":"insufficient_funds"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.invalid_account_number","text":"","title":"invalid_account_number"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.invalid_currency","text":"","title":"invalid_currency"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.no_account","text":"","title":"no_account"},{"location":"reference/enums/#djstripe.enums.PayoutFailureCode.unsupported_card","text":"","title":"unsupported_card"},{"location":"reference/enums/#djstripe.enums.PayoutMethod","text":"","title":"PayoutMethod"},{"location":"reference/enums/#djstripe.enums.PayoutMethod.instant","text":"","title":"instant"},{"location":"reference/enums/#djstripe.enums.PayoutMethod.standard","text":"","title":"standard"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType","text":"","title":"PayoutSourceType"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.PayoutSourceType.fpx","text":"","title":"fpx"},{"location":"reference/enums/#djstripe.enums.PayoutStatus","text":"","title":"PayoutStatus"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.in_transit","text":"","title":"in_transit"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.paid","text":"","title":"paid"},{"location":"reference/enums/#djstripe.enums.PayoutStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.PayoutType","text":"","title":"PayoutType"},{"location":"reference/enums/#djstripe.enums.PayoutType.bank_account","text":"","title":"bank_account"},{"location":"reference/enums/#djstripe.enums.PayoutType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage","text":"","title":"PlanAggregateUsage"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.last_during_period","text":"","title":"last_during_period"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.last_ever","text":"","title":"last_ever"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.max","text":"","title":"max"},{"location":"reference/enums/#djstripe.enums.PlanAggregateUsage.sum","text":"","title":"sum"},{"location":"reference/enums/#djstripe.enums.PlanInterval","text":"","title":"PlanInterval"},{"location":"reference/enums/#djstripe.enums.PlanInterval.day","text":"","title":"day"},{"location":"reference/enums/#djstripe.enums.PlanInterval.month","text":"","title":"month"},{"location":"reference/enums/#djstripe.enums.PlanInterval.week","text":"","title":"week"},{"location":"reference/enums/#djstripe.enums.PlanInterval.year","text":"","title":"year"},{"location":"reference/enums/#djstripe.enums.PlanTiersMode","text":"","title":"PlanTiersMode"},{"location":"reference/enums/#djstripe.enums.PlanTiersMode.graduated","text":"","title":"graduated"},{"location":"reference/enums/#djstripe.enums.PlanTiersMode.volume","text":"","title":"volume"},{"location":"reference/enums/#djstripe.enums.PlanUsageType","text":"","title":"PlanUsageType"},{"location":"reference/enums/#djstripe.enums.PlanUsageType.licensed","text":"","title":"licensed"},{"location":"reference/enums/#djstripe.enums.PlanUsageType.metered","text":"","title":"metered"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode","text":"","title":"PriceTiersMode"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode.graduated","text":"","title":"graduated"},{"location":"reference/enums/#djstripe.enums.PriceTiersMode.volume","text":"","title":"volume"},{"location":"reference/enums/#djstripe.enums.PriceType","text":"","title":"PriceType"},{"location":"reference/enums/#djstripe.enums.PriceType.one_time","text":"","title":"one_time"},{"location":"reference/enums/#djstripe.enums.PriceType.recurring","text":"","title":"recurring"},{"location":"reference/enums/#djstripe.enums.PriceUsageType","text":"","title":"PriceUsageType"},{"location":"reference/enums/#djstripe.enums.PriceUsageType.licensed","text":"","title":"licensed"},{"location":"reference/enums/#djstripe.enums.PriceUsageType.metered","text":"","title":"metered"},{"location":"reference/enums/#djstripe.enums.ProductType","text":"","title":"ProductType"},{"location":"reference/enums/#djstripe.enums.ProductType.good","text":"","title":"good"},{"location":"reference/enums/#djstripe.enums.ProductType.service","text":"","title":"service"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason","text":"","title":"RefundFailureReason"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason.expired_or_canceled_card","text":"","title":"expired_or_canceled_card"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason.lost_or_stolen_card","text":"","title":"lost_or_stolen_card"},{"location":"reference/enums/#djstripe.enums.RefundFailureReason.unknown","text":"","title":"unknown"},{"location":"reference/enums/#djstripe.enums.RefundReason","text":"","title":"RefundReason"},{"location":"reference/enums/#djstripe.enums.RefundReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.RefundReason.expired_uncaptured_charge","text":"","title":"expired_uncaptured_charge"},{"location":"reference/enums/#djstripe.enums.RefundReason.fraudulent","text":"","title":"fraudulent"},{"location":"reference/enums/#djstripe.enums.RefundReason.requested_by_customer","text":"","title":"requested_by_customer"},{"location":"reference/enums/#djstripe.enums.RefundStatus","text":"","title":"RefundStatus"},{"location":"reference/enums/#djstripe.enums.RefundStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.RefundStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.RefundStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.RefundStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus","text":"","title":"ScheduledQueryRunStatus"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.ScheduledQueryRunStatus.timed_out","text":"","title":"timed_out"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection","text":"","title":"SessionBillingAddressCollection"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection.auto","text":"","title":"auto"},{"location":"reference/enums/#djstripe.enums.SessionBillingAddressCollection.required","text":"","title":"required"},{"location":"reference/enums/#djstripe.enums.SessionMode","text":"","title":"SessionMode"},{"location":"reference/enums/#djstripe.enums.SessionMode.payment","text":"","title":"payment"},{"location":"reference/enums/#djstripe.enums.SessionMode.setup","text":"","title":"setup"},{"location":"reference/enums/#djstripe.enums.SessionMode.subscription","text":"","title":"subscription"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason","text":"","title":"SetupIntentCancellationReason"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason.abandoned","text":"","title":"abandoned"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason.duplicate","text":"","title":"duplicate"},{"location":"reference/enums/#djstripe.enums.SetupIntentCancellationReason.requested_by_customer","text":"","title":"requested_by_customer"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus","text":"","title":"SetupIntentStatus"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.processing","text":"","title":"processing"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.requires_action","text":"","title":"requires_action"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.requires_confirmation","text":"","title":"requires_confirmation"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.requires_payment_method","text":"","title":"requires_payment_method"},{"location":"reference/enums/#djstripe.enums.SetupIntentStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus","text":"","title":"SourceCodeVerificationStatus"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.SourceCodeVerificationStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.SourceFlow","text":"","title":"SourceFlow"},{"location":"reference/enums/#djstripe.enums.SourceFlow.code_verification","text":"","title":"code_verification"},{"location":"reference/enums/#djstripe.enums.SourceFlow.none","text":"","title":"none"},{"location":"reference/enums/#djstripe.enums.SourceFlow.receiver","text":"","title":"receiver"},{"location":"reference/enums/#djstripe.enums.SourceFlow.redirect","text":"","title":"redirect"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason","text":"","title":"SourceRedirectFailureReason"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason.declined","text":"","title":"declined"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason.processing_error","text":"","title":"processing_error"},{"location":"reference/enums/#djstripe.enums.SourceRedirectFailureReason.user_abort","text":"","title":"user_abort"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus","text":"","title":"SourceRedirectStatus"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.not_required","text":"","title":"not_required"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.SourceRedirectStatus.succeeded","text":"","title":"succeeded"},{"location":"reference/enums/#djstripe.enums.SourceStatus","text":"","title":"SourceStatus"},{"location":"reference/enums/#djstripe.enums.SourceStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SourceStatus.chargeable","text":"","title":"chargeable"},{"location":"reference/enums/#djstripe.enums.SourceStatus.consumed","text":"","title":"consumed"},{"location":"reference/enums/#djstripe.enums.SourceStatus.failed","text":"","title":"failed"},{"location":"reference/enums/#djstripe.enums.SourceStatus.pending","text":"","title":"pending"},{"location":"reference/enums/#djstripe.enums.SourceType","text":"","title":"SourceType"},{"location":"reference/enums/#djstripe.enums.SourceType.ach_credit_transfer","text":"","title":"ach_credit_transfer"},{"location":"reference/enums/#djstripe.enums.SourceType.ach_debit","text":"","title":"ach_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.acss_debit","text":"","title":"acss_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.alipay","text":"","title":"alipay"},{"location":"reference/enums/#djstripe.enums.SourceType.au_becs_debit","text":"","title":"au_becs_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.bancontact","text":"","title":"bancontact"},{"location":"reference/enums/#djstripe.enums.SourceType.bitcoin","text":"","title":"bitcoin"},{"location":"reference/enums/#djstripe.enums.SourceType.card","text":"","title":"card"},{"location":"reference/enums/#djstripe.enums.SourceType.card_present","text":"","title":"card_present"},{"location":"reference/enums/#djstripe.enums.SourceType.eps","text":"","title":"eps"},{"location":"reference/enums/#djstripe.enums.SourceType.giropay","text":"","title":"giropay"},{"location":"reference/enums/#djstripe.enums.SourceType.ideal","text":"","title":"ideal"},{"location":"reference/enums/#djstripe.enums.SourceType.klarna","text":"","title":"klarna"},{"location":"reference/enums/#djstripe.enums.SourceType.multibanco","text":"","title":"multibanco"},{"location":"reference/enums/#djstripe.enums.SourceType.p24","text":"","title":"p24"},{"location":"reference/enums/#djstripe.enums.SourceType.paper_check","text":"","title":"paper_check"},{"location":"reference/enums/#djstripe.enums.SourceType.sepa_credit_transfer","text":"","title":"sepa_credit_transfer"},{"location":"reference/enums/#djstripe.enums.SourceType.sepa_debit","text":"","title":"sepa_debit"},{"location":"reference/enums/#djstripe.enums.SourceType.sofort","text":"","title":"sofort"},{"location":"reference/enums/#djstripe.enums.SourceType.three_d_secure","text":"","title":"three_d_secure"},{"location":"reference/enums/#djstripe.enums.SourceType.wechat","text":"","title":"wechat"},{"location":"reference/enums/#djstripe.enums.SourceUsage","text":"","title":"SourceUsage"},{"location":"reference/enums/#djstripe.enums.SourceUsage.reusable","text":"","title":"reusable"},{"location":"reference/enums/#djstripe.enums.SourceUsage.single_use","text":"","title":"single_use"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus","text":"","title":"SubmitTypeStatus"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.auto","text":"","title":"auto"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.book","text":"","title":"book"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.donate","text":"","title":"donate"},{"location":"reference/enums/#djstripe.enums.SubmitTypeStatus.pay","text":"","title":"pay"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior","text":"","title":"SubscriptionScheduleEndBehavior"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior.cancel","text":"","title":"cancel"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleEndBehavior.release","text":"","title":"release"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus","text":"","title":"SubscriptionScheduleStatus"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.active","text":"","title":"active"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.completed","text":"","title":"completed"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.not_started","text":"","title":"not_started"},{"location":"reference/enums/#djstripe.enums.SubscriptionScheduleStatus.released","text":"","title":"released"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus","text":"","title":"SubscriptionStatus"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.active","text":"","title":"active"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.canceled","text":"","title":"canceled"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.incomplete","text":"","title":"incomplete"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.incomplete_expired","text":"","title":"incomplete_expired"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.past_due","text":"","title":"past_due"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.trialing","text":"","title":"trialing"},{"location":"reference/enums/#djstripe.enums.SubscriptionStatus.unpaid","text":"","title":"unpaid"},{"location":"reference/enums/#djstripe.enums.TaxIdType","text":"","title":"TaxIdType"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ae_trn","text":"","title":"ae_trn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.au_abn","text":"","title":"au_abn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.br_cnp","text":"","title":"br_cnp"},{"location":"reference/enums/#djstripe.enums.TaxIdType.br_cpf","text":"","title":"br_cpf"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ca_bn","text":"","title":"ca_bn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ca_qst","text":"","title":"ca_qst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ch_vat","text":"","title":"ch_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.cl_tin","text":"","title":"cl_tin"},{"location":"reference/enums/#djstripe.enums.TaxIdType.es_cif","text":"","title":"es_cif"},{"location":"reference/enums/#djstripe.enums.TaxIdType.eu_vat","text":"","title":"eu_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.hk_br","text":"","title":"hk_br"},{"location":"reference/enums/#djstripe.enums.TaxIdType.id_npw","text":"","title":"id_npw"},{"location":"reference/enums/#djstripe.enums.TaxIdType.in_gst","text":"","title":"in_gst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.jp_cn","text":"","title":"jp_cn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.jp_rn","text":"","title":"jp_rn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.kr_brn","text":"","title":"kr_brn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.li_uid","text":"","title":"li_uid"},{"location":"reference/enums/#djstripe.enums.TaxIdType.mx_rfc","text":"","title":"mx_rfc"},{"location":"reference/enums/#djstripe.enums.TaxIdType.my_frp","text":"","title":"my_frp"},{"location":"reference/enums/#djstripe.enums.TaxIdType.my_itn","text":"","title":"my_itn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.my_sst","text":"","title":"my_sst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.no_vat","text":"","title":"no_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.nz_gst","text":"","title":"nz_gst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ru_inn","text":"","title":"ru_inn"},{"location":"reference/enums/#djstripe.enums.TaxIdType.ru_kpp","text":"","title":"ru_kpp"},{"location":"reference/enums/#djstripe.enums.TaxIdType.sa_vat","text":"","title":"sa_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.sg_gst","text":"","title":"sg_gst"},{"location":"reference/enums/#djstripe.enums.TaxIdType.sg_uen","text":"","title":"sg_uen"},{"location":"reference/enums/#djstripe.enums.TaxIdType.th_vat","text":"","title":"th_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.tw_vat","text":"","title":"tw_vat"},{"location":"reference/enums/#djstripe.enums.TaxIdType.unknown","text":"","title":"unknown"},{"location":"reference/enums/#djstripe.enums.TaxIdType.us_ein","text":"","title":"us_ein"},{"location":"reference/enums/#djstripe.enums.TaxIdType.za_vat","text":"","title":"za_vat"},{"location":"reference/managers/","text":"Managers dj-stripe model managers Classes djstripe.managers.ChargeManager Manager used by models.Charge. Methods djstripe . managers . ChargeManager . during ( self , year , month ) Return Charges between a certain time range based on created . Source code in djstripe/managers.py def during ( self , year , month ): \"\"\"Return Charges between a certain time range based on `created`.\"\"\" return self . filter ( created__year = year , created__month = month ) djstripe . managers . ChargeManager . paid_totals_for ( self , year , month ) Return paid Charges during a certain year, month with total amount, fee and refunded annotated. Source code in djstripe/managers.py def paid_totals_for ( self , year , month ): \"\"\" Return paid Charges during a certain year, month with total amount, fee and refunded annotated. \"\"\" return ( self . during ( year , month ) . filter ( paid = True ) . aggregate ( total_amount = models . Sum ( \"amount\" ), total_refunded = models . Sum ( \"amount_refunded\" ), ) ) djstripe.managers.StripeModelManager Manager used in StripeModel. djstripe.managers.SubscriptionManager Manager used in models.Subscription. Methods djstripe . managers . SubscriptionManager . active ( self ) Return active Subscriptions. Source code in djstripe/managers.py def active ( self ): \"\"\"Return active Subscriptions.\"\"\" return self . filter ( status = \"active\" ) djstripe . managers . SubscriptionManager . active_plan_summary ( self ) Return active Subscriptions with plan counts annotated. Source code in djstripe/managers.py def active_plan_summary ( self ): \"\"\"Return active Subscriptions with plan counts annotated.\"\"\" return ( self . active () . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) djstripe . managers . SubscriptionManager . canceled ( self ) Return canceled Subscriptions. Source code in djstripe/managers.py def canceled ( self ): \"\"\"Return canceled Subscriptions.\"\"\" return self . filter ( status = \"canceled\" ) djstripe . managers . SubscriptionManager . canceled_during ( self , year , month ) Return Subscriptions canceled during a certain time range. Source code in djstripe/managers.py def canceled_during ( self , year , month ): \"\"\"Return Subscriptions canceled during a certain time range.\"\"\" return self . canceled () . filter ( canceled_at__year = year , canceled_at__month = month ) djstripe . managers . SubscriptionManager . canceled_plan_summary_for ( self , year , month ) Return Subscriptions canceled within a time range with plan counts annotated. Source code in djstripe/managers.py def canceled_plan_summary_for ( self , year , month ): \"\"\" Return Subscriptions canceled within a time range with plan counts annotated. \"\"\" return ( self . canceled_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) djstripe . managers . SubscriptionManager . churn ( self ) Return number of canceled Subscriptions divided by active Subscriptions. Source code in djstripe/managers.py def churn ( self ): \"\"\"Return number of canceled Subscriptions divided by active Subscriptions.\"\"\" canceled = self . canceled () . count () active = self . active () . count () return decimal . Decimal ( str ( canceled )) / decimal . Decimal ( str ( active )) djstripe . managers . SubscriptionManager . started_during ( self , year , month ) Return Subscriptions not in trial status between a certain time range. Source code in djstripe/managers.py def started_during ( self , year , month ): \"\"\"Return Subscriptions not in trial status between a certain time range.\"\"\" return self . exclude ( status = \"trialing\" ) . filter ( start_date__year = year , start_date__month = month ) djstripe . managers . SubscriptionManager . started_plan_summary_for ( self , year , month ) Return started_during Subscriptions with plan counts annotated. Source code in djstripe/managers.py def started_plan_summary_for ( self , year , month ): \"\"\"Return started_during Subscriptions with plan counts annotated.\"\"\" return ( self . started_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) ) djstripe.managers.TransferManager Manager used by models.Transfer. Methods djstripe . managers . TransferManager . during ( self , year , month ) Return Transfers between a certain time range. Source code in djstripe/managers.py def during ( self , year , month ): \"\"\"Return Transfers between a certain time range.\"\"\" return self . filter ( created__year = year , created__month = month ) djstripe . managers . TransferManager . paid_totals_for ( self , year , month ) Return paid Transfers during a certain year, month with total amounts annotated. Source code in djstripe/managers.py def paid_totals_for ( self , year , month ): \"\"\" Return paid Transfers during a certain year, month with total amounts annotated. \"\"\" return self . during ( year , month ) . aggregate ( total_amount = models . Sum ( \"amount\" ))","title":"Managers"},{"location":"reference/managers/#managers","text":"dj-stripe model managers","title":"Managers"},{"location":"reference/managers/#djstripe.managers-classes","text":"","title":"Classes"},{"location":"reference/managers/#djstripe.managers.ChargeManager","text":"Manager used by models.Charge.","title":"ChargeManager"},{"location":"reference/managers/#djstripe.managers.ChargeManager-methods","text":"","title":"Methods"},{"location":"reference/managers/#djstripe.managers.ChargeManager.during","text":"Return Charges between a certain time range based on created . Source code in djstripe/managers.py def during ( self , year , month ): \"\"\"Return Charges between a certain time range based on `created`.\"\"\" return self . filter ( created__year = year , created__month = month )","title":"during()"},{"location":"reference/managers/#djstripe.managers.ChargeManager.paid_totals_for","text":"Return paid Charges during a certain year, month with total amount, fee and refunded annotated. Source code in djstripe/managers.py def paid_totals_for ( self , year , month ): \"\"\" Return paid Charges during a certain year, month with total amount, fee and refunded annotated. \"\"\" return ( self . during ( year , month ) . filter ( paid = True ) . aggregate ( total_amount = models . Sum ( \"amount\" ), total_refunded = models . Sum ( \"amount_refunded\" ), ) )","title":"paid_totals_for()"},{"location":"reference/managers/#djstripe.managers.StripeModelManager","text":"Manager used in StripeModel.","title":"StripeModelManager"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager","text":"Manager used in models.Subscription.","title":"SubscriptionManager"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager-methods","text":"","title":"Methods"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.active","text":"Return active Subscriptions. Source code in djstripe/managers.py def active ( self ): \"\"\"Return active Subscriptions.\"\"\" return self . filter ( status = \"active\" )","title":"active()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.active_plan_summary","text":"Return active Subscriptions with plan counts annotated. Source code in djstripe/managers.py def active_plan_summary ( self ): \"\"\"Return active Subscriptions with plan counts annotated.\"\"\" return ( self . active () . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) )","title":"active_plan_summary()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.canceled","text":"Return canceled Subscriptions. Source code in djstripe/managers.py def canceled ( self ): \"\"\"Return canceled Subscriptions.\"\"\" return self . filter ( status = \"canceled\" )","title":"canceled()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.canceled_during","text":"Return Subscriptions canceled during a certain time range. Source code in djstripe/managers.py def canceled_during ( self , year , month ): \"\"\"Return Subscriptions canceled during a certain time range.\"\"\" return self . canceled () . filter ( canceled_at__year = year , canceled_at__month = month )","title":"canceled_during()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.canceled_plan_summary_for","text":"Return Subscriptions canceled within a time range with plan counts annotated. Source code in djstripe/managers.py def canceled_plan_summary_for ( self , year , month ): \"\"\" Return Subscriptions canceled within a time range with plan counts annotated. \"\"\" return ( self . canceled_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) )","title":"canceled_plan_summary_for()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.churn","text":"Return number of canceled Subscriptions divided by active Subscriptions. Source code in djstripe/managers.py def churn ( self ): \"\"\"Return number of canceled Subscriptions divided by active Subscriptions.\"\"\" canceled = self . canceled () . count () active = self . active () . count () return decimal . Decimal ( str ( canceled )) / decimal . Decimal ( str ( active ))","title":"churn()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.started_during","text":"Return Subscriptions not in trial status between a certain time range. Source code in djstripe/managers.py def started_during ( self , year , month ): \"\"\"Return Subscriptions not in trial status between a certain time range.\"\"\" return self . exclude ( status = \"trialing\" ) . filter ( start_date__year = year , start_date__month = month )","title":"started_during()"},{"location":"reference/managers/#djstripe.managers.SubscriptionManager.started_plan_summary_for","text":"Return started_during Subscriptions with plan counts annotated. Source code in djstripe/managers.py def started_plan_summary_for ( self , year , month ): \"\"\"Return started_during Subscriptions with plan counts annotated.\"\"\" return ( self . started_during ( year , month ) . values ( \"plan\" ) . order_by () . annotate ( count = models . Count ( \"plan\" )) )","title":"started_plan_summary_for()"},{"location":"reference/managers/#djstripe.managers.TransferManager","text":"Manager used by models.Transfer.","title":"TransferManager"},{"location":"reference/managers/#djstripe.managers.TransferManager-methods","text":"","title":"Methods"},{"location":"reference/managers/#djstripe.managers.TransferManager.during","text":"Return Transfers between a certain time range. Source code in djstripe/managers.py def during ( self , year , month ): \"\"\"Return Transfers between a certain time range.\"\"\" return self . filter ( created__year = year , created__month = month )","title":"during()"},{"location":"reference/managers/#djstripe.managers.TransferManager.paid_totals_for","text":"Return paid Transfers during a certain year, month with total amounts annotated. Source code in djstripe/managers.py def paid_totals_for ( self , year , month ): \"\"\" Return paid Transfers during a certain year, month with total amounts annotated. \"\"\" return self . during ( year , month ) . aggregate ( total_amount = models . Sum ( \"amount\" ))","title":"paid_totals_for()"},{"location":"reference/middleware/","text":"Middleware SubscriptionPaymentMiddleware Used to redirect users from subcription-locked request destinations. Rules: \"(app_name)\" means everything from this app is exempt \"[namespace]\" means everything with this name is exempt \"namespace:name\" means this namespaced URL is exempt \"name\" means this URL is exempt The entire djstripe namespace is exempt If settings.DEBUG is True, then django-debug-toolbar is exempt A 'fn:' prefix means the rest of the URL is fnmatch'd. Examples: DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS = ( \"[blogs]\" , # Anything in the blogs namespace \"products:detail\" , # A ProductDetail view you want shown to non-payers \"home\" , # Site homepage \"fn:/accounts*\" , # anything in the accounts/ URL path ) Methods djstripe . middleware . SubscriptionPaymentMiddleware . check_subscription ( self , request ) Redirect to the subscribe page if the user lacks an active subscription. Source code in djstripe/middleware.py def check_subscription ( self , request ): \"\"\"Redirect to the subscribe page if the user lacks an active subscription.\"\"\" from .settings import SUBSCRIPTION_REDIRECT , subscriber_request_callback subscriber = subscriber_request_callback ( request ) if not subscriber_has_active_subscription ( subscriber ): if not SUBSCRIPTION_REDIRECT : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIPTION_REDIRECT is not set.\" ) return redirect ( SUBSCRIPTION_REDIRECT ) djstripe . middleware . SubscriptionPaymentMiddleware . is_matching_rule ( self , request ) Check according to the rules defined in the class docstring. Source code in djstripe/middleware.py def is_matching_rule ( self , request ): \"\"\"Check according to the rules defined in the class docstring.\"\"\" # First, if in DEBUG mode and with django-debug-toolbar, we skip # this entire process. from .settings import SUBSCRIPTION_REQUIRED_EXCEPTION_URLS if settings . DEBUG and request . path . startswith ( \"/__debug__\" ): return True exempt_urls = list ( SUBSCRIPTION_REQUIRED_EXCEPTION_URLS ) + [ \"[djstripe]\" ] # Second we check against matches match = resolve ( request . path , getattr ( request , \"urlconf\" , settings . ROOT_URLCONF ) ) if \"( {0} )\" . format ( match . app_name ) in exempt_urls : return True if \"[ {0} ]\" . format ( match . namespace ) in exempt_urls : return True if \" {0} : {1} \" . format ( match . namespace , match . url_name ) in exempt_urls : return True if match . url_name in exempt_urls : return True # Third, we check wildcards: for exempt in [ x for x in exempt_urls if x . startswith ( \"fn:\" )]: exempt = exempt . replace ( \"fn:\" , \"\" ) if fnmatch . fnmatch ( request . path , exempt ): return True return False djstripe . middleware . SubscriptionPaymentMiddleware . process_request ( self , request ) Check the subscriber's subscription status. Returns early if request does not outlined in this middleware's docstring. Source code in djstripe/middleware.py def process_request ( self , request ): \"\"\"Check the subscriber's subscription status. Returns early if request does not outlined in this middleware's docstring. \"\"\" if self . is_matching_rule ( request ): return return self . check_subscription ( request )","title":"Middleware"},{"location":"reference/middleware/#middleware","text":"","title":"Middleware"},{"location":"reference/middleware/#subscriptionpaymentmiddleware","text":"Used to redirect users from subcription-locked request destinations. Rules: \"(app_name)\" means everything from this app is exempt \"[namespace]\" means everything with this name is exempt \"namespace:name\" means this namespaced URL is exempt \"name\" means this URL is exempt The entire djstripe namespace is exempt If settings.DEBUG is True, then django-debug-toolbar is exempt A 'fn:' prefix means the rest of the URL is fnmatch'd. Examples: DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS = ( \"[blogs]\" , # Anything in the blogs namespace \"products:detail\" , # A ProductDetail view you want shown to non-payers \"home\" , # Site homepage \"fn:/accounts*\" , # anything in the accounts/ URL path )","title":"SubscriptionPaymentMiddleware"},{"location":"reference/middleware/#djstripe.middleware.SubscriptionPaymentMiddleware-methods","text":"","title":"Methods"},{"location":"reference/middleware/#djstripe.middleware.SubscriptionPaymentMiddleware.check_subscription","text":"Redirect to the subscribe page if the user lacks an active subscription. Source code in djstripe/middleware.py def check_subscription ( self , request ): \"\"\"Redirect to the subscribe page if the user lacks an active subscription.\"\"\" from .settings import SUBSCRIPTION_REDIRECT , subscriber_request_callback subscriber = subscriber_request_callback ( request ) if not subscriber_has_active_subscription ( subscriber ): if not SUBSCRIPTION_REDIRECT : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIPTION_REDIRECT is not set.\" ) return redirect ( SUBSCRIPTION_REDIRECT )","title":"check_subscription()"},{"location":"reference/middleware/#djstripe.middleware.SubscriptionPaymentMiddleware.is_matching_rule","text":"Check according to the rules defined in the class docstring. Source code in djstripe/middleware.py def is_matching_rule ( self , request ): \"\"\"Check according to the rules defined in the class docstring.\"\"\" # First, if in DEBUG mode and with django-debug-toolbar, we skip # this entire process. from .settings import SUBSCRIPTION_REQUIRED_EXCEPTION_URLS if settings . DEBUG and request . path . startswith ( \"/__debug__\" ): return True exempt_urls = list ( SUBSCRIPTION_REQUIRED_EXCEPTION_URLS ) + [ \"[djstripe]\" ] # Second we check against matches match = resolve ( request . path , getattr ( request , \"urlconf\" , settings . ROOT_URLCONF ) ) if \"( {0} )\" . format ( match . app_name ) in exempt_urls : return True if \"[ {0} ]\" . format ( match . namespace ) in exempt_urls : return True if \" {0} : {1} \" . format ( match . namespace , match . url_name ) in exempt_urls : return True if match . url_name in exempt_urls : return True # Third, we check wildcards: for exempt in [ x for x in exempt_urls if x . startswith ( \"fn:\" )]: exempt = exempt . replace ( \"fn:\" , \"\" ) if fnmatch . fnmatch ( request . path , exempt ): return True return False","title":"is_matching_rule()"},{"location":"reference/middleware/#djstripe.middleware.SubscriptionPaymentMiddleware.process_request","text":"Check the subscriber's subscription status. Returns early if request does not outlined in this middleware's docstring. Source code in djstripe/middleware.py def process_request ( self , request ): \"\"\"Check the subscriber's subscription status. Returns early if request does not outlined in this middleware's docstring. \"\"\" if self . is_matching_rule ( request ): return return self . check_subscription ( request )","title":"process_request()"},{"location":"reference/models/","text":"Models Models hold the bulk of the functionality included in the dj-stripe package. Each model is tied closely to its corresponding object in the stripe dashboard. Fields that are not implemented for each model have a short reason behind the decision in the docstring for each model. Core Resources Classes djstripe.models.core.BalanceTransaction A single transaction that updates the Stripe balance. Stripe documentation: https://stripe.com/docs/api#balance_transaction_object djstripe . models . core . BalanceTransaction . amount djstripe . models . core . BalanceTransaction . available_on djstripe . models . core . BalanceTransaction . currency djstripe . models . core . BalanceTransaction . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . BalanceTransaction . exchange_rate djstripe . models . core . BalanceTransaction . fee djstripe . models . core . BalanceTransaction . fee_details djstripe . models . core . BalanceTransaction . net djstripe . models . core . BalanceTransaction . reporting_category djstripe . models . core . BalanceTransaction . source djstripe . models . core . BalanceTransaction . status djstripe . models . core . BalanceTransaction . type djstripe.models.core.BalanceTransaction.DoesNotExist djstripe.models.core.BalanceTransaction.MultipleObjectsReturned djstripe.models.core.BalanceTransaction.stripe_class Methods djstripe . models . core . BalanceTransaction . get_next_by_available_on ( self , * , field =< djstripe . fields . StripeDateTimeField : available_on > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_available_on ( self , * , field =< djstripe . fields . StripeDateTimeField : available_on > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_reporting_category_display ( self , * , field =< djstripe . fields . StripeEnumField : reporting_category > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_source_class ( self ) Source code in djstripe/models/core.py def get_source_class ( self ): return apps . get_model ( \"djstripe\" , self . type ) djstripe . models . core . BalanceTransaction . get_source_instance ( self ) Source code in djstripe/models/core.py def get_source_instance ( self ): return self . get_source_class () . objects . get ( id = self . source ) djstripe . models . core . BalanceTransaction . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . get_source_instance () . get_stripe_dashboard_url () djstripe . models . core . BalanceTransaction . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Charge To charge a credit or a debit card, you create a charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique random ID. Stripe documentation: https://stripe.com/docs/api/python#charges djstripe . models . core . Charge . account property readonly djstripe . models . core . Charge . amount djstripe . models . core . Charge . amount_captured djstripe . models . core . Charge . amount_refunded djstripe . models . core . Charge . application djstripe . models . core . Charge . application_fee djstripe . models . core . Charge . application_fee_amount djstripe . models . core . Charge . balance_transaction djstripe . models . core . Charge . billing_details djstripe . models . core . Charge . calculated_statement_descriptor djstripe . models . core . Charge . captured djstripe . models . core . Charge . currency djstripe . models . core . Charge . customer djstripe . models . core . Charge . dispute djstripe . models . core . Charge . disputed djstripe . models . core . Charge . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Charge . expand_fields : List [ str ] djstripe . models . core . Charge . failure_code djstripe . models . core . Charge . failure_message djstripe . models . core . Charge . fee property readonly djstripe . models . core . Charge . fraud_details djstripe . models . core . Charge . fraudulent : bool property readonly djstripe . models . core . Charge . human_readable_amount : str property readonly djstripe . models . core . Charge . human_readable_status : str property readonly djstripe . models . core . Charge . invoice djstripe . models . core . Charge . objects djstripe . models . core . Charge . on_behalf_of djstripe . models . core . Charge . outcome djstripe . models . core . Charge . paid djstripe . models . core . Charge . payment_intent djstripe . models . core . Charge . payment_method djstripe . models . core . Charge . payment_method_details djstripe . models . core . Charge . receipt_email djstripe . models . core . Charge . receipt_number djstripe . models . core . Charge . receipt_url djstripe . models . core . Charge . refunded djstripe . models . core . Charge . shipping djstripe . models . core . Charge . source djstripe . models . core . Charge . source_transfer djstripe . models . core . Charge . statement_descriptor djstripe . models . core . Charge . statement_descriptor_suffix djstripe . models . core . Charge . status djstripe . models . core . Charge . stripe_dashboard_item_name djstripe . models . core . Charge . transfer djstripe . models . core . Charge . transfer_data djstripe . models . core . Charge . transfer_group djstripe.models.core.Charge.DoesNotExist djstripe.models.core.Charge.MultipleObjectsReturned djstripe.models.core.Charge.stripe_class djstripe . models . core . Charge . stripe_class . OBJECT_NAME djstripe . models . core . Charge . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . close_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute/close\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute djstripe . models . core . Charge . stripe_class . mark_as_fraudulent ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_fraudulent ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"fraudulent\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . mark_as_safe ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_safe ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"safe\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def refund ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/refund\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . update_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def update_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute Methods djstripe . models . core . Charge . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): amount = self . human_readable_amount status = self . human_readable_status if not status : return amount return \" {amount} ( {status} )\" . format ( amount = amount , status = status ) djstripe . models . core . Charge . capture ( self , ** kwargs ) Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge Source code in djstripe/models/core.py def capture ( self , ** kwargs ) -> \"Charge\" : \"\"\" Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge \"\"\" captured_charge = self . api_retrieve () . capture ( ** kwargs ) return self . __class__ . sync_from_stripe_data ( captured_charge ) djstripe . models . core . Charge . get_failure_code_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_code > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . refund ( self , amount = None , reason = None ) Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are duplicate , fraudulent , and requested_by_customer . Specifying fraudulent as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. Source code in djstripe/models/core.py def refund ( self , amount : Decimal = None , reason : str = None ) -> \"Charge\" : \"\"\" Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are ``duplicate``, ``fraudulent``, and ``requested_by_customer``. Specifying ``fraudulent`` as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. \"\"\" charge_obj = self . api_retrieve () . refund ( amount = self . _calculate_refund_amount ( amount = amount ), reason = reason ) return self . __class__ . sync_from_stripe_data ( charge_obj ) djstripe.models.core.Customer Customer objects allow you to perform recurring charges and track multiple charges that are associated with the same customer. Stripe documentation: https://stripe.com/docs/api/python#customers Attributes djstripe . models . core . Customer . active_subscriptions property readonly Returns active subscriptions (subscriptions with an active status that end in the future). djstripe . models . core . Customer . address djstripe . models . core . Customer . balance djstripe . models . core . Customer . business_vat_id : str property readonly djstripe . models . core . Customer . coupon djstripe . models . core . Customer . coupon_end djstripe . models . core . Customer . coupon_start djstripe . models . core . Customer . credits property readonly The customer is considered to have credits if their balance is below 0. djstripe . models . core . Customer . currency djstripe . models . core . Customer . customer_payment_methods property readonly An iterable of all of the customer's payment methods (sources, then legacy cards) djstripe . models . core . Customer . date_purged djstripe . models . core . Customer . default_payment_method djstripe . models . core . Customer . default_source djstripe . models . core . Customer . delinquent djstripe . models . core . Customer . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Customer . email djstripe . models . core . Customer . expand_fields : List [ str ] djstripe . models . core . Customer . invoice_prefix djstripe . models . core . Customer . invoice_settings djstripe . models . core . Customer . name djstripe . models . core . Customer . pending_charges property readonly The customer is considered to have pending charges if their balance is above 0. djstripe . models . core . Customer . phone djstripe . models . core . Customer . preferred_locales djstripe . models . core . Customer . shipping djstripe . models . core . Customer . stripe_dashboard_item_name djstripe . models . core . Customer . subscriber djstripe . models . core . Customer . subscription property readonly Shortcut to get this customer's subscription. :returns: None if the customer has no subscriptions, the subscription if the customer has a subscription. :raises MultipleSubscriptionException: Raised if the customer has multiple subscriptions. In this case, use Customer.subscriptions instead. djstripe . models . core . Customer . tax_exempt djstripe . models . core . Customer . valid_subscriptions property readonly Returns this customer's valid subscriptions (subscriptions that aren't canceled or incomplete_expired). djstripe.models.core.Customer.DoesNotExist djstripe.models.core.Customer.MultipleObjectsReturned djstripe.models.core.Customer.stripe_class djstripe . models . core . Customer . stripe_class . OBJECT_NAME djstripe . models . core . Customer . stripe_class . balance_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . balance_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . create_balance_transaction ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_source ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_tax_id ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/core.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True ) djstripe . models . core . Customer . stripe_class . delete_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_balance_transactions ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_payment_methods ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def list_payment_methods ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/payment_methods\" headers = util . populate_headers ( idempotency_key ) resp = self . request ( \"get\" , url , params , headers ) stripe_object = util . convert_to_stripe_object ( resp ) stripe_object . _retrieve_params = params return stripe_object djstripe . models . core . Customer . stripe_class . list_sources ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_tax_ids ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . sources_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . sources_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . tax_ids_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . tax_ids_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . core . Customer . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): if self . subscriber : return str ( self . subscriber ) return self . name or self . description or self . id djstripe . models . core . Customer . add_card ( self , source , set_default = True ) Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean Source code in djstripe/models/core.py def add_card ( self , source , set_default = True ): \"\"\" Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean \"\"\" from .payment_methods import DjstripePaymentMethod stripe_customer = self . api_retrieve () new_stripe_payment_method = stripe_customer . sources . create ( source = source ) if set_default : stripe_customer . default_source = new_stripe_payment_method [ \"id\" ] stripe_customer . save () new_payment_method = DjstripePaymentMethod . from_stripe_object ( new_stripe_payment_method ) # Change the default source if set_default : self . default_source = new_payment_method self . save () return new_payment_method . resolve () djstripe . models . core . Customer . add_coupon ( self , coupon , idempotency_key = None ) Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. Source code in djstripe/models/core.py def add_coupon ( self , coupon , idempotency_key = None ): \"\"\" Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. \"\"\" if isinstance ( coupon , StripeModel ): coupon = coupon . id stripe_customer = self . api_retrieve () stripe_customer [ \"coupon\" ] = coupon stripe_customer . save ( idempotency_key = idempotency_key ) return self . __class__ . sync_from_stripe_data ( stripe_customer ) djstripe . models . core . Customer . add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None ) Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. Use this when adding invoice items in response to an invoice.created webhook. You cannot add an invoice item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using Customer.add_invoice_item() instead of .. Customer.add_invoice_item() , invoice and subscriptions .. can only be strings Source code in djstripe/models/core.py def add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None , ): \"\"\" Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming \\ scheduled invoice. \\ Use this when adding invoice items in response to an \\ ``invoice.created`` webhook. You cannot add an invoice \\ item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming \\ scheduled invoice. When set, scheduled invoices for subscriptions other \\ than the specified subscription will ignore the invoice item. \\ Use this when you want to express that an invoice item has been accrued \\ within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using ``Customer.add_invoice_item()`` instead of .. ``Customer.add_invoice_item()``, ``invoice`` and ``subscriptions`` .. can only be strings \"\"\" from .billing import InvoiceItem if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Invoice to id if invoice is not None and isinstance ( invoice , StripeModel ): invoice = invoice . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id stripe_invoiceitem = InvoiceItem . _api_create ( amount = int ( amount * 100 ), # Convert dollars into cents currency = currency , customer = self . id , description = description , discountable = discountable , invoice = invoice , metadata = metadata , subscription = subscription , ) return InvoiceItem . sync_from_stripe_data ( stripe_invoiceitem ) djstripe . models . core . Customer . add_payment_method ( self , payment_method , set_default = True ) Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod Source code in djstripe/models/core.py def add_payment_method ( self , payment_method , set_default = True ): \"\"\" Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod \"\"\" from .payment_methods import PaymentMethod stripe_customer = self . api_retrieve () payment_method = PaymentMethod . attach ( payment_method , stripe_customer ) if set_default : stripe_customer [ \"invoice_settings\" ][ \"default_payment_method\" ] = payment_method . id stripe_customer . save () # Refresh self from the stripe customer, this should have two effects: # 1) sets self.default_payment_method (we rely on logic in # Customer._manipulate_stripe_object_hook to do this) # 2) updates self.invoice_settings.default_payment_methods self . sync_from_stripe_data ( stripe_customer ) self . refresh_from_db () return payment_method djstripe . models . core . Customer . can_charge ( self ) Determines if this customer is able to be charged. Source code in djstripe/models/core.py def can_charge ( self ): \"\"\"Determines if this customer is able to be charged.\"\"\" return ( self . has_valid_source () or self . default_payment_method is not None ) and self . date_purged is None djstripe . models . core . Customer . charge ( self , amount , * , application_fee = None , source = None , ** kwargs ) Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source Source code in djstripe/models/core.py def charge ( self , amount : Decimal , * , application_fee : Decimal = None , source : Union [ str , StripeModel ] = None , ** kwargs ) -> Charge : \"\"\" Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source \"\"\" if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Source to id if source and isinstance ( source , StripeModel ): source = source . id stripe_charge = Charge . _api_create ( customer = self . id , amount = int ( amount * 100 ), # Convert dollars into cents application_fee = int ( application_fee * 100 ) if application_fee else None , # Convert dollars into cents source = source , ** kwargs ) return Charge . sync_from_stripe_data ( stripe_charge ) djstripe . models . core . Customer . create ( subscriber , idempotency_key = None , stripe_account = None ) classmethod Source code in djstripe/models/core.py @classmethod def create ( cls , subscriber , idempotency_key = None , stripe_account = None ): metadata = {} subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key not in ( \"\" , None ): metadata [ subscriber_key ] = subscriber . pk stripe_customer = cls . _api_create ( email = subscriber . email , idempotency_key = idempotency_key , metadata = metadata , stripe_account = stripe_account , ) customer , created = Customer . objects . get_or_create ( id = stripe_customer [ \"id\" ], defaults = { \"subscriber\" : subscriber , \"livemode\" : stripe_customer [ \"livemode\" ], \"balance\" : stripe_customer . get ( \"balance\" , 0 ), \"delinquent\" : stripe_customer . get ( \"delinquent\" , False ), }, ) return customer djstripe . models . core . Customer . delete ( self , using = None , keep_parents = False ) Overriding the delete method to keep the customer in the records. All identifying information is removed via the purge() method. The only way to delete a customer is to use SQL. Source code in djstripe/models/core.py def delete ( self , using = None , keep_parents = False ): \"\"\" Overriding the delete method to keep the customer in the records. All identifying information is removed via the purge() method. The only way to delete a customer is to use SQL. \"\"\" self . purge () djstripe . models . core . Customer . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_or_create ( subscriber , livemode = False , stripe_account = None ) classmethod Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None , ): \"\"\" Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool \"\"\" try : return Customer . objects . get ( subscriber = subscriber , livemode = livemode ), False except Customer . DoesNotExist : action = \"create: {} \" . format ( subscriber . pk ) idempotency_key = djstripe_settings . get_idempotency_key ( \"customer\" , action , livemode ) return ( cls . create ( subscriber , idempotency_key = idempotency_key , stripe_account = stripe_account , ), True , ) djstripe . models . core . Customer . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : tax_exempt > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . has_active_subscription ( self , plan = None ) Checks to see if this customer has an active subscription to the given plan. :param plan: The plan for which to check for an active subscription. If plan is None and there exists only one active subscription, this method will check if that subscription is valid. Calling this method with no plan and multiple valid subscriptions for this customer will throw an exception. :type plan: Plan or string (plan ID) :returns: True if there exists an active subscription, False otherwise. :throws: TypeError if plan is None and more than one active subscription exists for this customer. Source code in djstripe/models/core.py def has_active_subscription ( self , plan = None ): \"\"\" Checks to see if this customer has an active subscription to the given plan. :param plan: The plan for which to check for an active subscription. If plan is None and there exists only one active subscription, this method will check if that subscription is valid. Calling this method with no plan and multiple valid subscriptions for this customer will throw an exception. :type plan: Plan or string (plan ID) :returns: True if there exists an active subscription, False otherwise. :throws: TypeError if ``plan`` is None and more than one active subscription exists for this customer. \"\"\" warnings . warn ( \"has_active_subscription is deprecated in favor of `is_subscribed_to` \" \"and will be removed in a future release.\" , DeprecationWarning , ) if plan is None : valid_subscriptions = self . _get_valid_subscriptions () if len ( valid_subscriptions ) == 0 : return False elif len ( valid_subscriptions ) == 1 : return True else : raise TypeError ( \"plan cannot be None if more than one valid subscription \" \"exists for this customer.\" ) else : # Convert Plan to id if isinstance ( plan , StripeModel ): plan = plan . id return any ( [ subscription . is_valid () for subscription in self . subscriptions . filter ( plan__id = plan ) ] ) djstripe . models . core . Customer . has_any_active_subscription ( self ) Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def has_any_active_subscription ( self ): \"\"\" Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. \"\"\" return len ( self . _get_valid_subscriptions ()) != 0 djstripe . models . core . Customer . has_valid_source ( self ) Check whether the customer has a valid payment source. Source code in djstripe/models/core.py def has_valid_source ( self ): \"\"\"Check whether the customer has a valid payment source.\"\"\" return self . default_source is not None djstripe . models . core . Customer . is_subscribed_to ( self , product ) Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def is_subscribed_to ( self , product : Union [ Product , str ]) -> bool : \"\"\" Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. \"\"\" if isinstance ( product , StripeModel ): product = product . id for subscription in self . _get_valid_subscriptions (): for item in subscription . items . all (): if item . price and item . price . product . id == product : return True return False djstripe . models . core . Customer . purge ( self ) Source code in djstripe/models/core.py def purge ( self ): try : self . _api_delete () except InvalidRequestError as exc : if \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer was already # deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise if self . subscriber : # Delete the idempotency key used by Customer.create() # So re-creating a customer for this subscriber before the key expires # doesn't return the older Customer data idempotency_key_action = \"customer:create: {} \" . format ( self . subscriber . pk ) IdempotencyKey . objects . filter ( action = idempotency_key_action ) . delete () self . subscriber = None # Remove sources self . default_source = None for source in self . legacy_cards . all (): source . remove () for source in self . sources . all (): source . detach () self . date_purged = timezone . now () self . save () djstripe . models . core . Customer . retry_unpaid_invoices ( self ) Attempt to retry collecting payment on the customer's unpaid invoices. Source code in djstripe/models/core.py def retry_unpaid_invoices ( self ): \"\"\"Attempt to retry collecting payment on the customer's unpaid invoices.\"\"\" self . _sync_invoices () for invoice in self . invoices . filter ( auto_advance = True ) . exclude ( status = \"paid\" ): try : invoice . retry () # Always retry unpaid invoices except InvalidRequestError as exc : if str ( exc ) != \"Invoice is already paid\" : raise djstripe . models . core . Customer . send_invoice ( self ) Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). Source code in djstripe/models/core.py def send_invoice ( self ): \"\"\" Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). \"\"\" from .billing import Invoice try : invoice = Invoice . _api_create ( customer = self . id ) invoice . pay () return True except InvalidRequestError : # TODO: Check this for a more # specific error message. return False # There was nothing to invoice djstripe . models . core . Customer . subscribe ( self , price = None , plan = None , charge_immediately = True , ** kwargs ) Subscribes this customer to a price. NOTE: Only one item is supported at the moment. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) :param charge_immediately: Whether or not to charge for the subscription upon creation. If False, an invoice will be created at the end of this period. :type charge_immediately: boolean .. Notes: .. charge_immediately is only available on Customer.subscribe() .. if you're using Customer.subscribe() .. instead of Customer.subscribe() , plan can only be a string Source code in djstripe/models/core.py def subscribe ( self , price = None , plan = None , charge_immediately = True , ** kwargs ): \"\"\" Subscribes this customer to a price. NOTE: Only one item is supported at the moment. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) :param charge_immediately: Whether or not to charge for the subscription upon creation. If False, an invoice will be created at the end of this period. :type charge_immediately: boolean .. Notes: .. ``charge_immediately`` is only available on ``Customer.subscribe()`` .. if you're using ``Customer.subscribe()`` .. instead of ``Customer.subscribe()``, ``plan`` can only be a string \"\"\" from .billing import Subscription if price and plan : raise TypeError ( \"price and plan arguments cannot both be defined.\" ) price = price or plan if not price : raise TypeError ( \"you need to set either price or plan\" ) # Convert Price to id if isinstance ( price , StripeModel ): price = price . id stripe_subscription = Subscription . _api_create ( items = [{ \"price\" : price }], customer = self . id , ** kwargs ) if charge_immediately : self . send_invoice () return Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe . models . core . Customer . upcoming_invoice ( self , ** kwargs ) Gets the upcoming preview invoice (singular) for this customer. See Invoice.upcoming() <#djstripe.Invoice.upcoming> __. The customer argument to the upcoming() call is automatically set by this method. Source code in djstripe/models/core.py def upcoming_invoice ( self , ** kwargs ): \"\"\"Gets the upcoming preview invoice (singular) for this customer. See `Invoice.upcoming() <#djstripe.Invoice.upcoming>`__. The ``customer`` argument to the ``upcoming()`` call is automatically set by this method. \"\"\" from .billing import Invoice kwargs [ \"customer\" ] = self return Invoice . upcoming ( ** kwargs ) djstripe.models.core.Dispute Stripe documentation: https://stripe.com/docs/api#disputes djstripe . models . core . Dispute . amount djstripe . models . core . Dispute . currency djstripe . models . core . Dispute . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Dispute . evidence djstripe . models . core . Dispute . evidence_details djstripe . models . core . Dispute . is_charge_refundable djstripe . models . core . Dispute . reason djstripe . models . core . Dispute . status djstripe . models . core . Dispute . stripe_dashboard_item_name djstripe.models.core.Dispute.DoesNotExist djstripe.models.core.Dispute.MultipleObjectsReturned djstripe.models.core.Dispute.stripe_class djstripe . models . core . Dispute . stripe_class . OBJECT_NAME djstripe . models . core . Dispute . stripe_class . close ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/close\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Dispute . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Event Events are Stripe's way of letting you know when something interesting happens in your account. When an interesting event occurs, a new Event object is created and POSTed to the configured webhook URL if the Event type matches. Stripe documentation: https://stripe.com/docs/api/events djstripe . models . core . Event . api_version djstripe . models . core . Event . customer property readonly djstripe . models . core . Event . data djstripe . models . core . Event . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Event . idempotency_key djstripe . models . core . Event . request_id djstripe . models . core . Event . stripe_dashboard_item_name djstripe . models . core . Event . type djstripe.models.core.Event.DoesNotExist djstripe.models.core.Event.MultipleObjectsReturned djstripe.models.core.Event.stripe_class Methods djstripe . models . core . Event . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . invoke_webhook_handlers ( self ) Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the djstripe.event_handlers module (or handlers registered in djstripe plugins or contrib packages). Source code in djstripe/models/core.py def invoke_webhook_handlers ( self ): \"\"\" Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the ``djstripe.event_handlers`` module (or handlers registered in djstripe plugins or contrib packages). \"\"\" webhooks . call_handlers ( event = self ) signal = WEBHOOK_SIGNALS . get ( self . type ) if signal : return signal . send ( sender = Event , event = self ) djstripe . models . core . Event . process ( data ) classmethod Source code in djstripe/models/core.py @classmethod def process ( cls , data ): qs = cls . objects . filter ( id = data [ \"id\" ]) if qs . exists (): return qs . first () # Rollback any DB operations in the case of failure so # we will retry creating and processing the event the # next time the webhook fires. with transaction . atomic (): ret = cls . _create_from_stripe_object ( data ) ret . invoke_webhook_handlers () return ret djstripe . models . core . Event . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/core.py def str_parts ( self ): return [ \"type= {type} \" . format ( type = self . type )] + super () . str_parts () djstripe.models.core.File Stripe documentation: https://stripe.com/docs/api#file_uploads djstripe . models . core . File . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . File . filename djstripe . models . core . File . purpose djstripe . models . core . File . size djstripe . models . core . File . type djstripe . models . core . File . url djstripe.models.core.File.DoesNotExist djstripe.models.core.File.MultipleObjectsReturned djstripe.models.core.File.stripe_class djstripe . models . core . File . stripe_class . OBJECT_NAME djstripe . models . core . File . stripe_class . OBJECT_NAME_ALT djstripe . models . core . File . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . File . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account ) Methods djstripe . models . core . File . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_purpose_display ( self , * , field =< djstripe . fields . StripeEnumField : purpose > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" ) djstripe.models.core.FileUpload Stripe documentation: https://stripe.com/docs/api#file_uploads djstripe . models . core . FileUpload . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . FileUpload . filename djstripe . models . core . FileUpload . purpose djstripe . models . core . FileUpload . size djstripe . models . core . FileUpload . type djstripe . models . core . FileUpload . url djstripe.models.core.FileUpload.DoesNotExist djstripe.models.core.FileUpload.MultipleObjectsReturned djstripe.models.core.FileUpload.stripe_class djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME_ALT djstripe . models . core . FileUpload . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . FileUpload . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account ) Methods djstripe . models . core . FileUpload . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_purpose_display ( self , * , field =< djstripe . fields . StripeEnumField : purpose > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" ) djstripe.models.core.PaymentIntent Stripe documentation: https://stripe.com/docs/api#payment_intents djstripe . models . core . PaymentIntent . amount djstripe . models . core . PaymentIntent . amount_capturable djstripe . models . core . PaymentIntent . amount_received djstripe . models . core . PaymentIntent . canceled_at djstripe . models . core . PaymentIntent . cancellation_reason djstripe . models . core . PaymentIntent . capture_method djstripe . models . core . PaymentIntent . client_secret djstripe . models . core . PaymentIntent . confirmation_method djstripe . models . core . PaymentIntent . currency djstripe . models . core . PaymentIntent . customer djstripe . models . core . PaymentIntent . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . PaymentIntent . last_payment_error djstripe . models . core . PaymentIntent . next_action djstripe . models . core . PaymentIntent . on_behalf_of djstripe . models . core . PaymentIntent . payment_method djstripe . models . core . PaymentIntent . payment_method_types djstripe . models . core . PaymentIntent . receipt_email djstripe . models . core . PaymentIntent . setup_future_usage djstripe . models . core . PaymentIntent . shipping djstripe . models . core . PaymentIntent . statement_descriptor djstripe . models . core . PaymentIntent . status djstripe . models . core . PaymentIntent . stripe_dashboard_item_name djstripe . models . core . PaymentIntent . transfer_data djstripe . models . core . PaymentIntent . transfer_group djstripe.models.core.PaymentIntent.DoesNotExist djstripe.models.core.PaymentIntent.MultipleObjectsReturned djstripe.models.core.PaymentIntent.stripe_class djstripe . models . core . PaymentIntent . stripe_class . OBJECT_NAME djstripe . models . core . PaymentIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self Methods djstripe . models . core . PaymentIntent . get_cancellation_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : cancellation_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_capture_method_display ( self , * , field =< djstripe . fields . StripeEnumField : capture_method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_confirmation_method_display ( self , * , field =< djstripe . fields . StripeEnumField : confirmation_method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_setup_future_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : setup_future_usage > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . update ( self , api_key = None , ** kwargs ) Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/core.py def update ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key return self . api_retrieve ( api_key = api_key ) . modify ( ** kwargs ) djstripe.models.core.Payout A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. Stripe documentation: https://stripe.com/docs/api#payouts djstripe . models . core . Payout . amount djstripe . models . core . Payout . arrival_date djstripe . models . core . Payout . automatic djstripe . models . core . Payout . balance_transaction djstripe . models . core . Payout . currency djstripe . models . core . Payout . destination djstripe . models . core . Payout . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Payout . expand_fields : List [ str ] djstripe . models . core . Payout . failure_balance_transaction djstripe . models . core . Payout . failure_code djstripe . models . core . Payout . failure_message djstripe . models . core . Payout . method djstripe . models . core . Payout . source_type djstripe . models . core . Payout . statement_descriptor djstripe . models . core . Payout . status djstripe . models . core . Payout . stripe_dashboard_item_name djstripe . models . core . Payout . type djstripe.models.core.Payout.DoesNotExist djstripe.models.core.Payout.MultipleObjectsReturned djstripe.models.core.Payout.stripe_class djstripe . models . core . Payout . stripe_class . OBJECT_NAME djstripe . models . core . Payout . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Payout . stripe_class . reverse ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def reverse ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reverse\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Payout . get_failure_code_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_code > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_method_display ( self , * , field =< djstripe . fields . StripeEnumField : method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_arrival_date ( self , * , field =< djstripe . fields . StripeDateTimeField : arrival_date > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_arrival_date ( self , * , field =< djstripe . fields . StripeDateTimeField : arrival_date > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_source_type_display ( self , * , field =< djstripe . fields . StripeEnumField : source_type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Price Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Price and Plan objects are the same, but use a different representation. Creating a recurring Price in Stripe also makes a Plan available, and vice versa. This is not the case for a Price with interval=one_time. Price objects are a more recent API representation, support more features and its usage is encouraged instead of Plan objects. Stripe documentation: - https://stripe.com/docs/api/prices - https://stripe.com/docs/billing/prices-guide djstripe . models . core . Price . active djstripe . models . core . Price . billing_scheme djstripe . models . core . Price . currency djstripe . models . core . Price . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Price . expand_fields : List [ str ] djstripe . models . core . Price . human_readable_price property readonly djstripe . models . core . Price . lookup_key djstripe . models . core . Price . nickname djstripe . models . core . Price . product djstripe . models . core . Price . recurring djstripe . models . core . Price . stripe_dashboard_item_name djstripe . models . core . Price . tiers djstripe . models . core . Price . tiers_mode djstripe . models . core . Price . transform_quantity djstripe . models . core . Price . type djstripe . models . core . Price . unit_amount djstripe . models . core . Price . unit_amount_decimal djstripe.models.core.Price.DoesNotExist djstripe.models.core.Price.MultipleObjectsReturned djstripe.models.core.Price.stripe_class Methods djstripe . models . core . Price . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return self . nickname or self . id djstripe . models . core . Price . create ( ** kwargs ) classmethod Source code in djstripe/models/core.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"unit_amount\" ] = int ( api_kwargs [ \"unit_amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_price = cls . _api_create ( ** api_kwargs ) price = cls . sync_from_stripe_data ( stripe_price ) return price djstripe . models . core . Price . get_billing_scheme_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_scheme > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_or_create ( ** kwargs ) classmethod Get or create a Price. Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Price.\"\"\" try : return Price . objects . get ( id = kwargs [ \"id\" ]), False except Price . DoesNotExist : return cls . create ( ** kwargs ), True djstripe . models . core . Price . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_tiers_mode_display ( self , * , field =< djstripe . fields . StripeEnumField : tiers_mode > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Product Stripe documentation: - https://stripe.com/docs/api#products - https://stripe.com/docs/api#service_products djstripe . models . core . Product . active djstripe . models . core . Product . attributes djstripe . models . core . Product . caption djstripe . models . core . Product . deactivate_on djstripe . models . core . Product . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Product . images djstripe . models . core . Product . name djstripe . models . core . Product . package_dimensions djstripe . models . core . Product . shippable djstripe . models . core . Product . statement_descriptor djstripe . models . core . Product . stripe_dashboard_item_name djstripe . models . core . Product . type djstripe . models . core . Product . unit_label djstripe . models . core . Product . url djstripe.models.core.Product.DoesNotExist djstripe.models.core.Product.MultipleObjectsReturned djstripe.models.core.Product.stripe_class djstripe . models . core . Product . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return self . name djstripe . models . core . Product . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Refund Stripe documentation: https://stripe.com/docs/api#refund_object djstripe . models . core . Refund . amount djstripe . models . core . Refund . balance_transaction djstripe . models . core . Refund . charge djstripe . models . core . Refund . currency djstripe . models . core . Refund . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Refund . failure_balance_transaction djstripe . models . core . Refund . failure_reason djstripe . models . core . Refund . reason djstripe . models . core . Refund . receipt_number djstripe . models . core . Refund . status djstripe.models.core.Refund.DoesNotExist djstripe.models.core.Refund.MultipleObjectsReturned djstripe.models.core.Refund.stripe_class Methods djstripe . models . core . Refund . get_failure_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . charge . get_stripe_dashboard_url () djstripe.models.core.SetupIntent A SetupIntent guides you through the process of setting up a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow. NOTE: You should not maintain long-lived, unconfirmed SetupIntents. For security purposes, SetupIntents older than 24 hours may no longer be valid. Stripe documentation: https://stripe.com/docs/api#setup_intents djstripe . models . core . SetupIntent . application djstripe . models . core . SetupIntent . cancellation_reason djstripe . models . core . SetupIntent . client_secret djstripe . models . core . SetupIntent . customer djstripe . models . core . SetupIntent . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . SetupIntent . last_setup_error djstripe . models . core . SetupIntent . next_action djstripe . models . core . SetupIntent . on_behalf_of djstripe . models . core . SetupIntent . payment_method djstripe . models . core . SetupIntent . payment_method_types djstripe . models . core . SetupIntent . status djstripe . models . core . SetupIntent . usage djstripe.models.core.SetupIntent.DoesNotExist djstripe.models.core.SetupIntent.MultipleObjectsReturned djstripe.models.core.SetupIntent.stripe_class djstripe . models . core . SetupIntent . stripe_class . OBJECT_NAME djstripe . models . core . SetupIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . SetupIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . SetupIntent . get_cancellation_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : cancellation_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : usage > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Payment Methods Classes djstripe.models.payment_methods.BankAccount BankAccount(djstripe_id, id, djstripe_owner_account, livemode, created, metadata, description, djstripe_created, djstripe_updated, account, account_holder_name, account_holder_type, bank_name, country, currency, customer, default_for_currency, fingerprint, last4, routing_number, status) djstripe . models . payment_methods . BankAccount . account djstripe . models . payment_methods . BankAccount . account_holder_name djstripe . models . payment_methods . BankAccount . account_holder_type djstripe . models . payment_methods . BankAccount . bank_name djstripe . models . payment_methods . BankAccount . country djstripe . models . payment_methods . BankAccount . currency djstripe . models . payment_methods . BankAccount . customer : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . BankAccount . default_for_currency djstripe . models . payment_methods . BankAccount . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . BankAccount . fingerprint djstripe . models . payment_methods . BankAccount . last4 djstripe . models . payment_methods . BankAccount . routing_number djstripe . models . payment_methods . BankAccount . status djstripe.models.payment_methods.BankAccount.DoesNotExist djstripe.models.payment_methods.BankAccount.MultipleObjectsReturned djstripe.models.payment_methods.BankAccount.stripe_class djstripe . models . payment_methods . BankAccount . stripe_class . OBJECT_NAME djstripe . models . payment_methods . BankAccount . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether bank_account_id %s is \" \"attached to a customer or an account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . BankAccount . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a bank account without a customer or account ID. \" \"Call save on customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" ) djstripe . models . payment_methods . BankAccount . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a bank account without a customer or account ID. \" \"Use customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" ) Methods djstripe . models . payment_methods . BankAccount . api_retrieve ( self , ** kwargs ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/payment_methods.py def api_retrieve ( self , ** kwargs ): if not self . customer : raise NotImplementedError ( \"Cannot retrieve bank accounts not associated with a customer\" ) return super () . api_retrieve ( ** kwargs ) djstripe . models . payment_methods . BankAccount . get_account_holder_type_display ( self , * , field =< djstripe . fields . StripeEnumField : account_holder_type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.payment_methods.Card You can store multiple cards on a customer in order to charge the customer later. This is a legacy model which only applies to the \"v2\" Stripe API (eg. Checkout.js). You should strive to use the Stripe \"v3\" API (eg. Stripe Elements). Also see: https://stripe.com/docs/stripe-js/elements/migrating When using Elements, you will not be using Card objects. Instead, you will use Source objects. A Source object of type \"card\" is equivalent to a Card object. However, Card objects cannot be converted into Source objects by Stripe at this time. Stripe documentation: https://stripe.com/docs/api/python#cards djstripe . models . payment_methods . Card . address_city djstripe . models . payment_methods . Card . address_country djstripe . models . payment_methods . Card . address_line1 djstripe . models . payment_methods . Card . address_line1_check djstripe . models . payment_methods . Card . address_line2 djstripe . models . payment_methods . Card . address_state djstripe . models . payment_methods . Card . address_zip djstripe . models . payment_methods . Card . address_zip_check djstripe . models . payment_methods . Card . brand djstripe . models . payment_methods . Card . country djstripe . models . payment_methods . Card . customer : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Card . cvc_check djstripe . models . payment_methods . Card . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Card . dynamic_last4 djstripe . models . payment_methods . Card . exp_month djstripe . models . payment_methods . Card . exp_year djstripe . models . payment_methods . Card . fingerprint djstripe . models . payment_methods . Card . funding djstripe . models . payment_methods . Card . last4 djstripe . models . payment_methods . Card . name djstripe . models . payment_methods . Card . tokenization_method djstripe.models.payment_methods.Card.DoesNotExist djstripe.models.payment_methods.Card.MultipleObjectsReturned djstripe.models.payment_methods.Card.stripe_class djstripe . models . payment_methods . Card . stripe_class . OBJECT_NAME djstripe . models . payment_methods . Card . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"recipient\" ): recipient = util . utf8 ( self . recipient ) base = Recipient . class_url () owner_extn = quote_plus ( recipient ) class_base = \"cards\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether card_id %s is \" \"attached to a customer, recipient, or \" \"account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . Card . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a card without a customer, recipient or account \" \"ID. Call save on customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" ) djstripe . models . payment_methods . Card . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a card without a customer, recipient or account \" \"ID. Use customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" ) Methods djstripe . models . payment_methods . Card . create_token ( number , exp_month , exp_year , cvc , api_key = 'sk_test_123' , ** kwargs ) classmethod Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api/python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use Source code in djstripe/models/payment_methods.py @classmethod def create_token ( cls , number : str , exp_month : int , exp_year : int , cvc : str , api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs , ) -> stripe . Token : \"\"\" Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api/python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use \"\"\" card = { \"number\" : number , \"exp_month\" : exp_month , \"exp_year\" : exp_year , \"cvc\" : cvc , } card . update ( kwargs ) return stripe . Token . create ( api_key = api_key , card = card ) djstripe . models . payment_methods . Card . get_address_line1_check_display ( self , * , field =< djstripe . fields . StripeEnumField : address_line1_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_address_zip_check_display ( self , * , field =< djstripe . fields . StripeEnumField : address_zip_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_brand_display ( self , * , field =< djstripe . fields . StripeEnumField : brand > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_cvc_check_display ( self , * , field =< djstripe . fields . StripeEnumField : cvc_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_funding_display ( self , * , field =< djstripe . fields . StripeEnumField : funding > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_tokenization_method_display ( self , * , field =< djstripe . fields . StripeEnumField : tokenization_method > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/payment_methods.py def str_parts ( self ): return [ \"brand= {brand} \" . format ( brand = self . brand ), \"last4= {last4} \" . format ( last4 = self . last4 ), \"exp_month= {exp_month} \" . format ( exp_month = self . exp_month ), \"exp_year= {exp_year} \" . format ( exp_year = self . exp_year ), ] + super () . str_parts () djstripe.models.payment_methods.PaymentMethod Stripe documentation: https://stripe.com/docs/api#payment_methods djstripe . models . payment_methods . PaymentMethod . alipay djstripe . models . payment_methods . PaymentMethod . au_becs_debit djstripe . models . payment_methods . PaymentMethod . bacs_debit djstripe . models . payment_methods . PaymentMethod . bancontact djstripe . models . payment_methods . PaymentMethod . billing_details djstripe . models . payment_methods . PaymentMethod . card djstripe . models . payment_methods . PaymentMethod . card_present djstripe . models . payment_methods . PaymentMethod . customer djstripe . models . payment_methods . PaymentMethod . description djstripe . models . payment_methods . PaymentMethod . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . PaymentMethod . eps djstripe . models . payment_methods . PaymentMethod . fpx djstripe . models . payment_methods . PaymentMethod . giropay djstripe . models . payment_methods . PaymentMethod . ideal djstripe . models . payment_methods . PaymentMethod . interac_present djstripe . models . payment_methods . PaymentMethod . oxxo djstripe . models . payment_methods . PaymentMethod . p24 djstripe . models . payment_methods . PaymentMethod . sepa_debit djstripe . models . payment_methods . PaymentMethod . sofort djstripe . models . payment_methods . PaymentMethod . type djstripe.models.payment_methods.PaymentMethod.DoesNotExist djstripe.models.payment_methods.PaymentMethod.MultipleObjectsReturned djstripe.models.payment_methods.PaymentMethod.stripe_class djstripe . models . payment_methods . PaymentMethod . stripe_class . OBJECT_NAME djstripe . models . payment_methods . PaymentMethod . stripe_class . _cls_attach ( sid , ** params ) classmethod private Source code in djstripe/models/payment_methods.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . payment_methods . PaymentMethod . stripe_class . _cls_detach ( sid , ** params ) classmethod private Source code in djstripe/models/payment_methods.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . payment_methods . PaymentMethod . stripe_class . attach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def attach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/attach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . payment_methods . PaymentMethod . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/detach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self Methods djstripe . models . payment_methods . PaymentMethod . _attach_objects_hook ( self , cls , data , current_ids = None ) private Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/payment_methods.py def _attach_objects_hook ( self , cls , data , current_ids = None ): customer = None if current_ids is None or data . get ( \"customer\" ) not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids ) if customer : self . customer = customer else : self . customer = None djstripe . models . payment_methods . PaymentMethod . attach ( payment_method , customer , api_key = 'sk_test_123' ) classmethod Attach a payment method to a customer Source code in djstripe/models/payment_methods.py @classmethod def attach ( cls , payment_method : Union [ str , \"PaymentMethod\" ], customer : Union [ str , Customer ], api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ) -> \"PaymentMethod\" : \"\"\" Attach a payment method to a customer \"\"\" if isinstance ( payment_method , StripeModel ): payment_method = payment_method . id if isinstance ( customer , StripeModel ): customer = customer . id extra_kwargs = {} if not isinstance ( payment_method , stripe . PaymentMethod ): # send api_key if we're not passing in a Stripe object # avoids \"Received unknown parameter: api_key\" since api uses the # key cached in the Stripe object extra_kwargs = { \"api_key\" : api_key } stripe_payment_method = stripe . PaymentMethod . attach ( payment_method , customer = customer , ** extra_kwargs ) return cls . sync_from_stripe_data ( stripe_payment_method ) djstripe . models . payment_methods . PaymentMethod . detach ( self ) Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, false if it was already detached :rtype: bool Source code in djstripe/models/payment_methods.py def detach ( self ): \"\"\" Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, \\ false if it was already detached :rtype: bool \"\"\" # Find customers that use this customers = Customer . objects . filter ( default_payment_method = self ) . all () changed = True # special handling is needed for legacy \"card\"-type PaymentMethods, # since detaching them deletes them within Stripe. # see https://github.com/dj-stripe/dj-stripe/pull/967 is_legacy_card = self . id . startswith ( \"card_\" ) try : self . sync_from_stripe_data ( self . api_retrieve () . detach ()) # resync customer to update .default_payment_method and # .invoice_settings.default_payment_method for customer in customers : Customer . sync_from_stripe_data ( customer . api_retrieve ()) except ( InvalidRequestError ,): # The source was already detached. Resyncing. if self . pk and not is_legacy_card : self . sync_from_stripe_data ( self . api_retrieve ()) changed = False if self . pk : if is_legacy_card : self . delete () else : self . refresh_from_db () return changed djstripe . models . payment_methods . PaymentMethod . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.payment_methods.Source Stripe documentation: https://stripe.com/docs/api#sources djstripe . models . payment_methods . Source . amount djstripe . models . payment_methods . Source . client_secret djstripe . models . payment_methods . Source . code_verification djstripe . models . payment_methods . Source . currency djstripe . models . payment_methods . Source . customer djstripe . models . payment_methods . Source . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Source . flow djstripe . models . payment_methods . Source . owner djstripe . models . payment_methods . Source . receiver djstripe . models . payment_methods . Source . redirect djstripe . models . payment_methods . Source . source_data djstripe . models . payment_methods . Source . statement_descriptor djstripe . models . payment_methods . Source . status djstripe . models . payment_methods . Source . stripe_dashboard_item_name djstripe . models . payment_methods . Source . type djstripe . models . payment_methods . Source . usage Classes djstripe.models.payment_methods.Source.DoesNotExist djstripe.models.payment_methods.Source.MultipleObjectsReturned djstripe.models.payment_methods.Source.stripe_class djstripe . models . payment_methods . Source . stripe_class . OBJECT_NAME Methods djstripe . models . payment_methods . Source . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): token = util . utf8 ( self . id ) if hasattr ( self , \"customer\" ) and self . customer : extn = quote_plus ( token ) customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) url = \" %s / %s /sources/ %s \" % ( base , owner_extn , extn ) headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"delete\" , url , params , headers )) return self else : raise error . InvalidRequestError ( \"Source %s does not appear to be currently attached \" \"to a customer object.\" % token , \"id\" , ) djstripe . models . payment_methods . Source . stripe_class . list_source_transactions ( id , ** params ) classmethod Source code in djstripe/models/payment_methods.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions ( self , ** params ) source_transactions is deprecated, use Source.list_source_transactions instead. Source code in djstripe/models/payment_methods.py def source_transactions ( self , ** params ): \"\"\"source_transactions is deprecated, use Source.list_source_transactions instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/source_transactions\" , params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . payment_methods . Source . _attach_objects_hook ( self , cls , data , current_ids = None ) private Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/payment_methods.py def _attach_objects_hook ( self , cls , data , current_ids = None ): customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids ) if customer : self . customer = customer else : self . customer = None djstripe . models . payment_methods . Source . _manipulate_stripe_object_hook ( data ) classmethod private Gets called by this object's stripe object conversion method just before conversion. Use this to populate custom fields in a StripeModel from stripe data. Source code in djstripe/models/payment_methods.py @classmethod def _manipulate_stripe_object_hook ( cls , data ): # The source_data dict is an alias of all the source types data [ \"source_data\" ] = data [ data [ \"type\" ]] return data djstripe . models . payment_methods . Source . detach ( self ) Detach the source from its customer. Source code in djstripe/models/payment_methods.py def detach ( self ) -> bool : \"\"\" Detach the source from its customer. \"\"\" # First, wipe default source on all customers that use this. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) try : # TODO - we could use the return value of sync_from_stripe_data # or call its internals - self._sync/_attach_objects_hook etc here # to update `self` at this point? self . sync_from_stripe_data ( self . api_retrieve () . detach ()) return True except ( InvalidRequestError , NotImplementedError ): # The source was already detached. Resyncing. # NotImplementedError is an artifact of stripe-python<2.0 # https://github.com/stripe/stripe-python/issues/376 self . sync_from_stripe_data ( self . api_retrieve ()) return False djstripe . models . payment_methods . Source . get_flow_display ( self , * , field =< djstripe . fields . StripeEnumField : flow > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : usage > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Billing Classes djstripe.models.billing.Coupon Coupon(djstripe_id, djstripe_owner_account, livemode, created, metadata, description, djstripe_created, djstripe_updated, id, amount_off, currency, duration, duration_in_months, max_redemptions, name, percent_off, redeem_by, times_redeemed) djstripe . models . billing . Coupon . amount_off djstripe . models . billing . Coupon . currency djstripe . models . billing . Coupon . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Coupon . duration djstripe . models . billing . Coupon . duration_in_months djstripe . models . billing . Coupon . human_readable property readonly djstripe . models . billing . Coupon . human_readable_amount property readonly djstripe . models . billing . Coupon . max_redemptions djstripe . models . billing . Coupon . name djstripe . models . billing . Coupon . percent_off djstripe . models . billing . Coupon . redeem_by djstripe . models . billing . Coupon . stripe_dashboard_item_name djstripe . models . billing . Coupon . times_redeemed djstripe.models.billing.Coupon.DoesNotExist djstripe.models.billing.Coupon.MultipleObjectsReturned djstripe.models.billing.Coupon.stripe_class djstripe . models . billing . Coupon . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): if self . name : return self . name return self . human_readable djstripe . models . billing . Coupon . get_duration_display ( self , * , field =< djstripe . fields . StripeEnumField : duration > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.Invoice Invoices are statements of what a customer owes for a particular billing period, including subscriptions, invoice items, and any automatic proration adjustments if necessary. Once an invoice is created, payment is automatically attempted. Note that the payment, while automatic, does not happen exactly at the time of invoice creation. If you have configured webhooks, the invoice will wait until one hour after the last webhook is successfully sent (or the last webhook times out after failing). Any customer credit on the account is applied before determining how much is due for that invoice (the amount that will be actually charged). If the amount due for the invoice is less than 50 cents (the minimum for a charge), we add the amount to the customer's running account balance to be added to the next invoice. If this amount is negative, it will act as a credit to offset the next invoice. Note that the customer account balance does not include unpaid invoices; it only includes balances that need to be taken into account when calculating the amount due for the next invoice. Stripe documentation: https://stripe.com/docs/api/python#invoices djstripe . models . billing . Invoice . charge djstripe . models . billing . Invoice . customer djstripe . models . billing . Invoice . default_payment_method djstripe . models . billing . Invoice . default_source djstripe . models . billing . Invoice . default_tax_rates djstripe . models . billing . Invoice . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Invoice . payment_intent djstripe . models . billing . Invoice . subscription djstripe.models.billing.Invoice.DoesNotExist djstripe.models.billing.Invoice.MultipleObjectsReturned Methods djstripe . models . billing . Invoice . _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ) private Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) ) cls . _stripe_object_set_total_tax_amounts ( target_cls = DjstripeInvoiceTotalTaxAmount , data = data , instance = self ) djstripe . models . billing . Invoice . get_billing_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_reason > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_customer_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : customer_tax_exempt > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.InvoiceItem Sometimes you want to add a charge or credit to a customer but only actually charge the customer's card at the end of a regular billing cycle. This is useful for combining several charges to minimize per-transaction fees or having Stripe tabulate your usage-based billing totals. Stripe documentation: https://stripe.com/docs/api/python#invoiceitems djstripe . models . billing . InvoiceItem . amount djstripe . models . billing . InvoiceItem . currency djstripe . models . billing . InvoiceItem . customer djstripe . models . billing . InvoiceItem . date djstripe . models . billing . InvoiceItem . discountable djstripe . models . billing . InvoiceItem . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . InvoiceItem . invoice djstripe . models . billing . InvoiceItem . period djstripe . models . billing . InvoiceItem . period_end djstripe . models . billing . InvoiceItem . period_start djstripe . models . billing . InvoiceItem . plan djstripe . models . billing . InvoiceItem . price djstripe . models . billing . InvoiceItem . proration djstripe . models . billing . InvoiceItem . quantity djstripe . models . billing . InvoiceItem . subscription djstripe . models . billing . InvoiceItem . tax_rates djstripe . models . billing . InvoiceItem . unit_amount djstripe . models . billing . InvoiceItem . unit_amount_decimal djstripe.models.billing.InvoiceItem.DoesNotExist djstripe.models.billing.InvoiceItem.MultipleObjectsReturned djstripe.models.billing.InvoiceItem.stripe_class Methods djstripe . models . billing . InvoiceItem . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return self . description djstripe . models . billing . InvoiceItem . _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ) private Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) if self . pk : # only call .set() on saved instance (ie don't on items of UpcomingInvoice) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data ) ) djstripe . models . billing . InvoiceItem . _manipulate_stripe_object_hook ( data ) classmethod private Gets called by this object's stripe object conversion method just before conversion. Use this to populate custom fields in a StripeModel from stripe data. Source code in djstripe/models/billing.py @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data djstripe . models . billing . InvoiceItem . api_retrieve ( self , * args , ** kwargs ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , * args , ** kwargs ): if \"-il_\" in self . id : warnings . warn ( f \"Attempting to retrieve InvoiceItem with id= { self . id !r} \" \" will most likely fail. \" \"Run manage.py djstripe_update_invoiceitem_ids if this is a problem.\" ) return super () . api_retrieve ( * args , ** kwargs ) djstripe . models . billing . InvoiceItem . get_next_by_date ( self , * , field =< djstripe . fields . StripeDateTimeField : date > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_date ( self , * , field =< djstripe . fields . StripeDateTimeField : date > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return self . invoice . get_stripe_dashboard_url () djstripe . models . billing . InvoiceItem . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/billing.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"invoiceitem\" , \"line_item\" ) djstripe . models . billing . InvoiceItem . sync_from_stripe_data ( data ) classmethod Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls Source code in djstripe/models/billing.py @classmethod def sync_from_stripe_data ( cls , data ): invoice_data = data . get ( \"invoice\" ) if invoice_data : # sync the Invoice first if it doesn't yet exist in our DB # to avoid recursive Charge/Invoice loop invoice_id = cls . _id_from_data ( invoice_data ) if not Invoice . objects . filter ( id = invoice_id ) . exists (): if invoice_id == invoice_data : # we only have the id, fetch the full data invoice_data = Invoice ( id = invoice_id ) . api_retrieve () Invoice . sync_from_stripe_data ( data = invoice_data ) return super () . sync_from_stripe_data ( data ) djstripe.models.billing.Plan A subscription plan contains the pricing information for different products and feature levels on your site. Stripe documentation: https://stripe.com/docs/api/plans NOTE: The Stripe Plans API has been deprecated in favor of the Prices API. You may want to upgrade to use the Price model instead of the Plan model. djstripe . models . billing . Plan . active djstripe . models . billing . Plan . aggregate_usage djstripe . models . billing . Plan . amount djstripe . models . billing . Plan . amount_decimal djstripe . models . billing . Plan . amount_in_cents property readonly djstripe . models . billing . Plan . billing_scheme djstripe . models . billing . Plan . currency djstripe . models . billing . Plan . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Plan . human_readable_price property readonly djstripe . models . billing . Plan . interval djstripe . models . billing . Plan . interval_count djstripe . models . billing . Plan . nickname djstripe . models . billing . Plan . product djstripe . models . billing . Plan . stripe_dashboard_item_name djstripe . models . billing . Plan . tiers djstripe . models . billing . Plan . tiers_mode djstripe . models . billing . Plan . transform_usage djstripe . models . billing . Plan . trial_period_days djstripe . models . billing . Plan . usage_type djstripe.models.billing.Plan.DoesNotExist djstripe.models.billing.Plan.MultipleObjectsReturned djstripe.models.billing.Plan.stripe_class Methods djstripe . models . billing . Plan . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return self . nickname or self . id djstripe . models . billing . Plan . create ( ** kwargs ) classmethod Source code in djstripe/models/billing.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"amount\" ] = int ( api_kwargs [ \"amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_plan = cls . _api_create ( ** api_kwargs ) plan = cls . sync_from_stripe_data ( stripe_plan ) return plan djstripe . models . billing . Plan . get_aggregate_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : aggregate_usage > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_billing_scheme_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_scheme > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_interval_display ( self , * , field =< djstripe . fields . StripeEnumField : interval > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_or_create ( ** kwargs ) classmethod Get or create a Plan. Source code in djstripe/models/billing.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Plan.\"\"\" try : return Plan . objects . get ( id = kwargs [ \"id\" ]), False except Plan . DoesNotExist : return cls . create ( ** kwargs ), True djstripe . models . billing . Plan . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_tiers_mode_display ( self , * , field =< djstripe . fields . StripeEnumField : tiers_mode > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_usage_type_display ( self , * , field =< djstripe . fields . StripeEnumField : usage_type > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.Subscription Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to a particular plan you've created. A subscription still in its trial period is trialing and moves to active when the trial period is over. When payment to renew the subscription fails, the subscription becomes past_due . After Stripe has exhausted all payment retry attempts, the subscription ends up with a status of either canceled or unpaid depending on your retry settings. Note that when a subscription has a status of unpaid , no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed. Additionally, updating customer card details will not lead to Stripe retrying the latest invoice.). After receiving updated card details from a customer, you may choose to reopen and pay their closed invoices. Stripe documentation: https://stripe.com/docs/api/python#subscriptions djstripe . models . billing . Subscription . application_fee_percent djstripe . models . billing . Subscription . billing_cycle_anchor djstripe . models . billing . Subscription . billing_thresholds djstripe . models . billing . Subscription . cancel_at djstripe . models . billing . Subscription . cancel_at_period_end djstripe . models . billing . Subscription . canceled_at djstripe . models . billing . Subscription . collection_method djstripe . models . billing . Subscription . current_period_end djstripe . models . billing . Subscription . current_period_start djstripe . models . billing . Subscription . customer djstripe . models . billing . Subscription . days_until_due djstripe . models . billing . Subscription . default_payment_method djstripe . models . billing . Subscription . default_source djstripe . models . billing . Subscription . default_tax_rates djstripe . models . billing . Subscription . discount djstripe . models . billing . Subscription . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Subscription . ended_at djstripe . models . billing . Subscription . next_pending_invoice_item_invoice djstripe . models . billing . Subscription . objects djstripe . models . billing . Subscription . pending_invoice_item_interval djstripe . models . billing . Subscription . pending_setup_intent djstripe . models . billing . Subscription . pending_update djstripe . models . billing . Subscription . plan djstripe . models . billing . Subscription . quantity djstripe . models . billing . Subscription . schedule djstripe . models . billing . Subscription . start_date djstripe . models . billing . Subscription . status djstripe . models . billing . Subscription . stripe_dashboard_item_name djstripe . models . billing . Subscription . tax_percent djstripe . models . billing . Subscription . trial_end djstripe . models . billing . Subscription . trial_start djstripe.models.billing.Subscription.DoesNotExist djstripe.models.billing.Subscription.MultipleObjectsReturned djstripe.models.billing.Subscription.stripe_class djstripe . models . billing . Subscription . stripe_class . OBJECT_NAME djstripe . models . billing . Subscription . stripe_class . _cls_delete_discount ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . Subscription . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/billing.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True ) Methods djstripe . models . billing . Subscription . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return \" {customer} on {plan} \" . format ( customer = str ( self . customer ), plan = str ( self . plan ) ) djstripe . models . billing . Subscription . _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ) private Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) cls . _stripe_object_to_subscription_items ( target_cls = SubscriptionItem , data = data , subscription = self ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) ) djstripe . models . billing . Subscription . cancel ( self , at_period_end = True ) Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, the at_period_end flag will be overridden to False so that the trial ends immediately and the customer's card isn't charged. Source code in djstripe/models/billing.py def cancel ( self , at_period_end = djstripe_settings . CANCELLATION_AT_PERIOD_END ): \"\"\" Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation \\ of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, \\ the ``at_period_end`` flag will be overridden to False so that the trial ends \\ immediately and the customer's card isn't charged. \"\"\" # If plan has trial days and customer cancels before # trial period ends, then end subscription now, # i.e. at_period_end=False if self . trial_end and self . trial_end > timezone . now (): at_period_end = False if at_period_end : stripe_subscription = self . _api_update ( cancel_at_period_end = True ) else : try : stripe_subscription = self . _api_delete () except InvalidRequestError as exc : if \"No such subscription:\" in str ( exc ): # cancel() works by deleting the subscription. The object still # exists in Stripe however, and can still be retrieved. # If the subscription was already canceled (status=canceled), # that api_retrieve() call will fail with \"No such subscription\". # However, this may also happen if the subscription legitimately # does not exist, in which case the following line will re-raise. stripe_subscription = self . api_retrieve () else : raise return Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe . models . billing . Subscription . extend ( self , delta ) Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta Source code in djstripe/models/billing.py def extend ( self , delta ): \"\"\" Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta \"\"\" if delta . total_seconds () < 0 : raise ValueError ( \"delta must be a positive timedelta.\" ) if self . trial_end is not None and self . trial_end > timezone . now (): period_end = self . trial_end else : period_end = self . current_period_end period_end += delta return self . update ( proration_behavior = \"none\" , trial_end = period_end ) djstripe . models . billing . Subscription . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_current_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_current_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_current_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_current_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . is_period_current ( self ) Returns True if this subscription's period is current, false otherwise. Source code in djstripe/models/billing.py def is_period_current ( self ): \"\"\" Returns True if this subscription's period is current, false otherwise. \"\"\" return self . current_period_end > timezone . now () or ( self . trial_end and self . trial_end > timezone . now () ) djstripe . models . billing . Subscription . is_status_current ( self ) Returns True if this subscription's status is current (active or trialing), false otherwise. Source code in djstripe/models/billing.py def is_status_current ( self ): \"\"\" Returns True if this subscription's status is current (active or trialing), false otherwise. \"\"\" return self . status in [ \"trialing\" , \"active\" ] djstripe . models . billing . Subscription . is_status_temporarily_current ( self ) A status is temporarily current when the subscription is canceled with the at_period_end flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. Source code in djstripe/models/billing.py def is_status_temporarily_current ( self ): \"\"\" A status is temporarily current when the subscription is canceled with the ``at_period_end`` flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. \"\"\" return ( self . canceled_at and self . cancel_at_period_end and timezone . now () < self . current_period_end ) djstripe . models . billing . Subscription . is_valid ( self ) Returns True if this subscription's status and period are current, false otherwise. Source code in djstripe/models/billing.py def is_valid ( self ): \"\"\" Returns True if this subscription's status and period are current, false otherwise. \"\"\" if not self . is_status_current (): return False if not self . is_period_current (): return False return True djstripe . models . billing . Subscription . reactivate ( self ) Reactivates this subscription. If a customer's subscription is canceled with at_period_end set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/subscriptions/canceling-pausing) .. warning:: Reactivating a fully canceled Subscription will fail silently. Be sure to check the returned Subscription's status. Source code in djstripe/models/billing.py def reactivate ( self ): \"\"\" Reactivates this subscription. If a customer's subscription is canceled with ``at_period_end`` set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/subscriptions/canceling-pausing) .. warning:: Reactivating a fully canceled Subscription will fail silently. \\ Be sure to check the returned Subscription's status. \"\"\" stripe_subscription = self . api_retrieve () stripe_subscription . plan = self . plan . id stripe_subscription . cancel_at_period_end = False return Subscription . sync_from_stripe_data ( stripe_subscription . save ()) djstripe . models . billing . Subscription . update ( self , plan = None , prorate = None , ** kwargs ) See Customer.subscribe() <#djstripe.models.Customer.subscribe> __ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. note:: The default value for prorate is the DJSTRIPE_PRORATION_POLICY setting. .. important:: Updating a subscription by changing the plan or quantity creates a new Subscription in Stripe (and dj-stripe). Source code in djstripe/models/billing.py def update ( self , plan : Union [ StripeModel , str ] = None , prorate : bool = None , ** kwargs , ): \"\"\" See `Customer.subscribe() <#djstripe.models.Customer.subscribe>`__ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. note:: The default value for ``prorate`` is the DJSTRIPE_PRORATION_POLICY \\ setting. .. important:: Updating a subscription by changing the plan or quantity \\ creates a new ``Subscription`` in \\ Stripe (and dj-stripe). \"\"\" # Convert Plan to id if plan is not None and isinstance ( plan , StripeModel ): plan = plan . id if \"proration_behavior\" not in kwargs : if prorate is not None : warnings . warn ( \"The `prorate` parameter to Subscription.update() is deprecated \" \"by Stripe. Use `proration_behavior` instead. \\n \" \"Read more: \" \"https://stripe.com/docs/billing/subscriptions/prorations\" ) else : prorate = djstripe_settings . PRORATION_POLICY if prorate : kwargs . setdefault ( \"proration_behavior\" , \"create_prorations\" ) else : kwargs . setdefault ( \"proration_behavior\" , \"none\" ) stripe_subscription = self . _api_update ( plan = plan , ** kwargs ) return Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe.models.billing.SubscriptionItem Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. Stripe documentation: https://stripe.com/docs/api#subscription_items djstripe . models . billing . SubscriptionItem . billing_thresholds djstripe . models . billing . SubscriptionItem . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . SubscriptionItem . plan djstripe . models . billing . SubscriptionItem . price djstripe . models . billing . SubscriptionItem . quantity djstripe . models . billing . SubscriptionItem . subscription djstripe . models . billing . SubscriptionItem . tax_rates Classes djstripe.models.billing.SubscriptionItem.DoesNotExist djstripe.models.billing.SubscriptionItem.MultipleObjectsReturned djstripe.models.billing.SubscriptionItem.stripe_class djstripe . models . billing . SubscriptionItem . stripe_class . OBJECT_NAME Methods djstripe . models . billing . SubscriptionItem . stripe_class . create_usage_record ( id , ** params ) classmethod Source code in djstripe/models/billing.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . list_usage_record_summaries ( id , ** params ) classmethod Source code in djstripe/models/billing.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summaries ( self , ** params ) usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead. Source code in djstripe/models/billing.py def usage_record_summaries ( self , ** params ): \"\"\"usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/usage_record_summaries\" , params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . billing . SubscriptionItem . _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ) private Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data ) ) djstripe . models . billing . SubscriptionItem . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.SubscriptionSchedule Subscription schedules allow you to create and manage the lifecycle of a subscription by predefining expected changes. Stripe documentation: https://stripe.com/docs/api/subscription_schedules djstripe . models . billing . SubscriptionSchedule . billing_thresholds djstripe . models . billing . SubscriptionSchedule . canceled_at djstripe . models . billing . SubscriptionSchedule . completed_at djstripe . models . billing . SubscriptionSchedule . current_phase djstripe . models . billing . SubscriptionSchedule . customer djstripe . models . billing . SubscriptionSchedule . default_settings djstripe . models . billing . SubscriptionSchedule . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . SubscriptionSchedule . end_behavior djstripe . models . billing . SubscriptionSchedule . phases djstripe . models . billing . SubscriptionSchedule . released_at djstripe . models . billing . SubscriptionSchedule . released_subscription djstripe . models . billing . SubscriptionSchedule . status djstripe.models.billing.SubscriptionSchedule.DoesNotExist djstripe.models.billing.SubscriptionSchedule.MultipleObjectsReturned djstripe.models.billing.SubscriptionSchedule.stripe_class djstripe . models . billing . SubscriptionSchedule . stripe_class . OBJECT_NAME djstripe . models . billing . SubscriptionSchedule . stripe_class . _cls_cancel ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . SubscriptionSchedule . stripe_class . _cls_release ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . SubscriptionSchedule . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . SubscriptionSchedule . stripe_class . release ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def release ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/release\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . SubscriptionSchedule . get_end_behavior_display ( self , * , field =< djstripe . fields . StripeEnumField : end_behavior > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.TaxId TaxId(djstripe_id, id, djstripe_owner_account, livemode, created, djstripe_created, djstripe_updated, country, customer, type, value, verification) djstripe . models . billing . TaxId . country djstripe . models . billing . TaxId . customer djstripe . models . billing . TaxId . description djstripe . models . billing . TaxId . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . TaxId . metadata djstripe . models . billing . TaxId . type djstripe . models . billing . TaxId . value djstripe . models . billing . TaxId . verification djstripe.models.billing.TaxId.DoesNotExist djstripe.models.billing.TaxId.MultipleObjectsReturned djstripe.models.billing.TaxId.stripe_class djstripe . models . billing . TaxId . stripe_class . OBJECT_NAME djstripe . models . billing . TaxId . stripe_class . instance_url ( self ) Source code in djstripe/models/billing.py def instance_url ( self ): token = util . utf8 ( self . id ) customer = util . utf8 ( self . customer ) base = Customer . class_url () cust_extn = quote_plus ( customer ) extn = quote_plus ( token ) return \" %s / %s /tax_ids/ %s \" % ( base , cust_extn , extn ) djstripe . models . billing . TaxId . stripe_class . retrieve ( id , api_key = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def retrieve ( cls , id , api_key = None , ** params ): raise NotImplementedError ( \"Can't retrieve a tax id without a customer ID. Use customer.retrieve_tax_id('tax_id')\" ) Methods djstripe . models . billing . TaxId . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return self . value djstripe . models . billing . TaxId . api_list ( api_key = 'sk_test_123' , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): # OVERRIDING the parent version of this function # TaxIds must be manipulated through a customer.. from .core import Customer if \"customer\" not in kwargs or not isinstance ( kwargs [ \"customer\" ], Customer ): raise StripeObjectManipulationException ( \"TaxIds must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) customer = kwargs [ \"customer\" ] return customer . api_retrieve ( api_key = api_key ) . tax_ids djstripe . models . billing . TaxId . api_retrieve ( self , api_key = None , stripe_account = None ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , api_key = None , stripe_account = None ): if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) customer = self . customer . api_retrieve ( api_key = api_key or self . default_api_key , stripe_account = stripe_account , ) return customer . retrieve_tax_id ( customer . id , self . id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , ) djstripe . models . billing . TaxId . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.TaxRate Tax rates can be applied to invoices and subscriptions to collect tax. Stripe documentation: https://stripe.com/docs/api/tax_rates djstripe . models . billing . TaxRate . active djstripe . models . billing . TaxRate . display_name djstripe . models . billing . TaxRate . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . TaxRate . inclusive djstripe . models . billing . TaxRate . jurisdiction djstripe . models . billing . TaxRate . percentage djstripe.models.billing.TaxRate.DoesNotExist djstripe.models.billing.TaxRate.MultipleObjectsReturned djstripe.models.billing.TaxRate.stripe_class djstripe . models . billing . TaxRate . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return f \" { self . display_name } \u2013 { self . jurisdiction } at { self . percentage } %\" djstripe . models . billing . TaxRate . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.UpcomingInvoice The preview of an upcoming invoice - does not exist in the Django database. See BaseInvoice.upcoming() Logically it should be set abstract, but that doesn't quite work since we do actually want to instantiate the model and use relations. Attributes djstripe . models . billing . UpcomingInvoice . charge djstripe . models . billing . UpcomingInvoice . customer djstripe . models . billing . UpcomingInvoice . default_payment_method djstripe . models . billing . UpcomingInvoice . default_source djstripe . models . billing . UpcomingInvoice . default_tax_rates property readonly Gets the default tax rates associated with this upcoming invoice. :return: djstripe . models . billing . UpcomingInvoice . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . UpcomingInvoice . id property writable djstripe . models . billing . UpcomingInvoice . invoiceitems property readonly Gets the invoice items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the invoiceitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail. djstripe . models . billing . UpcomingInvoice . payment_intent djstripe . models . billing . UpcomingInvoice . subscription djstripe . models . billing . UpcomingInvoice . total_tax_amounts property readonly Gets the total tax amounts associated with this upcoming invoice. :return: djstripe.models.billing.UpcomingInvoice.DoesNotExist djstripe.models.billing.UpcomingInvoice.MultipleObjectsReturned Methods djstripe . models . billing . UpcomingInvoice . __init__ ( self , * args , ** kwargs ) special Source code in djstripe/models/billing.py def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _invoiceitems = [] self . _default_tax_rates = [] self . _total_tax_amounts = [] djstripe . models . billing . UpcomingInvoice . _attach_objects_hook ( self , cls , data , current_ids = None ) private Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/billing.py def _attach_objects_hook ( self , cls , data , current_ids = None ): super () . _attach_objects_hook ( cls , data , current_ids = current_ids ) self . _invoiceitems = cls . _stripe_object_to_invoice_items ( target_cls = InvoiceItem , data = data , invoice = self ) djstripe . models . billing . UpcomingInvoice . _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ) private Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . _default_tax_rates = cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) total_tax_amounts = [] for tax_amount_data in data . get ( \"total_tax_amounts\" , []): tax_rate_data = tax_amount_data [ \"tax_rate\" ] if isinstance ( tax_rate_data , str ): tax_rate_data = { \"tax_rate\" : tax_rate_data } tax_rate , _ = TaxRate . _get_or_create_from_stripe_object ( tax_rate_data , field_name = \"tax_rate\" , refetch = True ) tax_amount = DjstripeUpcomingInvoiceTotalTaxAmount ( invoice = self , amount = tax_amount_data [ \"amount\" ], inclusive = tax_amount_data [ \"inclusive\" ], tax_rate = tax_rate , ) total_tax_amounts . append ( tax_amount ) self . _total_tax_amounts = total_tax_amounts djstripe . models . billing . UpcomingInvoice . get_billing_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_reason > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_customer_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : customer_tax_exempt > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return \"\" djstripe . models . billing . UpcomingInvoice . save ( self , * args , ** kwargs ) Save the current instance. Override this in a subclass if you want to control the saving process. The 'force_insert' and 'force_update' parameters can be used to insist that the \"save\" must be an SQL insert or update (or equivalent for non-SQL backends), respectively. Normally, they should not be set. Source code in djstripe/models/billing.py def save ( self , * args , ** kwargs ): return # noop djstripe.models.billing.UsageRecord Usage records allow you to continually report usage and metrics to Stripe for metered billing of plans. Stripe documentation: https://stripe.com/docs/api#usage_records djstripe . models . billing . UsageRecord . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . UsageRecord . quantity djstripe . models . billing . UsageRecord . subscription_item djstripe.models.billing.UsageRecord.DoesNotExist djstripe.models.billing.UsageRecord.MultipleObjectsReturned djstripe.models.billing.UsageRecord.stripe_class djstripe . models . billing . UsageRecord . stripe_class . OBJECT_NAME djstripe . models . billing . UsageRecord . stripe_class . create ( api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def create ( cls , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): if \"subscription_item\" not in params : raise ValueError ( \"Params must have a subscription_item key\" ) subscription_item = params . pop ( \"subscription_item\" ) requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) url = \"/v1/subscription_items/ %s /usage_records\" % subscription_item headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . UsageRecord . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Connect Classes djstripe.models.account.Account Stripe documentation: https://stripe.com/docs/api#account Attributes djstripe . models . account . Account . branding_icon property readonly djstripe . models . account . Account . branding_logo property readonly djstripe . models . account . Account . business_profile djstripe . models . account . Account . business_type djstripe . models . account . Account . business_url : str property readonly The business\u2019s publicly available website. djstripe . models . account . Account . charges_enabled djstripe . models . account . Account . company djstripe . models . account . Account . country djstripe . models . account . Account . default_api_key : str property readonly djstripe . models . account . Account . default_currency djstripe . models . account . Account . details_submitted djstripe . models . account . Account . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . account . Account . email djstripe . models . account . Account . individual djstripe . models . account . Account . payouts_enabled djstripe . models . account . Account . product_description djstripe . models . account . Account . requirements djstripe . models . account . Account . settings djstripe . models . account . Account . tos_acceptance djstripe . models . account . Account . type djstripe.models.account.Account.DoesNotExist djstripe.models.account.Account.MultipleObjectsReturned djstripe.models.account.Account.stripe_class djstripe . models . account . Account . stripe_class . OBJECT_NAME djstripe . models . account . Account . stripe_class . capabilitys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . capabilitys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . create_external_account ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_login_link ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_person ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . deauthorize ( self , ** params ) Source code in djstripe/models/account.py def deauthorize ( self , ** params ): params [ \"stripe_user_id\" ] = self . id return oauth . OAuth . deauthorize ( ** params ) djstripe . models . account . Account . stripe_class . delete_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . delete_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . external_accounts_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . external_accounts_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . instance_url ( self ) Source code in djstripe/models/account.py def instance_url ( self ): return self . _build_instance_url ( self . get ( \"id\" )) djstripe . models . account . Account . stripe_class . list_capabilities ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_external_accounts ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_persons ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . login_links_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . login_links_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . modify ( id = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def modify ( cls , id = None , ** params ): url = cls . _build_instance_url ( id ) return cls . _static_request ( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . persons ( self , ** params ) Source code in djstripe/models/account.py def persons ( self , ** params ): return self . request ( \"get\" , self . instance_url () + \"/persons\" , params ) djstripe . models . account . Account . stripe_class . persons_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . persons_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . reject ( self , idempotency_key = None , ** params ) Source code in djstripe/models/account.py def reject ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reject\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . account . Account . stripe_class . retrieve ( id = None , api_key = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def retrieve ( cls , id = None , api_key = None , ** params ): instance = cls ( id , api_key , ** params ) instance . refresh () return instance djstripe . models . account . Account . stripe_class . retrieve_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . serialize ( self , previous ) Source code in djstripe/models/account.py def serialize ( self , previous ): params = super ( Account , self ) . serialize ( previous ) previous = previous or self . _previous or {} for k , v in six . iteritems ( self ): if ( k == \"individual\" and isinstance ( v , stripe . api_resources . Person ) and k not in params ): params [ k ] = v . serialize ( previous . get ( k , None )) return params djstripe . models . account . Account . __str__ ( self ) special Source code in djstripe/models/account.py def __str__ ( self ): settings = self . settings or {} business_profile = self . business_profile or {} return ( settings . get ( \"dashboard\" , {}) . get ( \"display_name\" ) or business_profile . get ( \"name\" ) or super () . __str__ () ) djstripe . models . account . Account . get_business_type_display ( self , * , field =< djstripe . fields . StripeEnumField : business_type > ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_connected_account_from_token ( access_token ) classmethod Source code in djstripe/models/account.py @classmethod def get_connected_account_from_token ( cls , access_token ): warnings . warn ( \"Account.get_connected_account_from_token is deprecated.\" \"Use Account.get_or_retrieve_for_api_key() instead.\" , DeprecationWarning , ) account_data = cls . stripe_class . retrieve ( api_key = access_token ) return cls . _get_or_create_from_stripe_object ( account_data )[ 0 ] djstripe . models . account . Account . get_default_account () classmethod Source code in djstripe/models/account.py @classmethod def get_default_account ( cls ): # As of API version 2020-03-02, there is no permission that can allow # restricted keys to call GET /v1/account if djstripe_settings . STRIPE_SECRET_KEY . startswith ( \"rk_\" ): return None account_data = cls . stripe_class . retrieve ( api_key = djstripe_settings . STRIPE_SECRET_KEY ) return cls . _get_or_create_from_stripe_object ( account_data )[ 0 ] djstripe . models . account . Account . get_default_api_key ( self ) Source code in djstripe/models/account.py def get_default_api_key ( self ) -> str : api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret ) . first () if api_key : return api_key . secret return djstripe_settings . get_default_api_key ( self . livemode ) djstripe . models . account . Account . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_or_retrieve_for_api_key ( api_key ) classmethod Source code in djstripe/models/account.py @classmethod def get_or_retrieve_for_api_key ( cls , api_key : str ): with transaction . atomic (): apikey_instance , _ = APIKey . objects . get_or_create_by_api_key ( api_key ) if not apikey_instance . djstripe_owner_account : apikey_instance . refresh_account () return apikey_instance . djstripe_owner_account djstripe . models . account . Account . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Classes djstripe.models.connect.ApplicationFee When you collect a transaction fee on top of a charge made for your user (using Connect), an ApplicationFee is created in your account. Stripe documentation: https://stripe.com/docs/api#application_fees djstripe . models . connect . ApplicationFee . amount djstripe . models . connect . ApplicationFee . amount_refunded djstripe . models . connect . ApplicationFee . balance_transaction djstripe . models . connect . ApplicationFee . charge djstripe . models . connect . ApplicationFee . currency djstripe . models . connect . ApplicationFee . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . ApplicationFee . refunded djstripe.models.connect.ApplicationFee.DoesNotExist djstripe.models.connect.ApplicationFee.MultipleObjectsReturned djstripe.models.connect.ApplicationFee.stripe_class djstripe . models . connect . ApplicationFee . stripe_class . OBJECT_NAME djstripe . models . connect . ApplicationFee . stripe_class . create_refund ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . list_refunds ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . modify_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def refund ( self , idempotency_key = None , ** params ): headers = util . populate_headers ( idempotency_key ) url = self . instance_url () + \"/refund\" self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . ApplicationFee . stripe_class . refunds_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . ApplicationFee . stripe_class . refunds_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . connect . ApplicationFee . stripe_class . retrieve_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . ApplicationFee . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.connect.ApplicationFeeRefund ApplicationFeeRefund objects allow you to refund an ApplicationFee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected. Stripe documentation: https://stripe.com/docs/api#fee_refunds djstripe . models . connect . ApplicationFeeRefund . amount djstripe . models . connect . ApplicationFeeRefund . balance_transaction djstripe . models . connect . ApplicationFeeRefund . currency djstripe . models . connect . ApplicationFeeRefund . description djstripe . models . connect . ApplicationFeeRefund . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . ApplicationFeeRefund . fee djstripe.models.connect.ApplicationFeeRefund.DoesNotExist djstripe.models.connect.ApplicationFeeRefund.MultipleObjectsReturned djstripe . models . connect . ApplicationFeeRefund . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.connect.CountrySpec Stripe documentation: https://stripe.com/docs/api#country_specs djstripe . models . connect . CountrySpec . created djstripe . models . connect . CountrySpec . default_currency djstripe . models . connect . CountrySpec . description djstripe . models . connect . CountrySpec . djstripe_id djstripe . models . connect . CountrySpec . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . CountrySpec . livemode djstripe . models . connect . CountrySpec . metadata djstripe . models . connect . CountrySpec . supported_bank_account_currencies djstripe . models . connect . CountrySpec . supported_payment_currencies djstripe . models . connect . CountrySpec . supported_payment_methods djstripe . models . connect . CountrySpec . supported_transfer_countries djstripe . models . connect . CountrySpec . verification_fields djstripe.models.connect.CountrySpec.DoesNotExist djstripe.models.connect.CountrySpec.MultipleObjectsReturned djstripe.models.connect.CountrySpec.stripe_class djstripe . models . connect . CountrySpec . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.connect.Transfer When Stripe sends you money or you initiate a transfer to a bank account, debit card, or connected Stripe account, a transfer object will be created. Stripe documentation: https://stripe.com/docs/api/python#transfers djstripe . models . connect . Transfer . amount djstripe . models . connect . Transfer . amount_reversed djstripe . models . connect . Transfer . balance_transaction djstripe . models . connect . Transfer . currency djstripe . models . connect . Transfer . destination djstripe . models . connect . Transfer . destination_payment djstripe . models . connect . Transfer . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . Transfer . expand_fields : List [ str ] djstripe . models . connect . Transfer . fee property readonly djstripe . models . connect . Transfer . objects djstripe . models . connect . Transfer . reversed djstripe . models . connect . Transfer . source_transaction djstripe . models . connect . Transfer . source_type djstripe . models . connect . Transfer . stripe_dashboard_item_name djstripe . models . connect . Transfer . transfer_group djstripe.models.connect.Transfer.DoesNotExist djstripe.models.connect.Transfer.MultipleObjectsReturned djstripe.models.connect.Transfer.stripe_class djstripe . models . connect . Transfer . stripe_class . OBJECT_NAME djstripe . models . connect . Transfer . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . Transfer . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . Transfer . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . connect . Transfer . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_source_type_display ( self , * , field =< djstripe . fields . StripeEnumField : source_type > ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/connect.py def str_parts ( self ): return [ \"amount= {amount} \" . format ( amount = self . amount )] + super () . str_parts () djstripe.models.connect.TransferReversal Stripe documentation: https://stripe.com/docs/api#transfer_reversals djstripe . models . connect . TransferReversal . amount djstripe . models . connect . TransferReversal . balance_transaction djstripe . models . connect . TransferReversal . currency djstripe . models . connect . TransferReversal . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . TransferReversal . transfer djstripe.models.connect.TransferReversal.DoesNotExist djstripe.models.connect.TransferReversal.MultipleObjectsReturned djstripe.models.connect.TransferReversal.stripe_class djstripe . models . connect . TransferReversal . stripe_class . OBJECT_NAME djstripe . models . connect . TransferReversal . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . TransferReversal . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . TransferReversal . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . connect . TransferReversal . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Fraud Orders Sigma Classes djstripe.models.sigma.ScheduledQueryRun Stripe documentation: https://stripe.com/docs/api#scheduled_queries djstripe . models . sigma . ScheduledQueryRun . data_load_time djstripe . models . sigma . ScheduledQueryRun . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . sigma . ScheduledQueryRun . error djstripe . models . sigma . ScheduledQueryRun . file djstripe . models . sigma . ScheduledQueryRun . result_available_until djstripe . models . sigma . ScheduledQueryRun . sql djstripe . models . sigma . ScheduledQueryRun . status djstripe . models . sigma . ScheduledQueryRun . title djstripe.models.sigma.ScheduledQueryRun.DoesNotExist djstripe.models.sigma.ScheduledQueryRun.MultipleObjectsReturned djstripe.models.sigma.ScheduledQueryRun.stripe_class djstripe . models . sigma . ScheduledQueryRun . stripe_class . OBJECT_NAME djstripe . models . sigma . ScheduledQueryRun . stripe_class . class_url () classmethod Source code in djstripe/models/sigma.py @classmethod def class_url ( cls ): return \"/v1/sigma/scheduled_query_runs\" djstripe . models . sigma . ScheduledQueryRun . get_next_by_data_load_time ( self , * , field =< djstripe . fields . StripeDateTimeField : data_load_time > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_result_available_until ( self , * , field =< djstripe . fields . StripeDateTimeField : result_available_until > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_data_load_time ( self , * , field =< djstripe . fields . StripeDateTimeField : data_load_time > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_result_available_until ( self , * , field =< djstripe . fields . StripeDateTimeField : result_available_until > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Webhooks Classes djstripe.models.webhooks.WebhookEventTrigger An instance of a request that reached the server endpoint for Stripe webhooks. Webhook Events are initially UNTRUSTED , as it is possible for any web entity to post any data to our webhook url. Data posted may be valid Stripe information, garbage, or even malicious. The 'valid' flag in this model monitors this. djstripe . models . webhooks . WebhookEventTrigger . body djstripe . models . webhooks . WebhookEventTrigger . created djstripe . models . webhooks . WebhookEventTrigger . djstripe_version djstripe . models . webhooks . WebhookEventTrigger . event djstripe . models . webhooks . WebhookEventTrigger . exception djstripe . models . webhooks . WebhookEventTrigger . headers djstripe . models . webhooks . WebhookEventTrigger . id djstripe . models . webhooks . WebhookEventTrigger . is_test_event property readonly djstripe . models . webhooks . WebhookEventTrigger . processed djstripe . models . webhooks . WebhookEventTrigger . remote_ip djstripe . models . webhooks . WebhookEventTrigger . traceback djstripe . models . webhooks . WebhookEventTrigger . updated djstripe . models . webhooks . WebhookEventTrigger . valid djstripe.models.webhooks.WebhookEventTrigger.DoesNotExist djstripe.models.webhooks.WebhookEventTrigger.MultipleObjectsReturned Methods djstripe . models . webhooks . WebhookEventTrigger . from_request ( request ) classmethod Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). Source code in djstripe/models/webhooks.py @classmethod def from_request ( cls , request ): \"\"\" Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). \"\"\" try : body = request . body . decode ( request . encoding or \"utf-8\" ) except Exception : body = \"(error decoding body)\" ip = request . META . get ( \"REMOTE_ADDR\" ) if not ip : warnings . warn ( \"Could not determine remote IP (missing REMOTE_ADDR). \" \"This is likely an issue with your wsgi/server setup.\" ) ip = \"0.0.0.0\" obj = cls . objects . create ( headers = dict ( request . headers ), body = body , remote_ip = ip ) try : obj . valid = obj . validate () if obj . valid : if djstripe_settings . WEBHOOK_EVENT_CALLBACK : # If WEBHOOK_EVENT_CALLBACK, pass it for processing djstripe_settings . WEBHOOK_EVENT_CALLBACK ( obj ) else : # Process the item (do not save it, it'll get saved below) obj . process ( save = False ) except Exception as e : max_length = WebhookEventTrigger . _meta . get_field ( \"exception\" ) . max_length obj . exception = str ( e )[: max_length ] obj . traceback = format_exc () # Send the exception as the webhook_processing_error signal webhook_processing_error . send ( sender = WebhookEventTrigger , exception = e , data = getattr ( e , \"http_body\" , \"\" ), ) # re-raise the exception so Django sees it raise e finally : obj . save () return obj djstripe . models . webhooks . WebhookEventTrigger . get_next_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = True , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_next_by_updated ( self , * , field =< django . db . models . fields . DateTimeField : updated > , is_next = True , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_previous_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = False , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_previous_by_updated ( self , * , field =< django . db . models . fields . DateTimeField : updated > , is_next = False , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . process ( self , save = True ) Source code in djstripe/models/webhooks.py def process ( self , save = True ): # Reset traceback and exception in case of reprocessing self . exception = \"\" self . traceback = \"\" self . event = Event . process ( self . json_body ) self . processed = True if save : self . save () return self . event djstripe . models . webhooks . WebhookEventTrigger . validate ( self , api_key = None ) The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. Source code in djstripe/models/webhooks.py def validate ( self , api_key = None ): \"\"\" The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. \"\"\" local_data = self . json_body if \"id\" not in local_data or \"livemode\" not in local_data : return False if self . is_test_event : logger . info ( \"Test webhook received: {} \" . format ( local_data )) return False if djstripe_settings . WEBHOOK_VALIDATION is None : # validation disabled return True elif ( djstripe_settings . WEBHOOK_VALIDATION == \"verify_signature\" and djstripe_settings . WEBHOOK_SECRET ): # HTTP headers are case-insensitive, but we store them as a dict. headers = CaseInsensitiveMapping ( self . headers ) try : stripe . WebhookSignature . verify_header ( self . body , headers . get ( \"stripe-signature\" ), djstripe_settings . WEBHOOK_SECRET , djstripe_settings . WEBHOOK_TOLERANCE , ) except stripe . error . SignatureVerificationError : return False else : return True livemode = local_data [ \"livemode\" ] api_key = api_key or djstripe_settings . get_default_api_key ( livemode ) # Retrieve the event using the api_version specified in itself with stripe_temporary_api_version ( local_data [ \"api_version\" ], validate = False ): remote_data = Event . stripe_class . retrieve ( id = local_data [ \"id\" ], api_key = api_key ) return local_data [ \"data\" ] == remote_data [ \"data\" ]","title":"Models"},{"location":"reference/models/#models","text":"Models hold the bulk of the functionality included in the dj-stripe package. Each model is tied closely to its corresponding object in the stripe dashboard. Fields that are not implemented for each model have a short reason behind the decision in the docstring for each model.","title":"Models"},{"location":"reference/models/#core-resources","text":"","title":"Core Resources"},{"location":"reference/models/#djstripe.models.core-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction","text":"A single transaction that updates the Stripe balance. Stripe documentation: https://stripe.com/docs/api#balance_transaction_object","title":"BalanceTransaction"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.available_on","text":"","title":"available_on"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.exchange_rate","text":"","title":"exchange_rate"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.fee_details","text":"","title":"fee_details"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.net","text":"","title":"net"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.reporting_category","text":"","title":"reporting_category"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.source","text":"","title":"source"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_next_by_available_on","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_available_on()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_previous_by_available_on","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_available_on()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_reporting_category_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_reporting_category_display()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_source_class","text":"Source code in djstripe/models/core.py def get_source_class ( self ): return apps . get_model ( \"djstripe\" , self . type )","title":"get_source_class()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_source_instance","text":"Source code in djstripe/models/core.py def get_source_instance ( self ): return self . get_source_class () . objects . get ( id = self . source )","title":"get_source_instance()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_stripe_dashboard_url","text":"Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . get_source_instance () . get_stripe_dashboard_url ()","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.core.BalanceTransaction.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.Charge","text":"To charge a credit or a debit card, you create a charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique random ID. Stripe documentation: https://stripe.com/docs/api/python#charges","title":"Charge"},{"location":"reference/models/#djstripe.models.core.Charge.account","text":"","title":"account"},{"location":"reference/models/#djstripe.models.core.Charge.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Charge.amount_captured","text":"","title":"amount_captured"},{"location":"reference/models/#djstripe.models.core.Charge.amount_refunded","text":"","title":"amount_refunded"},{"location":"reference/models/#djstripe.models.core.Charge.application","text":"","title":"application"},{"location":"reference/models/#djstripe.models.core.Charge.application_fee","text":"","title":"application_fee"},{"location":"reference/models/#djstripe.models.core.Charge.application_fee_amount","text":"","title":"application_fee_amount"},{"location":"reference/models/#djstripe.models.core.Charge.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Charge.billing_details","text":"","title":"billing_details"},{"location":"reference/models/#djstripe.models.core.Charge.calculated_statement_descriptor","text":"","title":"calculated_statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Charge.captured","text":"","title":"captured"},{"location":"reference/models/#djstripe.models.core.Charge.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Charge.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.Charge.dispute","text":"","title":"dispute"},{"location":"reference/models/#djstripe.models.core.Charge.disputed","text":"","title":"disputed"},{"location":"reference/models/#djstripe.models.core.Charge.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Charge.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Charge.failure_code","text":"","title":"failure_code"},{"location":"reference/models/#djstripe.models.core.Charge.failure_message","text":"","title":"failure_message"},{"location":"reference/models/#djstripe.models.core.Charge.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.core.Charge.fraud_details","text":"","title":"fraud_details"},{"location":"reference/models/#djstripe.models.core.Charge.fraudulent","text":"","title":"fraudulent"},{"location":"reference/models/#djstripe.models.core.Charge.human_readable_amount","text":"","title":"human_readable_amount"},{"location":"reference/models/#djstripe.models.core.Charge.human_readable_status","text":"","title":"human_readable_status"},{"location":"reference/models/#djstripe.models.core.Charge.invoice","text":"","title":"invoice"},{"location":"reference/models/#djstripe.models.core.Charge.objects","text":"","title":"objects"},{"location":"reference/models/#djstripe.models.core.Charge.on_behalf_of","text":"","title":"on_behalf_of"},{"location":"reference/models/#djstripe.models.core.Charge.outcome","text":"","title":"outcome"},{"location":"reference/models/#djstripe.models.core.Charge.paid","text":"","title":"paid"},{"location":"reference/models/#djstripe.models.core.Charge.payment_intent","text":"","title":"payment_intent"},{"location":"reference/models/#djstripe.models.core.Charge.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.Charge.payment_method_details","text":"","title":"payment_method_details"},{"location":"reference/models/#djstripe.models.core.Charge.receipt_email","text":"","title":"receipt_email"},{"location":"reference/models/#djstripe.models.core.Charge.receipt_number","text":"","title":"receipt_number"},{"location":"reference/models/#djstripe.models.core.Charge.receipt_url","text":"","title":"receipt_url"},{"location":"reference/models/#djstripe.models.core.Charge.refunded","text":"","title":"refunded"},{"location":"reference/models/#djstripe.models.core.Charge.shipping","text":"","title":"shipping"},{"location":"reference/models/#djstripe.models.core.Charge.source","text":"","title":"source"},{"location":"reference/models/#djstripe.models.core.Charge.source_transfer","text":"","title":"source_transfer"},{"location":"reference/models/#djstripe.models.core.Charge.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Charge.statement_descriptor_suffix","text":"","title":"statement_descriptor_suffix"},{"location":"reference/models/#djstripe.models.core.Charge.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Charge.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Charge.transfer","text":"","title":"transfer"},{"location":"reference/models/#djstripe.models.core.Charge.transfer_data","text":"","title":"transfer_data"},{"location":"reference/models/#djstripe.models.core.Charge.transfer_group","text":"","title":"transfer_group"},{"location":"reference/models/#djstripe.models.core.Charge.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Charge.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Charge.stripe_class","text":"djstripe . models . core . Charge . stripe_class . OBJECT_NAME djstripe . models . core . Charge . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . close_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute/close\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute djstripe . models . core . Charge . stripe_class . mark_as_fraudulent ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_fraudulent ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"fraudulent\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . mark_as_safe ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_safe ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"safe\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def refund ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/refund\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . update_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def update_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Charge-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.Charge.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): amount = self . human_readable_amount status = self . human_readable_status if not status : return amount return \" {amount} ( {status} )\" . format ( amount = amount , status = status )","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Charge.capture","text":"Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge Source code in djstripe/models/core.py def capture ( self , ** kwargs ) -> \"Charge\" : \"\"\" Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge \"\"\" captured_charge = self . api_retrieve () . capture ( ** kwargs ) return self . __class__ . sync_from_stripe_data ( captured_charge )","title":"capture()"},{"location":"reference/models/#djstripe.models.core.Charge.get_failure_code_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_failure_code_display()"},{"location":"reference/models/#djstripe.models.core.Charge.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Charge.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Charge.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Charge.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Charge.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.Charge.refund","text":"Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are duplicate , fraudulent , and requested_by_customer . Specifying fraudulent as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. Source code in djstripe/models/core.py def refund ( self , amount : Decimal = None , reason : str = None ) -> \"Charge\" : \"\"\" Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are ``duplicate``, ``fraudulent``, and ``requested_by_customer``. Specifying ``fraudulent`` as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. \"\"\" charge_obj = self . api_retrieve () . refund ( amount = self . _calculate_refund_amount ( amount = amount ), reason = reason ) return self . __class__ . sync_from_stripe_data ( charge_obj )","title":"refund()"},{"location":"reference/models/#djstripe.models.core.Customer","text":"Customer objects allow you to perform recurring charges and track multiple charges that are associated with the same customer. Stripe documentation: https://stripe.com/docs/api/python#customers","title":"Customer"},{"location":"reference/models/#djstripe.models.core.Customer-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.core.Customer.active_subscriptions","text":"Returns active subscriptions (subscriptions with an active status that end in the future).","title":"active_subscriptions"},{"location":"reference/models/#djstripe.models.core.Customer.address","text":"","title":"address"},{"location":"reference/models/#djstripe.models.core.Customer.balance","text":"","title":"balance"},{"location":"reference/models/#djstripe.models.core.Customer.business_vat_id","text":"","title":"business_vat_id"},{"location":"reference/models/#djstripe.models.core.Customer.coupon","text":"","title":"coupon"},{"location":"reference/models/#djstripe.models.core.Customer.coupon_end","text":"","title":"coupon_end"},{"location":"reference/models/#djstripe.models.core.Customer.coupon_start","text":"","title":"coupon_start"},{"location":"reference/models/#djstripe.models.core.Customer.credits","text":"The customer is considered to have credits if their balance is below 0.","title":"credits"},{"location":"reference/models/#djstripe.models.core.Customer.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Customer.customer_payment_methods","text":"An iterable of all of the customer's payment methods (sources, then legacy cards)","title":"customer_payment_methods"},{"location":"reference/models/#djstripe.models.core.Customer.date_purged","text":"","title":"date_purged"},{"location":"reference/models/#djstripe.models.core.Customer.default_payment_method","text":"","title":"default_payment_method"},{"location":"reference/models/#djstripe.models.core.Customer.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.core.Customer.delinquent","text":"","title":"delinquent"},{"location":"reference/models/#djstripe.models.core.Customer.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Customer.email","text":"","title":"email"},{"location":"reference/models/#djstripe.models.core.Customer.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Customer.invoice_prefix","text":"","title":"invoice_prefix"},{"location":"reference/models/#djstripe.models.core.Customer.invoice_settings","text":"","title":"invoice_settings"},{"location":"reference/models/#djstripe.models.core.Customer.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.core.Customer.pending_charges","text":"The customer is considered to have pending charges if their balance is above 0.","title":"pending_charges"},{"location":"reference/models/#djstripe.models.core.Customer.phone","text":"","title":"phone"},{"location":"reference/models/#djstripe.models.core.Customer.preferred_locales","text":"","title":"preferred_locales"},{"location":"reference/models/#djstripe.models.core.Customer.shipping","text":"","title":"shipping"},{"location":"reference/models/#djstripe.models.core.Customer.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Customer.subscriber","text":"","title":"subscriber"},{"location":"reference/models/#djstripe.models.core.Customer.subscription","text":"Shortcut to get this customer's subscription. :returns: None if the customer has no subscriptions, the subscription if the customer has a subscription. :raises MultipleSubscriptionException: Raised if the customer has multiple subscriptions. In this case, use Customer.subscriptions instead.","title":"subscription"},{"location":"reference/models/#djstripe.models.core.Customer.tax_exempt","text":"","title":"tax_exempt"},{"location":"reference/models/#djstripe.models.core.Customer.valid_subscriptions","text":"Returns this customer's valid subscriptions (subscriptions that aren't canceled or incomplete_expired).","title":"valid_subscriptions"},{"location":"reference/models/#djstripe.models.core.Customer.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Customer.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Customer.stripe_class","text":"djstripe . models . core . Customer . stripe_class . OBJECT_NAME djstripe . models . core . Customer . stripe_class . balance_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . balance_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . create_balance_transaction ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_source ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_tax_id ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/core.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True ) djstripe . models . core . Customer . stripe_class . delete_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_balance_transactions ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_payment_methods ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def list_payment_methods ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/payment_methods\" headers = util . populate_headers ( idempotency_key ) resp = self . request ( \"get\" , url , params , headers ) stripe_object = util . convert_to_stripe_object ( resp ) stripe_object . _retrieve_params = params return stripe_object djstripe . models . core . Customer . stripe_class . list_sources ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_tax_ids ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . sources_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . sources_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . tax_ids_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . tax_ids_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Customer-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.Customer.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): if self . subscriber : return str ( self . subscriber ) return self . name or self . description or self . id","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Customer.add_card","text":"Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean Source code in djstripe/models/core.py def add_card ( self , source , set_default = True ): \"\"\" Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean \"\"\" from .payment_methods import DjstripePaymentMethod stripe_customer = self . api_retrieve () new_stripe_payment_method = stripe_customer . sources . create ( source = source ) if set_default : stripe_customer . default_source = new_stripe_payment_method [ \"id\" ] stripe_customer . save () new_payment_method = DjstripePaymentMethod . from_stripe_object ( new_stripe_payment_method ) # Change the default source if set_default : self . default_source = new_payment_method self . save () return new_payment_method . resolve ()","title":"add_card()"},{"location":"reference/models/#djstripe.models.core.Customer.add_coupon","text":"Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. Source code in djstripe/models/core.py def add_coupon ( self , coupon , idempotency_key = None ): \"\"\" Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. \"\"\" if isinstance ( coupon , StripeModel ): coupon = coupon . id stripe_customer = self . api_retrieve () stripe_customer [ \"coupon\" ] = coupon stripe_customer . save ( idempotency_key = idempotency_key ) return self . __class__ . sync_from_stripe_data ( stripe_customer )","title":"add_coupon()"},{"location":"reference/models/#djstripe.models.core.Customer.add_invoice_item","text":"Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. Use this when adding invoice items in response to an invoice.created webhook. You cannot add an invoice item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using Customer.add_invoice_item() instead of .. Customer.add_invoice_item() , invoice and subscriptions .. can only be strings Source code in djstripe/models/core.py def add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None , ): \"\"\" Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming \\ scheduled invoice. \\ Use this when adding invoice items in response to an \\ ``invoice.created`` webhook. You cannot add an invoice \\ item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming \\ scheduled invoice. When set, scheduled invoices for subscriptions other \\ than the specified subscription will ignore the invoice item. \\ Use this when you want to express that an invoice item has been accrued \\ within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using ``Customer.add_invoice_item()`` instead of .. ``Customer.add_invoice_item()``, ``invoice`` and ``subscriptions`` .. can only be strings \"\"\" from .billing import InvoiceItem if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Invoice to id if invoice is not None and isinstance ( invoice , StripeModel ): invoice = invoice . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id stripe_invoiceitem = InvoiceItem . _api_create ( amount = int ( amount * 100 ), # Convert dollars into cents currency = currency , customer = self . id , description = description , discountable = discountable , invoice = invoice , metadata = metadata , subscription = subscription , ) return InvoiceItem . sync_from_stripe_data ( stripe_invoiceitem )","title":"add_invoice_item()"},{"location":"reference/models/#djstripe.models.core.Customer.add_payment_method","text":"Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod Source code in djstripe/models/core.py def add_payment_method ( self , payment_method , set_default = True ): \"\"\" Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod \"\"\" from .payment_methods import PaymentMethod stripe_customer = self . api_retrieve () payment_method = PaymentMethod . attach ( payment_method , stripe_customer ) if set_default : stripe_customer [ \"invoice_settings\" ][ \"default_payment_method\" ] = payment_method . id stripe_customer . save () # Refresh self from the stripe customer, this should have two effects: # 1) sets self.default_payment_method (we rely on logic in # Customer._manipulate_stripe_object_hook to do this) # 2) updates self.invoice_settings.default_payment_methods self . sync_from_stripe_data ( stripe_customer ) self . refresh_from_db () return payment_method","title":"add_payment_method()"},{"location":"reference/models/#djstripe.models.core.Customer.can_charge","text":"Determines if this customer is able to be charged. Source code in djstripe/models/core.py def can_charge ( self ): \"\"\"Determines if this customer is able to be charged.\"\"\" return ( self . has_valid_source () or self . default_payment_method is not None ) and self . date_purged is None","title":"can_charge()"},{"location":"reference/models/#djstripe.models.core.Customer.charge","text":"Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source Source code in djstripe/models/core.py def charge ( self , amount : Decimal , * , application_fee : Decimal = None , source : Union [ str , StripeModel ] = None , ** kwargs ) -> Charge : \"\"\" Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source \"\"\" if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Source to id if source and isinstance ( source , StripeModel ): source = source . id stripe_charge = Charge . _api_create ( customer = self . id , amount = int ( amount * 100 ), # Convert dollars into cents application_fee = int ( application_fee * 100 ) if application_fee else None , # Convert dollars into cents source = source , ** kwargs ) return Charge . sync_from_stripe_data ( stripe_charge )","title":"charge()"},{"location":"reference/models/#djstripe.models.core.Customer.create","text":"Source code in djstripe/models/core.py @classmethod def create ( cls , subscriber , idempotency_key = None , stripe_account = None ): metadata = {} subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key not in ( \"\" , None ): metadata [ subscriber_key ] = subscriber . pk stripe_customer = cls . _api_create ( email = subscriber . email , idempotency_key = idempotency_key , metadata = metadata , stripe_account = stripe_account , ) customer , created = Customer . objects . get_or_create ( id = stripe_customer [ \"id\" ], defaults = { \"subscriber\" : subscriber , \"livemode\" : stripe_customer [ \"livemode\" ], \"balance\" : stripe_customer . get ( \"balance\" , 0 ), \"delinquent\" : stripe_customer . get ( \"delinquent\" , False ), }, ) return customer","title":"create()"},{"location":"reference/models/#djstripe.models.core.Customer.delete","text":"Overriding the delete method to keep the customer in the records. All identifying information is removed via the purge() method. The only way to delete a customer is to use SQL. Source code in djstripe/models/core.py def delete ( self , using = None , keep_parents = False ): \"\"\" Overriding the delete method to keep the customer in the records. All identifying information is removed via the purge() method. The only way to delete a customer is to use SQL. \"\"\" self . purge ()","title":"delete()"},{"location":"reference/models/#djstripe.models.core.Customer.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Customer.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Customer.get_or_create","text":"Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None , ): \"\"\" Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool \"\"\" try : return Customer . objects . get ( subscriber = subscriber , livemode = livemode ), False except Customer . DoesNotExist : action = \"create: {} \" . format ( subscriber . pk ) idempotency_key = djstripe_settings . get_idempotency_key ( \"customer\" , action , livemode ) return ( cls . create ( subscriber , idempotency_key = idempotency_key , stripe_account = stripe_account , ), True , )","title":"get_or_create()"},{"location":"reference/models/#djstripe.models.core.Customer.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Customer.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Customer.get_tax_exempt_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_tax_exempt_display()"},{"location":"reference/models/#djstripe.models.core.Customer.has_active_subscription","text":"Checks to see if this customer has an active subscription to the given plan. :param plan: The plan for which to check for an active subscription. If plan is None and there exists only one active subscription, this method will check if that subscription is valid. Calling this method with no plan and multiple valid subscriptions for this customer will throw an exception. :type plan: Plan or string (plan ID) :returns: True if there exists an active subscription, False otherwise. :throws: TypeError if plan is None and more than one active subscription exists for this customer. Source code in djstripe/models/core.py def has_active_subscription ( self , plan = None ): \"\"\" Checks to see if this customer has an active subscription to the given plan. :param plan: The plan for which to check for an active subscription. If plan is None and there exists only one active subscription, this method will check if that subscription is valid. Calling this method with no plan and multiple valid subscriptions for this customer will throw an exception. :type plan: Plan or string (plan ID) :returns: True if there exists an active subscription, False otherwise. :throws: TypeError if ``plan`` is None and more than one active subscription exists for this customer. \"\"\" warnings . warn ( \"has_active_subscription is deprecated in favor of `is_subscribed_to` \" \"and will be removed in a future release.\" , DeprecationWarning , ) if plan is None : valid_subscriptions = self . _get_valid_subscriptions () if len ( valid_subscriptions ) == 0 : return False elif len ( valid_subscriptions ) == 1 : return True else : raise TypeError ( \"plan cannot be None if more than one valid subscription \" \"exists for this customer.\" ) else : # Convert Plan to id if isinstance ( plan , StripeModel ): plan = plan . id return any ( [ subscription . is_valid () for subscription in self . subscriptions . filter ( plan__id = plan ) ] )","title":"has_active_subscription()"},{"location":"reference/models/#djstripe.models.core.Customer.has_any_active_subscription","text":"Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def has_any_active_subscription ( self ): \"\"\" Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. \"\"\" return len ( self . _get_valid_subscriptions ()) != 0","title":"has_any_active_subscription()"},{"location":"reference/models/#djstripe.models.core.Customer.has_valid_source","text":"Check whether the customer has a valid payment source. Source code in djstripe/models/core.py def has_valid_source ( self ): \"\"\"Check whether the customer has a valid payment source.\"\"\" return self . default_source is not None","title":"has_valid_source()"},{"location":"reference/models/#djstripe.models.core.Customer.is_subscribed_to","text":"Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def is_subscribed_to ( self , product : Union [ Product , str ]) -> bool : \"\"\" Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. \"\"\" if isinstance ( product , StripeModel ): product = product . id for subscription in self . _get_valid_subscriptions (): for item in subscription . items . all (): if item . price and item . price . product . id == product : return True return False","title":"is_subscribed_to()"},{"location":"reference/models/#djstripe.models.core.Customer.purge","text":"Source code in djstripe/models/core.py def purge ( self ): try : self . _api_delete () except InvalidRequestError as exc : if \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer was already # deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise if self . subscriber : # Delete the idempotency key used by Customer.create() # So re-creating a customer for this subscriber before the key expires # doesn't return the older Customer data idempotency_key_action = \"customer:create: {} \" . format ( self . subscriber . pk ) IdempotencyKey . objects . filter ( action = idempotency_key_action ) . delete () self . subscriber = None # Remove sources self . default_source = None for source in self . legacy_cards . all (): source . remove () for source in self . sources . all (): source . detach () self . date_purged = timezone . now () self . save ()","title":"purge()"},{"location":"reference/models/#djstripe.models.core.Customer.retry_unpaid_invoices","text":"Attempt to retry collecting payment on the customer's unpaid invoices. Source code in djstripe/models/core.py def retry_unpaid_invoices ( self ): \"\"\"Attempt to retry collecting payment on the customer's unpaid invoices.\"\"\" self . _sync_invoices () for invoice in self . invoices . filter ( auto_advance = True ) . exclude ( status = \"paid\" ): try : invoice . retry () # Always retry unpaid invoices except InvalidRequestError as exc : if str ( exc ) != \"Invoice is already paid\" : raise","title":"retry_unpaid_invoices()"},{"location":"reference/models/#djstripe.models.core.Customer.send_invoice","text":"Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). Source code in djstripe/models/core.py def send_invoice ( self ): \"\"\" Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). \"\"\" from .billing import Invoice try : invoice = Invoice . _api_create ( customer = self . id ) invoice . pay () return True except InvalidRequestError : # TODO: Check this for a more # specific error message. return False # There was nothing to invoice","title":"send_invoice()"},{"location":"reference/models/#djstripe.models.core.Customer.subscribe","text":"Subscribes this customer to a price. NOTE: Only one item is supported at the moment. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) :param charge_immediately: Whether or not to charge for the subscription upon creation. If False, an invoice will be created at the end of this period. :type charge_immediately: boolean .. Notes: .. charge_immediately is only available on Customer.subscribe() .. if you're using Customer.subscribe() .. instead of Customer.subscribe() , plan can only be a string Source code in djstripe/models/core.py def subscribe ( self , price = None , plan = None , charge_immediately = True , ** kwargs ): \"\"\" Subscribes this customer to a price. NOTE: Only one item is supported at the moment. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) :param charge_immediately: Whether or not to charge for the subscription upon creation. If False, an invoice will be created at the end of this period. :type charge_immediately: boolean .. Notes: .. ``charge_immediately`` is only available on ``Customer.subscribe()`` .. if you're using ``Customer.subscribe()`` .. instead of ``Customer.subscribe()``, ``plan`` can only be a string \"\"\" from .billing import Subscription if price and plan : raise TypeError ( \"price and plan arguments cannot both be defined.\" ) price = price or plan if not price : raise TypeError ( \"you need to set either price or plan\" ) # Convert Price to id if isinstance ( price , StripeModel ): price = price . id stripe_subscription = Subscription . _api_create ( items = [{ \"price\" : price }], customer = self . id , ** kwargs ) if charge_immediately : self . send_invoice () return Subscription . sync_from_stripe_data ( stripe_subscription )","title":"subscribe()"},{"location":"reference/models/#djstripe.models.core.Customer.upcoming_invoice","text":"Gets the upcoming preview invoice (singular) for this customer. See Invoice.upcoming() <#djstripe.Invoice.upcoming> __. The customer argument to the upcoming() call is automatically set by this method. Source code in djstripe/models/core.py def upcoming_invoice ( self , ** kwargs ): \"\"\"Gets the upcoming preview invoice (singular) for this customer. See `Invoice.upcoming() <#djstripe.Invoice.upcoming>`__. The ``customer`` argument to the ``upcoming()`` call is automatically set by this method. \"\"\" from .billing import Invoice kwargs [ \"customer\" ] = self return Invoice . upcoming ( ** kwargs )","title":"upcoming_invoice()"},{"location":"reference/models/#djstripe.models.core.Dispute","text":"Stripe documentation: https://stripe.com/docs/api#disputes","title":"Dispute"},{"location":"reference/models/#djstripe.models.core.Dispute.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Dispute.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Dispute.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Dispute.evidence","text":"","title":"evidence"},{"location":"reference/models/#djstripe.models.core.Dispute.evidence_details","text":"","title":"evidence_details"},{"location":"reference/models/#djstripe.models.core.Dispute.is_charge_refundable","text":"","title":"is_charge_refundable"},{"location":"reference/models/#djstripe.models.core.Dispute.reason","text":"","title":"reason"},{"location":"reference/models/#djstripe.models.core.Dispute.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Dispute.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Dispute.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Dispute.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Dispute.stripe_class","text":"djstripe . models . core . Dispute . stripe_class . OBJECT_NAME djstripe . models . core . Dispute . stripe_class . close ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/close\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Dispute.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_reason_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_reason_display()"},{"location":"reference/models/#djstripe.models.core.Dispute.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.Event","text":"Events are Stripe's way of letting you know when something interesting happens in your account. When an interesting event occurs, a new Event object is created and POSTed to the configured webhook URL if the Event type matches. Stripe documentation: https://stripe.com/docs/api/events","title":"Event"},{"location":"reference/models/#djstripe.models.core.Event.api_version","text":"","title":"api_version"},{"location":"reference/models/#djstripe.models.core.Event.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.Event.data","text":"","title":"data"},{"location":"reference/models/#djstripe.models.core.Event.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Event.idempotency_key","text":"","title":"idempotency_key"},{"location":"reference/models/#djstripe.models.core.Event.request_id","text":"","title":"request_id"},{"location":"reference/models/#djstripe.models.core.Event.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Event.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Event.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Event.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Event.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Event-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.Event.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Event.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Event.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Event.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Event.invoke_webhook_handlers","text":"Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the djstripe.event_handlers module (or handlers registered in djstripe plugins or contrib packages). Source code in djstripe/models/core.py def invoke_webhook_handlers ( self ): \"\"\" Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the ``djstripe.event_handlers`` module (or handlers registered in djstripe plugins or contrib packages). \"\"\" webhooks . call_handlers ( event = self ) signal = WEBHOOK_SIGNALS . get ( self . type ) if signal : return signal . send ( sender = Event , event = self )","title":"invoke_webhook_handlers()"},{"location":"reference/models/#djstripe.models.core.Event.process","text":"Source code in djstripe/models/core.py @classmethod def process ( cls , data ): qs = cls . objects . filter ( id = data [ \"id\" ]) if qs . exists (): return qs . first () # Rollback any DB operations in the case of failure so # we will retry creating and processing the event the # next time the webhook fires. with transaction . atomic (): ret = cls . _create_from_stripe_object ( data ) ret . invoke_webhook_handlers () return ret","title":"process()"},{"location":"reference/models/#djstripe.models.core.Event.str_parts","text":"Extend this to add information to the string representation of the object Source code in djstripe/models/core.py def str_parts ( self ): return [ \"type= {type} \" . format ( type = self . type )] + super () . str_parts ()","title":"str_parts()"},{"location":"reference/models/#djstripe.models.core.File","text":"Stripe documentation: https://stripe.com/docs/api#file_uploads","title":"File"},{"location":"reference/models/#djstripe.models.core.File.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.File.filename","text":"","title":"filename"},{"location":"reference/models/#djstripe.models.core.File.purpose","text":"","title":"purpose"},{"location":"reference/models/#djstripe.models.core.File.size","text":"","title":"size"},{"location":"reference/models/#djstripe.models.core.File.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.File.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.core.File.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.File.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.File.stripe_class","text":"djstripe . models . core . File . stripe_class . OBJECT_NAME djstripe . models . core . File . stripe_class . OBJECT_NAME_ALT djstripe . models . core . File . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . File . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.File-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.File.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.File.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.File.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.File.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.File.get_purpose_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_purpose_display()"},{"location":"reference/models/#djstripe.models.core.File.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.File.is_valid_object","text":"Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" )","title":"is_valid_object()"},{"location":"reference/models/#djstripe.models.core.FileUpload","text":"Stripe documentation: https://stripe.com/docs/api#file_uploads","title":"FileUpload"},{"location":"reference/models/#djstripe.models.core.FileUpload.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.FileUpload.filename","text":"","title":"filename"},{"location":"reference/models/#djstripe.models.core.FileUpload.purpose","text":"","title":"purpose"},{"location":"reference/models/#djstripe.models.core.FileUpload.size","text":"","title":"size"},{"location":"reference/models/#djstripe.models.core.FileUpload.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.FileUpload.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.core.FileUpload.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.FileUpload.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.FileUpload.stripe_class","text":"djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME_ALT djstripe . models . core . FileUpload . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . FileUpload . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.FileUpload-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_purpose_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_purpose_display()"},{"location":"reference/models/#djstripe.models.core.FileUpload.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.FileUpload.is_valid_object","text":"Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" )","title":"is_valid_object()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent","text":"Stripe documentation: https://stripe.com/docs/api#payment_intents","title":"PaymentIntent"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.amount_capturable","text":"","title":"amount_capturable"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.amount_received","text":"","title":"amount_received"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.canceled_at","text":"","title":"canceled_at"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.cancellation_reason","text":"","title":"cancellation_reason"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.capture_method","text":"","title":"capture_method"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.client_secret","text":"","title":"client_secret"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.confirmation_method","text":"","title":"confirmation_method"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.last_payment_error","text":"","title":"last_payment_error"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.next_action","text":"","title":"next_action"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.on_behalf_of","text":"","title":"on_behalf_of"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.payment_method_types","text":"","title":"payment_method_types"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.receipt_email","text":"","title":"receipt_email"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.setup_future_usage","text":"","title":"setup_future_usage"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.shipping","text":"","title":"shipping"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.transfer_data","text":"","title":"transfer_data"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.transfer_group","text":"","title":"transfer_group"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.stripe_class","text":"djstripe . models . core . PaymentIntent . stripe_class . OBJECT_NAME djstripe . models . core . PaymentIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.PaymentIntent-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_cancellation_reason_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_cancellation_reason_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_capture_method_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_capture_method_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_confirmation_method_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_confirmation_method_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_setup_future_usage_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_setup_future_usage_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.PaymentIntent.update","text":"Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/core.py def update ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key return self . api_retrieve ( api_key = api_key ) . modify ( ** kwargs )","title":"update()"},{"location":"reference/models/#djstripe.models.core.Payout","text":"A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. Stripe documentation: https://stripe.com/docs/api#payouts","title":"Payout"},{"location":"reference/models/#djstripe.models.core.Payout.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Payout.arrival_date","text":"","title":"arrival_date"},{"location":"reference/models/#djstripe.models.core.Payout.automatic","text":"","title":"automatic"},{"location":"reference/models/#djstripe.models.core.Payout.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Payout.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Payout.destination","text":"","title":"destination"},{"location":"reference/models/#djstripe.models.core.Payout.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Payout.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Payout.failure_balance_transaction","text":"","title":"failure_balance_transaction"},{"location":"reference/models/#djstripe.models.core.Payout.failure_code","text":"","title":"failure_code"},{"location":"reference/models/#djstripe.models.core.Payout.failure_message","text":"","title":"failure_message"},{"location":"reference/models/#djstripe.models.core.Payout.method","text":"","title":"method"},{"location":"reference/models/#djstripe.models.core.Payout.source_type","text":"","title":"source_type"},{"location":"reference/models/#djstripe.models.core.Payout.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Payout.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Payout.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Payout.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Payout.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Payout.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Payout.stripe_class","text":"djstripe . models . core . Payout . stripe_class . OBJECT_NAME djstripe . models . core . Payout . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Payout . stripe_class . reverse ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def reverse ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reverse\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Payout.get_failure_code_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_failure_code_display()"},{"location":"reference/models/#djstripe.models.core.Payout.get_method_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_method_display()"},{"location":"reference/models/#djstripe.models.core.Payout.get_next_by_arrival_date","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_arrival_date()"},{"location":"reference/models/#djstripe.models.core.Payout.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Payout.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Payout.get_previous_by_arrival_date","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_arrival_date()"},{"location":"reference/models/#djstripe.models.core.Payout.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Payout.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Payout.get_source_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_source_type_display()"},{"location":"reference/models/#djstripe.models.core.Payout.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.Payout.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.Price","text":"Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Price and Plan objects are the same, but use a different representation. Creating a recurring Price in Stripe also makes a Plan available, and vice versa. This is not the case for a Price with interval=one_time. Price objects are a more recent API representation, support more features and its usage is encouraged instead of Plan objects. Stripe documentation: - https://stripe.com/docs/api/prices - https://stripe.com/docs/billing/prices-guide","title":"Price"},{"location":"reference/models/#djstripe.models.core.Price.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.core.Price.billing_scheme","text":"","title":"billing_scheme"},{"location":"reference/models/#djstripe.models.core.Price.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Price.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Price.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.core.Price.human_readable_price","text":"","title":"human_readable_price"},{"location":"reference/models/#djstripe.models.core.Price.lookup_key","text":"","title":"lookup_key"},{"location":"reference/models/#djstripe.models.core.Price.nickname","text":"","title":"nickname"},{"location":"reference/models/#djstripe.models.core.Price.product","text":"","title":"product"},{"location":"reference/models/#djstripe.models.core.Price.recurring","text":"","title":"recurring"},{"location":"reference/models/#djstripe.models.core.Price.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Price.tiers","text":"","title":"tiers"},{"location":"reference/models/#djstripe.models.core.Price.tiers_mode","text":"","title":"tiers_mode"},{"location":"reference/models/#djstripe.models.core.Price.transform_quantity","text":"","title":"transform_quantity"},{"location":"reference/models/#djstripe.models.core.Price.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Price.unit_amount","text":"","title":"unit_amount"},{"location":"reference/models/#djstripe.models.core.Price.unit_amount_decimal","text":"","title":"unit_amount_decimal"},{"location":"reference/models/#djstripe.models.core.Price.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Price.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Price.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Price-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.Price.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): return self . nickname or self . id","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Price.create","text":"Source code in djstripe/models/core.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"unit_amount\" ] = int ( api_kwargs [ \"unit_amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_price = cls . _api_create ( ** api_kwargs ) price = cls . sync_from_stripe_data ( stripe_price ) return price","title":"create()"},{"location":"reference/models/#djstripe.models.core.Price.get_billing_scheme_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_billing_scheme_display()"},{"location":"reference/models/#djstripe.models.core.Price.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Price.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Price.get_or_create","text":"Get or create a Price. Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Price.\"\"\" try : return Price . objects . get ( id = kwargs [ \"id\" ]), False except Price . DoesNotExist : return cls . create ( ** kwargs ), True","title":"get_or_create()"},{"location":"reference/models/#djstripe.models.core.Price.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Price.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Price.get_tiers_mode_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_tiers_mode_display()"},{"location":"reference/models/#djstripe.models.core.Price.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.Product","text":"Stripe documentation: - https://stripe.com/docs/api#products - https://stripe.com/docs/api#service_products","title":"Product"},{"location":"reference/models/#djstripe.models.core.Product.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.core.Product.attributes","text":"","title":"attributes"},{"location":"reference/models/#djstripe.models.core.Product.caption","text":"","title":"caption"},{"location":"reference/models/#djstripe.models.core.Product.deactivate_on","text":"","title":"deactivate_on"},{"location":"reference/models/#djstripe.models.core.Product.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Product.images","text":"","title":"images"},{"location":"reference/models/#djstripe.models.core.Product.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.core.Product.package_dimensions","text":"","title":"package_dimensions"},{"location":"reference/models/#djstripe.models.core.Product.shippable","text":"","title":"shippable"},{"location":"reference/models/#djstripe.models.core.Product.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.core.Product.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.core.Product.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.core.Product.unit_label","text":"","title":"unit_label"},{"location":"reference/models/#djstripe.models.core.Product.url","text":"","title":"url"},{"location":"reference/models/#djstripe.models.core.Product.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Product.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Product.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Product.__str__","text":"Source code in djstripe/models/core.py def __str__ ( self ): return self . name","title":"__str__()"},{"location":"reference/models/#djstripe.models.core.Product.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Product.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Product.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Product.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Product.get_type_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.core.Refund","text":"Stripe documentation: https://stripe.com/docs/api#refund_object","title":"Refund"},{"location":"reference/models/#djstripe.models.core.Refund.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.core.Refund.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.core.Refund.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.core.Refund.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.core.Refund.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.Refund.failure_balance_transaction","text":"","title":"failure_balance_transaction"},{"location":"reference/models/#djstripe.models.core.Refund.failure_reason","text":"","title":"failure_reason"},{"location":"reference/models/#djstripe.models.core.Refund.reason","text":"","title":"reason"},{"location":"reference/models/#djstripe.models.core.Refund.receipt_number","text":"","title":"receipt_number"},{"location":"reference/models/#djstripe.models.core.Refund.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.Refund.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.Refund.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.Refund.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.Refund-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.core.Refund.get_failure_reason_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_failure_reason_display()"},{"location":"reference/models/#djstripe.models.core.Refund.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Refund.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Refund.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.Refund.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.Refund.get_reason_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_reason_display()"},{"location":"reference/models/#djstripe.models.core.Refund.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.Refund.get_stripe_dashboard_url","text":"Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . charge . get_stripe_dashboard_url ()","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.core.SetupIntent","text":"A SetupIntent guides you through the process of setting up a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow. NOTE: You should not maintain long-lived, unconfirmed SetupIntents. For security purposes, SetupIntents older than 24 hours may no longer be valid. Stripe documentation: https://stripe.com/docs/api#setup_intents","title":"SetupIntent"},{"location":"reference/models/#djstripe.models.core.SetupIntent.application","text":"","title":"application"},{"location":"reference/models/#djstripe.models.core.SetupIntent.cancellation_reason","text":"","title":"cancellation_reason"},{"location":"reference/models/#djstripe.models.core.SetupIntent.client_secret","text":"","title":"client_secret"},{"location":"reference/models/#djstripe.models.core.SetupIntent.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.core.SetupIntent.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.core.SetupIntent.last_setup_error","text":"","title":"last_setup_error"},{"location":"reference/models/#djstripe.models.core.SetupIntent.next_action","text":"","title":"next_action"},{"location":"reference/models/#djstripe.models.core.SetupIntent.on_behalf_of","text":"","title":"on_behalf_of"},{"location":"reference/models/#djstripe.models.core.SetupIntent.payment_method","text":"","title":"payment_method"},{"location":"reference/models/#djstripe.models.core.SetupIntent.payment_method_types","text":"","title":"payment_method_types"},{"location":"reference/models/#djstripe.models.core.SetupIntent.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.core.SetupIntent.usage","text":"","title":"usage"},{"location":"reference/models/#djstripe.models.core.SetupIntent.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.core.SetupIntent.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.core.SetupIntent.stripe_class","text":"djstripe . models . core . SetupIntent . stripe_class . OBJECT_NAME djstripe . models . core . SetupIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . SetupIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_cancellation_reason_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_cancellation_reason_display()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_next_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_next_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_previous_by_djstripe_created","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_status_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.core.SetupIntent.get_usage_display","text":"Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_usage_display()"},{"location":"reference/models/#payment-methods","text":"","title":"Payment Methods"},{"location":"reference/models/#djstripe.models.payment_methods-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount","text":"BankAccount(djstripe_id, id, djstripe_owner_account, livemode, created, metadata, description, djstripe_created, djstripe_updated, account, account_holder_name, account_holder_type, bank_name, country, currency, customer, default_for_currency, fingerprint, last4, routing_number, status)","title":"BankAccount"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.account","text":"","title":"account"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.account_holder_name","text":"","title":"account_holder_name"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.account_holder_type","text":"","title":"account_holder_type"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.bank_name","text":"","title":"bank_name"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.default_for_currency","text":"","title":"default_for_currency"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.fingerprint","text":"","title":"fingerprint"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.last4","text":"","title":"last4"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.routing_number","text":"","title":"routing_number"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.stripe_class","text":"djstripe . models . payment_methods . BankAccount . stripe_class . OBJECT_NAME djstripe . models . payment_methods . BankAccount . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether bank_account_id %s is \" \"attached to a customer or an account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . BankAccount . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a bank account without a customer or account ID. \" \"Call save on customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" ) djstripe . models . payment_methods . BankAccount . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a bank account without a customer or account ID. \" \"Use customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.api_retrieve","text":"Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/payment_methods.py def api_retrieve ( self , ** kwargs ): if not self . customer : raise NotImplementedError ( \"Cannot retrieve bank accounts not associated with a customer\" ) return super () . api_retrieve ( ** kwargs )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_account_holder_type_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_account_holder_type_display()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_next_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_next_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_previous_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.BankAccount.get_status_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card","text":"You can store multiple cards on a customer in order to charge the customer later. This is a legacy model which only applies to the \"v2\" Stripe API (eg. Checkout.js). You should strive to use the Stripe \"v3\" API (eg. Stripe Elements). Also see: https://stripe.com/docs/stripe-js/elements/migrating When using Elements, you will not be using Card objects. Instead, you will use Source objects. A Source object of type \"card\" is equivalent to a Card object. However, Card objects cannot be converted into Source objects by Stripe at this time. Stripe documentation: https://stripe.com/docs/api/python#cards","title":"Card"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_city","text":"","title":"address_city"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_country","text":"","title":"address_country"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_line1","text":"","title":"address_line1"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_line1_check","text":"","title":"address_line1_check"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_line2","text":"","title":"address_line2"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_state","text":"","title":"address_state"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_zip","text":"","title":"address_zip"},{"location":"reference/models/#djstripe.models.payment_methods.Card.address_zip_check","text":"","title":"address_zip_check"},{"location":"reference/models/#djstripe.models.payment_methods.Card.brand","text":"","title":"brand"},{"location":"reference/models/#djstripe.models.payment_methods.Card.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.payment_methods.Card.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.Card.cvc_check","text":"","title":"cvc_check"},{"location":"reference/models/#djstripe.models.payment_methods.Card.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.payment_methods.Card.dynamic_last4","text":"","title":"dynamic_last4"},{"location":"reference/models/#djstripe.models.payment_methods.Card.exp_month","text":"","title":"exp_month"},{"location":"reference/models/#djstripe.models.payment_methods.Card.exp_year","text":"","title":"exp_year"},{"location":"reference/models/#djstripe.models.payment_methods.Card.fingerprint","text":"","title":"fingerprint"},{"location":"reference/models/#djstripe.models.payment_methods.Card.funding","text":"","title":"funding"},{"location":"reference/models/#djstripe.models.payment_methods.Card.last4","text":"","title":"last4"},{"location":"reference/models/#djstripe.models.payment_methods.Card.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.payment_methods.Card.tokenization_method","text":"","title":"tokenization_method"},{"location":"reference/models/#djstripe.models.payment_methods.Card.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.payment_methods.Card.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.payment_methods.Card.stripe_class","text":"djstripe . models . payment_methods . Card . stripe_class . OBJECT_NAME djstripe . models . payment_methods . Card . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"recipient\" ): recipient = util . utf8 ( self . recipient ) base = Recipient . class_url () owner_extn = quote_plus ( recipient ) class_base = \"cards\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether card_id %s is \" \"attached to a customer, recipient, or \" \"account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . Card . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a card without a customer, recipient or account \" \"ID. Call save on customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" ) djstripe . models . payment_methods . Card . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a card without a customer, recipient or account \" \"ID. Use customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.Card-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.payment_methods.Card.create_token","text":"Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api/python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use Source code in djstripe/models/payment_methods.py @classmethod def create_token ( cls , number : str , exp_month : int , exp_year : int , cvc : str , api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs , ) -> stripe . Token : \"\"\" Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api/python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use \"\"\" card = { \"number\" : number , \"exp_month\" : exp_month , \"exp_year\" : exp_year , \"cvc\" : cvc , } card . update ( kwargs ) return stripe . Token . create ( api_key = api_key , card = card )","title":"create_token()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_address_line1_check_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_address_line1_check_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_address_zip_check_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_address_zip_check_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_brand_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_brand_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_cvc_check_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_cvc_check_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_funding_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_funding_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_next_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_next_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_previous_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.get_tokenization_method_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_tokenization_method_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Card.str_parts","text":"Extend this to add information to the string representation of the object Source code in djstripe/models/payment_methods.py def str_parts ( self ): return [ \"brand= {brand} \" . format ( brand = self . brand ), \"last4= {last4} \" . format ( last4 = self . last4 ), \"exp_month= {exp_month} \" . format ( exp_month = self . exp_month ), \"exp_year= {exp_year} \" . format ( exp_year = self . exp_year ), ] + super () . str_parts ()","title":"str_parts()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod","text":"Stripe documentation: https://stripe.com/docs/api#payment_methods","title":"PaymentMethod"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.alipay","text":"","title":"alipay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.au_becs_debit","text":"","title":"au_becs_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.bacs_debit","text":"","title":"bacs_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.bancontact","text":"","title":"bancontact"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.billing_details","text":"","title":"billing_details"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.card","text":"","title":"card"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.card_present","text":"","title":"card_present"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.eps","text":"","title":"eps"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.fpx","text":"","title":"fpx"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.giropay","text":"","title":"giropay"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.ideal","text":"","title":"ideal"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.interac_present","text":"","title":"interac_present"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.oxxo","text":"","title":"oxxo"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.p24","text":"","title":"p24"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.sepa_debit","text":"","title":"sepa_debit"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.sofort","text":"","title":"sofort"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.stripe_class","text":"djstripe . models . payment_methods . PaymentMethod . stripe_class . OBJECT_NAME djstripe . models . payment_methods . PaymentMethod . stripe_class . _cls_attach ( sid , ** params ) classmethod private Source code in djstripe/models/payment_methods.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . payment_methods . PaymentMethod . stripe_class . _cls_detach ( sid , ** params ) classmethod private Source code in djstripe/models/payment_methods.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . payment_methods . PaymentMethod . stripe_class . attach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def attach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/attach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . payment_methods . PaymentMethod . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/detach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod._attach_objects_hook","text":"Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/payment_methods.py def _attach_objects_hook ( self , cls , data , current_ids = None ): customer = None if current_ids is None or data . get ( \"customer\" ) not in current_ids : customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids ) if customer : self . customer = customer else : self . customer = None","title":"_attach_objects_hook()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.attach","text":"Attach a payment method to a customer Source code in djstripe/models/payment_methods.py @classmethod def attach ( cls , payment_method : Union [ str , \"PaymentMethod\" ], customer : Union [ str , Customer ], api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ) -> \"PaymentMethod\" : \"\"\" Attach a payment method to a customer \"\"\" if isinstance ( payment_method , StripeModel ): payment_method = payment_method . id if isinstance ( customer , StripeModel ): customer = customer . id extra_kwargs = {} if not isinstance ( payment_method , stripe . PaymentMethod ): # send api_key if we're not passing in a Stripe object # avoids \"Received unknown parameter: api_key\" since api uses the # key cached in the Stripe object extra_kwargs = { \"api_key\" : api_key } stripe_payment_method = stripe . PaymentMethod . attach ( payment_method , customer = customer , ** extra_kwargs ) return cls . sync_from_stripe_data ( stripe_payment_method )","title":"attach()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.detach","text":"Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, false if it was already detached :rtype: bool Source code in djstripe/models/payment_methods.py def detach ( self ): \"\"\" Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, \\ false if it was already detached :rtype: bool \"\"\" # Find customers that use this customers = Customer . objects . filter ( default_payment_method = self ) . all () changed = True # special handling is needed for legacy \"card\"-type PaymentMethods, # since detaching them deletes them within Stripe. # see https://github.com/dj-stripe/dj-stripe/pull/967 is_legacy_card = self . id . startswith ( \"card_\" ) try : self . sync_from_stripe_data ( self . api_retrieve () . detach ()) # resync customer to update .default_payment_method and # .invoice_settings.default_payment_method for customer in customers : Customer . sync_from_stripe_data ( customer . api_retrieve ()) except ( InvalidRequestError ,): # The source was already detached. Resyncing. if self . pk and not is_legacy_card : self . sync_from_stripe_data ( self . api_retrieve ()) changed = False if self . pk : if is_legacy_card : self . delete () else : self . refresh_from_db () return changed","title":"detach()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_next_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_next_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_previous_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.PaymentMethod.get_type_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Source","text":"Stripe documentation: https://stripe.com/docs/api#sources","title":"Source"},{"location":"reference/models/#djstripe.models.payment_methods.Source.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.payment_methods.Source.client_secret","text":"","title":"client_secret"},{"location":"reference/models/#djstripe.models.payment_methods.Source.code_verification","text":"","title":"code_verification"},{"location":"reference/models/#djstripe.models.payment_methods.Source.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.payment_methods.Source.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.payment_methods.Source.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.payment_methods.Source.flow","text":"","title":"flow"},{"location":"reference/models/#djstripe.models.payment_methods.Source.owner","text":"","title":"owner"},{"location":"reference/models/#djstripe.models.payment_methods.Source.receiver","text":"","title":"receiver"},{"location":"reference/models/#djstripe.models.payment_methods.Source.redirect","text":"","title":"redirect"},{"location":"reference/models/#djstripe.models.payment_methods.Source.source_data","text":"","title":"source_data"},{"location":"reference/models/#djstripe.models.payment_methods.Source.statement_descriptor","text":"","title":"statement_descriptor"},{"location":"reference/models/#djstripe.models.payment_methods.Source.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.payment_methods.Source.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.payment_methods.Source.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.payment_methods.Source.usage","text":"","title":"usage"},{"location":"reference/models/#djstripe.models.payment_methods.Source-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.payment_methods.Source.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.payment_methods.Source.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.payment_methods.Source.stripe_class","text":"djstripe . models . payment_methods . Source . stripe_class . OBJECT_NAME","title":"stripe_class"},{"location":"reference/models/#djstripe.models.payment_methods.Source.stripe_class-methods","text":"djstripe . models . payment_methods . Source . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): token = util . utf8 ( self . id ) if hasattr ( self , \"customer\" ) and self . customer : extn = quote_plus ( token ) customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) url = \" %s / %s /sources/ %s \" % ( base , owner_extn , extn ) headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"delete\" , url , params , headers )) return self else : raise error . InvalidRequestError ( \"Source %s does not appear to be currently attached \" \"to a customer object.\" % token , \"id\" , ) djstripe . models . payment_methods . Source . stripe_class . list_source_transactions ( id , ** params ) classmethod Source code in djstripe/models/payment_methods.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions ( self , ** params ) source_transactions is deprecated, use Source.list_source_transactions instead. Source code in djstripe/models/payment_methods.py def source_transactions ( self , ** params ): \"\"\"source_transactions is deprecated, use Source.list_source_transactions instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/source_transactions\" , params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"Methods"},{"location":"reference/models/#djstripe.models.payment_methods.Source-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.payment_methods.Source._attach_objects_hook","text":"Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/payment_methods.py def _attach_objects_hook ( self , cls , data , current_ids = None ): customer = cls . _stripe_object_to_customer ( target_cls = Customer , data = data , current_ids = current_ids ) if customer : self . customer = customer else : self . customer = None","title":"_attach_objects_hook()"},{"location":"reference/models/#djstripe.models.payment_methods.Source._manipulate_stripe_object_hook","text":"Gets called by this object's stripe object conversion method just before conversion. Use this to populate custom fields in a StripeModel from stripe data. Source code in djstripe/models/payment_methods.py @classmethod def _manipulate_stripe_object_hook ( cls , data ): # The source_data dict is an alias of all the source types data [ \"source_data\" ] = data [ data [ \"type\" ]] return data","title":"_manipulate_stripe_object_hook()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.detach","text":"Detach the source from its customer. Source code in djstripe/models/payment_methods.py def detach ( self ) -> bool : \"\"\" Detach the source from its customer. \"\"\" # First, wipe default source on all customers that use this. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) try : # TODO - we could use the return value of sync_from_stripe_data # or call its internals - self._sync/_attach_objects_hook etc here # to update `self` at this point? self . sync_from_stripe_data ( self . api_retrieve () . detach ()) return True except ( InvalidRequestError , NotImplementedError ): # The source was already detached. Resyncing. # NotImplementedError is an artifact of stripe-python<2.0 # https://github.com/stripe/stripe-python/issues/376 self . sync_from_stripe_data ( self . api_retrieve ()) return False","title":"detach()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_flow_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_flow_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_next_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_next_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_previous_by_djstripe_created","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_status_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_type_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.payment_methods.Source.get_usage_display","text":"Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_usage_display()"},{"location":"reference/models/#billing","text":"","title":"Billing"},{"location":"reference/models/#djstripe.models.billing-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.Coupon","text":"Coupon(djstripe_id, djstripe_owner_account, livemode, created, metadata, description, djstripe_created, djstripe_updated, id, amount_off, currency, duration, duration_in_months, max_redemptions, name, percent_off, redeem_by, times_redeemed)","title":"Coupon"},{"location":"reference/models/#djstripe.models.billing.Coupon.amount_off","text":"","title":"amount_off"},{"location":"reference/models/#djstripe.models.billing.Coupon.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.billing.Coupon.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.Coupon.duration","text":"","title":"duration"},{"location":"reference/models/#djstripe.models.billing.Coupon.duration_in_months","text":"","title":"duration_in_months"},{"location":"reference/models/#djstripe.models.billing.Coupon.human_readable","text":"","title":"human_readable"},{"location":"reference/models/#djstripe.models.billing.Coupon.human_readable_amount","text":"","title":"human_readable_amount"},{"location":"reference/models/#djstripe.models.billing.Coupon.max_redemptions","text":"","title":"max_redemptions"},{"location":"reference/models/#djstripe.models.billing.Coupon.name","text":"","title":"name"},{"location":"reference/models/#djstripe.models.billing.Coupon.percent_off","text":"","title":"percent_off"},{"location":"reference/models/#djstripe.models.billing.Coupon.redeem_by","text":"","title":"redeem_by"},{"location":"reference/models/#djstripe.models.billing.Coupon.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.Coupon.times_redeemed","text":"","title":"times_redeemed"},{"location":"reference/models/#djstripe.models.billing.Coupon.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.Coupon.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.Coupon.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.Coupon.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): if self . name : return self . name return self . human_readable","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.Coupon.get_duration_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_duration_display()"},{"location":"reference/models/#djstripe.models.billing.Coupon.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Coupon.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Coupon.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Coupon.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Invoice","text":"Invoices are statements of what a customer owes for a particular billing period, including subscriptions, invoice items, and any automatic proration adjustments if necessary. Once an invoice is created, payment is automatically attempted. Note that the payment, while automatic, does not happen exactly at the time of invoice creation. If you have configured webhooks, the invoice will wait until one hour after the last webhook is successfully sent (or the last webhook times out after failing). Any customer credit on the account is applied before determining how much is due for that invoice (the amount that will be actually charged). If the amount due for the invoice is less than 50 cents (the minimum for a charge), we add the amount to the customer's running account balance to be added to the next invoice. If this amount is negative, it will act as a credit to offset the next invoice. Note that the customer account balance does not include unpaid invoices; it only includes balances that need to be taken into account when calculating the amount due for the next invoice. Stripe documentation: https://stripe.com/docs/api/python#invoices","title":"Invoice"},{"location":"reference/models/#djstripe.models.billing.Invoice.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.billing.Invoice.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.Invoice.default_payment_method","text":"","title":"default_payment_method"},{"location":"reference/models/#djstripe.models.billing.Invoice.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.billing.Invoice.default_tax_rates","text":"","title":"default_tax_rates"},{"location":"reference/models/#djstripe.models.billing.Invoice.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.Invoice.payment_intent","text":"","title":"payment_intent"},{"location":"reference/models/#djstripe.models.billing.Invoice.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.Invoice.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.Invoice.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.Invoice-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.Invoice._attach_objects_post_save_hook","text":"Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) ) cls . _stripe_object_set_total_tax_amounts ( target_cls = DjstripeInvoiceTotalTaxAmount , data = data , instance = self )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_billing_reason_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_billing_reason_display()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_collection_method_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_collection_method_display()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_customer_tax_exempt_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_customer_tax_exempt_display()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_next_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_next_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_previous_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_previous_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.Invoice.get_status_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem","text":"Sometimes you want to add a charge or credit to a customer but only actually charge the customer's card at the end of a regular billing cycle. This is useful for combining several charges to minimize per-transaction fees or having Stripe tabulate your usage-based billing totals. Stripe documentation: https://stripe.com/docs/api/python#invoiceitems","title":"InvoiceItem"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.date","text":"","title":"date"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.discountable","text":"","title":"discountable"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.invoice","text":"","title":"invoice"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.period","text":"","title":"period"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.period_end","text":"","title":"period_end"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.period_start","text":"","title":"period_start"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.plan","text":"","title":"plan"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.price","text":"","title":"price"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.proration","text":"","title":"proration"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.tax_rates","text":"","title":"tax_rates"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.unit_amount","text":"","title":"unit_amount"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.unit_amount_decimal","text":"","title":"unit_amount_decimal"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): return self . description","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem._attach_objects_post_save_hook","text":"Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) if self . pk : # only call .set() on saved instance (ie don't on items of UpcomingInvoice) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data ) )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem._manipulate_stripe_object_hook","text":"Gets called by this object's stripe object conversion method just before conversion. Use this to populate custom fields in a StripeModel from stripe data. Source code in djstripe/models/billing.py @classmethod def _manipulate_stripe_object_hook ( cls , data ): data [ \"period_start\" ] = data [ \"period\" ][ \"start\" ] data [ \"period_end\" ] = data [ \"period\" ][ \"end\" ] return data","title":"_manipulate_stripe_object_hook()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.api_retrieve","text":"Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , * args , ** kwargs ): if \"-il_\" in self . id : warnings . warn ( f \"Attempting to retrieve InvoiceItem with id= { self . id !r} \" \" will most likely fail. \" \"Run manage.py djstripe_update_invoiceitem_ids if this is a problem.\" ) return super () . api_retrieve ( * args , ** kwargs )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_next_by_date","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_date()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_next_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_next_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_previous_by_date","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_date()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_previous_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_previous_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.get_stripe_dashboard_url","text":"Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return self . invoice . get_stripe_dashboard_url ()","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.is_valid_object","text":"Returns whether the data is a valid object for the class Source code in djstripe/models/billing.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"invoiceitem\" , \"line_item\" )","title":"is_valid_object()"},{"location":"reference/models/#djstripe.models.billing.InvoiceItem.sync_from_stripe_data","text":"Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls Source code in djstripe/models/billing.py @classmethod def sync_from_stripe_data ( cls , data ): invoice_data = data . get ( \"invoice\" ) if invoice_data : # sync the Invoice first if it doesn't yet exist in our DB # to avoid recursive Charge/Invoice loop invoice_id = cls . _id_from_data ( invoice_data ) if not Invoice . objects . filter ( id = invoice_id ) . exists (): if invoice_id == invoice_data : # we only have the id, fetch the full data invoice_data = Invoice ( id = invoice_id ) . api_retrieve () Invoice . sync_from_stripe_data ( data = invoice_data ) return super () . sync_from_stripe_data ( data )","title":"sync_from_stripe_data()"},{"location":"reference/models/#djstripe.models.billing.Plan","text":"A subscription plan contains the pricing information for different products and feature levels on your site. Stripe documentation: https://stripe.com/docs/api/plans NOTE: The Stripe Plans API has been deprecated in favor of the Prices API. You may want to upgrade to use the Price model instead of the Plan model.","title":"Plan"},{"location":"reference/models/#djstripe.models.billing.Plan.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.billing.Plan.aggregate_usage","text":"","title":"aggregate_usage"},{"location":"reference/models/#djstripe.models.billing.Plan.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.billing.Plan.amount_decimal","text":"","title":"amount_decimal"},{"location":"reference/models/#djstripe.models.billing.Plan.amount_in_cents","text":"","title":"amount_in_cents"},{"location":"reference/models/#djstripe.models.billing.Plan.billing_scheme","text":"","title":"billing_scheme"},{"location":"reference/models/#djstripe.models.billing.Plan.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.billing.Plan.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.Plan.human_readable_price","text":"","title":"human_readable_price"},{"location":"reference/models/#djstripe.models.billing.Plan.interval","text":"","title":"interval"},{"location":"reference/models/#djstripe.models.billing.Plan.interval_count","text":"","title":"interval_count"},{"location":"reference/models/#djstripe.models.billing.Plan.nickname","text":"","title":"nickname"},{"location":"reference/models/#djstripe.models.billing.Plan.product","text":"","title":"product"},{"location":"reference/models/#djstripe.models.billing.Plan.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.Plan.tiers","text":"","title":"tiers"},{"location":"reference/models/#djstripe.models.billing.Plan.tiers_mode","text":"","title":"tiers_mode"},{"location":"reference/models/#djstripe.models.billing.Plan.transform_usage","text":"","title":"transform_usage"},{"location":"reference/models/#djstripe.models.billing.Plan.trial_period_days","text":"","title":"trial_period_days"},{"location":"reference/models/#djstripe.models.billing.Plan.usage_type","text":"","title":"usage_type"},{"location":"reference/models/#djstripe.models.billing.Plan.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.Plan.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.Plan.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.Plan-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.Plan.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): return self . nickname or self . id","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.Plan.create","text":"Source code in djstripe/models/billing.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"amount\" ] = int ( api_kwargs [ \"amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_plan = cls . _api_create ( ** api_kwargs ) plan = cls . sync_from_stripe_data ( stripe_plan ) return plan","title":"create()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_aggregate_usage_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_aggregate_usage_display()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_billing_scheme_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_billing_scheme_display()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_interval_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_interval_display()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_or_create","text":"Get or create a Plan. Source code in djstripe/models/billing.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Plan.\"\"\" try : return Plan . objects . get ( id = kwargs [ \"id\" ]), False except Plan . DoesNotExist : return cls . create ( ** kwargs ), True","title":"get_or_create()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_tiers_mode_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_tiers_mode_display()"},{"location":"reference/models/#djstripe.models.billing.Plan.get_usage_type_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_usage_type_display()"},{"location":"reference/models/#djstripe.models.billing.Subscription","text":"Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to a particular plan you've created. A subscription still in its trial period is trialing and moves to active when the trial period is over. When payment to renew the subscription fails, the subscription becomes past_due . After Stripe has exhausted all payment retry attempts, the subscription ends up with a status of either canceled or unpaid depending on your retry settings. Note that when a subscription has a status of unpaid , no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed. Additionally, updating customer card details will not lead to Stripe retrying the latest invoice.). After receiving updated card details from a customer, you may choose to reopen and pay their closed invoices. Stripe documentation: https://stripe.com/docs/api/python#subscriptions","title":"Subscription"},{"location":"reference/models/#djstripe.models.billing.Subscription.application_fee_percent","text":"","title":"application_fee_percent"},{"location":"reference/models/#djstripe.models.billing.Subscription.billing_cycle_anchor","text":"","title":"billing_cycle_anchor"},{"location":"reference/models/#djstripe.models.billing.Subscription.billing_thresholds","text":"","title":"billing_thresholds"},{"location":"reference/models/#djstripe.models.billing.Subscription.cancel_at","text":"","title":"cancel_at"},{"location":"reference/models/#djstripe.models.billing.Subscription.cancel_at_period_end","text":"","title":"cancel_at_period_end"},{"location":"reference/models/#djstripe.models.billing.Subscription.canceled_at","text":"","title":"canceled_at"},{"location":"reference/models/#djstripe.models.billing.Subscription.collection_method","text":"","title":"collection_method"},{"location":"reference/models/#djstripe.models.billing.Subscription.current_period_end","text":"","title":"current_period_end"},{"location":"reference/models/#djstripe.models.billing.Subscription.current_period_start","text":"","title":"current_period_start"},{"location":"reference/models/#djstripe.models.billing.Subscription.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.Subscription.days_until_due","text":"","title":"days_until_due"},{"location":"reference/models/#djstripe.models.billing.Subscription.default_payment_method","text":"","title":"default_payment_method"},{"location":"reference/models/#djstripe.models.billing.Subscription.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.billing.Subscription.default_tax_rates","text":"","title":"default_tax_rates"},{"location":"reference/models/#djstripe.models.billing.Subscription.discount","text":"","title":"discount"},{"location":"reference/models/#djstripe.models.billing.Subscription.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.Subscription.ended_at","text":"","title":"ended_at"},{"location":"reference/models/#djstripe.models.billing.Subscription.next_pending_invoice_item_invoice","text":"","title":"next_pending_invoice_item_invoice"},{"location":"reference/models/#djstripe.models.billing.Subscription.objects","text":"","title":"objects"},{"location":"reference/models/#djstripe.models.billing.Subscription.pending_invoice_item_interval","text":"","title":"pending_invoice_item_interval"},{"location":"reference/models/#djstripe.models.billing.Subscription.pending_setup_intent","text":"","title":"pending_setup_intent"},{"location":"reference/models/#djstripe.models.billing.Subscription.pending_update","text":"","title":"pending_update"},{"location":"reference/models/#djstripe.models.billing.Subscription.plan","text":"","title":"plan"},{"location":"reference/models/#djstripe.models.billing.Subscription.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.Subscription.schedule","text":"","title":"schedule"},{"location":"reference/models/#djstripe.models.billing.Subscription.start_date","text":"","title":"start_date"},{"location":"reference/models/#djstripe.models.billing.Subscription.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.billing.Subscription.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.billing.Subscription.tax_percent","text":"","title":"tax_percent"},{"location":"reference/models/#djstripe.models.billing.Subscription.trial_end","text":"","title":"trial_end"},{"location":"reference/models/#djstripe.models.billing.Subscription.trial_start","text":"","title":"trial_start"},{"location":"reference/models/#djstripe.models.billing.Subscription.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.Subscription.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.Subscription.stripe_class","text":"djstripe . models . billing . Subscription . stripe_class . OBJECT_NAME djstripe . models . billing . Subscription . stripe_class . _cls_delete_discount ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . Subscription . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/billing.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.Subscription-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.Subscription.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): return \" {customer} on {plan} \" . format ( customer = str ( self . customer ), plan = str ( self . plan ) )","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.Subscription._attach_objects_post_save_hook","text":"Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) cls . _stripe_object_to_subscription_items ( target_cls = SubscriptionItem , data = data , subscription = self ) self . default_tax_rates . set ( cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.Subscription.cancel","text":"Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, the at_period_end flag will be overridden to False so that the trial ends immediately and the customer's card isn't charged. Source code in djstripe/models/billing.py def cancel ( self , at_period_end = djstripe_settings . CANCELLATION_AT_PERIOD_END ): \"\"\" Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation \\ of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, \\ the ``at_period_end`` flag will be overridden to False so that the trial ends \\ immediately and the customer's card isn't charged. \"\"\" # If plan has trial days and customer cancels before # trial period ends, then end subscription now, # i.e. at_period_end=False if self . trial_end and self . trial_end > timezone . now (): at_period_end = False if at_period_end : stripe_subscription = self . _api_update ( cancel_at_period_end = True ) else : try : stripe_subscription = self . _api_delete () except InvalidRequestError as exc : if \"No such subscription:\" in str ( exc ): # cancel() works by deleting the subscription. The object still # exists in Stripe however, and can still be retrieved. # If the subscription was already canceled (status=canceled), # that api_retrieve() call will fail with \"No such subscription\". # However, this may also happen if the subscription legitimately # does not exist, in which case the following line will re-raise. stripe_subscription = self . api_retrieve () else : raise return Subscription . sync_from_stripe_data ( stripe_subscription )","title":"cancel()"},{"location":"reference/models/#djstripe.models.billing.Subscription.extend","text":"Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta Source code in djstripe/models/billing.py def extend ( self , delta ): \"\"\" Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta \"\"\" if delta . total_seconds () < 0 : raise ValueError ( \"delta must be a positive timedelta.\" ) if self . trial_end is not None and self . trial_end > timezone . now (): period_end = self . trial_end else : period_end = self . current_period_end period_end += delta return self . update ( proration_behavior = \"none\" , trial_end = period_end )","title":"extend()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_collection_method_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_collection_method_display()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_next_by_current_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_current_period_end()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_next_by_current_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_current_period_start()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_previous_by_current_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_current_period_end()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_previous_by_current_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_current_period_start()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.Subscription.get_status_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_period_current","text":"Returns True if this subscription's period is current, false otherwise. Source code in djstripe/models/billing.py def is_period_current ( self ): \"\"\" Returns True if this subscription's period is current, false otherwise. \"\"\" return self . current_period_end > timezone . now () or ( self . trial_end and self . trial_end > timezone . now () )","title":"is_period_current()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_status_current","text":"Returns True if this subscription's status is current (active or trialing), false otherwise. Source code in djstripe/models/billing.py def is_status_current ( self ): \"\"\" Returns True if this subscription's status is current (active or trialing), false otherwise. \"\"\" return self . status in [ \"trialing\" , \"active\" ]","title":"is_status_current()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_status_temporarily_current","text":"A status is temporarily current when the subscription is canceled with the at_period_end flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. Source code in djstripe/models/billing.py def is_status_temporarily_current ( self ): \"\"\" A status is temporarily current when the subscription is canceled with the ``at_period_end`` flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. \"\"\" return ( self . canceled_at and self . cancel_at_period_end and timezone . now () < self . current_period_end )","title":"is_status_temporarily_current()"},{"location":"reference/models/#djstripe.models.billing.Subscription.is_valid","text":"Returns True if this subscription's status and period are current, false otherwise. Source code in djstripe/models/billing.py def is_valid ( self ): \"\"\" Returns True if this subscription's status and period are current, false otherwise. \"\"\" if not self . is_status_current (): return False if not self . is_period_current (): return False return True","title":"is_valid()"},{"location":"reference/models/#djstripe.models.billing.Subscription.reactivate","text":"Reactivates this subscription. If a customer's subscription is canceled with at_period_end set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/subscriptions/canceling-pausing) .. warning:: Reactivating a fully canceled Subscription will fail silently. Be sure to check the returned Subscription's status. Source code in djstripe/models/billing.py def reactivate ( self ): \"\"\" Reactivates this subscription. If a customer's subscription is canceled with ``at_period_end`` set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/subscriptions/canceling-pausing) .. warning:: Reactivating a fully canceled Subscription will fail silently. \\ Be sure to check the returned Subscription's status. \"\"\" stripe_subscription = self . api_retrieve () stripe_subscription . plan = self . plan . id stripe_subscription . cancel_at_period_end = False return Subscription . sync_from_stripe_data ( stripe_subscription . save ())","title":"reactivate()"},{"location":"reference/models/#djstripe.models.billing.Subscription.update","text":"See Customer.subscribe() <#djstripe.models.Customer.subscribe> __ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. note:: The default value for prorate is the DJSTRIPE_PRORATION_POLICY setting. .. important:: Updating a subscription by changing the plan or quantity creates a new Subscription in Stripe (and dj-stripe). Source code in djstripe/models/billing.py def update ( self , plan : Union [ StripeModel , str ] = None , prorate : bool = None , ** kwargs , ): \"\"\" See `Customer.subscribe() <#djstripe.models.Customer.subscribe>`__ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. note:: The default value for ``prorate`` is the DJSTRIPE_PRORATION_POLICY \\ setting. .. important:: Updating a subscription by changing the plan or quantity \\ creates a new ``Subscription`` in \\ Stripe (and dj-stripe). \"\"\" # Convert Plan to id if plan is not None and isinstance ( plan , StripeModel ): plan = plan . id if \"proration_behavior\" not in kwargs : if prorate is not None : warnings . warn ( \"The `prorate` parameter to Subscription.update() is deprecated \" \"by Stripe. Use `proration_behavior` instead. \\n \" \"Read more: \" \"https://stripe.com/docs/billing/subscriptions/prorations\" ) else : prorate = djstripe_settings . PRORATION_POLICY if prorate : kwargs . setdefault ( \"proration_behavior\" , \"create_prorations\" ) else : kwargs . setdefault ( \"proration_behavior\" , \"none\" ) stripe_subscription = self . _api_update ( plan = plan , ** kwargs ) return Subscription . sync_from_stripe_data ( stripe_subscription )","title":"update()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem","text":"Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. Stripe documentation: https://stripe.com/docs/api#subscription_items","title":"SubscriptionItem"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.billing_thresholds","text":"","title":"billing_thresholds"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.plan","text":"","title":"plan"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.price","text":"","title":"price"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.tax_rates","text":"","title":"tax_rates"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.stripe_class","text":"djstripe . models . billing . SubscriptionItem . stripe_class . OBJECT_NAME","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.stripe_class-methods","text":"djstripe . models . billing . SubscriptionItem . stripe_class . create_usage_record ( id , ** params ) classmethod Source code in djstripe/models/billing.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . list_usage_record_summaries ( id , ** params ) classmethod Source code in djstripe/models/billing.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summaries ( self , ** params ) usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead. Source code in djstripe/models/billing.py def usage_record_summaries ( self , ** params ): \"\"\"usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/usage_record_summaries\" , params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem._attach_objects_post_save_hook","text":"Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . tax_rates . set ( cls . _stripe_object_to_tax_rates ( target_cls = TaxRate , data = data ) )","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionItem.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule","text":"Subscription schedules allow you to create and manage the lifecycle of a subscription by predefining expected changes. Stripe documentation: https://stripe.com/docs/api/subscription_schedules","title":"SubscriptionSchedule"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.billing_thresholds","text":"","title":"billing_thresholds"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.canceled_at","text":"","title":"canceled_at"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.completed_at","text":"","title":"completed_at"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.current_phase","text":"","title":"current_phase"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.default_settings","text":"","title":"default_settings"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.end_behavior","text":"","title":"end_behavior"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.phases","text":"","title":"phases"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.released_at","text":"","title":"released_at"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.released_subscription","text":"","title":"released_subscription"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.stripe_class","text":"djstripe . models . billing . SubscriptionSchedule . stripe_class . OBJECT_NAME djstripe . models . billing . SubscriptionSchedule . stripe_class . _cls_cancel ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . SubscriptionSchedule . stripe_class . _cls_release ( sid , ** params ) classmethod private Source code in djstripe/models/billing.py def custom_method_request ( cls , sid , ** params ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( util . utf8 ( sid )), http_path , ) obj = cls . _static_request ( http_verb , url , ** params ) # For list objects, we have to attach the parameters so that they # can be referenced in auto-pagination and ensure consistency. if \"object\" in obj and obj . object == \"list\" : obj . _retrieve_params = params return obj djstripe . models . billing . SubscriptionSchedule . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . SubscriptionSchedule . stripe_class . release ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def release ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/release\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_end_behavior_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_end_behavior_display()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.SubscriptionSchedule.get_status_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.billing.TaxId","text":"TaxId(djstripe_id, id, djstripe_owner_account, livemode, created, djstripe_created, djstripe_updated, country, customer, type, value, verification)","title":"TaxId"},{"location":"reference/models/#djstripe.models.billing.TaxId.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.billing.TaxId.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.TaxId.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.billing.TaxId.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.TaxId.metadata","text":"","title":"metadata"},{"location":"reference/models/#djstripe.models.billing.TaxId.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.billing.TaxId.value","text":"","title":"value"},{"location":"reference/models/#djstripe.models.billing.TaxId.verification","text":"","title":"verification"},{"location":"reference/models/#djstripe.models.billing.TaxId.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.TaxId.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.TaxId.stripe_class","text":"djstripe . models . billing . TaxId . stripe_class . OBJECT_NAME djstripe . models . billing . TaxId . stripe_class . instance_url ( self ) Source code in djstripe/models/billing.py def instance_url ( self ): token = util . utf8 ( self . id ) customer = util . utf8 ( self . customer ) base = Customer . class_url () cust_extn = quote_plus ( customer ) extn = quote_plus ( token ) return \" %s / %s /tax_ids/ %s \" % ( base , cust_extn , extn ) djstripe . models . billing . TaxId . stripe_class . retrieve ( id , api_key = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def retrieve ( cls , id , api_key = None , ** params ): raise NotImplementedError ( \"Can't retrieve a tax id without a customer ID. Use customer.retrieve_tax_id('tax_id')\" )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.TaxId-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.TaxId.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): return self . value","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.TaxId.api_list","text":"Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): # OVERRIDING the parent version of this function # TaxIds must be manipulated through a customer.. from .core import Customer if \"customer\" not in kwargs or not isinstance ( kwargs [ \"customer\" ], Customer ): raise StripeObjectManipulationException ( \"TaxIds must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) customer = kwargs [ \"customer\" ] return customer . api_retrieve ( api_key = api_key ) . tax_ids","title":"api_list()"},{"location":"reference/models/#djstripe.models.billing.TaxId.api_retrieve","text":"Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , api_key = None , stripe_account = None ): if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) customer = self . customer . api_retrieve ( api_key = api_key or self . default_api_key , stripe_account = stripe_account , ) return customer . retrieve_tax_id ( customer . id , self . id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , )","title":"api_retrieve()"},{"location":"reference/models/#djstripe.models.billing.TaxId.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.TaxId.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.TaxId.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.TaxId.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.TaxId.get_type_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.billing.TaxRate","text":"Tax rates can be applied to invoices and subscriptions to collect tax. Stripe documentation: https://stripe.com/docs/api/tax_rates","title":"TaxRate"},{"location":"reference/models/#djstripe.models.billing.TaxRate.active","text":"","title":"active"},{"location":"reference/models/#djstripe.models.billing.TaxRate.display_name","text":"","title":"display_name"},{"location":"reference/models/#djstripe.models.billing.TaxRate.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.TaxRate.inclusive","text":"","title":"inclusive"},{"location":"reference/models/#djstripe.models.billing.TaxRate.jurisdiction","text":"","title":"jurisdiction"},{"location":"reference/models/#djstripe.models.billing.TaxRate.percentage","text":"","title":"percentage"},{"location":"reference/models/#djstripe.models.billing.TaxRate.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.TaxRate.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.TaxRate.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.TaxRate.__str__","text":"Source code in djstripe/models/billing.py def __str__ ( self ): return f \" { self . display_name } \u2013 { self . jurisdiction } at { self . percentage } %\"","title":"__str__()"},{"location":"reference/models/#djstripe.models.billing.TaxRate.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.TaxRate.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.TaxRate.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.TaxRate.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice","text":"The preview of an upcoming invoice - does not exist in the Django database. See BaseInvoice.upcoming() Logically it should be set abstract, but that doesn't quite work since we do actually want to instantiate the model and use relations.","title":"UpcomingInvoice"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.customer","text":"","title":"customer"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.default_payment_method","text":"","title":"default_payment_method"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.default_source","text":"","title":"default_source"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.default_tax_rates","text":"Gets the default tax rates associated with this upcoming invoice. :return:","title":"default_tax_rates"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.id","text":"","title":"id"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.invoiceitems","text":"Gets the invoice items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the invoiceitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail.","title":"invoiceitems"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.payment_intent","text":"","title":"payment_intent"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.subscription","text":"","title":"subscription"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.total_tax_amounts","text":"Gets the total tax amounts associated with this upcoming invoice. :return:","title":"total_tax_amounts"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.__init__","text":"Source code in djstripe/models/billing.py def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _invoiceitems = [] self . _default_tax_rates = [] self . _total_tax_amounts = []","title":"__init__()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice._attach_objects_hook","text":"Gets called by this object's create and sync methods just before save. Use this to populate fields before the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict :param current_ids: stripe ids of objects that are currently being processed :type current_ids: set Source code in djstripe/models/billing.py def _attach_objects_hook ( self , cls , data , current_ids = None ): super () . _attach_objects_hook ( cls , data , current_ids = current_ids ) self . _invoiceitems = cls . _stripe_object_to_invoice_items ( target_cls = InvoiceItem , data = data , invoice = self )","title":"_attach_objects_hook()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice._attach_objects_post_save_hook","text":"Gets called by this object's create and sync methods just after save. Use this to populate fields after the model is saved. :param cls: The target class for the instantiated object. :param data: The data dictionary received from the Stripe API. :type data: dict Source code in djstripe/models/billing.py def _attach_objects_post_save_hook ( self , cls , data , pending_relations = None ): super () . _attach_objects_post_save_hook ( cls , data , pending_relations = pending_relations ) self . _default_tax_rates = cls . _stripe_object_to_default_tax_rates ( target_cls = TaxRate , data = data ) total_tax_amounts = [] for tax_amount_data in data . get ( \"total_tax_amounts\" , []): tax_rate_data = tax_amount_data [ \"tax_rate\" ] if isinstance ( tax_rate_data , str ): tax_rate_data = { \"tax_rate\" : tax_rate_data } tax_rate , _ = TaxRate . _get_or_create_from_stripe_object ( tax_rate_data , field_name = \"tax_rate\" , refetch = True ) tax_amount = DjstripeUpcomingInvoiceTotalTaxAmount ( invoice = self , amount = tax_amount_data [ \"amount\" ], inclusive = tax_amount_data [ \"inclusive\" ], tax_rate = tax_rate , ) total_tax_amounts . append ( tax_amount ) self . _total_tax_amounts = total_tax_amounts","title":"_attach_objects_post_save_hook()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_billing_reason_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_billing_reason_display()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_collection_method_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_collection_method_display()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_customer_tax_exempt_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_customer_tax_exempt_display()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_next_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_next_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_previous_by_period_end","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_end()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_previous_by_period_start","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_period_start()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_status_display","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.get_stripe_dashboard_url","text":"Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return \"\"","title":"get_stripe_dashboard_url()"},{"location":"reference/models/#djstripe.models.billing.UpcomingInvoice.save","text":"Save the current instance. Override this in a subclass if you want to control the saving process. The 'force_insert' and 'force_update' parameters can be used to insist that the \"save\" must be an SQL insert or update (or equivalent for non-SQL backends), respectively. Normally, they should not be set. Source code in djstripe/models/billing.py def save ( self , * args , ** kwargs ): return # noop","title":"save()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord","text":"Usage records allow you to continually report usage and metrics to Stripe for metered billing of plans. Stripe documentation: https://stripe.com/docs/api#usage_records","title":"UsageRecord"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.quantity","text":"","title":"quantity"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.subscription_item","text":"","title":"subscription_item"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.stripe_class","text":"djstripe . models . billing . UsageRecord . stripe_class . OBJECT_NAME djstripe . models . billing . UsageRecord . stripe_class . create ( api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def create ( cls , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): if \"subscription_item\" not in params : raise ValueError ( \"Params must have a subscription_item key\" ) subscription_item = params . pop ( \"subscription_item\" ) requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) url = \"/v1/subscription_items/ %s /usage_records\" % subscription_item headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.get_next_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.get_next_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.get_previous_by_djstripe_created","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.billing.UsageRecord.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#connect","text":"","title":"Connect"},{"location":"reference/models/#djstripe.models.account-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.account.Account","text":"Stripe documentation: https://stripe.com/docs/api#account","title":"Account"},{"location":"reference/models/#djstripe.models.account.Account-attributes","text":"","title":"Attributes"},{"location":"reference/models/#djstripe.models.account.Account.branding_icon","text":"","title":"branding_icon"},{"location":"reference/models/#djstripe.models.account.Account.branding_logo","text":"","title":"branding_logo"},{"location":"reference/models/#djstripe.models.account.Account.business_profile","text":"","title":"business_profile"},{"location":"reference/models/#djstripe.models.account.Account.business_type","text":"","title":"business_type"},{"location":"reference/models/#djstripe.models.account.Account.business_url","text":"The business\u2019s publicly available website.","title":"business_url"},{"location":"reference/models/#djstripe.models.account.Account.charges_enabled","text":"","title":"charges_enabled"},{"location":"reference/models/#djstripe.models.account.Account.company","text":"","title":"company"},{"location":"reference/models/#djstripe.models.account.Account.country","text":"","title":"country"},{"location":"reference/models/#djstripe.models.account.Account.default_api_key","text":"","title":"default_api_key"},{"location":"reference/models/#djstripe.models.account.Account.default_currency","text":"","title":"default_currency"},{"location":"reference/models/#djstripe.models.account.Account.details_submitted","text":"","title":"details_submitted"},{"location":"reference/models/#djstripe.models.account.Account.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.account.Account.email","text":"","title":"email"},{"location":"reference/models/#djstripe.models.account.Account.individual","text":"","title":"individual"},{"location":"reference/models/#djstripe.models.account.Account.payouts_enabled","text":"","title":"payouts_enabled"},{"location":"reference/models/#djstripe.models.account.Account.product_description","text":"","title":"product_description"},{"location":"reference/models/#djstripe.models.account.Account.requirements","text":"","title":"requirements"},{"location":"reference/models/#djstripe.models.account.Account.settings","text":"","title":"settings"},{"location":"reference/models/#djstripe.models.account.Account.tos_acceptance","text":"","title":"tos_acceptance"},{"location":"reference/models/#djstripe.models.account.Account.type","text":"","title":"type"},{"location":"reference/models/#djstripe.models.account.Account.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.account.Account.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.account.Account.stripe_class","text":"djstripe . models . account . Account . stripe_class . OBJECT_NAME djstripe . models . account . Account . stripe_class . capabilitys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . capabilitys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . create_external_account ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_login_link ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_person ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . deauthorize ( self , ** params ) Source code in djstripe/models/account.py def deauthorize ( self , ** params ): params [ \"stripe_user_id\" ] = self . id return oauth . OAuth . deauthorize ( ** params ) djstripe . models . account . Account . stripe_class . delete_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . delete_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . external_accounts_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . external_accounts_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . instance_url ( self ) Source code in djstripe/models/account.py def instance_url ( self ): return self . _build_instance_url ( self . get ( \"id\" )) djstripe . models . account . Account . stripe_class . list_capabilities ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_external_accounts ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_persons ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . login_links_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . login_links_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . modify ( id = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def modify ( cls , id = None , ** params ): url = cls . _build_instance_url ( id ) return cls . _static_request ( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . persons ( self , ** params ) Source code in djstripe/models/account.py def persons ( self , ** params ): return self . request ( \"get\" , self . instance_url () + \"/persons\" , params ) djstripe . models . account . Account . stripe_class . persons_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . persons_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . reject ( self , idempotency_key = None , ** params ) Source code in djstripe/models/account.py def reject ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reject\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . account . Account . stripe_class . retrieve ( id = None , api_key = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def retrieve ( cls , id = None , api_key = None , ** params ): instance = cls ( id , api_key , ** params ) instance . refresh () return instance djstripe . models . account . Account . stripe_class . retrieve_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . serialize ( self , previous ) Source code in djstripe/models/account.py def serialize ( self , previous ): params = super ( Account , self ) . serialize ( previous ) previous = previous or self . _previous or {} for k , v in six . iteritems ( self ): if ( k == \"individual\" and isinstance ( v , stripe . api_resources . Person ) and k not in params ): params [ k ] = v . serialize ( previous . get ( k , None )) return params","title":"stripe_class"},{"location":"reference/models/#djstripe.models.account.Account.__str__","text":"Source code in djstripe/models/account.py def __str__ ( self ): settings = self . settings or {} business_profile = self . business_profile or {} return ( settings . get ( \"dashboard\" , {}) . get ( \"display_name\" ) or business_profile . get ( \"name\" ) or super () . __str__ () )","title":"__str__()"},{"location":"reference/models/#djstripe.models.account.Account.get_business_type_display","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_business_type_display()"},{"location":"reference/models/#djstripe.models.account.Account.get_connected_account_from_token","text":"Source code in djstripe/models/account.py @classmethod def get_connected_account_from_token ( cls , access_token ): warnings . warn ( \"Account.get_connected_account_from_token is deprecated.\" \"Use Account.get_or_retrieve_for_api_key() instead.\" , DeprecationWarning , ) account_data = cls . stripe_class . retrieve ( api_key = access_token ) return cls . _get_or_create_from_stripe_object ( account_data )[ 0 ]","title":"get_connected_account_from_token()"},{"location":"reference/models/#djstripe.models.account.Account.get_default_account","text":"Source code in djstripe/models/account.py @classmethod def get_default_account ( cls ): # As of API version 2020-03-02, there is no permission that can allow # restricted keys to call GET /v1/account if djstripe_settings . STRIPE_SECRET_KEY . startswith ( \"rk_\" ): return None account_data = cls . stripe_class . retrieve ( api_key = djstripe_settings . STRIPE_SECRET_KEY ) return cls . _get_or_create_from_stripe_object ( account_data )[ 0 ]","title":"get_default_account()"},{"location":"reference/models/#djstripe.models.account.Account.get_default_api_key","text":"Source code in djstripe/models/account.py def get_default_api_key ( self ) -> str : api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret ) . first () if api_key : return api_key . secret return djstripe_settings . get_default_api_key ( self . livemode )","title":"get_default_api_key()"},{"location":"reference/models/#djstripe.models.account.Account.get_next_by_djstripe_created","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.account.Account.get_next_by_djstripe_updated","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.account.Account.get_or_retrieve_for_api_key","text":"Source code in djstripe/models/account.py @classmethod def get_or_retrieve_for_api_key ( cls , api_key : str ): with transaction . atomic (): apikey_instance , _ = APIKey . objects . get_or_create_by_api_key ( api_key ) if not apikey_instance . djstripe_owner_account : apikey_instance . refresh_account () return apikey_instance . djstripe_owner_account","title":"get_or_retrieve_for_api_key()"},{"location":"reference/models/#djstripe.models.account.Account.get_previous_by_djstripe_created","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.account.Account.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.account.Account.get_type_display","text":"Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_type_display()"},{"location":"reference/models/#djstripe.models.connect-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee","text":"When you collect a transaction fee on top of a charge made for your user (using Connect), an ApplicationFee is created in your account. Stripe documentation: https://stripe.com/docs/api#application_fees","title":"ApplicationFee"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.amount_refunded","text":"","title":"amount_refunded"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.charge","text":"","title":"charge"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.refunded","text":"","title":"refunded"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.stripe_class","text":"djstripe . models . connect . ApplicationFee . stripe_class . OBJECT_NAME djstripe . models . connect . ApplicationFee . stripe_class . create_refund ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . list_refunds ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . modify_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def refund ( self , idempotency_key = None , ** params ): headers = util . populate_headers ( idempotency_key ) url = self . instance_url () + \"/refund\" self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . ApplicationFee . stripe_class . refunds_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . ApplicationFee . stripe_class . refunds_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . connect . ApplicationFee . stripe_class . retrieve_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params )","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.get_next_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.get_next_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.get_previous_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFee.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund","text":"ApplicationFeeRefund objects allow you to refund an ApplicationFee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected. Stripe documentation: https://stripe.com/docs/api#fee_refunds","title":"ApplicationFeeRefund"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.get_next_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.get_next_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.get_previous_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.ApplicationFeeRefund.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec","text":"Stripe documentation: https://stripe.com/docs/api#country_specs","title":"CountrySpec"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.created","text":"","title":"created"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.default_currency","text":"","title":"default_currency"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.description","text":"","title":"description"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.djstripe_id","text":"","title":"djstripe_id"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.livemode","text":"","title":"livemode"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.metadata","text":"","title":"metadata"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_bank_account_currencies","text":"","title":"supported_bank_account_currencies"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_payment_currencies","text":"","title":"supported_payment_currencies"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_payment_methods","text":"","title":"supported_payment_methods"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.supported_transfer_countries","text":"","title":"supported_transfer_countries"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.verification_fields","text":"","title":"verification_fields"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.stripe_class","text":"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.get_next_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.get_next_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.get_previous_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.CountrySpec.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.Transfer","text":"When Stripe sends you money or you initiate a transfer to a bank account, debit card, or connected Stripe account, a transfer object will be created. Stripe documentation: https://stripe.com/docs/api/python#transfers","title":"Transfer"},{"location":"reference/models/#djstripe.models.connect.Transfer.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.Transfer.amount_reversed","text":"","title":"amount_reversed"},{"location":"reference/models/#djstripe.models.connect.Transfer.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.Transfer.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.Transfer.destination","text":"","title":"destination"},{"location":"reference/models/#djstripe.models.connect.Transfer.destination_payment","text":"","title":"destination_payment"},{"location":"reference/models/#djstripe.models.connect.Transfer.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.connect.Transfer.expand_fields","text":"","title":"expand_fields"},{"location":"reference/models/#djstripe.models.connect.Transfer.fee","text":"","title":"fee"},{"location":"reference/models/#djstripe.models.connect.Transfer.objects","text":"","title":"objects"},{"location":"reference/models/#djstripe.models.connect.Transfer.reversed","text":"","title":"reversed"},{"location":"reference/models/#djstripe.models.connect.Transfer.source_transaction","text":"","title":"source_transaction"},{"location":"reference/models/#djstripe.models.connect.Transfer.source_type","text":"","title":"source_type"},{"location":"reference/models/#djstripe.models.connect.Transfer.stripe_dashboard_item_name","text":"","title":"stripe_dashboard_item_name"},{"location":"reference/models/#djstripe.models.connect.Transfer.transfer_group","text":"","title":"transfer_group"},{"location":"reference/models/#djstripe.models.connect.Transfer.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.connect.Transfer.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.connect.Transfer.stripe_class","text":"djstripe . models . connect . Transfer . stripe_class . OBJECT_NAME djstripe . models . connect . Transfer . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . Transfer . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . Transfer . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.Transfer-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_next_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_next_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_previous_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.Transfer.get_source_type_display","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_source_type_display()"},{"location":"reference/models/#djstripe.models.connect.Transfer.str_parts","text":"Extend this to add information to the string representation of the object Source code in djstripe/models/connect.py def str_parts ( self ): return [ \"amount= {amount} \" . format ( amount = self . amount )] + super () . str_parts ()","title":"str_parts()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal","text":"Stripe documentation: https://stripe.com/docs/api#transfer_reversals","title":"TransferReversal"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.amount","text":"","title":"amount"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.balance_transaction","text":"","title":"balance_transaction"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.currency","text":"","title":"currency"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.transfer","text":"","title":"transfer"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.stripe_class","text":"djstripe . models . connect . TransferReversal . stripe_class . OBJECT_NAME djstripe . models . connect . TransferReversal . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . TransferReversal . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . TransferReversal . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"stripe_class"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.get_next_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.get_next_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.get_previous_by_djstripe_created","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.connect.TransferReversal.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#fraud","text":"","title":"Fraud"},{"location":"reference/models/#orders","text":"","title":"Orders"},{"location":"reference/models/#sigma","text":"","title":"Sigma"},{"location":"reference/models/#djstripe.models.sigma-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun","text":"Stripe documentation: https://stripe.com/docs/api#scheduled_queries","title":"ScheduledQueryRun"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.data_load_time","text":"","title":"data_load_time"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.djstripe_owner_account","text":"","title":"djstripe_owner_account"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.error","text":"","title":"error"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.file","text":"","title":"file"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.result_available_until","text":"","title":"result_available_until"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.sql","text":"","title":"sql"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.status","text":"","title":"status"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.title","text":"","title":"title"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.stripe_class","text":"djstripe . models . sigma . ScheduledQueryRun . stripe_class . OBJECT_NAME djstripe . models . sigma . ScheduledQueryRun . stripe_class . class_url () classmethod Source code in djstripe/models/sigma.py @classmethod def class_url ( cls ): return \"/v1/sigma/scheduled_query_runs\"","title":"stripe_class"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_next_by_data_load_time","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_data_load_time()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_next_by_djstripe_created","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_next_by_djstripe_updated","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_next_by_result_available_until","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_result_available_until()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_previous_by_data_load_time","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_data_load_time()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_previous_by_djstripe_created","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_created()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_previous_by_djstripe_updated","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_djstripe_updated()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_previous_by_result_available_until","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_result_available_until()"},{"location":"reference/models/#djstripe.models.sigma.ScheduledQueryRun.get_status_display","text":"Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_status_display()"},{"location":"reference/models/#webhooks","text":"","title":"Webhooks"},{"location":"reference/models/#djstripe.models.webhooks-classes","text":"","title":"Classes"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger","text":"An instance of a request that reached the server endpoint for Stripe webhooks. Webhook Events are initially UNTRUSTED , as it is possible for any web entity to post any data to our webhook url. Data posted may be valid Stripe information, garbage, or even malicious. The 'valid' flag in this model monitors this.","title":"WebhookEventTrigger"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.body","text":"","title":"body"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.created","text":"","title":"created"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.djstripe_version","text":"","title":"djstripe_version"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.event","text":"","title":"event"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.exception","text":"","title":"exception"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.headers","text":"","title":"headers"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.id","text":"","title":"id"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.is_test_event","text":"","title":"is_test_event"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.processed","text":"","title":"processed"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.remote_ip","text":"","title":"remote_ip"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.traceback","text":"","title":"traceback"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.updated","text":"","title":"updated"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.valid","text":"","title":"valid"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.DoesNotExist","text":"","title":"DoesNotExist"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.MultipleObjectsReturned","text":"","title":"MultipleObjectsReturned"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger-methods","text":"","title":"Methods"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.from_request","text":"Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). Source code in djstripe/models/webhooks.py @classmethod def from_request ( cls , request ): \"\"\" Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). \"\"\" try : body = request . body . decode ( request . encoding or \"utf-8\" ) except Exception : body = \"(error decoding body)\" ip = request . META . get ( \"REMOTE_ADDR\" ) if not ip : warnings . warn ( \"Could not determine remote IP (missing REMOTE_ADDR). \" \"This is likely an issue with your wsgi/server setup.\" ) ip = \"0.0.0.0\" obj = cls . objects . create ( headers = dict ( request . headers ), body = body , remote_ip = ip ) try : obj . valid = obj . validate () if obj . valid : if djstripe_settings . WEBHOOK_EVENT_CALLBACK : # If WEBHOOK_EVENT_CALLBACK, pass it for processing djstripe_settings . WEBHOOK_EVENT_CALLBACK ( obj ) else : # Process the item (do not save it, it'll get saved below) obj . process ( save = False ) except Exception as e : max_length = WebhookEventTrigger . _meta . get_field ( \"exception\" ) . max_length obj . exception = str ( e )[: max_length ] obj . traceback = format_exc () # Send the exception as the webhook_processing_error signal webhook_processing_error . send ( sender = WebhookEventTrigger , exception = e , data = getattr ( e , \"http_body\" , \"\" ), ) # re-raise the exception so Django sees it raise e finally : obj . save () return obj","title":"from_request()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.get_next_by_created","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_created()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.get_next_by_updated","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_next_by_updated()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.get_previous_by_created","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_created()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.get_previous_by_updated","text":"Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"get_previous_by_updated()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.process","text":"Source code in djstripe/models/webhooks.py def process ( self , save = True ): # Reset traceback and exception in case of reprocessing self . exception = \"\" self . traceback = \"\" self . event = Event . process ( self . json_body ) self . processed = True if save : self . save () return self . event","title":"process()"},{"location":"reference/models/#djstripe.models.webhooks.WebhookEventTrigger.validate","text":"The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. Source code in djstripe/models/webhooks.py def validate ( self , api_key = None ): \"\"\" The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. \"\"\" local_data = self . json_body if \"id\" not in local_data or \"livemode\" not in local_data : return False if self . is_test_event : logger . info ( \"Test webhook received: {} \" . format ( local_data )) return False if djstripe_settings . WEBHOOK_VALIDATION is None : # validation disabled return True elif ( djstripe_settings . WEBHOOK_VALIDATION == \"verify_signature\" and djstripe_settings . WEBHOOK_SECRET ): # HTTP headers are case-insensitive, but we store them as a dict. headers = CaseInsensitiveMapping ( self . headers ) try : stripe . WebhookSignature . verify_header ( self . body , headers . get ( \"stripe-signature\" ), djstripe_settings . WEBHOOK_SECRET , djstripe_settings . WEBHOOK_TOLERANCE , ) except stripe . error . SignatureVerificationError : return False else : return True livemode = local_data [ \"livemode\" ] api_key = api_key or djstripe_settings . get_default_api_key ( livemode ) # Retrieve the event using the api_version specified in itself with stripe_temporary_api_version ( local_data [ \"api_version\" ], validate = False ): remote_data = Event . stripe_class . retrieve ( id = local_data [ \"id\" ], api_key = api_key ) return local_data [ \"data\" ] == remote_data [ \"data\" ]","title":"validate()"},{"location":"reference/project/","text":"djstripe . models . __all__ special Modules djstripe.models.account Classes djstripe.models.account.Account Stripe documentation: https://stripe.com/docs/api#account Attributes djstripe . models . account . Account . branding_icon property readonly djstripe . models . account . Account . branding_logo property readonly djstripe . models . account . Account . business_profile djstripe . models . account . Account . business_type djstripe . models . account . Account . business_url : str property readonly The business\u2019s publicly available website. djstripe . models . account . Account . charges_enabled djstripe . models . account . Account . company djstripe . models . account . Account . country djstripe . models . account . Account . default_api_key : str property readonly djstripe . models . account . Account . default_currency djstripe . models . account . Account . details_submitted djstripe . models . account . Account . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . account . Account . email djstripe . models . account . Account . individual djstripe . models . account . Account . payouts_enabled djstripe . models . account . Account . product_description djstripe . models . account . Account . requirements djstripe . models . account . Account . settings djstripe . models . account . Account . tos_acceptance djstripe . models . account . Account . type djstripe.models.account.Account.DoesNotExist djstripe.models.account.Account.MultipleObjectsReturned djstripe.models.account.Account.stripe_class djstripe . models . account . Account . stripe_class . OBJECT_NAME djstripe . models . account . Account . stripe_class . capabilitys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . capabilitys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . create_external_account ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_login_link ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_person ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . deauthorize ( self , ** params ) Source code in djstripe/models/account.py def deauthorize ( self , ** params ): params [ \"stripe_user_id\" ] = self . id return oauth . OAuth . deauthorize ( ** params ) djstripe . models . account . Account . stripe_class . delete_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . delete_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . external_accounts_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . external_accounts_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . instance_url ( self ) Source code in djstripe/models/account.py def instance_url ( self ): return self . _build_instance_url ( self . get ( \"id\" )) djstripe . models . account . Account . stripe_class . list_capabilities ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_external_accounts ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_persons ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . login_links_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . login_links_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . modify ( id = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def modify ( cls , id = None , ** params ): url = cls . _build_instance_url ( id ) return cls . _static_request ( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . persons ( self , ** params ) Source code in djstripe/models/account.py def persons ( self , ** params ): return self . request ( \"get\" , self . instance_url () + \"/persons\" , params ) djstripe . models . account . Account . stripe_class . persons_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . persons_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . reject ( self , idempotency_key = None , ** params ) Source code in djstripe/models/account.py def reject ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reject\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . account . Account . stripe_class . retrieve ( id = None , api_key = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def retrieve ( cls , id = None , api_key = None , ** params ): instance = cls ( id , api_key , ** params ) instance . refresh () return instance djstripe . models . account . Account . stripe_class . retrieve_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . serialize ( self , previous ) Source code in djstripe/models/account.py def serialize ( self , previous ): params = super ( Account , self ) . serialize ( previous ) previous = previous or self . _previous or {} for k , v in six . iteritems ( self ): if ( k == \"individual\" and isinstance ( v , stripe . api_resources . Person ) and k not in params ): params [ k ] = v . serialize ( previous . get ( k , None )) return params djstripe . models . account . Account . __str__ ( self ) special Source code in djstripe/models/account.py def __str__ ( self ): settings = self . settings or {} business_profile = self . business_profile or {} return ( settings . get ( \"dashboard\" , {}) . get ( \"display_name\" ) or business_profile . get ( \"name\" ) or super () . __str__ () ) djstripe . models . account . Account . get_business_type_display ( self , * , field =< djstripe . fields . StripeEnumField : business_type > ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_connected_account_from_token ( access_token ) classmethod Source code in djstripe/models/account.py @classmethod def get_connected_account_from_token ( cls , access_token ): warnings . warn ( \"Account.get_connected_account_from_token is deprecated.\" \"Use Account.get_or_retrieve_for_api_key() instead.\" , DeprecationWarning , ) account_data = cls . stripe_class . retrieve ( api_key = access_token ) return cls . _get_or_create_from_stripe_object ( account_data )[ 0 ] djstripe . models . account . Account . get_default_account () classmethod Source code in djstripe/models/account.py @classmethod def get_default_account ( cls ): # As of API version 2020-03-02, there is no permission that can allow # restricted keys to call GET /v1/account if djstripe_settings . STRIPE_SECRET_KEY . startswith ( \"rk_\" ): return None account_data = cls . stripe_class . retrieve ( api_key = djstripe_settings . STRIPE_SECRET_KEY ) return cls . _get_or_create_from_stripe_object ( account_data )[ 0 ] djstripe . models . account . Account . get_default_api_key ( self ) Source code in djstripe/models/account.py def get_default_api_key ( self ) -> str : api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret ) . first () if api_key : return api_key . secret return djstripe_settings . get_default_api_key ( self . livemode ) djstripe . models . account . Account . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_or_retrieve_for_api_key ( api_key ) classmethod Source code in djstripe/models/account.py @classmethod def get_or_retrieve_for_api_key ( cls , api_key : str ): with transaction . atomic (): apikey_instance , _ = APIKey . objects . get_or_create_by_api_key ( api_key ) if not apikey_instance . djstripe_owner_account : apikey_instance . refresh_account () return apikey_instance . djstripe_owner_account djstripe . models . account . Account . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.api djstripe . models . api . API_KEY_REGEX Classes djstripe.models.api.APIKey APIKey(djstripe_id, djstripe_owner_account, created, djstripe_created, djstripe_updated, id, type, name, secret, livemode) Attributes djstripe . models . api . APIKey . description djstripe . models . api . APIKey . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . api . APIKey . metadata djstripe . models . api . APIKey . name djstripe . models . api . APIKey . object djstripe . models . api . APIKey . objects djstripe . models . api . APIKey . secret djstripe . models . api . APIKey . secret_redacted : str property readonly Returns a redacted version of the secret, suitable for display purposes. Same algorithm used on the Stripe dashboard. djstripe . models . api . APIKey . type djstripe.models.api.APIKey.DoesNotExist djstripe.models.api.APIKey.MultipleObjectsReturned Methods djstripe . models . api . APIKey . __str__ ( self ) special Source code in djstripe/models/api.py def __str__ ( self ): return self . name or self . secret_redacted djstripe . models . api . APIKey . clean ( self ) Hook for doing any extra model-wide validation after clean() has been called on every field by self.clean_fields. Any ValidationError raised by this method will not be associated with a particular field; it will have a special-case association with the field defined by NON_FIELD_ERRORS. Source code in djstripe/models/api.py def clean ( self ): self . _clean_livemode_and_type () if not self . djstripe_owner_account : self . refresh_account () return super () . clean () djstripe . models . api . APIKey . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/api.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . api . APIKey . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/api.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . api . APIKey . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/api.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . api . APIKey . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/api.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . api . APIKey . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/api.py def get_stripe_dashboard_url ( self ): return self . _get_base_stripe_dashboard_url () + \"apikeys\" djstripe . models . api . APIKey . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/api.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . api . APIKey . refresh_account ( self , commit = True ) Source code in djstripe/models/api.py def refresh_account ( self , commit = True ): from .account import Account if self . type != APIKeyType . secret : return account_data = Account . stripe_class . retrieve ( api_key = self . secret ) # NOTE: Do not immediately use _get_or_create_from_stripe_object() here. # Account needs to exist for things to work. Make a stub if necessary. account , created = Account . objects . get_or_create ( id = account_data [ \"id\" ], defaults = { \"charges_enabled\" : False , \"details_submitted\" : False }, ) if created : # If it's just been created, now we can sync the account. Account . sync_from_stripe_data ( account_data ) self . djstripe_owner_account = account if commit : self . save () djstripe . models . api . APIKey . save ( self , * args , ** kwargs ) Save the current instance. Override this in a subclass if you want to control the saving process. The 'force_insert' and 'force_update' parameters can be used to insist that the \"save\" must be an SQL insert or update (or equivalent for non-SQL backends), respectively. Normally, they should not be set. Source code in djstripe/models/api.py def save ( self , * args , ** kwargs ): self . _clean_livemode_and_type () if not self . djstripe_owner_account : self . refresh_account ( commit = False ) return super () . save ( * args , ** kwargs ) djstripe.models.api.APIKeyManager djstripe . models . api . APIKeyManager . get_or_create_by_api_key ( self , secret ) Source code in djstripe/models/api.py def get_or_create_by_api_key ( self , secret : str ): key_type , livemode = get_api_key_details_by_prefix ( secret ) return super () . get_or_create ( secret = secret , defaults = { \"type\" : key_type , \"livemode\" : livemode } ) djstripe . models . api . generate_api_key_id () Source code in djstripe/models/api.py def generate_api_key_id () -> str : b64_id = b64encode ( uuid4 () . bytes ) . decode () generated_id = b64_id . rstrip ( \"=\" ) . replace ( \"+\" , \"\" ) . replace ( \"/\" , \"\" ) return f \"djstripe_mk_ { generated_id } \" djstripe . models . api . get_api_key_details_by_prefix ( api_key ) Source code in djstripe/models/api.py def get_api_key_details_by_prefix ( api_key : str ): sre = re . match ( API_KEY_REGEX , api_key ) if not sre : raise ValueError ( f \"Invalid API key: { api_key !r} \" ) key_type = { \"pk\" : APIKeyType . publishable , \"sk\" : APIKeyType . secret , \"rk\" : APIKeyType . restricted , } . get ( sre . group ( 1 ), \"\" ) livemode = { \"test\" : False , \"live\" : True } . get ( sre . group ( 2 )) return key_type , livemode djstripe.models.base djstripe . models . base . logger Classes djstripe.models.base.IdempotencyKey IdempotencyKey(uuid, action, livemode, created) djstripe . models . base . IdempotencyKey . action djstripe . models . base . IdempotencyKey . created djstripe . models . base . IdempotencyKey . is_expired : bool property readonly djstripe . models . base . IdempotencyKey . livemode djstripe . models . base . IdempotencyKey . uuid djstripe.models.base.IdempotencyKey.DoesNotExist djstripe.models.base.IdempotencyKey.MultipleObjectsReturned djstripe . models . base . IdempotencyKey . __str__ ( self ) special Source code in djstripe/models/base.py def __str__ ( self ): return str ( self . uuid ) djstripe . models . base . IdempotencyKey . get_next_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = True , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . base . IdempotencyKey . get_previous_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = False , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.base.StripeModel djstripe . models . base . StripeModel . created djstripe . models . base . StripeModel . default_api_key : str property readonly djstripe . models . base . StripeModel . description djstripe . models . base . StripeModel . djstripe_created djstripe . models . base . StripeModel . djstripe_id djstripe . models . base . StripeModel . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . base . StripeModel . djstripe_updated djstripe . models . base . StripeModel . expand_fields : List [ str ] djstripe . models . base . StripeModel . id djstripe . models . base . StripeModel . livemode djstripe . models . base . StripeModel . metadata djstripe . models . base . StripeModel . objects djstripe . models . base . StripeModel . stripe_class : Optional [ stripe . api_resources . abstract . api_resource . APIResource ] djstripe . models . base . StripeModel . stripe_dashboard_item_name djstripe . models . base . StripeModel . stripe_objects djstripe.models.base.StripeModel.Meta djstripe . models . base . StripeModel . Meta . abstract djstripe . models . base . StripeModel . Meta . get_latest_by Methods djstripe . models . base . StripeModel . __str__ ( self ) special Source code in djstripe/models/base.py def __str__ ( self ): return smart_str ( \"< {list} >\" . format ( list = \", \" . join ( self . str_parts ()))) djstripe . models . base . StripeModel . api_list ( api_key = 'sk_test_123' , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/base.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return cls . stripe_class . list ( api_key = api_key , ** kwargs ) . auto_paging_iter () djstripe . models . base . StripeModel . api_retrieve ( self , api_key = None , stripe_account = None ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/base.py def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . retrieve ( id = self . id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , ) djstripe . models . base . StripeModel . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . base . StripeModel . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . base . StripeModel . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . base . StripeModel . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . base . StripeModel . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/base.py def get_stripe_dashboard_url ( self ) -> str : \"\"\"Get the stripe dashboard url for this object.\"\"\" if not self . stripe_dashboard_item_name or not self . id : return \"\" else : return \" {base_url}{item} / {id} \" . format ( base_url = self . _get_base_stripe_dashboard_url (), item = self . stripe_dashboard_item_name , id = self . id , ) djstripe . models . base . StripeModel . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/base.py @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return \"object\" in data and data [ \"object\" ] == cls . stripe_class . OBJECT_NAME djstripe . models . base . StripeModel . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/base.py def str_parts ( self ) -> List [ str ]: \"\"\" Extend this to add information to the string representation of the object \"\"\" return [ \"id= {id} \" . format ( id = self . id )] djstripe . models . base . StripeModel . sync_from_stripe_data ( data ) classmethod Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls Source code in djstripe/models/base.py @classmethod def sync_from_stripe_data ( cls , data ): \"\"\" Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls \"\"\" current_ids = set () data_id = data . get ( \"id\" ) if data_id : # stop nested objects from trying to retrieve this object before # initial sync is complete current_ids . add ( data_id ) instance , created = cls . _get_or_create_from_stripe_object ( data , current_ids = current_ids ) if not created : record_data = cls . _stripe_object_to_record ( data ) for attr , value in record_data . items (): setattr ( instance , attr , value ) instance . _attach_objects_hook ( cls , data , current_ids = current_ids ) instance . save () instance . _attach_objects_post_save_hook ( cls , data ) return instance djstripe.models.billing Classes djstripe.models.billing.BaseInvoice The abstract base model shared by Invoice and UpcomingInvoice Note: Most fields are defined on BaseInvoice so they're available to both models. ManyToManyFields are an exception, since UpcomingInvoice doesn't exist in the db. Attributes djstripe . models . billing . BaseInvoice . account_country djstripe . models . billing . BaseInvoice . account_name djstripe . models . billing . BaseInvoice . amount_due djstripe . models . billing . BaseInvoice . amount_paid djstripe . models . billing . BaseInvoice . amount_remaining djstripe . models . billing . BaseInvoice . application_fee_amount djstripe . models . billing . BaseInvoice . attempt_count djstripe . models . billing . BaseInvoice . attempted djstripe . models . billing . BaseInvoice . auto_advance djstripe . models . billing . BaseInvoice . billing_reason djstripe . models . billing . BaseInvoice . charge djstripe . models . billing . BaseInvoice . collection_method djstripe . models . billing . BaseInvoice . currency djstripe . models . billing . BaseInvoice . customer djstripe . models . billing . BaseInvoice . customer_address djstripe . models . billing . BaseInvoice . customer_email djstripe . models . billing . BaseInvoice . customer_name djstripe . models . billing . BaseInvoice . customer_phone djstripe . models . billing . BaseInvoice . customer_shipping djstripe . models . billing . BaseInvoice . customer_tax_exempt djstripe . models . billing . BaseInvoice . default_payment_method djstripe . models . billing . BaseInvoice . discount djstripe . models . billing . BaseInvoice . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . BaseInvoice . due_date djstripe . models . billing . BaseInvoice . ending_balance djstripe . models . billing . BaseInvoice . footer djstripe . models . billing . BaseInvoice . hosted_invoice_url djstripe . models . billing . BaseInvoice . invoice_pdf djstripe . models . billing . BaseInvoice . next_payment_attempt djstripe . models . billing . BaseInvoice . number djstripe . models . billing . BaseInvoice . paid djstripe . models . billing . BaseInvoice . payment_intent djstripe . models . billing . BaseInvoice . period_end djstripe . models . billing . BaseInvoice . period_start djstripe . models . billing . BaseInvoice . plan : Optional [ Plan ] property readonly Gets the associated plan for this invoice. In order to provide a consistent view of invoices, the plan object should be taken from the first invoice item that has one, rather than using the plan associated with the subscription. Subscriptions (and their associated plan) are updated by the customer and represent what is current, but invoice items are immutable within the invoice and stay static/unchanged. In other words, a plan retrieved from an invoice item will represent the plan as it was at the time an invoice was issued. The plan retrieved from the subscription will be the currently active plan. :returns: The associated plan for the invoice. djstripe . models . billing . BaseInvoice . post_payment_credit_notes_amount djstripe . models . billing . BaseInvoice . pre_payment_credit_notes_amount djstripe . models . billing . BaseInvoice . receipt_number djstripe . models . billing . BaseInvoice . starting_balance djstripe . models . billing . BaseInvoice . statement_descriptor djstripe . models . billing . BaseInvoice . status djstripe . models . billing . BaseInvoice . status_transitions djstripe . models . billing . BaseInvoice . stripe_dashboard_item_name djstripe . models . billing . BaseInvoice . subscription djstripe . models . billing . BaseInvoice . subscription_proration_date djstripe . models . billing . BaseInvoice . subtotal djstripe . models . billing . BaseInvoice . tax djstripe . models . billing . BaseInvoice . tax_percent djstripe . models . billing . BaseInvoice . threshold_reason djstripe . models . billing . BaseInvoice . total djstripe . models . billing . BaseInvoice . webhooks_delivered_at djstripe.models.billing.BaseInvoice.Meta djstripe . models . billing . BaseInvoice . Meta . abstract djstripe . models . billing . BaseInvoice . Meta . ordering djstripe.models.billing.BaseInvoice.stripe_class djstripe . models . billing . BaseInvoice . stripe_class . OBJECT_NAME djstripe . models . billing . BaseInvoice . stripe_class . finalize_invoice ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def finalize_invoice ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/finalize\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . BaseInvoice . stripe_class . mark_uncollectible ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def mark_uncollectible ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/mark_uncollectible\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . BaseInvoice . stripe_class . pay ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def pay ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/pay\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . BaseInvoice . stripe_class . send_invoice ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def send_invoice ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/send\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . BaseInvoice . stripe_class . upcoming ( api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def upcoming ( cls , api_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) url = cls . class_url () + \"/upcoming\" response , api_key = requestor . request ( \"get\" , url , params ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . BaseInvoice . stripe_class . void_invoice ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def void_invoice ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/void\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self Methods djstripe . models . billing . BaseInvoice . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return \"Invoice # {number} \" . format ( number = self . number or self . receipt_number or self . id ) djstripe . models . billing . BaseInvoice . get_billing_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_reason > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_customer_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : customer_tax_exempt > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return self . customer . get_stripe_dashboard_url () djstripe . models . billing . BaseInvoice . retry ( self ) Retry payment on this invoice if it isn't paid or uncollectible. Source code in djstripe/models/billing.py def retry ( self ): \"\"\"Retry payment on this invoice if it isn't paid or uncollectible.\"\"\" if ( self . status != enums . InvoiceStatus . paid and self . status != enums . InvoiceStatus . uncollectible and self . auto_advance ): stripe_invoice = self . api_retrieve () updated_stripe_invoice = ( stripe_invoice . pay () ) # pay() throws an exception if the charge is not successful. type ( self ) . sync_from_stripe_data ( updated_stripe_invoice ) return True return False djstripe . models . billing . BaseInvoice . upcoming ( api_key = 'sk_test_123' , customer = None , coupon = None , subscription = None , subscription_plan = None , subscription_prorate = None , subscription_proration_date = None , subscription_quantity = None , subscription_trial_end = None , ** kwargs ) classmethod Gets the upcoming preview invoice (singular) for a customer. At any time, you can preview the upcoming invoice for a customer. This will show you all the charges that are pending, including subscription renewal charges, invoice item charges, etc. It will also show you any discount that is applicable to the customer. (Source: https://stripe.com/docs/api#upcoming_invoice) .. important:: Note that when you are viewing an upcoming invoice, you are simply viewing a preview. :param customer: The identifier of the customer whose upcoming invoice you'd like to retrieve. :type customer: Customer or string (customer ID) :param coupon: The code of the coupon to apply. :type coupon: str :param subscription: The identifier of the subscription to retrieve an invoice for. :type subscription: Subscription or string (subscription ID) :param subscription_plan: If set, the invoice returned will preview updating the subscription given to this plan, or creating a new subscription to this plan if no subscription is given. :type subscription_plan: Plan or string (plan ID) :param subscription_prorate: If previewing an update to a subscription, this decides whether the preview will show the result of applying prorations or not. :type subscription_prorate: bool :param subscription_proration_date: If previewing an update to a subscription, and doing proration, subscription_proration_date forces the proration to be calculated as though the update was done at the specified time. :type subscription_proration_date: datetime :param subscription_quantity: If provided, the invoice returned will preview updating or creating a subscription with that quantity. :type subscription_quantity: int :param subscription_trial_end: If provided, the invoice returned will preview updating or creating a subscription with that trial end. :type subscription_trial_end: datetime :returns: The upcoming preview invoice. Source code in djstripe/models/billing.py @classmethod def upcoming ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , customer = None , coupon = None , subscription = None , subscription_plan = None , subscription_prorate = None , subscription_proration_date = None , subscription_quantity = None , subscription_trial_end = None , ** kwargs , ) -> Optional [ \"UpcomingInvoice\" ]: \"\"\" Gets the upcoming preview invoice (singular) for a customer. At any time, you can preview the upcoming invoice for a customer. This will show you all the charges that are pending, including subscription renewal charges, invoice item charges, etc. It will also show you any discount that is applicable to the customer. (Source: https://stripe.com/docs/api#upcoming_invoice) .. important:: Note that when you are viewing an upcoming invoice, you are simply viewing a preview. :param customer: The identifier of the customer whose upcoming invoice \\ you'd like to retrieve. :type customer: Customer or string (customer ID) :param coupon: The code of the coupon to apply. :type coupon: str :param subscription: The identifier of the subscription to retrieve an \\ invoice for. :type subscription: Subscription or string (subscription ID) :param subscription_plan: If set, the invoice returned will preview \\ updating the subscription given to this plan, or creating a new \\ subscription to this plan if no subscription is given. :type subscription_plan: Plan or string (plan ID) :param subscription_prorate: If previewing an update to a subscription, \\ this decides whether the preview will show the result of applying \\ prorations or not. :type subscription_prorate: bool :param subscription_proration_date: If previewing an update to a \\ subscription, and doing proration, subscription_proration_date forces \\ the proration to be calculated as though the update was done at the \\ specified time. :type subscription_proration_date: datetime :param subscription_quantity: If provided, the invoice returned will \\ preview updating or creating a subscription with that quantity. :type subscription_quantity: int :param subscription_trial_end: If provided, the invoice returned will \\ preview updating or creating a subscription with that trial end. :type subscription_trial_end: datetime :returns: The upcoming preview invoice. \"\"\" # Convert Customer to id if customer is not None and isinstance ( customer , StripeModel ): customer = customer . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id # Convert Plan to id if subscription_plan is not None and isinstance ( subscription_plan , StripeModel ): subscription_plan = subscription_plan . id try : upcoming_stripe_invoice = cls . stripe_class . upcoming ( api_key = api_key , customer = customer , coupon = coupon , subscription = subscription , subscription_plan = subscription_plan , subscription_prorate = subscription_prorate , subscription_proration_date = subscription_proration_date , subscription_quantity = subscription_quantity , subscription_trial_end = subscription_trial_end , ** kwargs , ) except InvalidRequestError as exc : if str ( exc ) != \"Nothing to invoice for customer\" : raise return None # Workaround for \"id\" being missing (upcoming invoices don't persist). upcoming_stripe_invoice [ \"id\" ] = \"upcoming\" return UpcomingInvoice . _create_from_stripe_object ( upcoming_stripe_invoice , save = False ) djstripe.models.billing.Coupon Coupon(djstripe_id, djstripe_owner_account, livemode, created, metadata, description, djstripe_created, djstripe_updated, id, amount_off, currency, duration, duration_in_months, max_redemptions, name, percent_off, redeem_by, times_redeemed) djstripe . models . billing . Coupon . amount_off djstripe . models . billing . Coupon . currency djstripe . models . billing . Coupon . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Coupon . duration djstripe . models . billing . Coupon . duration_in_months djstripe . models . billing . Coupon . human_readable property readonly djstripe . models . billing . Coupon . human_readable_amount property readonly djstripe . models . billing . Coupon . max_redemptions djstripe . models . billing . Coupon . name djstripe . models . billing . Coupon . percent_off djstripe . models . billing . Coupon . redeem_by djstripe . models . billing . Coupon . stripe_dashboard_item_name djstripe . models . billing . Coupon . times_redeemed djstripe.models.billing.Coupon.DoesNotExist djstripe.models.billing.Coupon.MultipleObjectsReturned djstripe.models.billing.Coupon.stripe_class djstripe . models . billing . Coupon . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): if self . name : return self . name return self . human_readable djstripe . models . billing . Coupon . get_duration_display ( self , * , field =< djstripe . fields . StripeEnumField : duration > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.DjstripeInvoiceTotalTaxAmount An internal model that holds the value of elements of Invoice.total_tax_amounts Note that this is named with the prefix Djstripe to avoid potential collision with a Stripe API object name. djstripe . models . billing . DjstripeInvoiceTotalTaxAmount . amount djstripe . models . billing . DjstripeInvoiceTotalTaxAmount . inclusive djstripe . models . billing . DjstripeInvoiceTotalTaxAmount . invoice djstripe . models . billing . DjstripeInvoiceTotalTaxAmount . tax_rate djstripe.models.billing.DjstripeInvoiceTotalTaxAmount.DoesNotExist djstripe.models.billing.DjstripeInvoiceTotalTaxAmount.MultipleObjectsReturned djstripe.models.billing.DjstripeUpcomingInvoiceTotalTaxAmount As per DjstripeInvoiceTotalTaxAmount, except for UpcomingInvoice djstripe . models . billing . DjstripeUpcomingInvoiceTotalTaxAmount . amount djstripe . models . billing . DjstripeUpcomingInvoiceTotalTaxAmount . inclusive djstripe . models . billing . DjstripeUpcomingInvoiceTotalTaxAmount . invoice djstripe . models . billing . DjstripeUpcomingInvoiceTotalTaxAmount . tax_rate djstripe.models.billing.DjstripeUpcomingInvoiceTotalTaxAmount.DoesNotExist djstripe.models.billing.DjstripeUpcomingInvoiceTotalTaxAmount.MultipleObjectsReturned djstripe.models.billing.Invoice Invoices are statements of what a customer owes for a particular billing period, including subscriptions, invoice items, and any automatic proration adjustments if necessary. Once an invoice is created, payment is automatically attempted. Note that the payment, while automatic, does not happen exactly at the time of invoice creation. If you have configured webhooks, the invoice will wait until one hour after the last webhook is successfully sent (or the last webhook times out after failing). Any customer credit on the account is applied before determining how much is due for that invoice (the amount that will be actually charged). If the amount due for the invoice is less than 50 cents (the minimum for a charge), we add the amount to the customer's running account balance to be added to the next invoice. If this amount is negative, it will act as a credit to offset the next invoice. Note that the customer account balance does not include unpaid invoices; it only includes balances that need to be taken into account when calculating the amount due for the next invoice. Stripe documentation: https://stripe.com/docs/api/python#invoices djstripe . models . billing . Invoice . charge djstripe . models . billing . Invoice . customer djstripe . models . billing . Invoice . default_payment_method djstripe . models . billing . Invoice . default_source djstripe . models . billing . Invoice . default_tax_rates djstripe . models . billing . Invoice . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Invoice . payment_intent djstripe . models . billing . Invoice . subscription djstripe.models.billing.Invoice.DoesNotExist djstripe.models.billing.Invoice.MultipleObjectsReturned djstripe . models . billing . Invoice . get_billing_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_reason > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_customer_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : customer_tax_exempt > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.InvoiceItem Sometimes you want to add a charge or credit to a customer but only actually charge the customer's card at the end of a regular billing cycle. This is useful for combining several charges to minimize per-transaction fees or having Stripe tabulate your usage-based billing totals. Stripe documentation: https://stripe.com/docs/api/python#invoiceitems djstripe . models . billing . InvoiceItem . amount djstripe . models . billing . InvoiceItem . currency djstripe . models . billing . InvoiceItem . customer djstripe . models . billing . InvoiceItem . date djstripe . models . billing . InvoiceItem . discountable djstripe . models . billing . InvoiceItem . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . InvoiceItem . invoice djstripe . models . billing . InvoiceItem . period djstripe . models . billing . InvoiceItem . period_end djstripe . models . billing . InvoiceItem . period_start djstripe . models . billing . InvoiceItem . plan djstripe . models . billing . InvoiceItem . price djstripe . models . billing . InvoiceItem . proration djstripe . models . billing . InvoiceItem . quantity djstripe . models . billing . InvoiceItem . subscription djstripe . models . billing . InvoiceItem . tax_rates djstripe . models . billing . InvoiceItem . unit_amount djstripe . models . billing . InvoiceItem . unit_amount_decimal djstripe.models.billing.InvoiceItem.DoesNotExist djstripe.models.billing.InvoiceItem.MultipleObjectsReturned djstripe.models.billing.InvoiceItem.stripe_class Methods djstripe . models . billing . InvoiceItem . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return self . description djstripe . models . billing . InvoiceItem . api_retrieve ( self , * args , ** kwargs ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , * args , ** kwargs ): if \"-il_\" in self . id : warnings . warn ( f \"Attempting to retrieve InvoiceItem with id= { self . id !r} \" \" will most likely fail. \" \"Run manage.py djstripe_update_invoiceitem_ids if this is a problem.\" ) return super () . api_retrieve ( * args , ** kwargs ) djstripe . models . billing . InvoiceItem . get_next_by_date ( self , * , field =< djstripe . fields . StripeDateTimeField : date > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_date ( self , * , field =< djstripe . fields . StripeDateTimeField : date > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return self . invoice . get_stripe_dashboard_url () djstripe . models . billing . InvoiceItem . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/billing.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"invoiceitem\" , \"line_item\" ) djstripe . models . billing . InvoiceItem . sync_from_stripe_data ( data ) classmethod Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls Source code in djstripe/models/billing.py @classmethod def sync_from_stripe_data ( cls , data ): invoice_data = data . get ( \"invoice\" ) if invoice_data : # sync the Invoice first if it doesn't yet exist in our DB # to avoid recursive Charge/Invoice loop invoice_id = cls . _id_from_data ( invoice_data ) if not Invoice . objects . filter ( id = invoice_id ) . exists (): if invoice_id == invoice_data : # we only have the id, fetch the full data invoice_data = Invoice ( id = invoice_id ) . api_retrieve () Invoice . sync_from_stripe_data ( data = invoice_data ) return super () . sync_from_stripe_data ( data ) djstripe.models.billing.Plan A subscription plan contains the pricing information for different products and feature levels on your site. Stripe documentation: https://stripe.com/docs/api/plans NOTE: The Stripe Plans API has been deprecated in favor of the Prices API. You may want to upgrade to use the Price model instead of the Plan model. djstripe . models . billing . Plan . active djstripe . models . billing . Plan . aggregate_usage djstripe . models . billing . Plan . amount djstripe . models . billing . Plan . amount_decimal djstripe . models . billing . Plan . amount_in_cents property readonly djstripe . models . billing . Plan . billing_scheme djstripe . models . billing . Plan . currency djstripe . models . billing . Plan . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Plan . human_readable_price property readonly djstripe . models . billing . Plan . interval djstripe . models . billing . Plan . interval_count djstripe . models . billing . Plan . nickname djstripe . models . billing . Plan . product djstripe . models . billing . Plan . stripe_dashboard_item_name djstripe . models . billing . Plan . tiers djstripe . models . billing . Plan . tiers_mode djstripe . models . billing . Plan . transform_usage djstripe . models . billing . Plan . trial_period_days djstripe . models . billing . Plan . usage_type djstripe.models.billing.Plan.DoesNotExist djstripe.models.billing.Plan.MultipleObjectsReturned djstripe.models.billing.Plan.stripe_class Methods djstripe . models . billing . Plan . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return self . nickname or self . id djstripe . models . billing . Plan . create ( ** kwargs ) classmethod Source code in djstripe/models/billing.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"amount\" ] = int ( api_kwargs [ \"amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_plan = cls . _api_create ( ** api_kwargs ) plan = cls . sync_from_stripe_data ( stripe_plan ) return plan djstripe . models . billing . Plan . get_aggregate_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : aggregate_usage > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_billing_scheme_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_scheme > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_interval_display ( self , * , field =< djstripe . fields . StripeEnumField : interval > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_or_create ( ** kwargs ) classmethod Get or create a Plan. Source code in djstripe/models/billing.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Plan.\"\"\" try : return Plan . objects . get ( id = kwargs [ \"id\" ]), False except Plan . DoesNotExist : return cls . create ( ** kwargs ), True djstripe . models . billing . Plan . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_tiers_mode_display ( self , * , field =< djstripe . fields . StripeEnumField : tiers_mode > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_usage_type_display ( self , * , field =< djstripe . fields . StripeEnumField : usage_type > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.Subscription Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to a particular plan you've created. A subscription still in its trial period is trialing and moves to active when the trial period is over. When payment to renew the subscription fails, the subscription becomes past_due . After Stripe has exhausted all payment retry attempts, the subscription ends up with a status of either canceled or unpaid depending on your retry settings. Note that when a subscription has a status of unpaid , no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed. Additionally, updating customer card details will not lead to Stripe retrying the latest invoice.). After receiving updated card details from a customer, you may choose to reopen and pay their closed invoices. Stripe documentation: https://stripe.com/docs/api/python#subscriptions djstripe . models . billing . Subscription . application_fee_percent djstripe . models . billing . Subscription . billing_cycle_anchor djstripe . models . billing . Subscription . billing_thresholds djstripe . models . billing . Subscription . cancel_at djstripe . models . billing . Subscription . cancel_at_period_end djstripe . models . billing . Subscription . canceled_at djstripe . models . billing . Subscription . collection_method djstripe . models . billing . Subscription . current_period_end djstripe . models . billing . Subscription . current_period_start djstripe . models . billing . Subscription . customer djstripe . models . billing . Subscription . days_until_due djstripe . models . billing . Subscription . default_payment_method djstripe . models . billing . Subscription . default_source djstripe . models . billing . Subscription . default_tax_rates djstripe . models . billing . Subscription . discount djstripe . models . billing . Subscription . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Subscription . ended_at djstripe . models . billing . Subscription . next_pending_invoice_item_invoice djstripe . models . billing . Subscription . objects djstripe . models . billing . Subscription . pending_invoice_item_interval djstripe . models . billing . Subscription . pending_setup_intent djstripe . models . billing . Subscription . pending_update djstripe . models . billing . Subscription . plan djstripe . models . billing . Subscription . quantity djstripe . models . billing . Subscription . schedule djstripe . models . billing . Subscription . start_date djstripe . models . billing . Subscription . status djstripe . models . billing . Subscription . stripe_dashboard_item_name djstripe . models . billing . Subscription . tax_percent djstripe . models . billing . Subscription . trial_end djstripe . models . billing . Subscription . trial_start djstripe.models.billing.Subscription.DoesNotExist djstripe.models.billing.Subscription.MultipleObjectsReturned djstripe.models.billing.Subscription.stripe_class djstripe . models . billing . Subscription . stripe_class . OBJECT_NAME djstripe . models . billing . Subscription . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/billing.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True ) Methods djstripe . models . billing . Subscription . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return \" {customer} on {plan} \" . format ( customer = str ( self . customer ), plan = str ( self . plan ) ) djstripe . models . billing . Subscription . cancel ( self , at_period_end = True ) Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, the at_period_end flag will be overridden to False so that the trial ends immediately and the customer's card isn't charged. Source code in djstripe/models/billing.py def cancel ( self , at_period_end = djstripe_settings . CANCELLATION_AT_PERIOD_END ): \"\"\" Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation \\ of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, \\ the ``at_period_end`` flag will be overridden to False so that the trial ends \\ immediately and the customer's card isn't charged. \"\"\" # If plan has trial days and customer cancels before # trial period ends, then end subscription now, # i.e. at_period_end=False if self . trial_end and self . trial_end > timezone . now (): at_period_end = False if at_period_end : stripe_subscription = self . _api_update ( cancel_at_period_end = True ) else : try : stripe_subscription = self . _api_delete () except InvalidRequestError as exc : if \"No such subscription:\" in str ( exc ): # cancel() works by deleting the subscription. The object still # exists in Stripe however, and can still be retrieved. # If the subscription was already canceled (status=canceled), # that api_retrieve() call will fail with \"No such subscription\". # However, this may also happen if the subscription legitimately # does not exist, in which case the following line will re-raise. stripe_subscription = self . api_retrieve () else : raise return Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe . models . billing . Subscription . extend ( self , delta ) Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta Source code in djstripe/models/billing.py def extend ( self , delta ): \"\"\" Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta \"\"\" if delta . total_seconds () < 0 : raise ValueError ( \"delta must be a positive timedelta.\" ) if self . trial_end is not None and self . trial_end > timezone . now (): period_end = self . trial_end else : period_end = self . current_period_end period_end += delta return self . update ( proration_behavior = \"none\" , trial_end = period_end ) djstripe . models . billing . Subscription . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_current_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_current_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_current_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_current_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . is_period_current ( self ) Returns True if this subscription's period is current, false otherwise. Source code in djstripe/models/billing.py def is_period_current ( self ): \"\"\" Returns True if this subscription's period is current, false otherwise. \"\"\" return self . current_period_end > timezone . now () or ( self . trial_end and self . trial_end > timezone . now () ) djstripe . models . billing . Subscription . is_status_current ( self ) Returns True if this subscription's status is current (active or trialing), false otherwise. Source code in djstripe/models/billing.py def is_status_current ( self ): \"\"\" Returns True if this subscription's status is current (active or trialing), false otherwise. \"\"\" return self . status in [ \"trialing\" , \"active\" ] djstripe . models . billing . Subscription . is_status_temporarily_current ( self ) A status is temporarily current when the subscription is canceled with the at_period_end flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. Source code in djstripe/models/billing.py def is_status_temporarily_current ( self ): \"\"\" A status is temporarily current when the subscription is canceled with the ``at_period_end`` flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. \"\"\" return ( self . canceled_at and self . cancel_at_period_end and timezone . now () < self . current_period_end ) djstripe . models . billing . Subscription . is_valid ( self ) Returns True if this subscription's status and period are current, false otherwise. Source code in djstripe/models/billing.py def is_valid ( self ): \"\"\" Returns True if this subscription's status and period are current, false otherwise. \"\"\" if not self . is_status_current (): return False if not self . is_period_current (): return False return True djstripe . models . billing . Subscription . reactivate ( self ) Reactivates this subscription. If a customer's subscription is canceled with at_period_end set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/subscriptions/canceling-pausing) .. warning:: Reactivating a fully canceled Subscription will fail silently. Be sure to check the returned Subscription's status. Source code in djstripe/models/billing.py def reactivate ( self ): \"\"\" Reactivates this subscription. If a customer's subscription is canceled with ``at_period_end`` set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/subscriptions/canceling-pausing) .. warning:: Reactivating a fully canceled Subscription will fail silently. \\ Be sure to check the returned Subscription's status. \"\"\" stripe_subscription = self . api_retrieve () stripe_subscription . plan = self . plan . id stripe_subscription . cancel_at_period_end = False return Subscription . sync_from_stripe_data ( stripe_subscription . save ()) djstripe . models . billing . Subscription . update ( self , plan = None , prorate = None , ** kwargs ) See Customer.subscribe() <#djstripe.models.Customer.subscribe> __ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. note:: The default value for prorate is the DJSTRIPE_PRORATION_POLICY setting. .. important:: Updating a subscription by changing the plan or quantity creates a new Subscription in Stripe (and dj-stripe). Source code in djstripe/models/billing.py def update ( self , plan : Union [ StripeModel , str ] = None , prorate : bool = None , ** kwargs , ): \"\"\" See `Customer.subscribe() <#djstripe.models.Customer.subscribe>`__ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. note:: The default value for ``prorate`` is the DJSTRIPE_PRORATION_POLICY \\ setting. .. important:: Updating a subscription by changing the plan or quantity \\ creates a new ``Subscription`` in \\ Stripe (and dj-stripe). \"\"\" # Convert Plan to id if plan is not None and isinstance ( plan , StripeModel ): plan = plan . id if \"proration_behavior\" not in kwargs : if prorate is not None : warnings . warn ( \"The `prorate` parameter to Subscription.update() is deprecated \" \"by Stripe. Use `proration_behavior` instead. \\n \" \"Read more: \" \"https://stripe.com/docs/billing/subscriptions/prorations\" ) else : prorate = djstripe_settings . PRORATION_POLICY if prorate : kwargs . setdefault ( \"proration_behavior\" , \"create_prorations\" ) else : kwargs . setdefault ( \"proration_behavior\" , \"none\" ) stripe_subscription = self . _api_update ( plan = plan , ** kwargs ) return Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe.models.billing.SubscriptionItem Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. Stripe documentation: https://stripe.com/docs/api#subscription_items djstripe . models . billing . SubscriptionItem . billing_thresholds djstripe . models . billing . SubscriptionItem . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . SubscriptionItem . plan djstripe . models . billing . SubscriptionItem . price djstripe . models . billing . SubscriptionItem . quantity djstripe . models . billing . SubscriptionItem . subscription djstripe . models . billing . SubscriptionItem . tax_rates Classes djstripe.models.billing.SubscriptionItem.DoesNotExist djstripe.models.billing.SubscriptionItem.MultipleObjectsReturned djstripe.models.billing.SubscriptionItem.stripe_class djstripe . models . billing . SubscriptionItem . stripe_class . OBJECT_NAME Methods djstripe . models . billing . SubscriptionItem . stripe_class . create_usage_record ( id , ** params ) classmethod Source code in djstripe/models/billing.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . list_usage_record_summaries ( id , ** params ) classmethod Source code in djstripe/models/billing.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summaries ( self , ** params ) usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead. Source code in djstripe/models/billing.py def usage_record_summaries ( self , ** params ): \"\"\"usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/usage_record_summaries\" , params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . billing . SubscriptionItem . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.SubscriptionSchedule Subscription schedules allow you to create and manage the lifecycle of a subscription by predefining expected changes. Stripe documentation: https://stripe.com/docs/api/subscription_schedules djstripe . models . billing . SubscriptionSchedule . billing_thresholds djstripe . models . billing . SubscriptionSchedule . canceled_at djstripe . models . billing . SubscriptionSchedule . completed_at djstripe . models . billing . SubscriptionSchedule . current_phase djstripe . models . billing . SubscriptionSchedule . customer djstripe . models . billing . SubscriptionSchedule . default_settings djstripe . models . billing . SubscriptionSchedule . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . SubscriptionSchedule . end_behavior djstripe . models . billing . SubscriptionSchedule . phases djstripe . models . billing . SubscriptionSchedule . released_at djstripe . models . billing . SubscriptionSchedule . released_subscription djstripe . models . billing . SubscriptionSchedule . status djstripe.models.billing.SubscriptionSchedule.DoesNotExist djstripe.models.billing.SubscriptionSchedule.MultipleObjectsReturned djstripe.models.billing.SubscriptionSchedule.stripe_class djstripe . models . billing . SubscriptionSchedule . stripe_class . OBJECT_NAME djstripe . models . billing . SubscriptionSchedule . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . SubscriptionSchedule . stripe_class . release ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def release ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/release\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . SubscriptionSchedule . get_end_behavior_display ( self , * , field =< djstripe . fields . StripeEnumField : end_behavior > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.TaxId TaxId(djstripe_id, id, djstripe_owner_account, livemode, created, djstripe_created, djstripe_updated, country, customer, type, value, verification) djstripe . models . billing . TaxId . country djstripe . models . billing . TaxId . customer djstripe . models . billing . TaxId . description djstripe . models . billing . TaxId . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . TaxId . metadata djstripe . models . billing . TaxId . type djstripe . models . billing . TaxId . value djstripe . models . billing . TaxId . verification djstripe.models.billing.TaxId.DoesNotExist djstripe.models.billing.TaxId.MultipleObjectsReturned djstripe.models.billing.TaxId.stripe_class djstripe . models . billing . TaxId . stripe_class . OBJECT_NAME djstripe . models . billing . TaxId . stripe_class . instance_url ( self ) Source code in djstripe/models/billing.py def instance_url ( self ): token = util . utf8 ( self . id ) customer = util . utf8 ( self . customer ) base = Customer . class_url () cust_extn = quote_plus ( customer ) extn = quote_plus ( token ) return \" %s / %s /tax_ids/ %s \" % ( base , cust_extn , extn ) djstripe . models . billing . TaxId . stripe_class . retrieve ( id , api_key = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def retrieve ( cls , id , api_key = None , ** params ): raise NotImplementedError ( \"Can't retrieve a tax id without a customer ID. Use customer.retrieve_tax_id('tax_id')\" ) Methods djstripe . models . billing . TaxId . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return self . value djstripe . models . billing . TaxId . api_list ( api_key = 'sk_test_123' , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): # OVERRIDING the parent version of this function # TaxIds must be manipulated through a customer.. from .core import Customer if \"customer\" not in kwargs or not isinstance ( kwargs [ \"customer\" ], Customer ): raise StripeObjectManipulationException ( \"TaxIds must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) customer = kwargs [ \"customer\" ] return customer . api_retrieve ( api_key = api_key ) . tax_ids djstripe . models . billing . TaxId . api_retrieve ( self , api_key = None , stripe_account = None ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , api_key = None , stripe_account = None ): if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) customer = self . customer . api_retrieve ( api_key = api_key or self . default_api_key , stripe_account = stripe_account , ) return customer . retrieve_tax_id ( customer . id , self . id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , ) djstripe . models . billing . TaxId . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.TaxRate Tax rates can be applied to invoices and subscriptions to collect tax. Stripe documentation: https://stripe.com/docs/api/tax_rates djstripe . models . billing . TaxRate . active djstripe . models . billing . TaxRate . display_name djstripe . models . billing . TaxRate . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . TaxRate . inclusive djstripe . models . billing . TaxRate . jurisdiction djstripe . models . billing . TaxRate . percentage djstripe.models.billing.TaxRate.DoesNotExist djstripe.models.billing.TaxRate.MultipleObjectsReturned djstripe.models.billing.TaxRate.stripe_class djstripe . models . billing . TaxRate . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return f \" { self . display_name } \u2013 { self . jurisdiction } at { self . percentage } %\" djstripe . models . billing . TaxRate . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.billing.UpcomingInvoice The preview of an upcoming invoice - does not exist in the Django database. See BaseInvoice.upcoming() Logically it should be set abstract, but that doesn't quite work since we do actually want to instantiate the model and use relations. Attributes djstripe . models . billing . UpcomingInvoice . charge djstripe . models . billing . UpcomingInvoice . customer djstripe . models . billing . UpcomingInvoice . default_payment_method djstripe . models . billing . UpcomingInvoice . default_source djstripe . models . billing . UpcomingInvoice . default_tax_rates property readonly Gets the default tax rates associated with this upcoming invoice. :return: djstripe . models . billing . UpcomingInvoice . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . UpcomingInvoice . id property writable djstripe . models . billing . UpcomingInvoice . invoiceitems property readonly Gets the invoice items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the invoiceitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail. djstripe . models . billing . UpcomingInvoice . payment_intent djstripe . models . billing . UpcomingInvoice . subscription djstripe . models . billing . UpcomingInvoice . total_tax_amounts property readonly Gets the total tax amounts associated with this upcoming invoice. :return: djstripe.models.billing.UpcomingInvoice.DoesNotExist djstripe.models.billing.UpcomingInvoice.MultipleObjectsReturned Methods djstripe . models . billing . UpcomingInvoice . __init__ ( self , * args , ** kwargs ) special Source code in djstripe/models/billing.py def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _invoiceitems = [] self . _default_tax_rates = [] self . _total_tax_amounts = [] djstripe . models . billing . UpcomingInvoice . get_billing_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_reason > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_customer_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : customer_tax_exempt > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return \"\" djstripe . models . billing . UpcomingInvoice . save ( self , * args , ** kwargs ) Save the current instance. Override this in a subclass if you want to control the saving process. The 'force_insert' and 'force_update' parameters can be used to insist that the \"save\" must be an SQL insert or update (or equivalent for non-SQL backends), respectively. Normally, they should not be set. Source code in djstripe/models/billing.py def save ( self , * args , ** kwargs ): return # noop djstripe.models.billing.UsageRecord Usage records allow you to continually report usage and metrics to Stripe for metered billing of plans. Stripe documentation: https://stripe.com/docs/api#usage_records djstripe . models . billing . UsageRecord . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . UsageRecord . quantity djstripe . models . billing . UsageRecord . subscription_item djstripe.models.billing.UsageRecord.DoesNotExist djstripe.models.billing.UsageRecord.MultipleObjectsReturned djstripe.models.billing.UsageRecord.stripe_class djstripe . models . billing . UsageRecord . stripe_class . OBJECT_NAME djstripe . models . billing . UsageRecord . stripe_class . create ( api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def create ( cls , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): if \"subscription_item\" not in params : raise ValueError ( \"Params must have a subscription_item key\" ) subscription_item = params . pop ( \"subscription_item\" ) requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) url = \"/v1/subscription_items/ %s /usage_records\" % subscription_item headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . UsageRecord . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.checkout Classes djstripe.models.checkout.Session A Checkout Session represents your customer's session as they pay for one-time purchases or subscriptions through Checkout. djstripe . models . checkout . Session . billing_address_collection djstripe . models . checkout . Session . cancel_url djstripe . models . checkout . Session . client_reference_id djstripe . models . checkout . Session . customer djstripe . models . checkout . Session . customer_email djstripe . models . checkout . Session . display_items djstripe . models . checkout . Session . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . checkout . Session . locale djstripe . models . checkout . Session . mode djstripe . models . checkout . Session . payment_intent djstripe . models . checkout . Session . payment_method_types djstripe . models . checkout . Session . submit_type djstripe . models . checkout . Session . subscription djstripe . models . checkout . Session . success_url djstripe.models.checkout.Session.DoesNotExist djstripe.models.checkout.Session.MultipleObjectsReturned djstripe.models.checkout.Session.stripe_class djstripe . models . checkout . Session . stripe_class . OBJECT_NAME djstripe . models . checkout . Session . stripe_class . expire ( self , idempotency_key = None , ** params ) Source code in djstripe/models/checkout.py def expire ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/expire\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . checkout . Session . stripe_class . line_items_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/checkout.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . checkout . Session . stripe_class . line_items_url ( id , nested_id = None ) classmethod Source code in djstripe/models/checkout.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . checkout . Session . stripe_class . list_line_items ( id , ** params ) classmethod Source code in djstripe/models/checkout.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . checkout . Session . get_billing_address_collection_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_address_collection > ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_mode_display ( self , * , field =< djstripe . fields . StripeEnumField : mode > ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_submit_type_display ( self , * , field =< djstripe . fields . StripeEnumField : submit_type > ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.connect Classes djstripe.models.connect.ApplicationFee When you collect a transaction fee on top of a charge made for your user (using Connect), an ApplicationFee is created in your account. Stripe documentation: https://stripe.com/docs/api#application_fees djstripe . models . connect . ApplicationFee . amount djstripe . models . connect . ApplicationFee . amount_refunded djstripe . models . connect . ApplicationFee . balance_transaction djstripe . models . connect . ApplicationFee . charge djstripe . models . connect . ApplicationFee . currency djstripe . models . connect . ApplicationFee . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . ApplicationFee . refunded djstripe.models.connect.ApplicationFee.DoesNotExist djstripe.models.connect.ApplicationFee.MultipleObjectsReturned djstripe.models.connect.ApplicationFee.stripe_class djstripe . models . connect . ApplicationFee . stripe_class . OBJECT_NAME djstripe . models . connect . ApplicationFee . stripe_class . create_refund ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . list_refunds ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . modify_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def refund ( self , idempotency_key = None , ** params ): headers = util . populate_headers ( idempotency_key ) url = self . instance_url () + \"/refund\" self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . ApplicationFee . stripe_class . refunds_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . ApplicationFee . stripe_class . refunds_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . connect . ApplicationFee . stripe_class . retrieve_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . ApplicationFee . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.connect.ApplicationFeeRefund ApplicationFeeRefund objects allow you to refund an ApplicationFee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected. Stripe documentation: https://stripe.com/docs/api#fee_refunds djstripe . models . connect . ApplicationFeeRefund . amount djstripe . models . connect . ApplicationFeeRefund . balance_transaction djstripe . models . connect . ApplicationFeeRefund . currency djstripe . models . connect . ApplicationFeeRefund . description djstripe . models . connect . ApplicationFeeRefund . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . ApplicationFeeRefund . fee djstripe.models.connect.ApplicationFeeRefund.DoesNotExist djstripe.models.connect.ApplicationFeeRefund.MultipleObjectsReturned djstripe . models . connect . ApplicationFeeRefund . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.connect.CountrySpec Stripe documentation: https://stripe.com/docs/api#country_specs djstripe . models . connect . CountrySpec . created djstripe . models . connect . CountrySpec . default_currency djstripe . models . connect . CountrySpec . description djstripe . models . connect . CountrySpec . djstripe_id djstripe . models . connect . CountrySpec . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . CountrySpec . livemode djstripe . models . connect . CountrySpec . metadata djstripe . models . connect . CountrySpec . supported_bank_account_currencies djstripe . models . connect . CountrySpec . supported_payment_currencies djstripe . models . connect . CountrySpec . supported_payment_methods djstripe . models . connect . CountrySpec . supported_transfer_countries djstripe . models . connect . CountrySpec . verification_fields djstripe.models.connect.CountrySpec.DoesNotExist djstripe.models.connect.CountrySpec.MultipleObjectsReturned djstripe.models.connect.CountrySpec.stripe_class djstripe . models . connect . CountrySpec . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.connect.Transfer When Stripe sends you money or you initiate a transfer to a bank account, debit card, or connected Stripe account, a transfer object will be created. Stripe documentation: https://stripe.com/docs/api/python#transfers djstripe . models . connect . Transfer . amount djstripe . models . connect . Transfer . amount_reversed djstripe . models . connect . Transfer . balance_transaction djstripe . models . connect . Transfer . currency djstripe . models . connect . Transfer . destination djstripe . models . connect . Transfer . destination_payment djstripe . models . connect . Transfer . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . Transfer . expand_fields : List [ str ] djstripe . models . connect . Transfer . fee property readonly djstripe . models . connect . Transfer . objects djstripe . models . connect . Transfer . reversed djstripe . models . connect . Transfer . source_transaction djstripe . models . connect . Transfer . source_type djstripe . models . connect . Transfer . stripe_dashboard_item_name djstripe . models . connect . Transfer . transfer_group djstripe.models.connect.Transfer.DoesNotExist djstripe.models.connect.Transfer.MultipleObjectsReturned djstripe.models.connect.Transfer.stripe_class djstripe . models . connect . Transfer . stripe_class . OBJECT_NAME djstripe . models . connect . Transfer . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . Transfer . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . Transfer . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . connect . Transfer . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_source_type_display ( self , * , field =< djstripe . fields . StripeEnumField : source_type > ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/connect.py def str_parts ( self ): return [ \"amount= {amount} \" . format ( amount = self . amount )] + super () . str_parts () djstripe.models.connect.TransferReversal Stripe documentation: https://stripe.com/docs/api#transfer_reversals djstripe . models . connect . TransferReversal . amount djstripe . models . connect . TransferReversal . balance_transaction djstripe . models . connect . TransferReversal . currency djstripe . models . connect . TransferReversal . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . TransferReversal . transfer djstripe.models.connect.TransferReversal.DoesNotExist djstripe.models.connect.TransferReversal.MultipleObjectsReturned djstripe.models.connect.TransferReversal.stripe_class djstripe . models . connect . TransferReversal . stripe_class . OBJECT_NAME djstripe . models . connect . TransferReversal . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . TransferReversal . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . TransferReversal . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . connect . TransferReversal . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core Classes djstripe.models.core.BalanceTransaction A single transaction that updates the Stripe balance. Stripe documentation: https://stripe.com/docs/api#balance_transaction_object djstripe . models . core . BalanceTransaction . amount djstripe . models . core . BalanceTransaction . available_on djstripe . models . core . BalanceTransaction . currency djstripe . models . core . BalanceTransaction . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . BalanceTransaction . exchange_rate djstripe . models . core . BalanceTransaction . fee djstripe . models . core . BalanceTransaction . fee_details djstripe . models . core . BalanceTransaction . net djstripe . models . core . BalanceTransaction . reporting_category djstripe . models . core . BalanceTransaction . source djstripe . models . core . BalanceTransaction . status djstripe . models . core . BalanceTransaction . type djstripe.models.core.BalanceTransaction.DoesNotExist djstripe.models.core.BalanceTransaction.MultipleObjectsReturned djstripe.models.core.BalanceTransaction.stripe_class Methods djstripe . models . core . BalanceTransaction . get_next_by_available_on ( self , * , field =< djstripe . fields . StripeDateTimeField : available_on > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_available_on ( self , * , field =< djstripe . fields . StripeDateTimeField : available_on > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_reporting_category_display ( self , * , field =< djstripe . fields . StripeEnumField : reporting_category > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_source_class ( self ) Source code in djstripe/models/core.py def get_source_class ( self ): return apps . get_model ( \"djstripe\" , self . type ) djstripe . models . core . BalanceTransaction . get_source_instance ( self ) Source code in djstripe/models/core.py def get_source_instance ( self ): return self . get_source_class () . objects . get ( id = self . source ) djstripe . models . core . BalanceTransaction . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . get_source_instance () . get_stripe_dashboard_url () djstripe . models . core . BalanceTransaction . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Charge To charge a credit or a debit card, you create a charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique random ID. Stripe documentation: https://stripe.com/docs/api/python#charges djstripe . models . core . Charge . account property readonly djstripe . models . core . Charge . amount djstripe . models . core . Charge . amount_captured djstripe . models . core . Charge . amount_refunded djstripe . models . core . Charge . application djstripe . models . core . Charge . application_fee djstripe . models . core . Charge . application_fee_amount djstripe . models . core . Charge . balance_transaction djstripe . models . core . Charge . billing_details djstripe . models . core . Charge . calculated_statement_descriptor djstripe . models . core . Charge . captured djstripe . models . core . Charge . currency djstripe . models . core . Charge . customer djstripe . models . core . Charge . dispute djstripe . models . core . Charge . disputed djstripe . models . core . Charge . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Charge . expand_fields : List [ str ] djstripe . models . core . Charge . failure_code djstripe . models . core . Charge . failure_message djstripe . models . core . Charge . fee property readonly djstripe . models . core . Charge . fraud_details djstripe . models . core . Charge . fraudulent : bool property readonly djstripe . models . core . Charge . human_readable_amount : str property readonly djstripe . models . core . Charge . human_readable_status : str property readonly djstripe . models . core . Charge . invoice djstripe . models . core . Charge . objects djstripe . models . core . Charge . on_behalf_of djstripe . models . core . Charge . outcome djstripe . models . core . Charge . paid djstripe . models . core . Charge . payment_intent djstripe . models . core . Charge . payment_method djstripe . models . core . Charge . payment_method_details djstripe . models . core . Charge . receipt_email djstripe . models . core . Charge . receipt_number djstripe . models . core . Charge . receipt_url djstripe . models . core . Charge . refunded djstripe . models . core . Charge . shipping djstripe . models . core . Charge . source djstripe . models . core . Charge . source_transfer djstripe . models . core . Charge . statement_descriptor djstripe . models . core . Charge . statement_descriptor_suffix djstripe . models . core . Charge . status djstripe . models . core . Charge . stripe_dashboard_item_name djstripe . models . core . Charge . transfer djstripe . models . core . Charge . transfer_data djstripe . models . core . Charge . transfer_group djstripe.models.core.Charge.DoesNotExist djstripe.models.core.Charge.MultipleObjectsReturned djstripe.models.core.Charge.stripe_class djstripe . models . core . Charge . stripe_class . OBJECT_NAME djstripe . models . core . Charge . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . close_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute/close\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute djstripe . models . core . Charge . stripe_class . mark_as_fraudulent ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_fraudulent ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"fraudulent\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . mark_as_safe ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_safe ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"safe\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def refund ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/refund\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . update_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def update_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute Methods djstripe . models . core . Charge . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): amount = self . human_readable_amount status = self . human_readable_status if not status : return amount return \" {amount} ( {status} )\" . format ( amount = amount , status = status ) djstripe . models . core . Charge . capture ( self , ** kwargs ) Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge Source code in djstripe/models/core.py def capture ( self , ** kwargs ) -> \"Charge\" : \"\"\" Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge \"\"\" captured_charge = self . api_retrieve () . capture ( ** kwargs ) return self . __class__ . sync_from_stripe_data ( captured_charge ) djstripe . models . core . Charge . get_failure_code_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_code > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . refund ( self , amount = None , reason = None ) Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are duplicate , fraudulent , and requested_by_customer . Specifying fraudulent as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. Source code in djstripe/models/core.py def refund ( self , amount : Decimal = None , reason : str = None ) -> \"Charge\" : \"\"\" Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are ``duplicate``, ``fraudulent``, and ``requested_by_customer``. Specifying ``fraudulent`` as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. \"\"\" charge_obj = self . api_retrieve () . refund ( amount = self . _calculate_refund_amount ( amount = amount ), reason = reason ) return self . __class__ . sync_from_stripe_data ( charge_obj ) djstripe.models.core.Customer Customer objects allow you to perform recurring charges and track multiple charges that are associated with the same customer. Stripe documentation: https://stripe.com/docs/api/python#customers Attributes djstripe . models . core . Customer . active_subscriptions property readonly Returns active subscriptions (subscriptions with an active status that end in the future). djstripe . models . core . Customer . address djstripe . models . core . Customer . balance djstripe . models . core . Customer . business_vat_id : str property readonly djstripe . models . core . Customer . coupon djstripe . models . core . Customer . coupon_end djstripe . models . core . Customer . coupon_start djstripe . models . core . Customer . credits property readonly The customer is considered to have credits if their balance is below 0. djstripe . models . core . Customer . currency djstripe . models . core . Customer . customer_payment_methods property readonly An iterable of all of the customer's payment methods (sources, then legacy cards) djstripe . models . core . Customer . date_purged djstripe . models . core . Customer . default_payment_method djstripe . models . core . Customer . default_source djstripe . models . core . Customer . delinquent djstripe . models . core . Customer . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Customer . email djstripe . models . core . Customer . expand_fields : List [ str ] djstripe . models . core . Customer . invoice_prefix djstripe . models . core . Customer . invoice_settings djstripe . models . core . Customer . name djstripe . models . core . Customer . pending_charges property readonly The customer is considered to have pending charges if their balance is above 0. djstripe . models . core . Customer . phone djstripe . models . core . Customer . preferred_locales djstripe . models . core . Customer . shipping djstripe . models . core . Customer . stripe_dashboard_item_name djstripe . models . core . Customer . subscriber djstripe . models . core . Customer . subscription property readonly Shortcut to get this customer's subscription. :returns: None if the customer has no subscriptions, the subscription if the customer has a subscription. :raises MultipleSubscriptionException: Raised if the customer has multiple subscriptions. In this case, use Customer.subscriptions instead. djstripe . models . core . Customer . tax_exempt djstripe . models . core . Customer . valid_subscriptions property readonly Returns this customer's valid subscriptions (subscriptions that aren't canceled or incomplete_expired). djstripe.models.core.Customer.DoesNotExist djstripe.models.core.Customer.MultipleObjectsReturned djstripe.models.core.Customer.stripe_class djstripe . models . core . Customer . stripe_class . OBJECT_NAME djstripe . models . core . Customer . stripe_class . balance_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . balance_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . create_balance_transaction ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_source ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_tax_id ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/core.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True ) djstripe . models . core . Customer . stripe_class . delete_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_balance_transactions ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_payment_methods ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def list_payment_methods ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/payment_methods\" headers = util . populate_headers ( idempotency_key ) resp = self . request ( \"get\" , url , params , headers ) stripe_object = util . convert_to_stripe_object ( resp ) stripe_object . _retrieve_params = params return stripe_object djstripe . models . core . Customer . stripe_class . list_sources ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_tax_ids ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . sources_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . sources_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . tax_ids_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . tax_ids_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . core . Customer . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): if self . subscriber : return str ( self . subscriber ) return self . name or self . description or self . id djstripe . models . core . Customer . add_card ( self , source , set_default = True ) Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean Source code in djstripe/models/core.py def add_card ( self , source , set_default = True ): \"\"\" Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean \"\"\" from .payment_methods import DjstripePaymentMethod stripe_customer = self . api_retrieve () new_stripe_payment_method = stripe_customer . sources . create ( source = source ) if set_default : stripe_customer . default_source = new_stripe_payment_method [ \"id\" ] stripe_customer . save () new_payment_method = DjstripePaymentMethod . from_stripe_object ( new_stripe_payment_method ) # Change the default source if set_default : self . default_source = new_payment_method self . save () return new_payment_method . resolve () djstripe . models . core . Customer . add_coupon ( self , coupon , idempotency_key = None ) Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. Source code in djstripe/models/core.py def add_coupon ( self , coupon , idempotency_key = None ): \"\"\" Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. \"\"\" if isinstance ( coupon , StripeModel ): coupon = coupon . id stripe_customer = self . api_retrieve () stripe_customer [ \"coupon\" ] = coupon stripe_customer . save ( idempotency_key = idempotency_key ) return self . __class__ . sync_from_stripe_data ( stripe_customer ) djstripe . models . core . Customer . add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None ) Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. Use this when adding invoice items in response to an invoice.created webhook. You cannot add an invoice item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using Customer.add_invoice_item() instead of .. Customer.add_invoice_item() , invoice and subscriptions .. can only be strings Source code in djstripe/models/core.py def add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None , ): \"\"\" Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming \\ scheduled invoice. \\ Use this when adding invoice items in response to an \\ ``invoice.created`` webhook. You cannot add an invoice \\ item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming \\ scheduled invoice. When set, scheduled invoices for subscriptions other \\ than the specified subscription will ignore the invoice item. \\ Use this when you want to express that an invoice item has been accrued \\ within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using ``Customer.add_invoice_item()`` instead of .. ``Customer.add_invoice_item()``, ``invoice`` and ``subscriptions`` .. can only be strings \"\"\" from .billing import InvoiceItem if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Invoice to id if invoice is not None and isinstance ( invoice , StripeModel ): invoice = invoice . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id stripe_invoiceitem = InvoiceItem . _api_create ( amount = int ( amount * 100 ), # Convert dollars into cents currency = currency , customer = self . id , description = description , discountable = discountable , invoice = invoice , metadata = metadata , subscription = subscription , ) return InvoiceItem . sync_from_stripe_data ( stripe_invoiceitem ) djstripe . models . core . Customer . add_payment_method ( self , payment_method , set_default = True ) Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod Source code in djstripe/models/core.py def add_payment_method ( self , payment_method , set_default = True ): \"\"\" Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod \"\"\" from .payment_methods import PaymentMethod stripe_customer = self . api_retrieve () payment_method = PaymentMethod . attach ( payment_method , stripe_customer ) if set_default : stripe_customer [ \"invoice_settings\" ][ \"default_payment_method\" ] = payment_method . id stripe_customer . save () # Refresh self from the stripe customer, this should have two effects: # 1) sets self.default_payment_method (we rely on logic in # Customer._manipulate_stripe_object_hook to do this) # 2) updates self.invoice_settings.default_payment_methods self . sync_from_stripe_data ( stripe_customer ) self . refresh_from_db () return payment_method djstripe . models . core . Customer . can_charge ( self ) Determines if this customer is able to be charged. Source code in djstripe/models/core.py def can_charge ( self ): \"\"\"Determines if this customer is able to be charged.\"\"\" return ( self . has_valid_source () or self . default_payment_method is not None ) and self . date_purged is None djstripe . models . core . Customer . charge ( self , amount , * , application_fee = None , source = None , ** kwargs ) Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source Source code in djstripe/models/core.py def charge ( self , amount : Decimal , * , application_fee : Decimal = None , source : Union [ str , StripeModel ] = None , ** kwargs ) -> Charge : \"\"\" Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source \"\"\" if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Source to id if source and isinstance ( source , StripeModel ): source = source . id stripe_charge = Charge . _api_create ( customer = self . id , amount = int ( amount * 100 ), # Convert dollars into cents application_fee = int ( application_fee * 100 ) if application_fee else None , # Convert dollars into cents source = source , ** kwargs ) return Charge . sync_from_stripe_data ( stripe_charge ) djstripe . models . core . Customer . create ( subscriber , idempotency_key = None , stripe_account = None ) classmethod Source code in djstripe/models/core.py @classmethod def create ( cls , subscriber , idempotency_key = None , stripe_account = None ): metadata = {} subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key not in ( \"\" , None ): metadata [ subscriber_key ] = subscriber . pk stripe_customer = cls . _api_create ( email = subscriber . email , idempotency_key = idempotency_key , metadata = metadata , stripe_account = stripe_account , ) customer , created = Customer . objects . get_or_create ( id = stripe_customer [ \"id\" ], defaults = { \"subscriber\" : subscriber , \"livemode\" : stripe_customer [ \"livemode\" ], \"balance\" : stripe_customer . get ( \"balance\" , 0 ), \"delinquent\" : stripe_customer . get ( \"delinquent\" , False ), }, ) return customer djstripe . models . core . Customer . delete ( self , using = None , keep_parents = False ) Overriding the delete method to keep the customer in the records. All identifying information is removed via the purge() method. The only way to delete a customer is to use SQL. Source code in djstripe/models/core.py def delete ( self , using = None , keep_parents = False ): \"\"\" Overriding the delete method to keep the customer in the records. All identifying information is removed via the purge() method. The only way to delete a customer is to use SQL. \"\"\" self . purge () djstripe . models . core . Customer . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_or_create ( subscriber , livemode = False , stripe_account = None ) classmethod Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None , ): \"\"\" Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool \"\"\" try : return Customer . objects . get ( subscriber = subscriber , livemode = livemode ), False except Customer . DoesNotExist : action = \"create: {} \" . format ( subscriber . pk ) idempotency_key = djstripe_settings . get_idempotency_key ( \"customer\" , action , livemode ) return ( cls . create ( subscriber , idempotency_key = idempotency_key , stripe_account = stripe_account , ), True , ) djstripe . models . core . Customer . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : tax_exempt > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . has_active_subscription ( self , plan = None ) Checks to see if this customer has an active subscription to the given plan. :param plan: The plan for which to check for an active subscription. If plan is None and there exists only one active subscription, this method will check if that subscription is valid. Calling this method with no plan and multiple valid subscriptions for this customer will throw an exception. :type plan: Plan or string (plan ID) :returns: True if there exists an active subscription, False otherwise. :throws: TypeError if plan is None and more than one active subscription exists for this customer. Source code in djstripe/models/core.py def has_active_subscription ( self , plan = None ): \"\"\" Checks to see if this customer has an active subscription to the given plan. :param plan: The plan for which to check for an active subscription. If plan is None and there exists only one active subscription, this method will check if that subscription is valid. Calling this method with no plan and multiple valid subscriptions for this customer will throw an exception. :type plan: Plan or string (plan ID) :returns: True if there exists an active subscription, False otherwise. :throws: TypeError if ``plan`` is None and more than one active subscription exists for this customer. \"\"\" warnings . warn ( \"has_active_subscription is deprecated in favor of `is_subscribed_to` \" \"and will be removed in a future release.\" , DeprecationWarning , ) if plan is None : valid_subscriptions = self . _get_valid_subscriptions () if len ( valid_subscriptions ) == 0 : return False elif len ( valid_subscriptions ) == 1 : return True else : raise TypeError ( \"plan cannot be None if more than one valid subscription \" \"exists for this customer.\" ) else : # Convert Plan to id if isinstance ( plan , StripeModel ): plan = plan . id return any ( [ subscription . is_valid () for subscription in self . subscriptions . filter ( plan__id = plan ) ] ) djstripe . models . core . Customer . has_any_active_subscription ( self ) Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def has_any_active_subscription ( self ): \"\"\" Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. \"\"\" return len ( self . _get_valid_subscriptions ()) != 0 djstripe . models . core . Customer . has_valid_source ( self ) Check whether the customer has a valid payment source. Source code in djstripe/models/core.py def has_valid_source ( self ): \"\"\"Check whether the customer has a valid payment source.\"\"\" return self . default_source is not None djstripe . models . core . Customer . is_subscribed_to ( self , product ) Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def is_subscribed_to ( self , product : Union [ Product , str ]) -> bool : \"\"\" Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. \"\"\" if isinstance ( product , StripeModel ): product = product . id for subscription in self . _get_valid_subscriptions (): for item in subscription . items . all (): if item . price and item . price . product . id == product : return True return False djstripe . models . core . Customer . purge ( self ) Source code in djstripe/models/core.py def purge ( self ): try : self . _api_delete () except InvalidRequestError as exc : if \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer was already # deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise if self . subscriber : # Delete the idempotency key used by Customer.create() # So re-creating a customer for this subscriber before the key expires # doesn't return the older Customer data idempotency_key_action = \"customer:create: {} \" . format ( self . subscriber . pk ) IdempotencyKey . objects . filter ( action = idempotency_key_action ) . delete () self . subscriber = None # Remove sources self . default_source = None for source in self . legacy_cards . all (): source . remove () for source in self . sources . all (): source . detach () self . date_purged = timezone . now () self . save () djstripe . models . core . Customer . retry_unpaid_invoices ( self ) Attempt to retry collecting payment on the customer's unpaid invoices. Source code in djstripe/models/core.py def retry_unpaid_invoices ( self ): \"\"\"Attempt to retry collecting payment on the customer's unpaid invoices.\"\"\" self . _sync_invoices () for invoice in self . invoices . filter ( auto_advance = True ) . exclude ( status = \"paid\" ): try : invoice . retry () # Always retry unpaid invoices except InvalidRequestError as exc : if str ( exc ) != \"Invoice is already paid\" : raise djstripe . models . core . Customer . send_invoice ( self ) Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). Source code in djstripe/models/core.py def send_invoice ( self ): \"\"\" Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). \"\"\" from .billing import Invoice try : invoice = Invoice . _api_create ( customer = self . id ) invoice . pay () return True except InvalidRequestError : # TODO: Check this for a more # specific error message. return False # There was nothing to invoice djstripe . models . core . Customer . subscribe ( self , price = None , plan = None , charge_immediately = True , ** kwargs ) Subscribes this customer to a price. NOTE: Only one item is supported at the moment. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) :param charge_immediately: Whether or not to charge for the subscription upon creation. If False, an invoice will be created at the end of this period. :type charge_immediately: boolean .. Notes: .. charge_immediately is only available on Customer.subscribe() .. if you're using Customer.subscribe() .. instead of Customer.subscribe() , plan can only be a string Source code in djstripe/models/core.py def subscribe ( self , price = None , plan = None , charge_immediately = True , ** kwargs ): \"\"\" Subscribes this customer to a price. NOTE: Only one item is supported at the moment. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) :param charge_immediately: Whether or not to charge for the subscription upon creation. If False, an invoice will be created at the end of this period. :type charge_immediately: boolean .. Notes: .. ``charge_immediately`` is only available on ``Customer.subscribe()`` .. if you're using ``Customer.subscribe()`` .. instead of ``Customer.subscribe()``, ``plan`` can only be a string \"\"\" from .billing import Subscription if price and plan : raise TypeError ( \"price and plan arguments cannot both be defined.\" ) price = price or plan if not price : raise TypeError ( \"you need to set either price or plan\" ) # Convert Price to id if isinstance ( price , StripeModel ): price = price . id stripe_subscription = Subscription . _api_create ( items = [{ \"price\" : price }], customer = self . id , ** kwargs ) if charge_immediately : self . send_invoice () return Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe . models . core . Customer . upcoming_invoice ( self , ** kwargs ) Gets the upcoming preview invoice (singular) for this customer. See Invoice.upcoming() <#djstripe.Invoice.upcoming> __. The customer argument to the upcoming() call is automatically set by this method. Source code in djstripe/models/core.py def upcoming_invoice ( self , ** kwargs ): \"\"\"Gets the upcoming preview invoice (singular) for this customer. See `Invoice.upcoming() <#djstripe.Invoice.upcoming>`__. The ``customer`` argument to the ``upcoming()`` call is automatically set by this method. \"\"\" from .billing import Invoice kwargs [ \"customer\" ] = self return Invoice . upcoming ( ** kwargs ) djstripe.models.core.Dispute Stripe documentation: https://stripe.com/docs/api#disputes djstripe . models . core . Dispute . amount djstripe . models . core . Dispute . currency djstripe . models . core . Dispute . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Dispute . evidence djstripe . models . core . Dispute . evidence_details djstripe . models . core . Dispute . is_charge_refundable djstripe . models . core . Dispute . reason djstripe . models . core . Dispute . status djstripe . models . core . Dispute . stripe_dashboard_item_name djstripe.models.core.Dispute.DoesNotExist djstripe.models.core.Dispute.MultipleObjectsReturned djstripe.models.core.Dispute.stripe_class djstripe . models . core . Dispute . stripe_class . OBJECT_NAME djstripe . models . core . Dispute . stripe_class . close ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/close\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Dispute . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Event Events are Stripe's way of letting you know when something interesting happens in your account. When an interesting event occurs, a new Event object is created and POSTed to the configured webhook URL if the Event type matches. Stripe documentation: https://stripe.com/docs/api/events djstripe . models . core . Event . api_version djstripe . models . core . Event . customer property readonly djstripe . models . core . Event . data djstripe . models . core . Event . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Event . idempotency_key djstripe . models . core . Event . request_id djstripe . models . core . Event . stripe_dashboard_item_name djstripe . models . core . Event . type djstripe.models.core.Event.DoesNotExist djstripe.models.core.Event.MultipleObjectsReturned djstripe.models.core.Event.stripe_class Methods djstripe . models . core . Event . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . invoke_webhook_handlers ( self ) Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the djstripe.event_handlers module (or handlers registered in djstripe plugins or contrib packages). Source code in djstripe/models/core.py def invoke_webhook_handlers ( self ): \"\"\" Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the ``djstripe.event_handlers`` module (or handlers registered in djstripe plugins or contrib packages). \"\"\" webhooks . call_handlers ( event = self ) signal = WEBHOOK_SIGNALS . get ( self . type ) if signal : return signal . send ( sender = Event , event = self ) djstripe . models . core . Event . process ( data ) classmethod Source code in djstripe/models/core.py @classmethod def process ( cls , data ): qs = cls . objects . filter ( id = data [ \"id\" ]) if qs . exists (): return qs . first () # Rollback any DB operations in the case of failure so # we will retry creating and processing the event the # next time the webhook fires. with transaction . atomic (): ret = cls . _create_from_stripe_object ( data ) ret . invoke_webhook_handlers () return ret djstripe . models . core . Event . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/core.py def str_parts ( self ): return [ \"type= {type} \" . format ( type = self . type )] + super () . str_parts () djstripe.models.core.File Stripe documentation: https://stripe.com/docs/api#file_uploads djstripe . models . core . File . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . File . filename djstripe . models . core . File . purpose djstripe . models . core . File . size djstripe . models . core . File . type djstripe . models . core . File . url djstripe.models.core.File.DoesNotExist djstripe.models.core.File.MultipleObjectsReturned djstripe.models.core.File.stripe_class djstripe . models . core . File . stripe_class . OBJECT_NAME djstripe . models . core . File . stripe_class . OBJECT_NAME_ALT djstripe . models . core . File . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . File . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account ) Methods djstripe . models . core . File . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_purpose_display ( self , * , field =< djstripe . fields . StripeEnumField : purpose > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" ) djstripe.models.core.FileUpload Stripe documentation: https://stripe.com/docs/api#file_uploads djstripe . models . core . FileUpload . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . FileUpload . filename djstripe . models . core . FileUpload . purpose djstripe . models . core . FileUpload . size djstripe . models . core . FileUpload . type djstripe . models . core . FileUpload . url djstripe.models.core.FileUpload.DoesNotExist djstripe.models.core.FileUpload.MultipleObjectsReturned djstripe.models.core.FileUpload.stripe_class djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME_ALT djstripe . models . core . FileUpload . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . FileUpload . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account ) Methods djstripe . models . core . FileUpload . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_purpose_display ( self , * , field =< djstripe . fields . StripeEnumField : purpose > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" ) djstripe.models.core.PaymentIntent Stripe documentation: https://stripe.com/docs/api#payment_intents djstripe . models . core . PaymentIntent . amount djstripe . models . core . PaymentIntent . amount_capturable djstripe . models . core . PaymentIntent . amount_received djstripe . models . core . PaymentIntent . canceled_at djstripe . models . core . PaymentIntent . cancellation_reason djstripe . models . core . PaymentIntent . capture_method djstripe . models . core . PaymentIntent . client_secret djstripe . models . core . PaymentIntent . confirmation_method djstripe . models . core . PaymentIntent . currency djstripe . models . core . PaymentIntent . customer djstripe . models . core . PaymentIntent . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . PaymentIntent . last_payment_error djstripe . models . core . PaymentIntent . next_action djstripe . models . core . PaymentIntent . on_behalf_of djstripe . models . core . PaymentIntent . payment_method djstripe . models . core . PaymentIntent . payment_method_types djstripe . models . core . PaymentIntent . receipt_email djstripe . models . core . PaymentIntent . setup_future_usage djstripe . models . core . PaymentIntent . shipping djstripe . models . core . PaymentIntent . statement_descriptor djstripe . models . core . PaymentIntent . status djstripe . models . core . PaymentIntent . stripe_dashboard_item_name djstripe . models . core . PaymentIntent . transfer_data djstripe . models . core . PaymentIntent . transfer_group djstripe.models.core.PaymentIntent.DoesNotExist djstripe.models.core.PaymentIntent.MultipleObjectsReturned djstripe.models.core.PaymentIntent.stripe_class djstripe . models . core . PaymentIntent . stripe_class . OBJECT_NAME djstripe . models . core . PaymentIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self Methods djstripe . models . core . PaymentIntent . get_cancellation_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : cancellation_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_capture_method_display ( self , * , field =< djstripe . fields . StripeEnumField : capture_method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_confirmation_method_display ( self , * , field =< djstripe . fields . StripeEnumField : confirmation_method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_setup_future_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : setup_future_usage > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . update ( self , api_key = None , ** kwargs ) Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/core.py def update ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key return self . api_retrieve ( api_key = api_key ) . modify ( ** kwargs ) djstripe.models.core.Payout A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. Stripe documentation: https://stripe.com/docs/api#payouts djstripe . models . core . Payout . amount djstripe . models . core . Payout . arrival_date djstripe . models . core . Payout . automatic djstripe . models . core . Payout . balance_transaction djstripe . models . core . Payout . currency djstripe . models . core . Payout . destination djstripe . models . core . Payout . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Payout . expand_fields : List [ str ] djstripe . models . core . Payout . failure_balance_transaction djstripe . models . core . Payout . failure_code djstripe . models . core . Payout . failure_message djstripe . models . core . Payout . method djstripe . models . core . Payout . source_type djstripe . models . core . Payout . statement_descriptor djstripe . models . core . Payout . status djstripe . models . core . Payout . stripe_dashboard_item_name djstripe . models . core . Payout . type djstripe.models.core.Payout.DoesNotExist djstripe.models.core.Payout.MultipleObjectsReturned djstripe.models.core.Payout.stripe_class djstripe . models . core . Payout . stripe_class . OBJECT_NAME djstripe . models . core . Payout . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Payout . stripe_class . reverse ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def reverse ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reverse\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Payout . get_failure_code_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_code > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_method_display ( self , * , field =< djstripe . fields . StripeEnumField : method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_arrival_date ( self , * , field =< djstripe . fields . StripeDateTimeField : arrival_date > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_arrival_date ( self , * , field =< djstripe . fields . StripeDateTimeField : arrival_date > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_source_type_display ( self , * , field =< djstripe . fields . StripeEnumField : source_type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Price Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Price and Plan objects are the same, but use a different representation. Creating a recurring Price in Stripe also makes a Plan available, and vice versa. This is not the case for a Price with interval=one_time. Price objects are a more recent API representation, support more features and its usage is encouraged instead of Plan objects. Stripe documentation: - https://stripe.com/docs/api/prices - https://stripe.com/docs/billing/prices-guide djstripe . models . core . Price . active djstripe . models . core . Price . billing_scheme djstripe . models . core . Price . currency djstripe . models . core . Price . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Price . expand_fields : List [ str ] djstripe . models . core . Price . human_readable_price property readonly djstripe . models . core . Price . lookup_key djstripe . models . core . Price . nickname djstripe . models . core . Price . product djstripe . models . core . Price . recurring djstripe . models . core . Price . stripe_dashboard_item_name djstripe . models . core . Price . tiers djstripe . models . core . Price . tiers_mode djstripe . models . core . Price . transform_quantity djstripe . models . core . Price . type djstripe . models . core . Price . unit_amount djstripe . models . core . Price . unit_amount_decimal djstripe.models.core.Price.DoesNotExist djstripe.models.core.Price.MultipleObjectsReturned djstripe.models.core.Price.stripe_class Methods djstripe . models . core . Price . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return self . nickname or self . id djstripe . models . core . Price . create ( ** kwargs ) classmethod Source code in djstripe/models/core.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"unit_amount\" ] = int ( api_kwargs [ \"unit_amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_price = cls . _api_create ( ** api_kwargs ) price = cls . sync_from_stripe_data ( stripe_price ) return price djstripe . models . core . Price . get_billing_scheme_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_scheme > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_or_create ( ** kwargs ) classmethod Get or create a Price. Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Price.\"\"\" try : return Price . objects . get ( id = kwargs [ \"id\" ]), False except Price . DoesNotExist : return cls . create ( ** kwargs ), True djstripe . models . core . Price . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_tiers_mode_display ( self , * , field =< djstripe . fields . StripeEnumField : tiers_mode > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Product Stripe documentation: - https://stripe.com/docs/api#products - https://stripe.com/docs/api#service_products djstripe . models . core . Product . active djstripe . models . core . Product . attributes djstripe . models . core . Product . caption djstripe . models . core . Product . deactivate_on djstripe . models . core . Product . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Product . images djstripe . models . core . Product . name djstripe . models . core . Product . package_dimensions djstripe . models . core . Product . shippable djstripe . models . core . Product . statement_descriptor djstripe . models . core . Product . stripe_dashboard_item_name djstripe . models . core . Product . type djstripe . models . core . Product . unit_label djstripe . models . core . Product . url djstripe.models.core.Product.DoesNotExist djstripe.models.core.Product.MultipleObjectsReturned djstripe.models.core.Product.stripe_class djstripe . models . core . Product . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return self . name djstripe . models . core . Product . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.core.Refund Stripe documentation: https://stripe.com/docs/api#refund_object djstripe . models . core . Refund . amount djstripe . models . core . Refund . balance_transaction djstripe . models . core . Refund . charge djstripe . models . core . Refund . currency djstripe . models . core . Refund . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Refund . failure_balance_transaction djstripe . models . core . Refund . failure_reason djstripe . models . core . Refund . reason djstripe . models . core . Refund . receipt_number djstripe . models . core . Refund . status djstripe.models.core.Refund.DoesNotExist djstripe.models.core.Refund.MultipleObjectsReturned djstripe.models.core.Refund.stripe_class Methods djstripe . models . core . Refund . get_failure_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . charge . get_stripe_dashboard_url () djstripe.models.core.SetupIntent A SetupIntent guides you through the process of setting up a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow. NOTE: You should not maintain long-lived, unconfirmed SetupIntents. For security purposes, SetupIntents older than 24 hours may no longer be valid. Stripe documentation: https://stripe.com/docs/api#setup_intents djstripe . models . core . SetupIntent . application djstripe . models . core . SetupIntent . cancellation_reason djstripe . models . core . SetupIntent . client_secret djstripe . models . core . SetupIntent . customer djstripe . models . core . SetupIntent . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . SetupIntent . last_setup_error djstripe . models . core . SetupIntent . next_action djstripe . models . core . SetupIntent . on_behalf_of djstripe . models . core . SetupIntent . payment_method djstripe . models . core . SetupIntent . payment_method_types djstripe . models . core . SetupIntent . status djstripe . models . core . SetupIntent . usage djstripe.models.core.SetupIntent.DoesNotExist djstripe.models.core.SetupIntent.MultipleObjectsReturned djstripe.models.core.SetupIntent.stripe_class djstripe . models . core . SetupIntent . stripe_class . OBJECT_NAME djstripe . models . core . SetupIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . SetupIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . SetupIntent . get_cancellation_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : cancellation_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : usage > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.fraud djstripe.models.orders djstripe.models.payment_methods Classes djstripe.models.payment_methods.BankAccount BankAccount(djstripe_id, id, djstripe_owner_account, livemode, created, metadata, description, djstripe_created, djstripe_updated, account, account_holder_name, account_holder_type, bank_name, country, currency, customer, default_for_currency, fingerprint, last4, routing_number, status) djstripe . models . payment_methods . BankAccount . account djstripe . models . payment_methods . BankAccount . account_holder_name djstripe . models . payment_methods . BankAccount . account_holder_type djstripe . models . payment_methods . BankAccount . bank_name djstripe . models . payment_methods . BankAccount . country djstripe . models . payment_methods . BankAccount . currency djstripe . models . payment_methods . BankAccount . customer : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . BankAccount . default_for_currency djstripe . models . payment_methods . BankAccount . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . BankAccount . fingerprint djstripe . models . payment_methods . BankAccount . last4 djstripe . models . payment_methods . BankAccount . routing_number djstripe . models . payment_methods . BankAccount . status djstripe.models.payment_methods.BankAccount.DoesNotExist djstripe.models.payment_methods.BankAccount.MultipleObjectsReturned djstripe.models.payment_methods.BankAccount.stripe_class djstripe . models . payment_methods . BankAccount . stripe_class . OBJECT_NAME djstripe . models . payment_methods . BankAccount . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether bank_account_id %s is \" \"attached to a customer or an account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . BankAccount . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a bank account without a customer or account ID. \" \"Call save on customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" ) djstripe . models . payment_methods . BankAccount . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a bank account without a customer or account ID. \" \"Use customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" ) Methods djstripe . models . payment_methods . BankAccount . api_retrieve ( self , ** kwargs ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/payment_methods.py def api_retrieve ( self , ** kwargs ): if not self . customer : raise NotImplementedError ( \"Cannot retrieve bank accounts not associated with a customer\" ) return super () . api_retrieve ( ** kwargs ) djstripe . models . payment_methods . BankAccount . get_account_holder_type_display ( self , * , field =< djstripe . fields . StripeEnumField : account_holder_type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.payment_methods.Card You can store multiple cards on a customer in order to charge the customer later. This is a legacy model which only applies to the \"v2\" Stripe API (eg. Checkout.js). You should strive to use the Stripe \"v3\" API (eg. Stripe Elements). Also see: https://stripe.com/docs/stripe-js/elements/migrating When using Elements, you will not be using Card objects. Instead, you will use Source objects. A Source object of type \"card\" is equivalent to a Card object. However, Card objects cannot be converted into Source objects by Stripe at this time. Stripe documentation: https://stripe.com/docs/api/python#cards djstripe . models . payment_methods . Card . address_city djstripe . models . payment_methods . Card . address_country djstripe . models . payment_methods . Card . address_line1 djstripe . models . payment_methods . Card . address_line1_check djstripe . models . payment_methods . Card . address_line2 djstripe . models . payment_methods . Card . address_state djstripe . models . payment_methods . Card . address_zip djstripe . models . payment_methods . Card . address_zip_check djstripe . models . payment_methods . Card . brand djstripe . models . payment_methods . Card . country djstripe . models . payment_methods . Card . customer : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Card . cvc_check djstripe . models . payment_methods . Card . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Card . dynamic_last4 djstripe . models . payment_methods . Card . exp_month djstripe . models . payment_methods . Card . exp_year djstripe . models . payment_methods . Card . fingerprint djstripe . models . payment_methods . Card . funding djstripe . models . payment_methods . Card . last4 djstripe . models . payment_methods . Card . name djstripe . models . payment_methods . Card . tokenization_method djstripe.models.payment_methods.Card.DoesNotExist djstripe.models.payment_methods.Card.MultipleObjectsReturned djstripe.models.payment_methods.Card.stripe_class djstripe . models . payment_methods . Card . stripe_class . OBJECT_NAME djstripe . models . payment_methods . Card . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"recipient\" ): recipient = util . utf8 ( self . recipient ) base = Recipient . class_url () owner_extn = quote_plus ( recipient ) class_base = \"cards\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether card_id %s is \" \"attached to a customer, recipient, or \" \"account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . Card . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a card without a customer, recipient or account \" \"ID. Call save on customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" ) djstripe . models . payment_methods . Card . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a card without a customer, recipient or account \" \"ID. Use customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" ) Methods djstripe . models . payment_methods . Card . create_token ( number , exp_month , exp_year , cvc , api_key = 'sk_test_123' , ** kwargs ) classmethod Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api/python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use Source code in djstripe/models/payment_methods.py @classmethod def create_token ( cls , number : str , exp_month : int , exp_year : int , cvc : str , api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs , ) -> stripe . Token : \"\"\" Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api/python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use \"\"\" card = { \"number\" : number , \"exp_month\" : exp_month , \"exp_year\" : exp_year , \"cvc\" : cvc , } card . update ( kwargs ) return stripe . Token . create ( api_key = api_key , card = card ) djstripe . models . payment_methods . Card . get_address_line1_check_display ( self , * , field =< djstripe . fields . StripeEnumField : address_line1_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_address_zip_check_display ( self , * , field =< djstripe . fields . StripeEnumField : address_zip_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_brand_display ( self , * , field =< djstripe . fields . StripeEnumField : brand > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_cvc_check_display ( self , * , field =< djstripe . fields . StripeEnumField : cvc_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_funding_display ( self , * , field =< djstripe . fields . StripeEnumField : funding > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_tokenization_method_display ( self , * , field =< djstripe . fields . StripeEnumField : tokenization_method > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/payment_methods.py def str_parts ( self ): return [ \"brand= {brand} \" . format ( brand = self . brand ), \"last4= {last4} \" . format ( last4 = self . last4 ), \"exp_month= {exp_month} \" . format ( exp_month = self . exp_month ), \"exp_year= {exp_year} \" . format ( exp_year = self . exp_year ), ] + super () . str_parts () djstripe.models.payment_methods.DjstripePaymentMethod An internal model that abstracts the legacy Card and BankAccount objects with Source objects. Contains two fields: id and type : - id is the id of the Stripe object. - type can be card , bank_account or source . djstripe . models . payment_methods . DjstripePaymentMethod . id djstripe . models . payment_methods . DjstripePaymentMethod . object_model property readonly djstripe . models . payment_methods . DjstripePaymentMethod . type djstripe.models.payment_methods.DjstripePaymentMethod.DoesNotExist djstripe.models.payment_methods.DjstripePaymentMethod.MultipleObjectsReturned djstripe . models . payment_methods . DjstripePaymentMethod . from_stripe_object ( data ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def from_stripe_object ( cls , data ): source_type = data [ \"object\" ] model = cls . _model_for_type ( source_type ) with transaction . atomic (): model . sync_from_stripe_data ( data ) instance , _ = cls . objects . get_or_create ( id = data [ \"id\" ], defaults = { \"type\" : source_type } ) return instance djstripe . models . payment_methods . DjstripePaymentMethod . resolve ( self ) Source code in djstripe/models/payment_methods.py def resolve ( self ): return self . object_model . objects . get ( id = self . id ) djstripe.models.payment_methods.LegacySourceMixin Mixin for functionality shared between the legacy Card & BankAccount sources Methods djstripe . models . payment_methods . LegacySourceMixin . api_list ( api_key = 'sk_test_123' , ** kwargs ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): # OVERRIDING the parent version of this function # Cards & Bank Accounts must be manipulated through a customer or account. # TODO: When managed accounts are supported, this method needs to # check if either a customer or account is supplied to determine # the correct object to use. customer , clean_kwargs = cls . _get_customer_from_kwargs ( ** kwargs ) return ( customer . api_retrieve ( api_key = api_key ) . sources . list ( object = cls . stripe_class . OBJECT_NAME , ** clean_kwargs ) . auto_paging_iter () ) djstripe . models . payment_methods . LegacySourceMixin . api_retrieve ( self , api_key = None , stripe_account = None ) Source code in djstripe/models/payment_methods.py def api_retrieve ( self , api_key = None , stripe_account = None ): # OVERRIDING the parent version of this function # Cards & Banks Accounts must be manipulated through a customer or account. # TODO: When managed accounts are supported, this method needs to check if # either a customer or account is supplied to determine the # correct object to use. api_key = api_key or self . default_api_key customer = self . customer . api_retrieve ( api_key = api_key , stripe_account = stripe_account ) # If the customer is deleted, the sources attribute will be absent. # eg. {\"id\": \"cus_XXXXXXXX\", \"deleted\": True} if \"sources\" not in customer : # We fake a native stripe InvalidRequestError so that it's caught # like an invalid ID error. raise InvalidRequestError ( f \"No such source: { self . id !r} \" , \"id\" ) # This will retrieve the source using the account ID where the customer resides, # so we don't have to pass `stripe_account`. return customer . sources . retrieve ( self . id , expand = self . expand_fields ) djstripe . models . payment_methods . LegacySourceMixin . get_stripe_dashboard_url ( self ) Source code in djstripe/models/payment_methods.py def get_stripe_dashboard_url ( self ) -> str : if self . customer : return self . customer . get_stripe_dashboard_url () else : return \"\" djstripe . models . payment_methods . LegacySourceMixin . remove ( self ) Removes a legacy source from this customer's account. Source code in djstripe/models/payment_methods.py def remove ( self ): \"\"\" Removes a legacy source from this customer's account. \"\"\" # First, wipe default source on all customers that use this card. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) try : self . _api_delete () except InvalidRequestError as exc : if \"No such source:\" in str ( exc ) or \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer or card # was already deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise self . delete () djstripe.models.payment_methods.PaymentMethod Stripe documentation: https://stripe.com/docs/api#payment_methods djstripe . models . payment_methods . PaymentMethod . alipay djstripe . models . payment_methods . PaymentMethod . au_becs_debit djstripe . models . payment_methods . PaymentMethod . bacs_debit djstripe . models . payment_methods . PaymentMethod . bancontact djstripe . models . payment_methods . PaymentMethod . billing_details djstripe . models . payment_methods . PaymentMethod . card djstripe . models . payment_methods . PaymentMethod . card_present djstripe . models . payment_methods . PaymentMethod . customer djstripe . models . payment_methods . PaymentMethod . description djstripe . models . payment_methods . PaymentMethod . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . PaymentMethod . eps djstripe . models . payment_methods . PaymentMethod . fpx djstripe . models . payment_methods . PaymentMethod . giropay djstripe . models . payment_methods . PaymentMethod . ideal djstripe . models . payment_methods . PaymentMethod . interac_present djstripe . models . payment_methods . PaymentMethod . oxxo djstripe . models . payment_methods . PaymentMethod . p24 djstripe . models . payment_methods . PaymentMethod . sepa_debit djstripe . models . payment_methods . PaymentMethod . sofort djstripe . models . payment_methods . PaymentMethod . type djstripe.models.payment_methods.PaymentMethod.DoesNotExist djstripe.models.payment_methods.PaymentMethod.MultipleObjectsReturned djstripe.models.payment_methods.PaymentMethod.stripe_class djstripe . models . payment_methods . PaymentMethod . stripe_class . OBJECT_NAME djstripe . models . payment_methods . PaymentMethod . stripe_class . attach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def attach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/attach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . payment_methods . PaymentMethod . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/detach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self Methods djstripe . models . payment_methods . PaymentMethod . attach ( payment_method , customer , api_key = 'sk_test_123' ) classmethod Attach a payment method to a customer Source code in djstripe/models/payment_methods.py @classmethod def attach ( cls , payment_method : Union [ str , \"PaymentMethod\" ], customer : Union [ str , Customer ], api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ) -> \"PaymentMethod\" : \"\"\" Attach a payment method to a customer \"\"\" if isinstance ( payment_method , StripeModel ): payment_method = payment_method . id if isinstance ( customer , StripeModel ): customer = customer . id extra_kwargs = {} if not isinstance ( payment_method , stripe . PaymentMethod ): # send api_key if we're not passing in a Stripe object # avoids \"Received unknown parameter: api_key\" since api uses the # key cached in the Stripe object extra_kwargs = { \"api_key\" : api_key } stripe_payment_method = stripe . PaymentMethod . attach ( payment_method , customer = customer , ** extra_kwargs ) return cls . sync_from_stripe_data ( stripe_payment_method ) djstripe . models . payment_methods . PaymentMethod . detach ( self ) Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, false if it was already detached :rtype: bool Source code in djstripe/models/payment_methods.py def detach ( self ): \"\"\" Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, \\ false if it was already detached :rtype: bool \"\"\" # Find customers that use this customers = Customer . objects . filter ( default_payment_method = self ) . all () changed = True # special handling is needed for legacy \"card\"-type PaymentMethods, # since detaching them deletes them within Stripe. # see https://github.com/dj-stripe/dj-stripe/pull/967 is_legacy_card = self . id . startswith ( \"card_\" ) try : self . sync_from_stripe_data ( self . api_retrieve () . detach ()) # resync customer to update .default_payment_method and # .invoice_settings.default_payment_method for customer in customers : Customer . sync_from_stripe_data ( customer . api_retrieve ()) except ( InvalidRequestError ,): # The source was already detached. Resyncing. if self . pk and not is_legacy_card : self . sync_from_stripe_data ( self . api_retrieve ()) changed = False if self . pk : if is_legacy_card : self . delete () else : self . refresh_from_db () return changed djstripe . models . payment_methods . PaymentMethod . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.payment_methods.Source Stripe documentation: https://stripe.com/docs/api#sources djstripe . models . payment_methods . Source . amount djstripe . models . payment_methods . Source . client_secret djstripe . models . payment_methods . Source . code_verification djstripe . models . payment_methods . Source . currency djstripe . models . payment_methods . Source . customer djstripe . models . payment_methods . Source . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Source . flow djstripe . models . payment_methods . Source . owner djstripe . models . payment_methods . Source . receiver djstripe . models . payment_methods . Source . redirect djstripe . models . payment_methods . Source . source_data djstripe . models . payment_methods . Source . statement_descriptor djstripe . models . payment_methods . Source . status djstripe . models . payment_methods . Source . stripe_dashboard_item_name djstripe . models . payment_methods . Source . type djstripe . models . payment_methods . Source . usage Classes djstripe.models.payment_methods.Source.DoesNotExist djstripe.models.payment_methods.Source.MultipleObjectsReturned djstripe.models.payment_methods.Source.stripe_class djstripe . models . payment_methods . Source . stripe_class . OBJECT_NAME Methods djstripe . models . payment_methods . Source . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): token = util . utf8 ( self . id ) if hasattr ( self , \"customer\" ) and self . customer : extn = quote_plus ( token ) customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) url = \" %s / %s /sources/ %s \" % ( base , owner_extn , extn ) headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"delete\" , url , params , headers )) return self else : raise error . InvalidRequestError ( \"Source %s does not appear to be currently attached \" \"to a customer object.\" % token , \"id\" , ) djstripe . models . payment_methods . Source . stripe_class . list_source_transactions ( id , ** params ) classmethod Source code in djstripe/models/payment_methods.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions ( self , ** params ) source_transactions is deprecated, use Source.list_source_transactions instead. Source code in djstripe/models/payment_methods.py def source_transactions ( self , ** params ): \"\"\"source_transactions is deprecated, use Source.list_source_transactions instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/source_transactions\" , params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url Methods djstripe . models . payment_methods . Source . detach ( self ) Detach the source from its customer. Source code in djstripe/models/payment_methods.py def detach ( self ) -> bool : \"\"\" Detach the source from its customer. \"\"\" # First, wipe default source on all customers that use this. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) try : # TODO - we could use the return value of sync_from_stripe_data # or call its internals - self._sync/_attach_objects_hook etc here # to update `self` at this point? self . sync_from_stripe_data ( self . api_retrieve () . detach ()) return True except ( InvalidRequestError , NotImplementedError ): # The source was already detached. Resyncing. # NotImplementedError is an artifact of stripe-python<2.0 # https://github.com/stripe/stripe-python/issues/376 self . sync_from_stripe_data ( self . api_retrieve ()) return False djstripe . models . payment_methods . Source . get_flow_display ( self , * , field =< djstripe . fields . StripeEnumField : flow > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : usage > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.sigma Classes djstripe.models.sigma.ScheduledQueryRun Stripe documentation: https://stripe.com/docs/api#scheduled_queries djstripe . models . sigma . ScheduledQueryRun . data_load_time djstripe . models . sigma . ScheduledQueryRun . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . sigma . ScheduledQueryRun . error djstripe . models . sigma . ScheduledQueryRun . file djstripe . models . sigma . ScheduledQueryRun . result_available_until djstripe . models . sigma . ScheduledQueryRun . sql djstripe . models . sigma . ScheduledQueryRun . status djstripe . models . sigma . ScheduledQueryRun . title djstripe.models.sigma.ScheduledQueryRun.DoesNotExist djstripe.models.sigma.ScheduledQueryRun.MultipleObjectsReturned djstripe.models.sigma.ScheduledQueryRun.stripe_class djstripe . models . sigma . ScheduledQueryRun . stripe_class . OBJECT_NAME djstripe . models . sigma . ScheduledQueryRun . stripe_class . class_url () classmethod Source code in djstripe/models/sigma.py @classmethod def class_url ( cls ): return \"/v1/sigma/scheduled_query_runs\" djstripe . models . sigma . ScheduledQueryRun . get_next_by_data_load_time ( self , * , field =< djstripe . fields . StripeDateTimeField : data_load_time > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_result_available_until ( self , * , field =< djstripe . fields . StripeDateTimeField : result_available_until > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_data_load_time ( self , * , field =< djstripe . fields . StripeDateTimeField : data_load_time > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_result_available_until ( self , * , field =< djstripe . fields . StripeDateTimeField : result_available_until > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe.models.webhooks Classes djstripe.models.webhooks.WebhookEventTrigger An instance of a request that reached the server endpoint for Stripe webhooks. Webhook Events are initially UNTRUSTED , as it is possible for any web entity to post any data to our webhook url. Data posted may be valid Stripe information, garbage, or even malicious. The 'valid' flag in this model monitors this. djstripe . models . webhooks . WebhookEventTrigger . body djstripe . models . webhooks . WebhookEventTrigger . created djstripe . models . webhooks . WebhookEventTrigger . djstripe_version djstripe . models . webhooks . WebhookEventTrigger . event djstripe . models . webhooks . WebhookEventTrigger . exception djstripe . models . webhooks . WebhookEventTrigger . headers djstripe . models . webhooks . WebhookEventTrigger . id djstripe . models . webhooks . WebhookEventTrigger . is_test_event property readonly djstripe . models . webhooks . WebhookEventTrigger . processed djstripe . models . webhooks . WebhookEventTrigger . remote_ip djstripe . models . webhooks . WebhookEventTrigger . traceback djstripe . models . webhooks . WebhookEventTrigger . updated djstripe . models . webhooks . WebhookEventTrigger . valid djstripe.models.webhooks.WebhookEventTrigger.DoesNotExist djstripe.models.webhooks.WebhookEventTrigger.MultipleObjectsReturned Methods djstripe . models . webhooks . WebhookEventTrigger . from_request ( request ) classmethod Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). Source code in djstripe/models/webhooks.py @classmethod def from_request ( cls , request ): \"\"\" Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). \"\"\" try : body = request . body . decode ( request . encoding or \"utf-8\" ) except Exception : body = \"(error decoding body)\" ip = request . META . get ( \"REMOTE_ADDR\" ) if not ip : warnings . warn ( \"Could not determine remote IP (missing REMOTE_ADDR). \" \"This is likely an issue with your wsgi/server setup.\" ) ip = \"0.0.0.0\" obj = cls . objects . create ( headers = dict ( request . headers ), body = body , remote_ip = ip ) try : obj . valid = obj . validate () if obj . valid : if djstripe_settings . WEBHOOK_EVENT_CALLBACK : # If WEBHOOK_EVENT_CALLBACK, pass it for processing djstripe_settings . WEBHOOK_EVENT_CALLBACK ( obj ) else : # Process the item (do not save it, it'll get saved below) obj . process ( save = False ) except Exception as e : max_length = WebhookEventTrigger . _meta . get_field ( \"exception\" ) . max_length obj . exception = str ( e )[: max_length ] obj . traceback = format_exc () # Send the exception as the webhook_processing_error signal webhook_processing_error . send ( sender = WebhookEventTrigger , exception = e , data = getattr ( e , \"http_body\" , \"\" ), ) # re-raise the exception so Django sees it raise e finally : obj . save () return obj djstripe . models . webhooks . WebhookEventTrigger . get_next_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = True , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_next_by_updated ( self , * , field =< django . db . models . fields . DateTimeField : updated > , is_next = True , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_previous_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = False , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_previous_by_updated ( self , * , field =< django . db . models . fields . DateTimeField : updated > , is_next = False , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . process ( self , save = True ) Source code in djstripe/models/webhooks.py def process ( self , save = True ): # Reset traceback and exception in case of reprocessing self . exception = \"\" self . traceback = \"\" self . event = Event . process ( self . json_body ) self . processed = True if save : self . save () return self . event djstripe . models . webhooks . WebhookEventTrigger . validate ( self , api_key = None ) The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. Source code in djstripe/models/webhooks.py def validate ( self , api_key = None ): \"\"\" The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. \"\"\" local_data = self . json_body if \"id\" not in local_data or \"livemode\" not in local_data : return False if self . is_test_event : logger . info ( \"Test webhook received: {} \" . format ( local_data )) return False if djstripe_settings . WEBHOOK_VALIDATION is None : # validation disabled return True elif ( djstripe_settings . WEBHOOK_VALIDATION == \"verify_signature\" and djstripe_settings . WEBHOOK_SECRET ): # HTTP headers are case-insensitive, but we store them as a dict. headers = CaseInsensitiveMapping ( self . headers ) try : stripe . WebhookSignature . verify_header ( self . body , headers . get ( \"stripe-signature\" ), djstripe_settings . WEBHOOK_SECRET , djstripe_settings . WEBHOOK_TOLERANCE , ) except stripe . error . SignatureVerificationError : return False else : return True livemode = local_data [ \"livemode\" ] api_key = api_key or djstripe_settings . get_default_api_key ( livemode ) # Retrieve the event using the api_version specified in itself with stripe_temporary_api_version ( local_data [ \"api_version\" ], validate = False ): remote_data = Event . stripe_class . retrieve ( id = local_data [ \"id\" ], api_key = api_key ) return local_data [ \"data\" ] == remote_data [ \"data\" ] .. module:: djstripe.management. :synopsis: dj-stripe - management module, contains commands. Modules djstripe.management.commands special .. module:: djstripe.management.commands. :synopsis: dj-stripe commands. Modules djstripe.management.commands.djstripe_clear_expired_idempotency_keys Classes djstripe.management.commands.djstripe_clear_expired_idempotency_keys.Command djstripe . management . commands . djstripe_clear_expired_idempotency_keys . Command . help Methods djstripe . management . commands . djstripe_clear_expired_idempotency_keys . Command . handle ( self , * args , ** options ) The actual logic of the command. Subclasses must implement this method. Source code in djstripe/management/commands/djstripe_clear_expired_idempotency_keys.py def handle ( self , * args , ** options ): clear_expired_idempotency_keys () djstripe.management.commands.djstripe_init_customers init_customers command. Classes djstripe.management.commands.djstripe_init_customers.Command Create customer objects for existing subscribers that don't have one. djstripe . management . commands . djstripe_init_customers . Command . help Methods djstripe . management . commands . djstripe_init_customers . Command . handle ( self , * args , ** options ) Create Customer objects for Subscribers without Customer objects associated. Source code in djstripe/management/commands/djstripe_init_customers.py def handle ( self , * args , ** options ): \"\"\" Create Customer objects for Subscribers without Customer objects associated. \"\"\" for subscriber in get_subscriber_model () . objects . filter ( djstripe_customers = None ): # use get_or_create in case of race conditions on large subscriber bases Customer . get_or_create ( subscriber = subscriber ) print ( \"Created subscriber for {0} \" . format ( subscriber . email )) djstripe.management.commands.djstripe_process_events Classes djstripe.management.commands.djstripe_process_events.Command Command to process all Events. Optional arguments are provided to limit the number of Events processed. Note: this is only guaranteed go back at most 30 days based on the current limitation of stripe's events API. See: https://stripe.com/docs/api/events djstripe . management . commands . djstripe_process_events . Command . help Methods djstripe . management . commands . djstripe_process_events . Command . add_arguments ( self , parser ) Add optional arugments to filter Events by. Source code in djstripe/management/commands/djstripe_process_events.py def add_arguments ( self , parser ): \"\"\"Add optional arugments to filter Events by.\"\"\" # Use a mutually exclusive group to prevent multiple arguments being # specified together. group = parser . add_mutually_exclusive_group () group . add_argument ( \"--ids\" , nargs = \"*\" , help = \"An optional space separated list of specific Event IDs to sync.\" , ) group . add_argument ( \"--failed\" , action = \"store_true\" , help = \"Syncs and processes only the events that have failed webhooks.\" , ) group . add_argument ( \"--type\" , help = ( \"A string containing a specific event name,\" \" or group of events using * as a wildcard.\" \" The list will be filtered to include only\" \" events with a matching event property.\" ), ) djstripe . management . commands . djstripe_process_events . Command . handle ( self , * args , ** options ) Try to process Events listed from the API. Source code in djstripe/management/commands/djstripe_process_events.py def handle ( self , * args , ** options ): \"\"\"Try to process Events listed from the API.\"\"\" # Set the verbosity to determine how much we output, if at all. self . set_verbosity ( options ) event_ids = options [ \"ids\" ] failed = options [ \"failed\" ] type_filter = options [ \"type\" ] # Args are mutually exclusive, # so output what we are doing based on that assumption. if failed : self . output ( \"Processing all failed events\" ) elif type_filter : self . output ( \"Processing all events that match {filter} \" . format ( filter = type_filter ) ) elif event_ids : self . output ( \"Processing specific events {events} \" . format ( events = event_ids )) else : self . output ( \"Processing all available events\" ) # Either use the specific event IDs to retrieve data, or use the api_list # if no specific event IDs are specified. if event_ids : listed_events = ( models . Event . stripe_class . retrieve ( id = event_id , api_key = djstripe_settings . STRIPE_SECRET_KEY ) for event_id in event_ids ) else : list_kwargs = {} if failed : list_kwargs [ \"delivery_success\" ] = False if type_filter : list_kwargs [ \"type\" ] = type_filter listed_events = models . Event . api_list ( ** list_kwargs ) self . process_events ( listed_events ) djstripe . management . commands . djstripe_process_events . Command . process_events ( self , listed_events ) Source code in djstripe/management/commands/djstripe_process_events.py def process_events ( self , listed_events ): # Process each listed event. Capture failures and continue, # outputting debug information as verbosity dictates. count = 0 total = 0 for event_data in listed_events : try : total += 1 event = models . Event . process ( data = event_data ) count += 1 self . verbose_output ( \" Synced Event {id} \" . format ( id = event . id )) except Exception as exception : self . verbose_output ( \" Failed processing Event {id} \" . format ( id = event_data [ \"id\" ]) ) self . output ( \" {exception} \" . format ( exception = exception )) self . verbose_traceback () if total == 0 : self . output ( \" (no results)\" ) else : self . output ( \" Processed {count} out of {total} Events\" . format ( count = count , total = total ) ) djstripe.management.commands.djstripe_sync_customers sync_customer command. Classes djstripe.management.commands.djstripe_sync_customers.Command Sync subscriber data with stripe. djstripe . management . commands . djstripe_sync_customers . Command . help Methods djstripe . management . commands . djstripe_sync_customers . Command . handle ( self , * args , ** options ) Call sync_subscriber on Subscribers without customers associated to them. Source code in djstripe/management/commands/djstripe_sync_customers.py def handle ( self , * args , ** options ): \"\"\"Call sync_subscriber on Subscribers without customers associated to them.\"\"\" qs = get_subscriber_model () . objects . filter ( djstripe_customers__isnull = True ) count = 0 total = qs . count () for subscriber in qs : count += 1 perc = int ( round ( 100 * ( float ( count ) / float ( total )))) print ( \"[ {0} / {1} {2} %] Syncing {3} [ {4} ]\" . format ( count , total , perc , subscriber . email , subscriber . pk ) ) sync_subscriber ( subscriber ) djstripe.management.commands.djstripe_sync_models Classes djstripe.management.commands.djstripe_sync_models.Command Sync models from stripe. djstripe . management . commands . djstripe_sync_models . Command . help Methods djstripe . management . commands . djstripe_sync_models . Command . add_arguments ( self , parser ) Entry point for subclassed commands to add custom arguments. Source code in djstripe/management/commands/djstripe_sync_models.py def add_arguments ( self , parser ): parser . add_argument ( \"args\" , metavar = \"ModelName\" , nargs = \"*\" , help = \"restricts sync to these model names (default is to sync all \" \"supported models)\" , ) djstripe . management . commands . djstripe_sync_models . Command . get_list_kwargs ( self , model ) Returns a sequence of kwargs dicts to pass to model.api_list This allows us to sync models that require parameters to api_list :param model: :return: Sequence[dict] Source code in djstripe/management/commands/djstripe_sync_models.py def get_list_kwargs ( self , model ): \"\"\" Returns a sequence of kwargs dicts to pass to model.api_list This allows us to sync models that require parameters to api_list :param model: :return: Sequence[dict] \"\"\" all_list_kwargs = ( [{ \"expand\" : [ f \"data. { k } \" for k in model . expand_fields ]}] if model . expand_fields else [] ) if model is models . PaymentMethod : # special case all_list_kwargs . extend ( ( { \"customer\" : stripe_customer . id , \"type\" : \"card\" } for stripe_customer in models . Customer . api_list () ) ) elif model is models . SubscriptionItem : all_list_kwargs . extend ( ( { \"subscription\" : subscription . id } for subscription in models . Subscription . api_list () ) ) elif not all_list_kwargs : all_list_kwargs . append ({}) return all_list_kwargs djstripe . management . commands . djstripe_sync_models . Command . handle ( self , * args , ** options ) The actual logic of the command. Subclasses must implement this method. Source code in djstripe/management/commands/djstripe_sync_models.py def handle ( self , * args , ** options ): app_label = \"djstripe\" app_config = apps . get_app_config ( app_label ) model_list = [] # type: List[models.StripeModel] if args : for model_label in args : try : model = app_config . get_model ( model_label ) except LookupError : raise CommandError ( \"Unknown model: {} . {} \" . format ( app_label , model_label ) ) model_list . append ( model ) else : model_list = app_config . get_models () for model in model_list : self . sync_model ( model ) djstripe . management . commands . djstripe_sync_models . Command . sync_model ( self , model ) Source code in djstripe/management/commands/djstripe_sync_models.py def sync_model ( self , model ): model_name = model . __name__ should_sync , reason = self . _should_sync_model ( model ) if not should_sync : self . stdout . write ( f \"Skipping { model } : { reason } \" ) return self . stdout . write ( \"Syncing {} :\" . format ( model_name )) count = 0 try : for list_kwargs in self . get_list_kwargs ( model ): if model is models . Account : # special case, since own account isn't returned by Account.api_list stripe_obj = models . Account . stripe_class . retrieve ( api_key = settings . STRIPE_SECRET_KEY ) count += 1 djstripe_obj = model . sync_from_stripe_data ( stripe_obj ) self . stdout . write ( \" id= {id} , pk= {pk} ( {djstripe_obj} )\" . format ( id = djstripe_obj . id , pk = djstripe_obj . pk , djstripe_obj = djstripe_obj , ) ) for stripe_obj in model . api_list ( ** list_kwargs ): count += 1 djstripe_obj = model . sync_from_stripe_data ( stripe_obj ) self . stdout . write ( \" id= {id} , pk= {pk} ( {djstripe_obj} )\" . format ( id = djstripe_obj . id , pk = djstripe_obj . pk , djstripe_obj = djstripe_obj , ) ) except Exception as e : self . stderr . write ( str ( e )) if count == 0 : self . stdout . write ( \" (no results)\" ) else : self . stdout . write ( \" Synced {count} {model_name} \" . format ( count = count , model_name = model_name ) ) djstripe.management.commands.djstripe_sync_plans_from_stripe sync_plans_from_stripe command. Classes djstripe.management.commands.djstripe_sync_plans_from_stripe.Command Sync prices (and plans) from stripe. djstripe . management . commands . djstripe_sync_plans_from_stripe . Command . help Methods djstripe . management . commands . djstripe_sync_plans_from_stripe . Command . handle ( self , * args , ** options ) The actual logic of the command. Subclasses must implement this method. Source code in djstripe/management/commands/djstripe_sync_plans_from_stripe.py def handle ( self , * args , ** options ): for price_data in Price . api_list (): price = Price . sync_from_stripe_data ( price_data ) self . stdout . write ( f \"Synchronized price { price . id } \" ) for plan_data in Plan . api_list (): plan = Plan . sync_from_stripe_data ( plan_data ) self . stdout . write ( f \"Synchronized plan { plan . id } \" ) djstripe.management.commands.djstripe_update_invoiceitem_ids djstripe . management . commands . djstripe_update_invoiceitem_ids . no_results_msg Classes djstripe.management.commands.djstripe_update_invoiceitem_ids.Command djstripe . management . commands . djstripe_update_invoiceitem_ids . Command . help Methods djstripe . management . commands . djstripe_update_invoiceitem_ids . Command . add_arguments ( self , parser ) Add optional arugments to filter Events by. Source code in djstripe/management/commands/djstripe_update_invoiceitem_ids.py def add_arguments ( self , parser ): \"\"\"Add optional arugments to filter Events by.\"\"\" # Use a mutually exclusive group to prevent multiple arguments being # specified together. group = parser . add_mutually_exclusive_group () group . add_argument ( \"--i-understand\" , action = \"store_true\" , help = \"Run the command, once you've read the warning and understand it.\" , ) djstripe . management . commands . djstripe_update_invoiceitem_ids . Command . handle ( self , * args , ** options ) The actual logic of the command. Subclasses must implement this method. Source code in djstripe/management/commands/djstripe_update_invoiceitem_ids.py def handle ( self , * args , ** options ): invoice_items = InvoiceItem . objects . filter ( id__contains = \"-il_\" ) count = invoice_items . count () if not options [ \"i_understand\" ]: self . stderr . write ( \"In Stripe API 2019-12-03, the format of invoice line items changed. \" \"This means that existing InvoiceItem objects with the old ID format \" \"may still be in the database and need to be migrated. \\n \" \"This is a destructive migration, but this command will attempt to \" \"perform it as safely as possible. \\n \" \"More information: https://stripe.com/docs/upgrades#2019-12-03 \\n\\n \" ) if count : first_few_ids = invoice_items [: 10 ] . values_list ( \"id\" , flat = True ) self . stdout . write ( f \"I have found { count } InvoiceItems to migrate:\" ) self . stdout . write ( \" \" + \", \" . join ( first_few_ids ) + f \", \u2026 (and { count - 10 } more)\" if count > 10 else \"\" ) self . stderr . write ( \"To perform this migration, run this again with `--i-understand`.\" ) else : self . stdout . write ( no_results_msg ) return if not count : self . stdout . write ( no_results_msg ) return for ii in invoice_items : old_id = ii . id new_id = old_id . partition ( \"-\" )[ 2 ] if \"-\" in new_id or not new_id . startswith ( \"il_\" ): self . stderr . write ( f \"Don't know how to migrate { old_id !r} . This is a bug. \" \"Could you report it? \\n https://github.com/dj-stripe/dj-stripe\" ) continue self . stdout . write ( f \"Migrating { old_id } => { new_id } \" ) with transaction . atomic (): ii . id = new_id stripe_data = ii . api_retrieve () ii . save () InvoiceItem . sync_from_stripe_data ( stripe_data ) A Fake or multiple fakes for each stripe object. Originally collected using API VERSION 2015-07-28. Updated to API VERSION 2016-03-07 with bogus fields. tests . FAKE_ACCOUNT tests . FAKE_BALANCE_TRANSACTION tests . FAKE_BALANCE_TRANSACTION_II tests . FAKE_BALANCE_TRANSACTION_III tests . FAKE_BALANCE_TRANSACTION_IV tests . FAKE_BALANCE_TRANSACTION_REFUND tests . FAKE_BANK_ACCOUNT tests . FAKE_BANK_ACCOUNT_II tests . FAKE_BANK_ACCOUNT_SOURCE tests . FAKE_CARD tests . FAKE_CARD_AS_PAYMENT_METHOD tests . FAKE_CARD_II tests . FAKE_CARD_III tests . FAKE_CARD_IV tests . FAKE_CARD_V tests . FAKE_CHARGE tests . FAKE_CHARGE_II tests . FAKE_CHARGE_REFUNDED tests . FAKE_COUPON tests . FAKE_CUSTOMER tests . FAKE_CUSTOMER_BEFORE_TAX_ID tests . FAKE_CUSTOMER_II tests . FAKE_CUSTOMER_III tests . FAKE_CUSTOMER_IV tests . FAKE_CUSTOMER_WITHOUT_TAX_ID tests . FAKE_CUSTOMER_WITH_TAX_ID tests . FAKE_DISCOUNT_CUSTOMER tests . FAKE_DISPUTE tests . FAKE_EVENT_ACCOUNT_APPLICATION_DEAUTHORIZED tests . FAKE_EVENT_CARD_PAYMENT_METHOD_ATTACHED tests . FAKE_EVENT_CARD_PAYMENT_METHOD_DETACHED tests . FAKE_EVENT_CHARGE_SUCCEEDED tests . FAKE_EVENT_CUSTOMER_CREATED tests . FAKE_EVENT_CUSTOMER_DELETED tests . FAKE_EVENT_CUSTOMER_DISCOUNT_CREATED tests . FAKE_EVENT_CUSTOMER_DISCOUNT_DELETED tests . FAKE_EVENT_CUSTOMER_SOURCE_CREATED tests . FAKE_EVENT_CUSTOMER_SOURCE_DELETED tests . FAKE_EVENT_CUSTOMER_SOURCE_DELETED_DUPE tests . FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED tests . FAKE_EVENT_CUSTOMER_SUBSCRIPTION_DELETED tests . FAKE_EVENT_DISPUTE_CREATED tests . FAKE_EVENT_INVOICEITEM_CREATED tests . FAKE_EVENT_INVOICEITEM_DELETED tests . FAKE_EVENT_INVOICE_CREATED tests . FAKE_EVENT_INVOICE_DELETED tests . FAKE_EVENT_INVOICE_UPCOMING tests . FAKE_EVENT_PAYMENT_INTENT_SUCCEEDED_DESTINATION_CHARGE tests . FAKE_EVENT_PAYMENT_METHOD_ATTACHED tests . FAKE_EVENT_PAYMENT_METHOD_DETACHED tests . FAKE_EVENT_PLAN_CREATED tests . FAKE_EVENT_PLAN_DELETED tests . FAKE_EVENT_PLAN_REQUEST_IS_OBJECT tests . FAKE_EVENT_PRICE_CREATED tests . FAKE_EVENT_PRICE_DELETED tests . FAKE_EVENT_PRICE_UPDATED tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CANCELED tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_RELEASED tests . FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED tests . FAKE_EVENT_TEST_CHARGE_SUCCEEDED tests . FAKE_EVENT_TRANSFER_CREATED tests . FAKE_EVENT_TRANSFER_DELETED tests . FAKE_FILEUPLOAD_ICON tests . FAKE_FILEUPLOAD_LOGO tests . FAKE_INVOICE tests . FAKE_INVOICEITEM tests . FAKE_INVOICEITEM_II tests . FAKE_INVOICEITEM_III tests . FAKE_INVOICE_II tests . FAKE_INVOICE_III tests . FAKE_INVOICE_IV tests . FAKE_PAYMENT_INTENT_DESTINATION_CHARGE tests . FAKE_PAYMENT_INTENT_I tests . FAKE_PAYMENT_INTENT_II tests . FAKE_PAYMENT_METHOD_I tests . FAKE_PAYMENT_METHOD_II tests . FAKE_PLAN tests . FAKE_PLAN_II tests . FAKE_PLAN_METERED tests . FAKE_PRICE tests . FAKE_PRICE_II tests . FAKE_PRICE_METERED tests . FAKE_PRICE_ONETIME tests . FAKE_PRICE_TIER tests . FAKE_PRODUCT tests . FAKE_REFUND tests . FAKE_SESSION_I tests . FAKE_SETUP_INTENT_I tests . FAKE_SOURCE tests . FAKE_SOURCE_II tests . FAKE_SUBSCRIPTION tests . FAKE_SUBSCRIPTION_CANCELED tests . FAKE_SUBSCRIPTION_CANCELED_AT_PERIOD_END tests . FAKE_SUBSCRIPTION_II tests . FAKE_SUBSCRIPTION_III tests . FAKE_SUBSCRIPTION_METERED tests . FAKE_SUBSCRIPTION_MULTI_PLAN tests . FAKE_SUBSCRIPTION_NOT_PERIOD_CURRENT tests . FAKE_SUBSCRIPTION_SCHEDULE tests . FAKE_TAX_ID tests . FAKE_TAX_RATE_EXAMPLE_1_VAT tests . FAKE_TAX_RATE_EXAMPLE_2_SALES tests . FAKE_TIER_PLAN tests . FAKE_TOKEN tests . FAKE_TRANSFER tests . FAKE_TRANSFER_II tests . FAKE_TRANSFER_III tests . FAKE_UPCOMING_INVOICE tests . FIXTURE_DIR_PATH tests . FUTURE_DATE tests . IS_STATICMETHOD_AUTOSPEC_SUPPORTED tests . logger Classes tests.AssertStripeFksMixin Methods tests . AssertStripeFksMixin . assert_fks ( self , obj , expected_blank_fks , processed_stripe_ids = None ) Recursively walk through fks on obj, asserting they're not-none :param obj: :param expected_blank_fks: fields that are expected to be None :param processed_stripe_ids: set of objects ids already processed :return: Source code in tests/__init__.py def assert_fks ( self , obj , expected_blank_fks , processed_stripe_ids = None ): \"\"\" Recursively walk through fks on obj, asserting they're not-none :param obj: :param expected_blank_fks: fields that are expected to be None :param processed_stripe_ids: set of objects ids already processed :return: \"\"\" if processed_stripe_ids is None : processed_stripe_ids = set () processed_stripe_ids . add ( obj . id ) for field in obj . _meta . get_fields (): field_str = self . _get_field_str ( field ) if not field_str or field_str . endswith ( \".djstripe_owner_account\" ): continue try : field_value = getattr ( obj , field . name ) except ObjectDoesNotExist : field_value = None if field_str in expected_blank_fks : self . assertIsNone ( field_value , field_str ) else : self . assertIsNotNone ( field_value , field_str ) if field_value . id not in processed_stripe_ids : # recurse into the object if it's not already been checked self . assert_fks ( field_value , expected_blank_fks , processed_stripe_ids ) logger . warning ( \"checked {} \" . format ( field_str )) tests.BankAccountDict tests.CardDict tests.ChargeDict Methods tests . ChargeDict . __init__ ( self , * args , ** kwargs ) special Match Stripe's behavior: return a stripe iterable on charge.refunds . Source code in tests/__init__.py def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `charge.refunds`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . refunds = StripeList ( self . refunds ) tests . ChargeDict . capture ( self ) Source code in tests/__init__.py def capture ( self ): self . update ({ \"captured\" : True }) return self tests . ChargeDict . refund ( self , amount = None , reason = None ) Source code in tests/__init__.py def refund ( self , amount = None , reason = None ): self . update ({ \"refunded\" : True , \"amount_refunded\" : amount }) return self tests.CustomerDict tests . CustomerDict . sources property readonly tests . CustomerDict . tax_ids property readonly tests . CustomerDict . __init__ ( self , * args , ** kwargs ) special Source code in tests/__init__.py def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self [ \"default_source\" ] = convert_source_dict ( self [ \"default_source\" ]) for n , d in enumerate ( self [ \"sources\" ] . get ( \"data\" , [])): self [ \"sources\" ][ \"data\" ][ n ] = convert_source_dict ( d ) tests . CustomerDict . create_for_user ( self , user ) Source code in tests/__init__.py def create_for_user ( self , user ): from djstripe.models import Customer stripe_customer = Customer . sync_from_stripe_data ( self ) stripe_customer . subscriber = user stripe_customer . save () return stripe_customer tests . CustomerDict . delete ( self ) Source code in tests/__init__.py def delete ( self ): return self tests . CustomerDict . save ( self , idempotency_key = None ) Source code in tests/__init__.py def save ( self , idempotency_key = None ): return self tests.InvoiceDict Methods tests . InvoiceDict . __init__ ( self , * args , ** kwargs ) special Match Stripe's behavior: return a stripe iterable on invoice.lines . Source code in tests/__init__.py def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `invoice.lines`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . lines = StripeList ( self . lines ) tests . InvoiceDict . pay ( self ) Source code in tests/__init__.py def pay ( self ): return self tests.LegacySourceDict tests . LegacySourceDict . delete ( self ) Source code in tests/__init__.py def delete ( self ): return self tests.PaymentMethodDict tests . PaymentMethodDict . detach ( self ) Source code in tests/__init__.py def detach ( self ): self . pop ( \"customer\" ) return self tests.SourceDict tests . SourceDict . detach ( self ) Source code in tests/__init__.py def detach ( self ): self . pop ( \"customer\" ) self . update ({ \"status\" : \"consumed\" }) return self tests.Sources tests . Sources . __init__ ( self , card_fakes ) special Source code in tests/__init__.py def __init__ ( self , card_fakes ): self . card_fakes = card_fakes tests . Sources . create ( self , source , api_key = None ) Source code in tests/__init__.py def create ( self , source , api_key = None ): for fake_card in self . card_fakes : if fake_card [ \"id\" ] == source : return fake_card tests . Sources . list ( self , ** kwargs ) Source code in tests/__init__.py def list ( self , ** kwargs ): return StripeList ( data = self . card_fakes ) tests . Sources . retrieve ( self , id , expand = None ) Source code in tests/__init__.py def retrieve ( self , id , expand = None ): # noqa for fake_card in self . card_fakes : if fake_card [ \"id\" ] == id : return fake_card tests.StripeItem Flexible class built to mock any generic Stripe object. Implements object access + deletion methods to match the behavior of Stripe's library, which allows both object + dictionary access. Has a delete method since (most) Stripe objects can be deleted. Methods tests . StripeItem . __delattr__ ( self , name ) special Source code in tests/__init__.py def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) tests . StripeItem . __getattr__ ( self , name ) special Give StripeItem normal object access to match Stripe behavior. Source code in tests/__init__.py def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) tests . StripeItem . __setattr__ ( self , name , value ) special Source code in tests/__init__.py def __setattr__ ( self , name , value ): self [ name ] = value tests . StripeItem . class_url () classmethod Source code in tests/__init__.py @classmethod def class_url ( cls ): return \"/v1/test-items/\" tests . StripeItem . delete ( self ) Superficial mock that adds a deleted attribute. Source code in tests/__init__.py def delete ( self ) -> bool : \"\"\"Superficial mock that adds a deleted attribute.\"\"\" self . deleted = True return self . deleted tests . StripeItem . instance_url ( self ) Superficial mock that emulates instance_url. Source code in tests/__init__.py def instance_url ( self ): \"\"\"Superficial mock that emulates instance_url.\"\"\" id = self . get ( \"id\" ) base = self . class_url () return \" %s / %s \" % ( base , id ) tests . StripeItem . request ( self , method , url , params ) Superficial mock that emulates request method. Source code in tests/__init__.py def request ( self , method , url , params ) -> dict : \"\"\"Superficial mock that emulates request method.\"\"\" assert method == \"post\" for key , value in params . items (): self . __setattr__ ( key , value ) return self tests.StripeList Mock a generic Stripe Iterable. It has the relevant attributes of a stripe iterable (has_more, data). This mock is important so we can use stripe's list method in our testing. StripeList.list() will return the StripeList. Additionally, iterating over instances of MockStripeIterable will iterate over the data attribute, just like Stripe iterables. Attributes: Name Type Description has_more mock has_more flag. Default False. **kwargs all of the fields of the stripe object, generally as a dictionary. tests . StripeList . has_more tests . StripeList . object tests . StripeList . total_count property readonly tests . StripeList . url Methods tests . StripeList . __delattr__ ( self , name ) special Source code in tests/__init__.py def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) tests . StripeList . __getattr__ ( self , name ) special Give StripeItem normal object access to match Stripe behavior. Source code in tests/__init__.py def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name ) tests . StripeList . __iter__ ( self ) special Make StripeList an iterable, to match the Stripe iterable behavior. Source code in tests/__init__.py def __iter__ ( self ) -> Any : \"\"\"Make StripeList an iterable, to match the Stripe iterable behavior.\"\"\" self . iter_copy = self . data . copy () return self tests . StripeList . __next__ ( self ) special Define iteration for StripeList. Source code in tests/__init__.py def __next__ ( self ) -> StripeItem : \"\"\"Define iteration for StripeList.\"\"\" if len ( self . iter_copy ) > 0 : return self . iter_copy . pop ( 0 ) else : raise StopIteration () tests . StripeList . __setattr__ ( self , name , value ) special Source code in tests/__init__.py def __setattr__ ( self , name , value ): self [ name ] = value tests . StripeList . auto_paging_iter ( self ) Add an auto_paging_iter method to the StripeList which returns itself. The StripeList is an iterable, so this mimics the real behavior. Source code in tests/__init__.py def auto_paging_iter ( self ) -> \"StripeList\" : \"\"\"Add an auto_paging_iter method to the StripeList which returns itself. The StripeList is an iterable, so this mimics the real behavior. \"\"\" return self tests . StripeList . list ( self , ** kwargs ) Add a list method to the StripeList which returns itself. list() accepts arbitrary kwargs, be careful is you expect the argument-accepting functionality of Stripe's list() method. Source code in tests/__init__.py def list ( self , ** kwargs : Any ) -> \"StripeList\" : \"\"\"Add a list method to the StripeList which returns itself. list() accepts arbitrary kwargs, be careful is you expect the argument-accepting functionality of Stripe's list() method. \"\"\" return self tests.SubscriptionDict Methods tests . SubscriptionDict . __init__ ( self , * args , ** kwargs ) special Match Stripe's behavior: return a stripe iterable on subscription.items . Source code in tests/__init__.py def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `subscription.items`.\"\"\" super () . __init__ ( * args , ** kwargs ) self [ \"items\" ] = StripeList ( self [ \"items\" ]) tests . SubscriptionDict . __setattr__ ( self , name , value ) special Source code in tests/__init__.py def __setattr__ ( self , name , value ): if type ( value ) == datetime : value = datetime_to_unix ( value ) # Special case for price and plan if name == \"price\" : for price in [ FAKE_PRICE , FAKE_PRICE_II , FAKE_PRICE_TIER , FAKE_PRICE_METERED , ]: if value == price [ \"id\" ]: value = price elif name == \"plan\" : for plan in [ FAKE_PLAN , FAKE_PLAN_II , FAKE_TIER_PLAN , FAKE_PLAN_METERED ]: if value == plan [ \"id\" ]: value = plan self [ name ] = value tests . SubscriptionDict . delete ( self , ** kwargs ) Superficial mock that adds a deleted attribute. Source code in tests/__init__.py def delete ( self , ** kwargs ): if \"at_period_end\" in kwargs : self [ \"cancel_at_period_end\" ] = kwargs [ \"at_period_end\" ] return self tests . SubscriptionDict . save ( self , idempotency_key = None ) Source code in tests/__init__.py def save ( self , idempotency_key = None ): return self tests . convert_source_dict ( data ) Source code in tests/__init__.py def convert_source_dict ( data ): if data : source_type = data [ \"object\" ] if source_type == \"card\" : data = CardDict ( data ) elif source_type == \"bank_account\" : data = BankAccountDict ( data ) elif source_type == \"source\" : data = SourceDict ( data ) else : raise ValueError ( \"Unknown source type: {} \" . format ( source_type )) return data tests . datetime_to_unix ( datetime_ ) Source code in tests/__init__.py def datetime_to_unix ( datetime_ ): return int ( dateformat . format ( datetime_ , \"U\" )) tests . default_account () Source code in tests/__init__.py def default_account (): from djstripe.models import Account return Account . objects . create ( id = \"acct_TESTXXXXX\" , charges_enabled = True , details_submitted = True , payouts_enabled = True , ) tests . load_fixture ( filename ) Source code in tests/__init__.py def load_fixture ( filename ): with FIXTURE_DIR_PATH . joinpath ( filename ) . open ( \"r\" ) as f : return json . load ( f ) Modules tests.apps special Modules tests.apps.example special Modules tests.apps.example.forms tests.apps.example.forms.PaymentIntentForm tests . apps . example . forms . PaymentIntentForm . media property readonly tests.apps.example.forms.PurchaseSubscriptionForm tests . apps . example . forms . PurchaseSubscriptionForm . media property readonly tests.apps.example.management special Modules tests.apps.example.management.commands special Modules tests.apps.example.management.commands.regenerate_test_fixtures tests . apps . example . management . commands . regenerate_test_fixtures . FAKE_ID_METADATA_KEY Classes tests.apps.example.management.commands.regenerate_test_fixtures.Command This does the following: 1) Load existing fixtures from JSON files 2) Attempts to read the corresponding objects from Stripe 3) If found, for types Stripe doesn't allow us to choose ids for, we build a map between the fake ids in the fixtures and real Stripe ids 3) If not found, creates objects in Stripe from the fixtures 4) Save objects back as fixtures, using fake ids if available The rationale for this is so that the fixtures can automatically be updated with Stripe schema changes running this command. This should make keeping our tests and model schema compatible with Stripe schema changes less pain-staking and simplify the process of upgrading the targeted Stripe API version. tests . apps . example . management . commands . regenerate_test_fixtures . Command . fake_data_map tests . apps . example . management . commands . regenerate_test_fixtures . Command . fake_id_map tests . apps . example . management . commands . regenerate_test_fixtures . Command . help Methods tests . apps . example . management . commands . regenerate_test_fixtures . Command . add_arguments ( self , parser ) Entry point for subclassed commands to add custom arguments. Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def add_arguments ( self , parser ): parser . add_argument ( \"--delete-stale\" , action = \"store_true\" , help = \"Delete any untouched fixtures in the directory\" , ) parser . add_argument ( \"--update-sideeffect-fields\" , action = \"store_true\" , help = \"Don't preserve sideeffect fields such as 'created'\" , ) tests . apps . example . management . commands . regenerate_test_fixtures . Command . fake_json_ids ( self , json_str ) Replace real ids with fakes ones in the JSON fixture Do this on the serialized JSON string since it's a simple string replace :param json_str: :return: Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def fake_json_ids ( self , json_str ): \"\"\" Replace real ids with fakes ones in the JSON fixture Do this on the serialized JSON string since it's a simple string replace :param json_str: :return: \"\"\" for fake_id , actual_id in self . fake_id_map . items (): json_str = json_str . replace ( actual_id , fake_id ) return json_str tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_fake_id ( self , obj ) Get a stable fake id from a real Stripe object, we use this so that fixtures are stable :param obj: :return: Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_fake_id ( self , obj ): \"\"\" Get a stable fake id from a real Stripe object, we use this so that fixtures are stable :param obj: :return: \"\"\" fake_id = None if isinstance ( obj , str ): real_id = obj real_id_map = { v : k for k , v in self . fake_id_map . items ()} fake_id = real_id_map . get ( real_id ) elif \"metadata\" in obj : # Note: not all objects have a metadata dict # (eg Account, BalanceTransaction don't) fake_id = obj . get ( \"metadata\" , {}) . get ( FAKE_ID_METADATA_KEY ) elif obj . get ( \"object\" ) == \"balance_transaction\" : # assume for purposes of fixture generation that 1 balance_transaction per # source charge (etc) fake_source_id = self . get_fake_id ( obj [ \"source\" ]) fake_id = \"txn_fake_ {} \" . format ( fake_source_id ) return fake_id tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_account ( self , old_obj , readonly_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_account ( self , old_obj , readonly_fields ): obj = djstripe . models . Account () . api_retrieve () return True , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_balance_transaction ( self , old_obj ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_balance_transaction ( self , old_obj ): source = old_obj [ \"source\" ] if source . startswith ( \"ch_\" ): charge = djstripe . models . Charge ( id = source ) . api_retrieve () id_ = djstripe . models . StripeModel . _id_from_data ( charge [ \"balance_transaction\" ] ) try : obj = djstripe . models . BalanceTransaction ( id = id_ ) . api_retrieve () created = False self . stdout . write ( f \" found { id_ } \" ) except InvalidRequestError : assert False , \"Expected to find balance transaction via source\" return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_bank_account ( self , old_obj , readonly_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_bank_account ( self , old_obj , readonly_fields ): customer = djstripe . models . Customer ( id = old_obj [ \"customer\" ]) . api_retrieve () id_ = old_obj [ \"id\" ] try : obj = customer . sources . retrieve ( id_ ) created = False self . stdout . write ( \" found\" ) except InvalidRequestError : self . stdout . write ( \" creating\" ) create_obj = deepcopy ( old_obj ) # create in Stripe for k in readonly_fields : create_obj . pop ( k , None ) # see https://stripe.com/docs/connect/testing#account-numbers # we've stash the account number in the metadata # so we can regenerate the fixture create_obj [ \"account_number\" ] = old_obj [ \"metadata\" ][ \"djstripe_test_fixture_account_number\" ] create_obj [ \"object\" ] = \"bank_account\" obj = customer . sources . create ( source = create_obj ) created = True return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_card ( self , old_obj , readonly_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_card ( self , old_obj , readonly_fields ): customer = djstripe . models . Customer ( id = old_obj [ \"customer\" ]) . api_retrieve () id_ = old_obj [ \"id\" ] try : obj = customer . sources . retrieve ( id_ ) created = False self . stdout . write ( \" found\" ) except InvalidRequestError : self . stdout . write ( \" creating\" ) create_obj = deepcopy ( old_obj ) # create in Stripe for k in readonly_fields : create_obj . pop ( k , None ) obj = customer . sources . create ( ** { \"source\" : \"tok_visa\" }) for k , v in create_obj . items (): setattr ( obj , k , v ) obj . save () created = True return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_charge ( self , old_obj , writable_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_charge ( self , old_obj , writable_fields ): invoice = djstripe . models . Invoice ( id = old_obj [ \"invoice\" ]) . api_retrieve () id_ = invoice [ \"charge\" ] try : obj = djstripe . models . Charge ( id = id_ ) . api_retrieve () created = False self . stdout . write ( f \" found { id_ } \" ) except InvalidRequestError : assert False , \"Expected to find charge via invoice\" for k in writable_fields : if isinstance ( obj . get ( k ), dict ): # merge dicts (eg metadata) obj [ k ] . update ( old_obj . get ( k , {})) else : obj [ k ] = old_obj [ k ] obj . save () return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_invoice ( self , old_obj , writable_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_invoice ( self , old_obj , writable_fields ): subscription = djstripe . models . Subscription ( id = old_obj [ \"subscription\" ] ) . api_retrieve () id_ = subscription [ \"latest_invoice\" ] try : obj = djstripe . models . Invoice ( id = id_ ) . api_retrieve () created = False self . stdout . write ( f \" found { id_ } \" ) except InvalidRequestError : assert False , \"Expected to find invoice via subscription\" for k in writable_fields : if isinstance ( obj . get ( k ), dict ): # merge dicts (eg metadata) obj [ k ] . update ( old_obj . get ( k , {})) else : obj [ k ] = old_obj [ k ] obj . save () return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_payment_intent ( self , old_obj , writable_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_payment_intent ( self , old_obj , writable_fields ): invoice = djstripe . models . Invoice ( id = old_obj [ \"invoice\" ]) . api_retrieve () id_ = invoice [ \"payment_intent\" ] try : obj = djstripe . models . PaymentIntent ( id = id_ ) . api_retrieve () created = False self . stdout . write ( f \" found { id_ } \" ) except InvalidRequestError : assert False , \"Expected to find payment_intent via invoice\" for k in writable_fields : if isinstance ( obj . get ( k ), dict ): # merge dicts (eg metadata) obj [ k ] . update ( old_obj . get ( k , {})) else : obj [ k ] = old_obj [ k ] obj . save () return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_payment_method ( self , old_obj , writable_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_payment_method ( self , old_obj , writable_fields ): id_ = old_obj [ \"id\" ] customer_id = old_obj [ \"customer\" ] type_ = old_obj [ \"type\" ] try : obj = djstripe . models . PaymentMethod ( id = id_ ) . api_retrieve () created = False self . stdout . write ( \" found\" ) except InvalidRequestError : self . stdout . write ( \" creating\" ) obj = djstripe . models . PaymentMethod () . _api_create ( type = type_ , card = { \"token\" : \"tok_visa\" } ) stripe . PaymentMethod . attach ( obj [ \"id\" ], customer = customer_id , api_key = djstripe . settings . STRIPE_SECRET_KEY , ) for k in writable_fields : if isinstance ( obj . get ( k ), dict ): # merge dicts (eg metadata) obj [ k ] . update ( old_obj . get ( k , {})) else : obj [ k ] = old_obj [ k ] obj . save () created = True return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_source ( self , old_obj , readonly_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_source ( self , old_obj , readonly_fields ): customer = djstripe . models . Customer ( id = old_obj [ \"customer\" ]) . api_retrieve () id_ = old_obj [ \"id\" ] try : obj = customer . sources . retrieve ( id_ ) created = False self . stdout . write ( \" found\" ) except InvalidRequestError : self . stdout . write ( \" creating\" ) create_obj = deepcopy ( old_obj ) # create in Stripe for k in readonly_fields : create_obj . pop ( k , None ) source_obj = djstripe . models . Source . _api_create ( ** { \"token\" : \"tok_visa\" , \"type\" : \"card\" } ) obj = customer . sources . create ( ** { \"source\" : source_obj . id }) for k , v in create_obj . items (): setattr ( obj , k , v ) obj . save () created = True return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . handle ( self , * args , ** options ) The actual logic of the command. Subclasses must implement this method. Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def handle ( self , * args , ** options ): do_delete_stale_fixtures = options [ \"delete_stale\" ] do_preserve_sideeffect_fields = not options [ \"update_sideeffect_fields\" ] common_readonly_fields = [ \"object\" , \"created\" , \"updated\" , \"livemode\" ] common_sideeffect_fields = [ \"created\" ] # TODO - is it be possible to get a list of which fields are writable from # the API? maybe using https://github.com/stripe/openapi ? # (though that's only for current version) \"\"\" Fields that we treat as read-only. Most of these will cause an error if sent to the Stripe API. \"\"\" model_extra_readonly_fields = { djstripe . models . Account : [ \"id\" ], djstripe . models . Customer : [ \"account_balance\" , \"currency\" , \"default_source\" , \"delinquent\" , \"invoice_prefix\" , \"subscriptions\" , \"sources\" , ], djstripe . models . BankAccount : [ \"id\" , \"bank_name\" , \"customer\" , \"last4\" , \"fingerprint\" , \"status\" , ], djstripe . models . Card : [ \"id\" , \"address_line1_check\" , \"address_zip_check\" , \"brand\" , \"country\" , \"customer\" , \"cvc_check\" , \"dynamic_last4\" , \"exp_month\" , \"exp_year\" , \"fingerprint\" , \"funding\" , \"last4\" , \"tokenization_method\" , ], djstripe . models . PaymentIntent : [ \"id\" ], djstripe . models . PaymentMethod : [ \"id\" ], djstripe . models . Plan : [ # Can only specify one of amount and amount_decimal \"amount_decimal\" ], djstripe . models . Source : [ \"id\" , \"amount\" , \"card\" , \"client_secret\" , \"currency\" , \"customer\" , \"flow\" , \"owner\" , \"statement_descriptor\" , \"status\" , \"type\" , \"usage\" , ], djstripe . models . Subscription : [ \"id\" , # not actually read-only \"billing_cycle_anchor\" , \"billing\" , \"current_period_end\" , \"current_period_start\" , # workaround for \"the # `invoice_customer_balance_settings[consume_applied_balance_on_void]` # parameter is only supported in API version 2019-11-05 and below. # See # https://stripe.com/docs/api#versioning and # https://stripe.com/docs/upgrades#2019-12-03 for more detail. \"invoice_customer_balance_settings\" , \"latest_invoice\" , \"start\" , \"start_date\" , \"status\" , ], djstripe . models . TaxRate : [ \"id\" ], } # type: Dict[Type[djstripe.models.StripeModel], List[str]] \"\"\" Fields that we don't care about the value of, and that preserving allows us to avoid churn in the fixtures \"\"\" model_sideeffect_fields = { djstripe . models . BalanceTransaction : [ \"available_on\" ], djstripe . models . Source : [ \"client_secret\" ], djstripe . models . Charge : [ \"receipt_url\" ], djstripe . models . Subscription : [ \"billing_cycle_anchor\" , \"current_period_start\" , \"current_period_end\" , \"start\" , \"start_date\" , ], djstripe . models . SubscriptionItem : [ # we don't currently track separate fixtures for SubscriptionItems \"id\" ], djstripe . models . Product : [ \"updated\" ], djstripe . models . Invoice : [ \"date\" , \"finalized_at\" , \"hosted_invoice_url\" , \"invoice_pdf\" , \"webhooks_delivered_at\" , \"period_start\" , \"period_end\" , # we don't currently track separate fixtures for SubscriptionItems \"subscription_item\" , ], } # type: Dict[Type[djstripe.models.StripeModel], List[str]] object_sideeffect_fields = { model . stripe_class . OBJECT_NAME : set ( v ) for model , v in model_sideeffect_fields . items () } # type: Dict[str, Set[str]] self . fake_data_map = { # djstripe.models.Account: [tests.FAKE_ACCOUNT], djstripe . models . Customer : [ tests . FAKE_CUSTOMER , tests . FAKE_CUSTOMER_II , tests . FAKE_CUSTOMER_III , tests . FAKE_CUSTOMER_IV , ], djstripe . models . BankAccount : [ tests . FAKE_BANK_ACCOUNT_SOURCE ], djstripe . models . Card : [ tests . FAKE_CARD , tests . FAKE_CARD_II , tests . FAKE_CARD_V , ], djstripe . models . Source : [ tests . FAKE_SOURCE ], djstripe . models . Plan : [ tests . FAKE_PLAN , tests . FAKE_PLAN_II ], djstripe . models . Price : [ tests . FAKE_PRICE , tests . FAKE_PRICE_II ], djstripe . models . Product : [ tests . FAKE_PRODUCT ], djstripe . models . TaxRate : [ tests . FAKE_TAX_RATE_EXAMPLE_1_VAT , tests . FAKE_TAX_RATE_EXAMPLE_2_SALES , ], djstripe . models . Subscription : [ tests . FAKE_SUBSCRIPTION , tests . FAKE_SUBSCRIPTION_II , tests . FAKE_SUBSCRIPTION_III , tests . FAKE_SUBSCRIPTION_MULTI_PLAN , ], djstripe . models . SubscriptionSchedule : [ tests . FAKE_SUBSCRIPTION_SCHEDULE , ], djstripe . models . Invoice : [ tests . FAKE_INVOICE , tests . FAKE_INVOICE_IV ], djstripe . models . Charge : [ tests . FAKE_CHARGE ], djstripe . models . PaymentIntent : [ tests . FAKE_PAYMENT_INTENT_I ], djstripe . models . PaymentMethod : [ tests . FAKE_PAYMENT_METHOD_I , tests . FAKE_CARD_AS_PAYMENT_METHOD , ], djstripe . models . BalanceTransaction : [ tests . FAKE_BALANCE_TRANSACTION ], } self . init_fake_id_map () objs = [] # Regenerate each of the fixture objects via Stripe # We re-fetch objects in a second pass if they were created during # the first pass, to ensure nested objects are up to date # (eg Customer.subscriptions), for n in range ( 2 ): any_created = False self . stdout . write ( f \"Updating fixture objects, pass { n } \" ) # reset the objects list since we don't want to keep those from # the first pass objs . clear () for model_class , old_objs in self . fake_data_map . items (): readonly_fields = ( common_readonly_fields + model_extra_readonly_fields . get ( model_class , []) ) for old_obj in old_objs : created , obj = self . update_fixture_obj ( old_obj = deepcopy ( old_obj ), model_class = model_class , readonly_fields = readonly_fields , do_preserve_sideeffect_fields = do_preserve_sideeffect_fields , object_sideeffect_fields = object_sideeffect_fields , common_sideeffect_fields = common_sideeffect_fields , ) objs . append ( obj ) any_created = created or any_created if not any_created : # nothing created on this pass, no need to continue break else : self . stderr . write ( \"Warning, unexpected behaviour - some fixtures still being created \" \"in second pass?\" ) # Now the fake_id_map should be complete and the objs should be up to date, # save all the fixtures paths = set () for obj in objs : path = self . save_fixture ( obj ) paths . add ( path ) if do_delete_stale_fixtures : for path in tests . FIXTURE_DIR_PATH . glob ( \"*.json\" ): if path in paths : continue else : self . stdout . write ( \"deleting {} \" . format ( path )) path . unlink () tests . apps . example . management . commands . regenerate_test_fixtures . Command . init_fake_id_map ( self ) Build a mapping between fake ids stored in Stripe metadata and those obj's actual ids We do this so we can have fixtures with stable ids for objects Stripe doesn't allow us to specify an id for (eg Card). Fixtures and tests will use the fake ids, when we talk to stripe we use the real ids :return: Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def init_fake_id_map ( self ): \"\"\" Build a mapping between fake ids stored in Stripe metadata and those obj's actual ids We do this so we can have fixtures with stable ids for objects Stripe doesn't allow us to specify an id for (eg Card). Fixtures and tests will use the fake ids, when we talk to stripe we use the real ids :return: \"\"\" for fake_customer in self . fake_data_map [ djstripe . models . Customer ]: try : # can only access Cards via the customer customer = djstripe . models . Customer ( id = fake_customer [ \"id\" ] ) . api_retrieve () except InvalidRequestError : self . stdout . write ( f \"Fake customer { fake_customer [ 'id' ] } doesn't exist in Stripe yet\" ) return # assume that test customers don't have more than 100 cards... for card in customer . sources . list ( limit = 100 ): self . update_fake_id_map ( card ) for payment_method in djstripe . models . PaymentMethod . api_list ( customer = customer . id , type = \"card\" ): self . update_fake_id_map ( payment_method ) for subscription in customer [ \"subscriptions\" ][ \"data\" ]: self . update_fake_id_map ( subscription ) for tax_rate in djstripe . models . TaxRate . api_list (): self . update_fake_id_map ( tax_rate ) tests . apps . example . management . commands . regenerate_test_fixtures . Command . pre_process_subscription ( self , create_obj ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def pre_process_subscription ( self , create_obj ): # flatten plan/items/tax rates on create items = create_obj . get ( \"items\" , {}) . get ( \"data\" , []) if len ( items ): # don't try and create with both plan and item (list of plans) create_obj . pop ( \"plan\" , None ) create_obj . pop ( \"quantity\" , None ) # TODO - move this to SubscriptionItem handling? subscription_item_create_fields = { \"plan\" , \"billing_thresholds\" , \"metadata\" , \"quantity\" , \"tax_rates\" , } create_items = [] for item in items : create_item = { k : v for k , v in item . items () if k in subscription_item_create_fields } create_item [ \"plan\" ] = djstripe . models . StripeModel . _id_from_data ( create_item [ \"plan\" ] ) if create_item . get ( \"tax_rates\" , []): create_item [ \"tax_rates\" ] = [ djstripe . models . StripeModel . _id_from_data ( t ) for t in create_item [ \"tax_rates\" ] ] create_items . append ( create_item ) create_obj [ \"items\" ] = create_items else : # don't try and send empty items list create_obj . pop ( \"items\" , None ) create_obj [ \"plan\" ] = djstripe . models . StripeModel . _id_from_data ( create_obj [ \"plan\" ] ) if create_obj . get ( \"default_tax_rates\" , []): create_obj [ \"default_tax_rates\" ] = [ djstripe . models . StripeModel . _id_from_data ( t ) for t in create_obj [ \"default_tax_rates\" ] ] # don't send both default_tax_rates and tax_percent create_obj . pop ( \"tax_percent\" , None ) return create_obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . preserve_old_sideeffect_values ( self , old_obj , new_obj , object_sideeffect_fields , common_sideeffect_fields ) Try to preserve values of side-effect fields from old_obj, to reduce churn in fixtures Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def preserve_old_sideeffect_values ( self , old_obj , new_obj , object_sideeffect_fields , common_sideeffect_fields ): \"\"\" Try to preserve values of side-effect fields from old_obj, to reduce churn in fixtures \"\"\" object_name = new_obj . get ( \"object\" ) sideeffect_fields = object_sideeffect_fields . get ( object_name , set ()) . union ( set ( common_sideeffect_fields ) ) old_obj = old_obj or {} for f , old_val in old_obj . items (): try : new_val = new_obj [ f ] except KeyError : continue if isinstance ( new_val , stripe . api_resources . ListObject ): # recursively process nested lists for n , ( old_val_item , new_val_item ) in enumerate ( zip ( old_val . get ( \"data\" , []), new_val . data ) ): new_val . data [ n ] = self . preserve_old_sideeffect_values ( old_obj = old_val_item , new_obj = new_val_item , object_sideeffect_fields = object_sideeffect_fields , common_sideeffect_fields = common_sideeffect_fields , ) elif isinstance ( new_val , stripe . stripe_object . StripeObject ): # recursively process nested objects new_obj [ f ] = self . preserve_old_sideeffect_values ( old_obj = old_val , new_obj = new_val , object_sideeffect_fields = object_sideeffect_fields , common_sideeffect_fields = common_sideeffect_fields , ) elif ( f in sideeffect_fields and type ( old_val ) == type ( new_val ) and old_val != new_val ): # only preserve old values if the type is the same new_obj [ f ] = old_val return new_obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . save_fixture ( self , obj ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def save_fixture ( self , obj ): type_name = obj [ \"object\" ] id_ = self . update_fake_id_map ( obj ) fixture_path = tests . FIXTURE_DIR_PATH . joinpath ( f \" { type_name } _ { id_ } .json\" ) with fixture_path . open ( \"w\" ) as f : json_str = self . fake_json_ids ( json . dumps ( obj , indent = 4 )) f . write ( json_str ) return fixture_path tests . apps . example . management . commands . regenerate_test_fixtures . Command . unfake_json_ids ( self , json_str ) Replace fake ids with actual ones in the JSON fixture Do this on the serialized JSON string since it's a simple string replace :param json_str: :return: Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def unfake_json_ids ( self , json_str ): \"\"\" Replace fake ids with actual ones in the JSON fixture Do this on the serialized JSON string since it's a simple string replace :param json_str: :return: \"\"\" for fake_id , actual_id in self . fake_id_map . items (): json_str = json_str . replace ( fake_id , actual_id ) # special-case: undo the replace for the djstripe_test_fake_id in metadata json_str = json_str . replace ( f '\" { FAKE_ID_METADATA_KEY } \": \" { actual_id } \"' , f '\" { FAKE_ID_METADATA_KEY } \": \" { fake_id } \"' , ) return json_str tests . apps . example . management . commands . regenerate_test_fixtures . Command . update_fake_id_map ( self , obj ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def update_fake_id_map ( self , obj ): fake_id = self . get_fake_id ( obj ) actual_id = obj [ \"id\" ] if fake_id : if fake_id in self . fake_id_map : assert self . fake_id_map [ fake_id ] == actual_id , ( f \"Duplicate fake_id { fake_id } - reset your test Stripe data at \" f \"https://dashboard.stripe.com/account/data\" ) self . fake_id_map [ fake_id ] = actual_id return fake_id else : return actual_id tests . apps . example . management . commands . regenerate_test_fixtures . Command . update_fixture_obj ( self , old_obj , model_class , readonly_fields , do_preserve_sideeffect_fields , object_sideeffect_fields , common_sideeffect_fields ) Given a fixture object, update it via stripe :param model_class: :param old_obj: :param readonly_fields: :return: Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def update_fixture_obj ( # noqa: C901 self , old_obj , model_class , readonly_fields , do_preserve_sideeffect_fields , object_sideeffect_fields , common_sideeffect_fields , ): \"\"\" Given a fixture object, update it via stripe :param model_class: :param old_obj: :param readonly_fields: :return: \"\"\" # restore real ids from Stripe old_obj = json . loads ( self . unfake_json_ids ( json . dumps ( old_obj ))) id_ = old_obj [ \"id\" ] self . stdout . write ( f \" { model_class . __name__ } { id_ } \" , ending = \"\" ) # For objects that we can't directly choose the ids of # (and that will thus vary between stripe accounts) # we fetch the id from a related object if issubclass ( model_class , djstripe . models . Account ): created , obj = self . get_or_create_stripe_account ( old_obj = old_obj , readonly_fields = readonly_fields ) elif issubclass ( model_class , djstripe . models . BankAccount ): created , obj = self . get_or_create_stripe_bank_account ( old_obj = old_obj , readonly_fields = readonly_fields ) elif issubclass ( model_class , djstripe . models . Card ): created , obj = self . get_or_create_stripe_card ( old_obj = old_obj , readonly_fields = readonly_fields ) elif issubclass ( model_class , djstripe . models . Source ): created , obj = self . get_or_create_stripe_source ( old_obj = old_obj , readonly_fields = readonly_fields ) elif issubclass ( model_class , djstripe . models . Invoice ): created , obj = self . get_or_create_stripe_invoice ( old_obj = old_obj , writable_fields = [ \"metadata\" ] ) elif issubclass ( model_class , djstripe . models . Charge ): created , obj = self . get_or_create_stripe_charge ( old_obj = old_obj , writable_fields = [ \"metadata\" ] ) elif issubclass ( model_class , djstripe . models . PaymentIntent ): created , obj = self . get_or_create_stripe_payment_intent ( old_obj = old_obj , writable_fields = [ \"metadata\" ] ) elif issubclass ( model_class , djstripe . models . PaymentMethod ): created , obj = self . get_or_create_stripe_payment_method ( old_obj = old_obj , writable_fields = [ \"metadata\" ] ) elif issubclass ( model_class , djstripe . models . BalanceTransaction ): created , obj = self . get_or_create_stripe_balance_transaction ( old_obj = old_obj ) else : try : # fetch from Stripe, using the active API version # this allows us regenerate the fixtures from Stripe # and hopefully, automatically get schema changes obj = model_class ( id = id_ ) . api_retrieve () created = False self . stdout . write ( \" found\" ) except InvalidRequestError : self . stdout . write ( \" creating\" ) create_obj = deepcopy ( old_obj ) # create in Stripe for k in readonly_fields : create_obj . pop ( k , None ) if issubclass ( model_class , djstripe . models . Subscription ): create_obj = self . pre_process_subscription ( create_obj = create_obj ) obj = model_class . _api_create ( ** create_obj ) created = True self . update_fake_id_map ( obj ) if do_preserve_sideeffect_fields : obj = self . preserve_old_sideeffect_values ( old_obj = old_obj , new_obj = obj , object_sideeffect_fields = object_sideeffect_fields , common_sideeffect_fields = common_sideeffect_fields , ) return created , obj tests.apps.example.urls tests . apps . example . urls . app_name tests . apps . example . urls . urlpatterns tests.apps.example.views tests . apps . example . views . User tests . apps . example . views . logger Classes tests.apps.example.views.PurchaseSubscriptionSuccessView tests . apps . example . views . PurchaseSubscriptionSuccessView . context_object_name tests . apps . example . views . PurchaseSubscriptionSuccessView . queryset tests . apps . example . views . PurchaseSubscriptionSuccessView . slug_field tests . apps . example . views . PurchaseSubscriptionSuccessView . slug_url_kwarg tests . apps . example . views . PurchaseSubscriptionSuccessView . template_name tests.apps.example.views.PurchaseSubscriptionView Example view to demonstrate how to use dj-stripe to: create a Customer add a card to the Customer create a Subscription using that card This does a non-logged in purchase for the user of the provided email tests . apps . example . views . PurchaseSubscriptionView . template_name tests.apps.example.views.PurchaseSubscriptionView.form_class tests . apps . example . views . PurchaseSubscriptionView . form_class . media property readonly Methods tests . apps . example . views . PurchaseSubscriptionView . form_valid ( self , form ) If the form is valid, redirect to the supplied URL. Source code in tests/apps/example/views.py def form_valid ( self , form ): stripe_source = form . cleaned_data [ \"stripe_source\" ] email = form . cleaned_data [ \"email\" ] plan = form . cleaned_data [ \"plan\" ] # Guest checkout with the provided email try : user = User . objects . get ( email = email ) except User . DoesNotExist : user = User . objects . create ( username = email , email = email ) # Create the stripe Customer, by default subscriber Model is User, # this can be overridden with settings.DJSTRIPE_SUBSCRIBER_MODEL customer , created = djstripe . models . Customer . get_or_create ( subscriber = user ) # Add the source as the customer's default card customer . add_card ( stripe_source ) # Using the Stripe API, create a subscription for this customer, # using the customer's default payment source stripe_subscription = stripe . Subscription . create ( customer = customer . id , items = [{ \"plan\" : plan . id }], collection_method = \"charge_automatically\" , # tax_percent=15, api_key = djstripe . settings . STRIPE_SECRET_KEY , ) # Sync the Stripe API return data to the database, # this way we don't need to wait for a webhook-triggered sync subscription = djstripe . models . Subscription . sync_from_stripe_data ( stripe_subscription ) self . request . subscription = subscription return super () . form_valid ( form ) tests . apps . example . views . PurchaseSubscriptionView . get_context_data ( self , ** kwargs ) Insert the form into the context dict. Source code in tests/apps/example/views.py def get_context_data ( self , ** kwargs ): ctx = super () . get_context_data ( ** kwargs ) if djstripe . models . Plan . objects . count () == 0 : raise Exception ( \"No Product Plans in the dj-stripe database - create some in your \" \"stripe account and then \" \"run `./manage.py djstripe_sync_plans_from_stripe` \" \"(or use the dj-stripe webhooks)\" ) ctx [ \"STRIPE_PUBLIC_KEY\" ] = djstripe . settings . STRIPE_PUBLIC_KEY return ctx tests . apps . example . views . PurchaseSubscriptionView . get_success_url ( self ) Return the URL to redirect to after processing a valid form. Source code in tests/apps/example/views.py def get_success_url ( self ): return reverse ( \"djstripe_example:purchase_subscription_success\" , kwargs = { \"id\" : self . request . subscription . id }, ) tests . apps . example . views . create_payment_intent ( request ) Source code in tests/apps/example/views.py def create_payment_intent ( request ): if request . method == \"POST\" : intent = None data = json . loads ( request . body ) try : if \"payment_method_id\" in data : # Create the PaymentIntent intent = stripe . PaymentIntent . create ( payment_method = data [ \"payment_method_id\" ], amount = 1099 , currency = \"usd\" , confirmation_method = \"manual\" , confirm = True , api_key = djstripe . settings . STRIPE_SECRET_KEY , ) elif \"payment_intent_id\" in data : intent = stripe . PaymentIntent . confirm ( data [ \"payment_intent_id\" ], api_key = djstripe . settings . STRIPE_SECRET_KEY , ) except stripe . error . CardError as e : # Display error on client return_data = json . dumps ({ \"error\" : e . user_message }), 200 return HttpResponse ( return_data [ 0 ], content_type = \"application/json\" , status = return_data [ 1 ] ) if ( intent . status == \"requires_action\" and intent . next_action . type == \"use_stripe_sdk\" ): # Tell the client to handle the action return_data = ( json . dumps ( { \"requires_action\" : True , \"payment_intent_client_secret\" : intent . client_secret , } ), 200 , ) elif intent . status == \"succeeded\" : # The payment did not need any additional actions and completed! # Handle post-payment fulfillment return_data = json . dumps ({ \"success\" : True }), 200 else : # Invalid status return_data = json . dumps ({ \"error\" : \"Invalid PaymentIntent status\" }), 500 return HttpResponse ( return_data [ 0 ], content_type = \"application/json\" , status = return_data [ 1 ] ) else : ctx = { \"STRIPE_PUBLIC_KEY\" : djstripe . settings . STRIPE_PUBLIC_KEY } return TemplateResponse ( request , \"payment_intent.html\" , ctx ) tests.apps.testapp special Modules tests.apps.testapp.models Classes tests.apps.testapp.models.NoEmailOrganization Model used to test the new custom model setting. tests . apps . testapp . models . NoEmailOrganization . name tests.apps.testapp.models.NoEmailOrganization.DoesNotExist tests.apps.testapp.models.NoEmailOrganization.MultipleObjectsReturned tests.apps.testapp.models.Organization Model used to test the new custom model setting. tests . apps . testapp . models . Organization . email tests.apps.testapp.models.Organization.DoesNotExist tests.apps.testapp.models.Organization.MultipleObjectsReturned tests.apps.testapp.models.StaticEmailOrganization Model used to test the new custom model setting. tests . apps . testapp . models . StaticEmailOrganization . email property readonly tests . apps . testapp . models . StaticEmailOrganization . name tests.apps.testapp.models.StaticEmailOrganization.DoesNotExist tests.apps.testapp.models.StaticEmailOrganization.MultipleObjectsReturned tests.apps.testapp.urls tests . apps . testapp . urls . urlpatterns tests . apps . testapp . urls . empty_view ( request ) Source code in tests/apps/testapp/urls.py def empty_view ( request ): return HttpResponse () tests.apps.testapp_content special Modules tests.apps.testapp_content.models tests.apps.testapp_content.urls Represents protected content tests . apps . testapp_content . urls . urlpatterns tests . apps . testapp_content . urls . testview ( request ) Source code in tests/apps/testapp_content/urls.py def testview ( request ): return HttpResponse () tests.apps.testapp_namespaced special tests.apps.testapp_namespaced.models tests.apps.testapp_namespaced.urls tests . apps . testapp_namespaced . urls . app_name tests . apps . testapp_namespaced . urls . urlpatterns tests . apps . testapp_namespaced . urls . testview ( request ) Source code in tests/apps/testapp_namespaced/urls.py def testview ( request ): return HttpResponse () tests.settings tests . settings . ALLOWED_HOSTS tests . settings . BASE_DIR tests . settings . DEBUG tests . settings . DEFAULT_AUTO_FIELD tests . settings . DJSTRIPE_FOREIGN_KEY_TO_FIELD tests . settings . DJSTRIPE_SUBSCRIPTION_REDIRECT tests . settings . DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS tests . settings . DJSTRIPE_USE_NATIVE_JSONFIELD tests . settings . DJSTRIPE_WEBHOOK_SECRET tests . settings . DJSTRIPE_WEBHOOK_VALIDATION tests . settings . INSTALLED_APPS tests . settings . MIDDLEWARE tests . settings . PROJECT_DIR tests . settings . ROOT_URLCONF tests . settings . SECRET_KEY tests . settings . SITE_ID tests . settings . STATIC_URL tests . settings . STRIPE_LIVE_PUBLIC_KEY tests . settings . STRIPE_LIVE_SECRET_KEY tests . settings . STRIPE_TEST_PUBLIC_KEY tests . settings . STRIPE_TEST_SECRET_KEY tests . settings . TEMPLATES tests . settings . TIME_ZONE tests . settings . USE_TZ tests . settings . test_db_name tests . settings . test_db_pass tests . settings . test_db_port tests . settings . test_db_user tests . settings . test_db_vendor tests.test_account dj-stripe Account Tests. Classes tests.test_account.TestAccount tests . test_account . TestAccount . test_get_connected_account_from_token ( self , fileupload_retrieve_mock , account_retrieve_mock ) Source code in tests/test_account.py @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.FileUpload.retrieve\" , side_effect = [ deepcopy ( FAKE_FILEUPLOAD_ICON ), deepcopy ( FAKE_FILEUPLOAD_LOGO )], autospec = True , ) def test_get_connected_account_from_token ( self , fileupload_retrieve_mock , account_retrieve_mock ): account_retrieve_mock . return_value = deepcopy ( FAKE_ACCOUNT ) account = Account . get_connected_account_from_token ( \"fake_token\" ) account_retrieve_mock . assert_called_once_with ( api_key = \"fake_token\" ) self . assert_fks ( account , expected_blank_fks = {}) tests . test_account . TestAccount . test_get_default_account ( self , fileupload_retrieve_mock , account_retrieve_mock ) Source code in tests/test_account.py @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.FileUpload.retrieve\" , side_effect = [ deepcopy ( FAKE_FILEUPLOAD_ICON ), deepcopy ( FAKE_FILEUPLOAD_LOGO )], autospec = True , ) def test_get_default_account ( self , fileupload_retrieve_mock , account_retrieve_mock ): account_retrieve_mock . return_value = deepcopy ( FAKE_ACCOUNT ) account = Account . get_default_account () account_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY ) self . assertGreater ( len ( account . business_profile ), 0 ) self . assertGreater ( len ( account . settings ), 0 ) self . assertEqual ( account . branding_icon . id , FAKE_FILEUPLOAD_ICON [ \"id\" ]) self . assertEqual ( account . branding_logo . id , FAKE_FILEUPLOAD_LOGO [ \"id\" ]) self . assertEqual ( account . settings [ \"branding\" ][ \"icon\" ], account . branding_icon . id ) self . assertEqual ( account . settings [ \"branding\" ][ \"logo\" ], account . branding_logo . id ) self . assertNotEqual ( account . branding_logo . id , account . branding_icon . id ) self . assert_fks ( account , expected_blank_fks = {}) self . assertEqual ( account . business_url , \"https://example.com\" ) account . business_profile = None self . assertEqual ( account . business_url , \"\" ) tests . test_account . TestAccount . test_get_default_account_null_logo ( self , fileupload_retrieve_mock , account_retrieve_mock ) Source code in tests/test_account.py @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.FileUpload.retrieve\" , return_value = deepcopy ( FAKE_FILEUPLOAD_LOGO ), autospec = True , ) def test_get_default_account_null_logo ( self , fileupload_retrieve_mock , account_retrieve_mock ): fake_account = deepcopy ( FAKE_ACCOUNT ) fake_account [ \"settings\" ][ \"branding\" ][ \"icon\" ] = None fake_account [ \"settings\" ][ \"branding\" ][ \"logo\" ] = None account_retrieve_mock . return_value = fake_account account = Account . get_default_account () account_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY ) self . assert_fks ( account , expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , }, ) tests.test_account.TestAccountRestrictedKeys Methods tests . test_account . TestAccountRestrictedKeys . tearDown ( self ) Hook method for deconstructing the test fixture after testing it. Source code in tests/test_account.py def tearDown ( self ): reload ( djstripe_settings ) tests . test_account . TestAccountRestrictedKeys . test_account_str_restricted_key ( self , account_retrieve_mock ) Test that we do not attempt to retrieve account ID with restricted keys. Source code in tests/test_account.py @override_settings ( STRIPE_TEST_SECRET_KEY = \"rk_test_blah\" , STRIPE_TEST_PUBLIC_KEY = \"pk_test_foo\" , STRIPE_LIVE_MODE = False , ) @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) def test_account_str_restricted_key ( self , account_retrieve_mock ): \"\"\" Test that we do not attempt to retrieve account ID with restricted keys. \"\"\" reload ( djstripe_settings ) assert djstripe_settings . STRIPE_SECRET_KEY == \"rk_test_blah\" account = Account . get_default_account () assert account is None account_retrieve_mock . assert_not_called () Functions tests . test_account . test__str__null_settings_null_business_profile () Test that str doesn't crash when settings and business_profile are NULL. Source code in tests/test_account.py def test__str__null_settings_null_business_profile (): \"\"\"Test that __str__ doesn't crash when settings and business_profile are NULL.\"\"\" account = Account () account . settings = None account . business_profile = None assert str ( account ) == \"<id=>\" tests . test_account . test_account__create_from_stripe_object ( mock_super__create_from_stripe_object , mock_account_id , other_mock_account_id , expected_stripe_account ) Ensure that we are setting the ID value correctly. Source code in tests/test_account.py @pytest . mark . parametrize ( \"mock_account_id, other_mock_account_id, expected_stripe_account\" , ( ( \"acct_fakefakefakefake001\" , None , \"acct_fakefakefakefake001\" ), ( \"acct_fakefakefakefake001\" , \"acct_fakefakefakefake002\" , \"acct_fakefakefakefake002\" , ), ), ) @patch ( target = \"djstripe.models.connect.StripeModel._create_from_stripe_object\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_account__create_from_stripe_object ( mock_super__create_from_stripe_object , mock_account_id , other_mock_account_id , expected_stripe_account , ): \"\"\"Ensure that we are setting the ID value correctly.\"\"\" mock_data = { \"id\" : mock_account_id } Account . _create_from_stripe_object ( data = mock_data , stripe_account = other_mock_account_id ) mock_super__create_from_stripe_object . assert_called_once_with ( data = mock_data , current_ids = None , pending_relations = None , save = True , stripe_account = expected_stripe_account , ) tests . test_account . test_account_str ( fileupload_retrieve_mock , account_retrieve_mock , business_profile_update , settings_dashboard_update , expected_account_str ) Source code in tests/test_account.py @pytest . mark . django_db @pytest . mark . parametrize ( ( \"business_profile_update\" , \"settings_dashboard_update\" , \"expected_account_str\" ), ( ({}, {}, \"dj-stripe\" ), ({}, { \"display_name\" : \"some display name\" }, \"some display name\" ), ({ \"name\" : \"some business name\" }, { \"display_name\" : \"\" }, \"some business name\" ), ({ \"name\" : \"\" }, { \"display_name\" : \"\" }, \"<id=acct_1032D82eZvKYlo2C>\" ), ), ) @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.FileUpload.retrieve\" , return_value = deepcopy ( FAKE_FILEUPLOAD_LOGO ), autospec = True , ) def test_account_str ( fileupload_retrieve_mock , account_retrieve_mock , business_profile_update , settings_dashboard_update , expected_account_str , ): fake_account = deepcopy ( FAKE_ACCOUNT ) fake_account [ \"business_profile\" ] . update ( business_profile_update ) fake_account [ \"settings\" ][ \"dashboard\" ] . update ( settings_dashboard_update ) account_retrieve_mock . return_value = fake_account account = Account . get_default_account () assert str ( account ) == expected_account_str tests.test_admin dj-stripe Admin Tests. Classes tests.test_admin.TestAdminSite Methods tests . test_admin . TestAdminSite . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_admin.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) tests . test_admin . TestAdminSite . test_search_fields ( self ) Search for errors like this: Bad search field for Customer model. Source code in tests/test_admin.py def test_search_fields ( self ): \"\"\" Search for errors like this: Bad search field <customer__user__username> for Customer model. \"\"\" for _model , model_admin in admin . site . _registry . items (): for search_field in getattr ( model_admin , \"search_fields\" , []): model_name = model_admin . model . __name__ self . assertFalse ( search_field . startswith ( \" {table_name} __\" . format ( table_name = model_name . lower ()) ), \"Bad search field < {search_field} > for {model_name} model.\" . format ( search_field = search_field , model_name = model_name ), ) tests.test_api_keys Classes tests.test_api_keys.TestCheckApiKeySettings Methods tests . test_api_keys . TestCheckApiKeySettings . tearDown ( self ) Hook method for deconstructing the test fixture after testing it. Source code in tests/test_api_keys.py def tearDown ( self ): reload ( djstripe_settings ) tests . test_api_keys . TestCheckApiKeySettings . test_api_key_live_mode ( self ) Source code in tests/test_api_keys.py @override_settings ( STRIPE_TEST_SECRET_KEY = \"sk_test_foo\" , STRIPE_LIVE_SECRET_KEY = \"sk_live_foo\" , STRIPE_TEST_PUBLIC_KEY = \"pk_test_foo\" , STRIPE_LIVE_PUBLIC_KEY = \"pk_live_foo\" , STRIPE_LIVE_MODE = True , ) def test_api_key_live_mode ( self ): del settings . STRIPE_SECRET_KEY , settings . STRIPE_TEST_SECRET_KEY del settings . STRIPE_PUBLIC_KEY , settings . STRIPE_TEST_PUBLIC_KEY reload ( djstripe_settings ) self . assertEqual ( djstripe_settings . STRIPE_LIVE_MODE , True ) self . assertEqual ( djstripe_settings . STRIPE_SECRET_KEY , \"sk_live_foo\" ) self . assertEqual ( djstripe_settings . STRIPE_PUBLIC_KEY , \"pk_live_foo\" ) self . assertEqual ( djstripe_settings . LIVE_API_KEY , \"sk_live_foo\" ) self . assertEqual ( models . Account ( livemode = True ) . default_api_key , \"sk_live_foo\" ) tests . test_api_keys . TestCheckApiKeySettings . test_global_api_keys_live_mode ( self ) Source code in tests/test_api_keys.py @override_settings ( STRIPE_LIVE_SECRET_KEY = \"sk_live_foo\" , STRIPE_LIVE_PUBLIC_KEY = \"sk_live_foo\" , STRIPE_LIVE_MODE = True , ) def test_global_api_keys_live_mode ( self ): reload ( djstripe_settings ) self . assertEqual ( djstripe_settings . STRIPE_LIVE_MODE , True ) self . assertEqual ( djstripe_settings . STRIPE_SECRET_KEY , \"sk_live_foo\" ) self . assertEqual ( djstripe_settings . LIVE_API_KEY , \"sk_live_foo\" ) self . assertEqual ( models . Account ( livemode = True ) . default_api_key , \"sk_live_foo\" ) tests . test_api_keys . TestCheckApiKeySettings . test_global_api_keys_test_mode ( self ) Source code in tests/test_api_keys.py @override_settings ( STRIPE_TEST_SECRET_KEY = \"sk_test_foo\" , STRIPE_TEST_PUBLIC_KEY = \"pk_test_foo\" , STRIPE_LIVE_MODE = False , ) def test_global_api_keys_test_mode ( self ): reload ( djstripe_settings ) self . assertEqual ( djstripe_settings . STRIPE_LIVE_MODE , False ) self . assertEqual ( djstripe_settings . STRIPE_SECRET_KEY , \"sk_test_foo\" ) self . assertEqual ( djstripe_settings . TEST_API_KEY , \"sk_test_foo\" ) self . assertEqual ( models . Account ( livemode = False ) . default_api_key , \"sk_test_foo\" ) tests . test_api_keys . TestCheckApiKeySettings . test_secret_key_test_mode ( self ) Source code in tests/test_api_keys.py @override_settings ( STRIPE_TEST_SECRET_KEY = \"sk_test_foo\" , STRIPE_LIVE_SECRET_KEY = \"sk_live_foo\" , STRIPE_TEST_PUBLIC_KEY = \"pk_test_foo\" , STRIPE_LIVE_PUBLIC_KEY = \"pk_live_foo\" , STRIPE_LIVE_MODE = False , ) def test_secret_key_test_mode ( self ): del settings . STRIPE_SECRET_KEY del settings . STRIPE_PUBLIC_KEY reload ( djstripe_settings ) self . assertEqual ( djstripe_settings . STRIPE_LIVE_MODE , False ) self . assertEqual ( djstripe_settings . STRIPE_SECRET_KEY , \"sk_test_foo\" ) self . assertEqual ( djstripe_settings . STRIPE_PUBLIC_KEY , \"pk_test_foo\" ) self . assertEqual ( djstripe_settings . TEST_API_KEY , \"sk_test_foo\" ) self . assertEqual ( models . Account ( livemode = False ) . default_api_key , \"sk_test_foo\" ) tests.test_apikey dj-stripe APIKey model tests tests . test_apikey . PK_LIVE tests . test_apikey . PK_TEST tests . test_apikey . RK_LIVE tests . test_apikey . RK_TEST tests . test_apikey . SK_LIVE tests . test_apikey . SK_TEST Classes tests.test_apikey.APIKeyTest Methods tests . test_apikey . APIKeyTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_apikey.py def setUp ( self ): self . account = default_account () self . apikey_test = APIKey . objects . create ( type = APIKeyType . secret , name = \"Test Secret Key\" , secret = SK_TEST , livemode = False , djstripe_owner_account = self . account , ) self . apikey_live = APIKey . objects . create ( type = APIKeyType . secret , name = \"Live Secret Key\" , secret = SK_LIVE , livemode = True , djstripe_owner_account = self . account , ) tests . test_apikey . APIKeyTest . test_get_account_by_api_key ( self ) Source code in tests/test_apikey.py def test_get_account_by_api_key ( self ): account = Account . get_or_retrieve_for_api_key ( self . apikey_test . secret ) assert account == self . account tests . test_apikey . APIKeyTest . test_get_stripe_dashboard_url ( self ) Source code in tests/test_apikey.py def test_get_stripe_dashboard_url ( self ): self . assertEqual ( self . apikey_test . get_stripe_dashboard_url (), \"https://dashboard.stripe.com/acct_TESTXXXXX/test/apikeys\" , ) self . assertEqual ( self . apikey_live . get_stripe_dashboard_url (), \"https://dashboard.stripe.com/acct_TESTXXXXX/apikeys\" , ) tests . test_apikey . APIKeyTest . test_refresh_account ( self , fileupload_retrieve_mock , account_retrieve_mock ) Source code in tests/test_apikey.py @patch ( \"stripe.Account.retrieve\" , return_value = deepcopy ( FAKE_ACCOUNT ), ) @patch ( \"stripe.FileUpload.retrieve\" , return_value = deepcopy ( FAKE_FILEUPLOAD_ICON )) def test_refresh_account ( self , fileupload_retrieve_mock , account_retrieve_mock ): self . apikey_test . djstripe_owner_account = None self . apikey_test . save () self . apikey_test . clean () assert self . apikey_test . djstripe_owner_account . id == FAKE_ACCOUNT [ \"id\" ] tests . test_apikey . APIKeyTest . test_secret_not_in_str ( self ) Source code in tests/test_apikey.py def test_secret_not_in_str ( self ): assert self . apikey_test . secret not in str ( self . apikey_test ) assert self . apikey_live . secret not in str ( self . apikey_live ) tests . test_apikey . APIKeyTest . test_secret_redacted ( self ) Source code in tests/test_apikey.py def test_secret_redacted ( self ): self . assertEqual ( self . apikey_test . secret_redacted , \"sk_test_...1234\" ) self . assertEqual ( self . apikey_live . secret_redacted , \"sk_live_...5678\" ) tests . test_apikey . test_apikey_detect_livemode_and_type ( fileupload_retrieve_mock , account_retrieve_mock ) Source code in tests/test_apikey.py @pytest . mark . django_db @patch ( \"stripe.Account.retrieve\" , return_value = deepcopy ( FAKE_ACCOUNT )) @patch ( \"stripe.FileUpload.retrieve\" , return_value = deepcopy ( FAKE_FILEUPLOAD_ICON )) def test_apikey_detect_livemode_and_type ( fileupload_retrieve_mock , account_retrieve_mock ): keys_and_values = ( ( PK_TEST , False , APIKeyType . publishable ), ( RK_TEST , False , APIKeyType . restricted ), ( SK_TEST , False , APIKeyType . secret ), ( PK_LIVE , True , APIKeyType . publishable ), ( RK_LIVE , True , APIKeyType . restricted ), ( SK_LIVE , True , APIKeyType . secret ), ) for secret , livemode , type in keys_and_values : key = APIKey . objects . create ( secret = secret ) assert key . livemode is livemode assert key . type is type key . clean () assert key . livemode is livemode assert key . type is type tests . test_apikey . test_clean_public_apikey () Source code in tests/test_apikey.py def test_clean_public_apikey (): key = APIKey ( type = APIKeyType . publishable , livemode = False , secret = PK_TEST ) assert not key . djstripe_owner_account key . clean () assert not key . djstripe_owner_account tests . test_apikey . test_get_api_key_details_by_prefix () Source code in tests/test_apikey.py def test_get_api_key_details_by_prefix (): assert get_api_key_details_by_prefix ( SK_TEST ) == ( APIKeyType . secret , False ) assert get_api_key_details_by_prefix ( SK_LIVE ) == ( APIKeyType . secret , True ) assert get_api_key_details_by_prefix ( RK_TEST ) == ( APIKeyType . restricted , False ) assert get_api_key_details_by_prefix ( RK_LIVE ) == ( APIKeyType . restricted , True ) assert get_api_key_details_by_prefix ( PK_TEST ) == ( APIKeyType . publishable , False ) assert get_api_key_details_by_prefix ( PK_LIVE ) == ( APIKeyType . publishable , True ) tests . test_apikey . test_get_api_key_details_by_prefix_bad_values () Source code in tests/test_apikey.py def test_get_api_key_details_by_prefix_bad_values (): with pytest . raises ( ValueError ): get_api_key_details_by_prefix ( \"pk_a\" ) with pytest . raises ( ValueError ): get_api_key_details_by_prefix ( \"sk_a\" ) with pytest . raises ( ValueError ): get_api_key_details_by_prefix ( \"rk_nope_1234\" ) tests.test_bank_account dj-stripe Bank Account Model Tests. Classes tests.test_bank_account.BankAccountTest Methods tests . test_bank_account . BankAccountTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_bank_account.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"testuser\" , email = \"djstripe@example.com\" ) fake_empty_customer = deepcopy ( FAKE_CUSTOMER_IV ) fake_empty_customer [ \"default_source\" ] = None fake_empty_customer [ \"sources\" ] = [] self . customer = fake_empty_customer . create_for_user ( self . user ) tests . test_bank_account . BankAccountTest . test_api_call_bad_customer ( self ) Source code in tests/test_bank_account.py def test_api_call_bad_customer ( self ): exception_message = ( \"BankAccounts must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): BankAccount . _api_create ( customer = \"fish\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): BankAccount . api_list ( customer = \"fish\" ) tests . test_bank_account . BankAccountTest . test_api_call_no_customer ( self ) Source code in tests/test_bank_account.py def test_api_call_no_customer ( self ): exception_message = ( \"BankAccounts must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): BankAccount . _api_create () with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): BankAccount . api_list () tests . test_bank_account . BankAccountTest . test_api_create ( self , customer_retrieve_mock ) Source code in tests/test_bank_account.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_IV ), autospec = True , ) def test_api_create ( self , customer_retrieve_mock ): stripe_bank_account = BankAccount . _api_create ( customer = self . customer , source = FAKE_BANK_ACCOUNT_SOURCE [ \"id\" ] ) self . assertEqual ( FAKE_BANK_ACCOUNT_SOURCE , stripe_bank_account ) tests . test_bank_account . BankAccountTest . test_api_list ( self , customer_retrieve_mock ) Source code in tests/test_bank_account.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_IV ), autospec = True , ) def test_api_list ( self , customer_retrieve_mock ): bank_account_list = BankAccount . api_list ( customer = self . customer ) self . assertEqual ([ FAKE_BANK_ACCOUNT_SOURCE ], [ i for i in bank_account_list ]) tests . test_bank_account . BankAccountTest . test_create_bank_account_finds_customer ( self ) Source code in tests/test_bank_account.py def test_create_bank_account_finds_customer ( self ): bank_account = BankAccount . sync_from_stripe_data ( deepcopy ( FAKE_BANK_ACCOUNT_SOURCE ) ) self . assertEqual ( self . customer , bank_account . customer ) self . assertEqual ( bank_account . get_stripe_dashboard_url (), self . customer . get_stripe_dashboard_url (), ) self . assert_fks ( bank_account , expected_blank_fks = { \"djstripe.BankAccount.account\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , \"djstripe.Customer.coupon\" , }, ) tests . test_bank_account . BankAccountTest . test_remove ( self , customer_retrieve_mock , bank_account_retrieve_mock , bank_account_delete_mock ) Source code in tests/test_bank_account.py @patch ( \"tests.BankAccountDict.delete\" , autospec = True ) @patch ( \"stripe.BankAccount.retrieve\" , return_value = deepcopy ( FAKE_BANK_ACCOUNT_SOURCE ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_IV ), autospec = True , ) def test_remove ( self , customer_retrieve_mock , bank_account_retrieve_mock , bank_account_delete_mock , ): stripe_bank_account = BankAccount . _api_create ( customer = self . customer , source = FAKE_BANK_ACCOUNT_SOURCE [ \"id\" ] ) BankAccount . sync_from_stripe_data ( stripe_bank_account ) self . assertEqual ( 1 , self . customer . bank_account . count ()) bank_account = self . customer . bank_account . all ()[ 0 ] bank_account . remove () self . assertEqual ( 0 , self . customer . bank_account . count ()) self . assertTrue ( bank_account_delete_mock . called ) tests . test_bank_account . BankAccountTest . test_remove_already_deleted_card ( self , customer_retrieve_mock ) Source code in tests/test_bank_account.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_IV ), autospec = True , ) def test_remove_already_deleted_card ( self , customer_retrieve_mock ): stripe_bank_account = BankAccount . _api_create ( customer = self . customer , source = FAKE_BANK_ACCOUNT_SOURCE [ \"id\" ] ) BankAccount . sync_from_stripe_data ( stripe_bank_account ) self . assertEqual ( self . customer . bank_account . count (), 1 ) bank_account_object = self . customer . bank_account . first () BankAccount . objects . filter ( id = stripe_bank_account [ \"id\" ]) . delete () self . assertEqual ( self . customer . bank_account . count (), 0 ) bank_account_object . remove () self . assertEqual ( self . customer . bank_account . count (), 0 ) tests.test_card dj-stripe Card Model Tests. Classes tests.test_card.CardTest Methods tests . test_card . CardTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_card.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"testuser\" , email = \"djstripe@example.com\" ) fake_empty_customer = deepcopy ( FAKE_CUSTOMER ) fake_empty_customer [ \"default_source\" ] = None fake_empty_customer [ \"sources\" ] = [] self . customer = fake_empty_customer . create_for_user ( self . user ) tests . test_card . CardTest . test_api_call_bad_customer ( self ) Source code in tests/test_card.py def test_api_call_bad_customer ( self ): exception_message = ( \"Cards must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): Card . _api_create ( customer = \"fish\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): Card . api_list ( customer = \"fish\" ) tests . test_card . CardTest . test_api_call_no_customer ( self ) Source code in tests/test_card.py def test_api_call_no_customer ( self ): exception_message = ( \"Cards must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): Card . _api_create () with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): Card . api_list () tests . test_card . CardTest . test_api_create ( self , customer_retrieve_mock ) Source code in tests/test_card.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_api_create ( self , customer_retrieve_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) self . assertEqual ( FAKE_CARD , stripe_card ) tests . test_card . CardTest . test_api_list ( self , customer_retrieve_mock ) Source code in tests/test_card.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_api_list ( self , customer_retrieve_mock ): card_list = Card . api_list ( customer = self . customer ) self . assertEqual ([ FAKE_CARD , FAKE_CARD_V ], [ i for i in card_list ]) tests . test_card . CardTest . test_attach_objects_hook_without_customer ( self ) Source code in tests/test_card.py def test_attach_objects_hook_without_customer ( self ): card = Card . sync_from_stripe_data ( deepcopy ( FAKE_CARD_III )) self . assertEqual ( card . customer , None ) tests . test_card . CardTest . test_card_create_token ( self , token_create_mock ) Source code in tests/test_card.py @patch ( \"stripe.Token.create\" , autospec = True ) def test_card_create_token ( self , token_create_mock ): card = { \"number\" : \"4242\" , \"exp_month\" : 5 , \"exp_year\" : 2012 , \"cvc\" : 445 } Card . create_token ( ** card ) token_create_mock . assert_called_with ( api_key = ANY , card = card ) tests . test_card . CardTest . test_create_card_finds_customer ( self ) Source code in tests/test_card.py def test_create_card_finds_customer ( self ): card = Card . sync_from_stripe_data ( deepcopy ( FAKE_CARD )) self . assertEqual ( self . customer , card . customer ) self . assertEqual ( card . get_stripe_dashboard_url (), self . customer . get_stripe_dashboard_url () ) self . assert_fks ( card , expected_blank_fks = { \"djstripe.BankAccount.account\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , }, ) tests . test_card . CardTest . test_remove ( self , customer_retrieve_mock , card_retrieve_mock , card_delete_mock ) Source code in tests/test_card.py @patch ( \"tests.CardDict.delete\" , autospec = True ) @patch ( \"stripe.Card.retrieve\" , return_value = deepcopy ( FAKE_CARD ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_remove ( self , customer_retrieve_mock , card_retrieve_mock , card_delete_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) Card . sync_from_stripe_data ( stripe_card ) self . assertEqual ( 1 , self . customer . legacy_cards . count ()) card = self . customer . legacy_cards . all ()[ 0 ] card . remove () self . assertEqual ( 0 , self . customer . legacy_cards . count ()) self . assertTrue ( card_delete_mock . called ) tests . test_card . CardTest . test_remove_already_deleted_card ( self , customer_retrieve_mock ) Source code in tests/test_card.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_remove_already_deleted_card ( self , customer_retrieve_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) Card . sync_from_stripe_data ( stripe_card ) self . assertEqual ( self . customer . legacy_cards . count (), 1 ) card_object = self . customer . legacy_cards . first () Card . objects . filter ( id = stripe_card [ \"id\" ]) . delete () self . assertEqual ( self . customer . legacy_cards . count (), 0 ) card_object . remove () self . assertEqual ( self . customer . legacy_cards . count (), 0 ) tests . test_card . CardTest . test_remove_no_such_customer ( self , customer_retrieve_mock , card_delete_mock ) Source code in tests/test_card.py @patch ( \"djstripe.models.Card._api_delete\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_remove_no_such_customer ( self , customer_retrieve_mock , card_delete_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) Card . sync_from_stripe_data ( stripe_card ) card_delete_mock . side_effect = InvalidRequestError ( \"No such customer:\" , \"blah\" ) self . assertEqual ( 1 , self . customer . legacy_cards . count ()) card = self . customer . legacy_cards . all ()[ 0 ] card . remove () self . assertEqual ( 0 , self . customer . legacy_cards . count ()) self . assertTrue ( card_delete_mock . called ) tests . test_card . CardTest . test_remove_no_such_source ( self , customer_retrieve_mock , card_delete_mock ) Source code in tests/test_card.py @patch ( \"djstripe.models.Card._api_delete\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_remove_no_such_source ( self , customer_retrieve_mock , card_delete_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) Card . sync_from_stripe_data ( stripe_card ) card_delete_mock . side_effect = InvalidRequestError ( \"No such source:\" , \"blah\" ) self . assertEqual ( 1 , self . customer . legacy_cards . count ()) card = self . customer . legacy_cards . all ()[ 0 ] card . remove () self . assertEqual ( 0 , self . customer . legacy_cards . count ()) self . assertTrue ( card_delete_mock . called ) tests . test_card . CardTest . test_remove_unexpected_exception ( self , customer_retrieve_mock , card_delete_mock ) Source code in tests/test_card.py @patch ( \"djstripe.models.Card._api_delete\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_remove_unexpected_exception ( self , customer_retrieve_mock , card_delete_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) Card . sync_from_stripe_data ( stripe_card ) card_delete_mock . side_effect = InvalidRequestError ( \"Unexpected Exception\" , \"blah\" ) self . assertEqual ( 1 , self . customer . legacy_cards . count ()) card = self . customer . legacy_cards . all ()[ 0 ] with self . assertRaisesMessage ( InvalidRequestError , \"Unexpected Exception\" ): card . remove () tests . test_card . CardTest . test_str ( self ) Source code in tests/test_card.py def test_str ( self ): fake_card = deepcopy ( FAKE_CARD ) card = Card . sync_from_stripe_data ( fake_card ) self . assertEqual ( \"<brand= {brand} , last4= {last4} , exp_month= {exp_month} , \" \"exp_year= {exp_year} , id= {id} >\" . format ( brand = fake_card [ \"brand\" ], last4 = fake_card [ \"last4\" ], exp_month = fake_card [ \"exp_month\" ], exp_year = fake_card [ \"exp_year\" ], id = fake_card [ \"id\" ], ), str ( card ), ) self . assert_fks ( card , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , }, ) tests.test_charge dj-stripe Charge Model Tests. Classes tests.test_charge.ChargeTest Methods tests . test_charge . ChargeTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_charge.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"user\" , email = \"user@example.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . account = default_account () self . default_expected_blank_fks = { \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Invoice.default_payment_method\" , \"djstripe.Invoice.default_source\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , \"djstripe.Subscription.default_payment_method\" , \"djstripe.Subscription.default_source\" , \"djstripe.Subscription.pending_setup_intent\" , \"djstripe.Subscription.schedule\" , } tests . test_charge . ChargeTest . test__attach_objects_hook_missing_source_data ( self , mock_account , mock_payment_method , mock_charge_account , mock_charge_source ) Make sure we handle the case where the source data is empty or insufficient. Source code in tests/test_charge.py @patch . object ( target = Charge , attribute = \"source\" , autospec = True ) @patch . object ( target = Charge , attribute = \"account\" , autospec = True ) @patch ( target = \"djstripe.models.payment_methods.DjstripePaymentMethod\" , autospec = True ) @patch ( target = \"djstripe.models.account.Account\" , autospec = True ) def test__attach_objects_hook_missing_source_data ( self , mock_account , mock_payment_method , mock_charge_account , mock_charge_source ): \"\"\" Make sure we handle the case where the source data is empty or insufficient. \"\"\" charge = Charge ( amount = 50 , currency = \"usd\" , id = \"ch_test\" , status = ChargeStatus . failed , captured = False , paid = False , ) mock_cls = create_autospec ( spec = Charge , spec_set = True ) # Empty data dict works for this test since we only look up the source key and # everything else is mocked. mock_data = {} starting_source = charge . source charge . _attach_objects_hook ( cls = mock_cls , data = mock_data ) # source shouldn't be touched self . assertEqual ( starting_source , charge . source ) mock_payment_method . _get_or_create_source . assert_not_called () # try again with a source key, but no object sub key. mock_data = { \"source\" : { \"foo\" : \"bar\" }} charge . _attach_objects_hook ( cls = mock_cls , data = mock_data ) # source shouldn't be touched self . assertEqual ( starting_source , charge . source ) mock_payment_method . _get_or_create_source . assert_not_called () tests . test_charge . ChargeTest . test_capture_charge ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , balance_transaction_retrieve_mock , charge_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_capture_charge ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , balance_transaction_retrieve_mock , charge_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_no_invoice = deepcopy ( FAKE_CHARGE ) fake_charge_no_invoice . update ({ \"invoice\" : None }) charge_retrieve_mock . return_value = fake_charge_no_invoice # TODO - I think this is needed in line with above? fake_payment_intent_no_invoice = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent_no_invoice . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent_no_invoice charge , created = Charge . _get_or_create_from_stripe_object ( fake_charge_no_invoice ) self . assertTrue ( created ) captured_charge = charge . capture () self . assertTrue ( captured_charge . captured ) self . assertFalse ( captured_charge . fraudulent ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.Plan.product\" , }, ) tests . test_charge . ChargeTest . test_max_size_large_charge_on_decimal_amount ( self , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) By contacting stripe support, some accounts will have their limit raised to 11 digits Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED and IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_max_size_large_charge_on_decimal_amount ( self , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): \"\"\" By contacting stripe support, some accounts will have their limit raised to 11 digits \"\"\" amount = 99999999999 assert len ( str ( amount )) == 11 fake_transaction = deepcopy ( FAKE_BALANCE_TRANSACTION ) fake_transaction . update ({ \"amount\" : amount }) default_account_mock . return_value = self . account balance_transaction_retrieve_mock . return_value = fake_transaction fake_charge = deepcopy ( FAKE_CHARGE ) fake_charge . update ({ \"amount\" : amount }) charge = Charge . sync_from_stripe_data ( fake_charge ) charge_retrieve_mock . assert_not_called () self . assertTrue ( bool ( charge . pk )) self . assertEqual ( charge . amount , Decimal ( \"999999999.99\" )) self . assertEqual ( charge . balance_transaction . amount , 99999999999 ) tests . test_charge . ChargeTest . test_str ( self ) Source code in tests/test_charge.py def test_str ( self ): charge = Charge ( amount = 50 , currency = \"usd\" , id = \"ch_test\" , status = ChargeStatus . failed , captured = False , paid = False , ) self . assertEqual ( str ( charge ), \"$50.00 USD (Uncaptured)\" ) charge . captured = True self . assertEqual ( str ( charge ), \"$50.00 USD (Failed)\" ) charge . status = ChargeStatus . succeeded charge . disputed = True self . assertEqual ( str ( charge ), \"$50.00 USD (Disputed)\" ) charge . disputed = False charge . refunded = True charge . amount_refunded = 50 self . assertEqual ( str ( charge ), \"$50.00 USD (Refunded)\" ) charge . refunded = False self . assertEqual ( str ( charge ), \"$50.00 USD (Partially refunded)\" ) charge . amount_refunded = 0 self . assertEqual ( str ( charge ), \"$50.00 USD\" ) tests . test_charge . ChargeTest . test_sync_from_stripe_data ( self , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED and IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_sync_from_stripe_data ( self , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) charge = Charge . sync_from_stripe_data ( fake_charge_copy ) self . assertEqual ( Decimal ( \"20\" ), charge . amount ) self . assertEqual ( True , charge . paid ) self . assertEqual ( False , charge . refunded ) self . assertEqual ( True , charge . captured ) self . assertEqual ( False , charge . disputed ) self . assertEqual ( \"Subscription creation\" , charge . description ) self . assertEqual ( 0 , charge . amount_refunded ) self . assertEqual ( self . customer . default_source . id , charge . source_id ) self . assertEqual ( charge . source . type , LegacySourceType . card ) self . assertGreater ( len ( charge . receipt_url ), 1 ) self . assertTrue ( charge . payment_method_details [ \"type\" ]) charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_max_amount ( self , default_account_mock , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock ) Source code in tests/test_charge.py @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_sync_from_stripe_data_max_amount ( self , default_account_mock , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) # https://support.stripe.com/questions/what-is-the-maximum-amount-i-can-charge-with-stripe fake_charge_copy . update ({ \"amount\" : 99999999 }) charge = Charge . sync_from_stripe_data ( fake_charge_copy ) self . assertEqual ( Decimal ( \"999999.99\" ), charge . amount ) self . assertEqual ( True , charge . paid ) self . assertEqual ( False , charge . refunded ) self . assertEqual ( True , charge . captured ) self . assertEqual ( False , charge . disputed ) self . assertEqual ( 0 , charge . amount_refunded ) charge_retrieve_mock . assert_not_called () self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_no_customer ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_sync_from_stripe_data_no_customer ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . pop ( \"customer\" , None ) # remove invoice since it requires a customer fake_charge_copy . pop ( \"invoice\" , None ) fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent [ \"invoice\" ] = None payment_intent_retrieve_mock . return_value = fake_payment_intent Charge . sync_from_stripe_data ( fake_charge_copy ) assert Charge . objects . count () == 1 charge = Charge . objects . get () assert charge . customer is None charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.customer\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.Plan.product\" , }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_refunded ( self , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , side_effect = [ deepcopy ( FAKE_BALANCE_TRANSACTION ), deepcopy ( FAKE_BALANCE_TRANSACTION_REFUND ), ], ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_sync_from_stripe_data_refunded ( self , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE_REFUNDED ) charge = Charge . sync_from_stripe_data ( fake_charge_copy ) self . assertEqual ( Decimal ( \"20\" ), charge . amount ) self . assertEqual ( True , charge . paid ) self . assertEqual ( True , charge . refunded ) self . assertEqual ( True , charge . captured ) self . assertEqual ( False , charge . disputed ) self . assertEqual ( \"Subscription creation\" , charge . description ) self . assertEqual ( charge . amount , charge . amount_refunded ) charge_retrieve_mock . assert_not_called () # We expect two calls - for charge and then for charge.refunds balance_transaction_retrieve_mock . assert_has_calls ( [ call ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ), call ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION_REFUND [ \"id\" ], stripe_account = None , ), ] ) refunds = list ( charge . refunds . all ()) self . assertEqual ( len ( refunds ), 1 ) refund = refunds [ 0 ] self . assertEqual ( refund . id , FAKE_REFUND [ \"id\" ]) self . assertNotEqual ( charge . balance_transaction . id , refund . balance_transaction . id ) self . assertEqual ( charge . balance_transaction . id , FAKE_BALANCE_TRANSACTION [ \"id\" ]) self . assertEqual ( refund . balance_transaction . id , FAKE_BALANCE_TRANSACTION_REFUND [ \"id\" ] ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_refunded_on_update ( self , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_sync_from_stripe_data_refunded_on_update ( self , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , default_account_mock , ): # first sync charge (as per test_sync_from_stripe_data) # then sync refunded version, to hit the update code-path instead of insert from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) with patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), ): charge = Charge . sync_from_stripe_data ( fake_charge_copy ) self . assertEqual ( Decimal ( \"20\" ), charge . amount ) self . assertEqual ( True , charge . paid ) self . assertEqual ( False , charge . refunded ) self . assertEqual ( True , charge . captured ) self . assertEqual ( False , charge . disputed ) self . assertEqual ( len ( charge . refunds . all ()), 0 ) fake_charge_refunded_copy = deepcopy ( FAKE_CHARGE_REFUNDED ) with patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION_REFUND ), ) as balance_transaction_retrieve_mock : charge_refunded = Charge . sync_from_stripe_data ( fake_charge_refunded_copy ) self . assertEqual ( charge . id , charge_refunded . id ) self . assertEqual ( Decimal ( \"20\" ), charge_refunded . amount ) self . assertEqual ( True , charge_refunded . paid ) self . assertEqual ( True , charge_refunded . refunded ) self . assertEqual ( True , charge_refunded . captured ) self . assertEqual ( False , charge_refunded . disputed ) self . assertEqual ( \"Subscription creation\" , charge_refunded . description ) self . assertEqual ( charge_refunded . amount , charge_refunded . amount_refunded ) charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION_REFUND [ \"id\" ], stripe_account = None , ) refunds = list ( charge_refunded . refunds . all ()) self . assertEqual ( len ( refunds ), 1 ) refund = refunds [ 0 ] self . assertEqual ( refund . id , FAKE_REFUND [ \"id\" ]) self . assertNotEqual ( charge_refunded . balance_transaction . id , refund . balance_transaction . id ) self . assertEqual ( charge_refunded . balance_transaction . id , FAKE_BALANCE_TRANSACTION [ \"id\" ] ) self . assertEqual ( refund . balance_transaction . id , FAKE_BALANCE_TRANSACTION_REFUND [ \"id\" ] ) self . assert_fks ( charge_refunded , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_unsupported_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_sync_from_stripe_data_unsupported_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"source\" : { \"id\" : \"test_id\" , \"object\" : \"unsupported\" }}) charge = Charge . sync_from_stripe_data ( fake_charge_copy ) self . assertEqual ( \"test_id\" , charge . source_id ) self . assertEqual ( \"unsupported\" , charge . source . type ) self . assertEqual ( charge . source , DjstripePaymentMethod . objects . get ( id = \"test_id\" )) charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_with_destination ( self , file_retrieve_mock , invoice_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , account_retrieve_mock , charge_retrieve_mock ) Source code in tests/test_charge.py @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.File.retrieve\" , side_effect = [ deepcopy ( FAKE_FILEUPLOAD_ICON ), deepcopy ( FAKE_FILEUPLOAD_LOGO )], autospec = True , ) def test_sync_from_stripe_data_with_destination ( self , file_retrieve_mock , invoice_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , account_retrieve_mock , charge_retrieve_mock , ): from djstripe.settings import STRIPE_SECRET_KEY account_retrieve_mock . return_value = FAKE_ACCOUNT fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"destination\" : FAKE_ACCOUNT [ \"id\" ]}) charge , created = Charge . _get_or_create_from_stripe_object ( fake_charge_copy , current_ids = { fake_charge_copy [ \"id\" ]} ) self . assertTrue ( created ) charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_with_transfer ( self , default_account_mock , subscription_retrieve_mock , product_retrieve_mock , transfer_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock ) Source code in tests/test_charge.py @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Transfer.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_sync_from_stripe_data_with_transfer ( self , default_account_mock , subscription_retrieve_mock , product_retrieve_mock , transfer_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , ): from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_transfer = deepcopy ( FAKE_TRANSFER ) fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"transfer\" : fake_transfer [ \"id\" ]}) transfer_retrieve_mock . return_value = fake_transfer charge_retrieve_mock . return_value = fake_charge_copy charge , created = Charge . _get_or_create_from_stripe_object ( fake_charge_copy , current_ids = { fake_charge_copy [ \"id\" ]} ) self . assertTrue ( created ) self . assertNotEqual ( None , charge . transfer ) self . assertEqual ( fake_transfer [ \"id\" ], charge . transfer . id ) charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ) self . assert_fks ( charge , expected_blank_fks = ( self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" } ) - { \"djstripe.Charge.transfer\" }, ) tests.test_context_managers dj-stripe Context Manager Tests. tests.test_context_managers.TestTemporaryVersion tests . test_context_managers . TestTemporaryVersion . test_basic_with_exception ( self ) Source code in tests/test_context_managers.py def test_basic_with_exception ( self ): version = stripe . api_version with self . assertRaises ( ValueError ): with stripe_temporary_api_version ( \"2016-03-07\" ): self . assertEqual ( stripe . api_version , \"2016-03-07\" ) raise ValueError ( \"Something happened\" ) self . assertEqual ( stripe . api_version , version ) tests . test_context_managers . TestTemporaryVersion . test_basic_without_validation ( self ) Source code in tests/test_context_managers.py def test_basic_without_validation ( self ): version = stripe . api_version with stripe_temporary_api_version ( \"newversion\" , validate = False ): self . assertEqual ( stripe . api_version , \"newversion\" ) self . assertEqual ( stripe . api_version , version ) tests.test_contrib special Modules tests.test_contrib.test_rest_framework_permissions Classes tests.test_contrib.test_rest_framework_permissions.TestUserHasActiveSubscription Methods tests . test_contrib . test_rest_framework_permissions . TestUserHasActiveSubscription . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_contrib/test_rest_framework_permissions.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_contrib . test_rest_framework_permissions . TestUserHasActiveSubscription . test_no_user_in_request ( self ) Source code in tests/test_contrib/test_rest_framework_permissions.py def test_no_user_in_request ( self ): request = RequestFactory () . get ( \"djstripe/\" ) self . assertFalse ( DJStripeSubscriptionPermission () . has_permission ( request = request , view = None ) ) tests . test_contrib . test_rest_framework_permissions . TestUserHasActiveSubscription . test_user ( self ) Source code in tests/test_contrib/test_rest_framework_permissions.py def test_user ( self ): request = RequestFactory () . get ( \"djstripe/\" ) request . user = self . user self . assertFalse ( DJStripeSubscriptionPermission () . has_permission ( request = request , view = None ) ) tests.test_contrib.test_serializers .. module:: dj-stripe.tests.test_contrib.test_serializers :synopsis: dj-stripe Serializer Tests. Classes tests.test_contrib.test_serializers.CreateSubscriptionSerializerTest Methods tests . test_contrib . test_serializers . CreateSubscriptionSerializerTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_contrib/test_serializers.py def setUp ( self ): with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) tests . test_contrib . test_serializers . CreateSubscriptionSerializerTest . test_invalid_serializer ( self ) Source code in tests/test_contrib/test_serializers.py def test_invalid_serializer ( self ): serializer = CreateSubscriptionSerializer ( data = { \"plan\" : self . plan . id }) self . assertFalse ( serializer . is_valid ()) self . assertEqual ( serializer . validated_data , {}) self . assertEqual ( serializer . errors , { \"stripe_token\" : [ \"This field is required.\" ]} ) tests . test_contrib . test_serializers . CreateSubscriptionSerializerTest . test_valid_serializer ( self , stripe_token_mock ) Source code in tests/test_contrib/test_serializers.py @patch ( \"stripe.Token.create\" , return_value = PropertyMock ( id = \"token_test\" ), autospec = True ) def test_valid_serializer ( self , stripe_token_mock ): token = stripe_token_mock ( card = {}) serializer = CreateSubscriptionSerializer ( data = { \"plan\" : self . plan . id , \"stripe_token\" : token . id } ) self . assertTrue ( serializer . is_valid ()) self . assertEqual ( serializer . validated_data [ \"plan\" ], str ( self . plan . id )) self . assertIn ( \"stripe_token\" , serializer . validated_data ) self . assertEqual ( serializer . errors , {}) tests . test_contrib . test_serializers . CreateSubscriptionSerializerTest . test_valid_serializer_non_required_fields ( self , stripe_token_mock ) Test the CreateSubscriptionSerializer is_valid method. Source code in tests/test_contrib/test_serializers.py @patch ( \"stripe.Token.create\" , return_value = PropertyMock ( id = \"token_test\" ), autospec = True ) def test_valid_serializer_non_required_fields ( self , stripe_token_mock ): \"\"\"Test the CreateSubscriptionSerializer is_valid method.\"\"\" token = stripe_token_mock ( card = {}) serializer = CreateSubscriptionSerializer ( data = { \"plan\" : self . plan . id , \"stripe_token\" : token . id , \"charge_immediately\" : True , \"tax_percent\" : 13.00 , } ) self . assertTrue ( serializer . is_valid ()) tests.test_contrib.test_serializers.SubscriptionSerializerTest Methods tests . test_contrib . test_serializers . SubscriptionSerializerTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_contrib/test_serializers.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) tests . test_contrib . test_serializers . SubscriptionSerializerTest . test_invalid_serializer ( self , product_retrieve_mock ) Source code in tests/test_contrib/test_serializers.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invalid_serializer ( self , product_retrieve_mock ): now = timezone . now () serializer = SubscriptionSerializer ( data = { \"id\" : \"sub_6lsC8pt7IcFpjA\" , \"customer\" : self . customer . pk , \"plan\" : self . plan . pk , \"start_date\" : now , \"status\" : SubscriptionStatus . active , \"current_period_end\" : now + timezone . timedelta ( days = 5 ), \"current_period_start\" : now , } ) self . assertFalse ( serializer . is_valid ()) self . assertEqual ( serializer . validated_data , {}) self . assertEqual ( serializer . errors , { \"collection_method\" : [ \"This field is required.\" ]} ) tests . test_contrib . test_serializers . SubscriptionSerializerTest . test_valid_serializer ( self ) Source code in tests/test_contrib/test_serializers.py def test_valid_serializer ( self ): now = timezone . now () serializer = SubscriptionSerializer ( data = { \"id\" : \"sub_6lsC8pt7IcFpjA\" , \"collection_method\" : \"charge_automatically\" , \"customer\" : self . customer . pk , \"plan\" : self . plan . pk , \"quantity\" : 2 , \"start_date\" : now , \"status\" : SubscriptionStatus . active , \"current_period_end\" : now + timezone . timedelta ( days = 5 ), \"current_period_start\" : now , } ) self . assertTrue ( serializer . is_valid ()) self . assertEqual ( serializer . validated_data , { \"id\" : \"sub_6lsC8pt7IcFpjA\" , \"collection_method\" : \"charge_automatically\" , \"customer\" : self . customer , \"plan\" : self . plan , \"quantity\" : 2 , \"start_date\" : now , \"status\" : SubscriptionStatus . active , \"current_period_end\" : now + timezone . timedelta ( days = 5 ), \"current_period_start\" : now , }, ) self . assertEqual ( serializer . errors , {}) tests.test_contrib.test_views .. module:: dj-stripe.tests.test_contrib.test_views :synopsis: dj-stripe Rest views for Subscription Tests. Classes tests.test_contrib.test_views.RestSubscriptionNotLoggedInTest Test the exceptions thrown by the subscription rest views. Methods tests . test_contrib . test_views . RestSubscriptionNotLoggedInTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_contrib/test_views.py def setUp ( self ): self . url = reverse ( \"rest_djstripe:subscription\" ) tests . test_contrib . test_views . RestSubscriptionNotLoggedInTest . test_create_subscription_not_logged_in ( self ) Source code in tests/test_contrib/test_views.py def test_create_subscription_not_logged_in ( self ): data = { \"plan\" : \"test0\" , \"stripe_token\" : \"cake\" } response = self . client . post ( self . url , data ) self . assertEqual ( response . status_code , status . HTTP_403_FORBIDDEN ) tests.test_contrib.test_views.RestSubscriptionTest Test the REST api for subscriptions. Methods tests . test_contrib . test_views . RestSubscriptionTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_contrib/test_views.py def setUp ( self ): self . url = reverse ( \"rest_djstripe:subscription\" ) self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" , password = \"password\" ) self . assertTrue ( self . client . login ( username = \"pydanny\" , password = \"password\" )) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_contrib . test_views . RestSubscriptionTest . test_cancel_subscription ( self , cancel_subscription_mock ) Test a DELETE to the SubscriptionRestView. Should cancel a Customer objects subscription. Source code in tests/test_contrib/test_views.py @patch ( \"djstripe.models.Subscription.cancel\" , autospec = True ) def test_cancel_subscription ( self , cancel_subscription_mock ): \"\"\"Test a DELETE to the SubscriptionRestView. Should cancel a Customer objects subscription. \"\"\" def _cancel_sub ( * args , ** kwargs ): subscription = Subscription . objects . first () subscription . status = SubscriptionStatus . canceled subscription . canceled_at = timezone . now () subscription . ended_at = timezone . now () subscription . save () return subscription fake_canceled_subscription = deepcopy ( FAKE_SUBSCRIPTION ) with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): Subscription . sync_from_stripe_data ( fake_canceled_subscription ) cancel_subscription_mock . side_effect = _cancel_sub self . assertEqual ( 1 , Subscription . objects . count ()) self . assertEqual ( Subscription . objects . first () . status , SubscriptionStatus . active ) response = self . client . delete ( self . url ) self . assertEqual ( response . status_code , status . HTTP_204_NO_CONTENT ) # Cancelled means flagged as canceled, so it should still be there self . assertEqual ( 1 , Subscription . objects . count ()) self . assertEqual ( Subscription . objects . first () . status , SubscriptionStatus . canceled ) cancel_subscription_mock . assert_called_once_with ( Subscription . objects . first (), at_period_end = djstripe_settings . CANCELLATION_AT_PERIOD_END , ) self . assertTrue ( self . user . is_authenticated ) tests . test_contrib . test_views . RestSubscriptionTest . test_cancel_subscription_exception ( self ) Test a DELETE to the SubscriptionRestView. Should return a 400 when an exception is raised. Source code in tests/test_contrib/test_views.py def test_cancel_subscription_exception ( self ): \"\"\"Test a DELETE to the SubscriptionRestView. Should return a 400 when an exception is raised. \"\"\" response = self . client . delete ( self . url ) self . assertEqual ( response . status_code , status . HTTP_400_BAD_REQUEST ) tests . test_contrib . test_views . RestSubscriptionTest . test_create_subscription ( self , add_card_mock , subscribe_mock ) Test a POST to the SubscriptionRestView. Should Create a Customer object Add a card to the Customer object Subcribe the Customer to a plan Source code in tests/test_contrib/test_views.py @patch ( \"djstripe.models.Customer.subscribe\" , autospec = True ) @patch ( \"djstripe.models.Customer.add_card\" , autospec = True ) def test_create_subscription ( self , add_card_mock , subscribe_mock ): \"\"\"Test a POST to the SubscriptionRestView. Should: - Create a Customer object - Add a card to the Customer object - Subcribe the Customer to a plan \"\"\" data = { \"plan\" : \"test0\" , \"stripe_token\" : \"cake\" } response = self . client . post ( self . url , data ) self . assertEqual ( 1 , Customer . objects . count ()) customer = Customer . objects . get () add_card_mock . assert_called_once_with ( customer , \"cake\" ) subscribe_mock . assert_called_once_with ( customer , \"test0\" , True ) self . assertEqual ( response . status_code , status . HTTP_201_CREATED ) data [ \"charge_immediately\" ] = None self . assertEqual ( response . data , data ) tests . test_contrib . test_views . RestSubscriptionTest . test_create_subscription_charge_immediately ( self , add_card_mock , subscribe_mock ) Test a POST to the SubscriptionRestView. Should be able to accept an charge_immediately. This will not send an invoice to the customer on subscribe. Source code in tests/test_contrib/test_views.py @patch ( \"djstripe.models.Customer.subscribe\" , autospec = True ) @patch ( \"djstripe.models.Customer.add_card\" , autospec = True ) def test_create_subscription_charge_immediately ( self , add_card_mock , subscribe_mock ): \"\"\"Test a POST to the SubscriptionRestView. Should be able to accept an charge_immediately. This will not send an invoice to the customer on subscribe. \"\"\" data = { \"plan\" : \"test0\" , \"stripe_token\" : \"cake\" , \"charge_immediately\" : False } response = self . client . post ( self . url , data ) self . assertEqual ( 1 , Customer . objects . count ()) customer = Customer . objects . get () subscribe_mock . assert_called_once_with ( customer , \"test0\" , False ) self . assertEqual ( response . status_code , status . HTTP_201_CREATED ) self . assertEqual ( response . data , data ) tests . test_contrib . test_views . RestSubscriptionTest . test_create_subscription_exception ( self , add_card_mock , subscribe_mock ) Test a POST to the SubscriptionRestView. Should return a 400 when an Exception is raised. Source code in tests/test_contrib/test_views.py @patch ( \"djstripe.models.Customer.subscribe\" , autospec = True ) @patch ( \"djstripe.models.Customer.add_card\" , autospec = True ) def test_create_subscription_exception ( self , add_card_mock , subscribe_mock ): \"\"\"Test a POST to the SubscriptionRestView. Should return a 400 when an Exception is raised. \"\"\" subscribe_mock . side_effect = Exception data = { \"plan\" : \"test0\" , \"stripe_token\" : \"cake\" } response = self . client . post ( self . url , data ) self . assertEqual ( response . status_code , status . HTTP_400_BAD_REQUEST ) tests . test_contrib . test_views . RestSubscriptionTest . test_create_subscription_incorrect_data ( self ) Test a POST to the SubscriptionRestView. Should return a 400 when a the serializer is invalid. Source code in tests/test_contrib/test_views.py def test_create_subscription_incorrect_data ( self ): \"\"\"Test a POST to the SubscriptionRestView. Should return a 400 when a the serializer is invalid. \"\"\" data = { \"foo\" : \"bar\" } response = self . client . post ( self . url , data ) self . assertEqual ( response . status_code , status . HTTP_400_BAD_REQUEST ) tests . test_contrib . test_views . RestSubscriptionTest . test_get_subscription ( self ) Test a GET to the SubscriptionRestView. Should return the correct data. Source code in tests/test_contrib/test_views.py def test_get_subscription ( self ): \"\"\"Test a GET to the SubscriptionRestView. Should return the correct data. \"\"\" with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) subscription = Subscription . sync_from_stripe_data ( deepcopy ( FAKE_SUBSCRIPTION )) response = self . client . get ( self . url ) self . assertEqual ( response . status_code , status . HTTP_200_OK ) self . assertEqual ( response . data [ \"plan\" ], plan . pk ) self . assertEqual ( response . data [ \"status\" ], subscription . status ) self . assertEqual ( response . data [ \"cancel_at_period_end\" ], subscription . cancel_at_period_end ) tests.test_coupon tests.test_coupon.HumanReadableCouponTest tests . test_coupon . HumanReadableCouponTest . test_human_readable_eur_off_forever ( self ) Source code in tests/test_coupon.py def test_human_readable_eur_off_forever ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-amount-off-forever\" , amount_off = 10 , currency = \"eur\" , duration = \"forever\" , ) self . assertEqual ( coupon . human_readable , \"\u20ac10.00 EUR off forever\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_integer_percent_off_forever ( self ) Source code in tests/test_coupon.py def test_human_readable_integer_percent_off_forever ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-percent-off-forever\" , percent_off = 10 , currency = \"usd\" , duration = \"forever\" , ) self . assertEqual ( coupon . human_readable , \"10 % o ff forever\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_percent_off_forever ( self ) Source code in tests/test_coupon.py def test_human_readable_percent_off_forever ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-percent-off-forever\" , percent_off = 10.25 , currency = \"usd\" , duration = \"forever\" , ) self . assertEqual ( coupon . human_readable , \"10.25 % o ff forever\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_percent_off_once ( self ) Source code in tests/test_coupon.py def test_human_readable_percent_off_once ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-percent-off-once\" , percent_off = 10.25 , currency = \"usd\" , duration = \"once\" , ) self . assertEqual ( coupon . human_readable , \"10.25 % o ff once\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_percent_off_one_month ( self ) Source code in tests/test_coupon.py def test_human_readable_percent_off_one_month ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-percent-off-1month\" , percent_off = 10.25 , currency = \"usd\" , duration = \"repeating\" , duration_in_months = 1 , ) self . assertEqual ( coupon . human_readable , \"10.25 % o ff for 1 month\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_percent_off_three_months ( self ) Source code in tests/test_coupon.py def test_human_readable_percent_off_three_months ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-percent-off-3month\" , percent_off = 10.25 , currency = \"usd\" , duration = \"repeating\" , duration_in_months = 3 , ) self . assertEqual ( coupon . human_readable , \"10.25 % o ff for 3 months\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_usd_off_forever ( self ) Source code in tests/test_coupon.py def test_human_readable_usd_off_forever ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-amount-off-forever\" , amount_off = 10 , currency = \"usd\" , duration = \"forever\" , ) self . assertEqual ( coupon . human_readable , \"$10.00 USD off forever\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_str_name ( self ) Source code in tests/test_coupon.py def test_str_name ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-amount-off-forever\" , amount_off = 10 , currency = \"usd\" , duration = \"forever\" , name = \"Test coupon\" , ) self . assertEqual ( str ( coupon ), \"Test coupon\" ) tests.test_coupon.TransferTest tests . test_coupon . TransferTest . test_retrieve_coupon ( self ) Source code in tests/test_coupon.py def test_retrieve_coupon ( self ): coupon_data = deepcopy ( FAKE_COUPON ) coupon = Coupon . sync_from_stripe_data ( coupon_data ) self . assertEqual ( coupon . id , FAKE_COUPON [ \"id\" ]) tests . test_coupon . test_blank_coupon_str () Source code in tests/test_coupon.py def test_blank_coupon_str (): coupon = Coupon () assert str ( coupon ) . strip () == \"(invalid amount) off\" tests.test_customer Customer Model Tests. Classes tests.test_customer.TestCustomer Methods tests . test_customer . TestCustomer . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_customer.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . payment_method , _ = DjstripePaymentMethod . _get_or_create_source ( FAKE_CARD , \"card\" ) self . card = self . payment_method . resolve () self . customer . default_source = self . payment_method self . customer . save () self . account = default_account () tests . test_customer . TestCustomer . test_add_card_set_default_false ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_add_card_set_default_false ( self , customer_retrieve_mock ): self . customer . add_card ( FAKE_CARD [ \"id\" ], set_default = False ) self . customer . add_card ( FAKE_CARD_V [ \"id\" ], set_default = False ) self . assertEqual ( 2 , Card . objects . count ()) self . assertEqual ( FAKE_CARD [ \"id\" ], self . customer . default_source . id ) tests . test_customer . TestCustomer . test_add_card_set_default_false_with_single_card_still_becomes_default ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_add_card_set_default_false_with_single_card_still_becomes_default ( self , customer_retrieve_mock ): self . customer . add_card ( FAKE_CARD [ \"id\" ], set_default = False ) self . assertEqual ( 2 , Card . objects . count ()) self . assertEqual ( FAKE_CARD [ \"id\" ], self . customer . default_source . id ) tests . test_customer . TestCustomer . test_add_card_set_default_true ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_add_card_set_default_true ( self , customer_retrieve_mock ): self . customer . add_card ( FAKE_CARD [ \"id\" ]) self . customer . add_card ( FAKE_CARD_V [ \"id\" ]) self . assertEqual ( 2 , Card . objects . count ()) self . assertEqual ( FAKE_CARD_V [ \"id\" ], self . customer . default_source . id ) tests . test_customer . TestCustomer . test_add_coupon_by_id ( self , customer_retrieve_mock , coupon_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Coupon.retrieve\" , return_value = deepcopy ( FAKE_COUPON ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_add_coupon_by_id ( self , customer_retrieve_mock , coupon_retrieve_mock ): self . assertEqual ( self . customer . coupon , None ) self . customer . add_coupon ( FAKE_COUPON [ \"id\" ]) customer_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = ANY , id = FAKE_CUSTOMER [ \"id\" ], stripe_account = None , ) tests . test_customer . TestCustomer . test_add_coupon_by_object ( self , customer_retrieve_mock , coupon_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Coupon.retrieve\" , return_value = deepcopy ( FAKE_COUPON ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_add_coupon_by_object ( self , customer_retrieve_mock , coupon_retrieve_mock ): self . assertEqual ( self . customer . coupon , None ) coupon = Coupon . sync_from_stripe_data ( FAKE_COUPON ) fake_discount = deepcopy ( FAKE_DISCOUNT_CUSTOMER ) def fake_customer_save ( self , * args , ** kwargs ): # fake the api coupon update behaviour coupon = self . pop ( \"coupon\" , None ) if coupon : self [ \"discount\" ] = fake_discount else : self [ \"discount\" ] = None return self with patch ( \"tests.CustomerDict.save\" , new = fake_customer_save ): self . customer . add_coupon ( coupon ) customer_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = ANY , id = FAKE_CUSTOMER [ \"id\" ], stripe_account = None , ) self . customer . refresh_from_db () self . assert_fks ( self . customer , expected_blank_fks = { \"djstripe.Customer.default_payment_method\" }, ) tests . test_customer . TestCustomer . test_add_invoice_item ( self , invoiceitem_create_mock , invoiceitem_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.InvoiceItem.sync_from_stripe_data\" , return_value = \"pancakes\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.InvoiceItem.create\" , return_value = deepcopy ( FAKE_INVOICEITEM ), autospec = True , ) def test_add_invoice_item ( self , invoiceitem_create_mock , invoiceitem_sync_mock ): invoiceitem = self . customer . add_invoice_item ( amount = decimal . Decimal ( \"50.00\" ), currency = \"eur\" , description = \"test\" , invoice = 77 , subscription = 25 , ) self . assertEqual ( \"pancakes\" , invoiceitem ) invoiceitem_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , amount = 5000 , customer = self . customer . id , currency = \"eur\" , description = \"test\" , discountable = None , invoice = 77 , metadata = None , subscription = 25 , ) tests . test_customer . TestCustomer . test_add_invoice_item_bad_decimal ( self ) Source code in tests/test_customer.py def test_add_invoice_item_bad_decimal ( self ): with self . assertRaisesMessage ( ValueError , \"You must supply a decimal value representing dollars.\" ): self . customer . add_invoice_item ( amount = 5000 , currency = \"usd\" ) tests . test_customer . TestCustomer . test_add_invoice_item_djstripe_objects ( self , invoiceitem_create_mock , invoiceitem_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.InvoiceItem.sync_from_stripe_data\" , return_value = \"pancakes\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.InvoiceItem.create\" , return_value = deepcopy ( FAKE_INVOICEITEM ), autospec = True , ) def test_add_invoice_item_djstripe_objects ( self , invoiceitem_create_mock , invoiceitem_sync_mock ): invoiceitem = self . customer . add_invoice_item ( amount = decimal . Decimal ( \"50.00\" ), currency = \"eur\" , description = \"test\" , invoice = Invoice ( id = 77 ), subscription = Subscription ( id = 25 ), ) self . assertEqual ( \"pancakes\" , invoiceitem ) invoiceitem_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , amount = 5000 , customer = self . customer . id , currency = \"eur\" , description = \"test\" , discountable = None , invoice = 77 , metadata = None , subscription = 25 , ) tests . test_customer . TestCustomer . test_add_payment_method_obj ( self , attach_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_add_payment_method_obj ( self , attach_mock , customer_retrieve_mock ): self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 0 , ) payment_method = PaymentMethod . sync_from_stripe_data ( FAKE_PAYMENT_METHOD_I ) payment_method = self . customer . add_payment_method ( payment_method ) self . assertEqual ( payment_method . customer . id , self . customer . id ) self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 1 , ) self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . first (), self . customer . default_payment_method , ) self . assertEqual ( self . customer . default_payment_method . id , self . customer . invoice_settings [ \"default_payment_method\" ], ) self . assert_fks ( self . customer , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_customer . TestCustomer . test_add_payment_method_set_default_false ( self , attach_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_add_payment_method_set_default_false ( self , attach_mock , customer_retrieve_mock ): # clear default source so we can check can_charge() fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"default_source\" ] = None customer_retrieve_mock . return_value = fake_customer self . customer . default_source = None self . customer . save () self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 0 , ) payment_method = self . customer . add_payment_method ( FAKE_PAYMENT_METHOD_I [ \"id\" ], set_default = False ) self . assertEqual ( payment_method . customer . id , self . customer . id ) self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 1 , ) self . assertFalse ( self . customer . can_charge (), \"Expect not to be able to charge since we've not set a \" \"default_payment_method\" , ) self . assert_fks ( self . customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , }, ) tests . test_customer . TestCustomer . test_add_payment_method_set_default_true ( self , attach_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_add_payment_method_set_default_true ( self , attach_mock , customer_retrieve_mock ): # clear default source so we can check can_charge() fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"default_source\" ] = None customer_retrieve_mock . return_value = fake_customer self . customer . default_source = None self . customer . save () self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 0 , ) payment_method = self . customer . add_payment_method ( FAKE_PAYMENT_METHOD_I [ \"id\" ]) self . assertEqual ( payment_method . customer . id , self . customer . id ) self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 1 , ) self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . first (), self . customer . default_payment_method , ) self . assertEqual ( self . customer . default_payment_method . id , self . customer . invoice_settings [ \"default_payment_method\" ], ) self . assertTrue ( self . customer . can_charge (), \"Expect to be able to charge since we've set a default_payment_method\" , ) self . assert_fks ( self . customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_source\" , }, ) tests . test_customer . TestCustomer . test_balance ( self ) Source code in tests/test_customer.py def test_balance ( self ): self . assertEqual ( self . customer . balance , 0 ) self . assertEqual ( self . customer . credits , 0 ) self . customer . balance = 1000 self . assertEqual ( self . customer . balance , 1000 ) self . assertEqual ( self . customer . credits , 0 ) self . assertEqual ( self . customer . pending_charges , 1000 ) self . customer . balance = - 1000 self . assertEqual ( self . customer . balance , - 1000 ) self . assertEqual ( self . customer . credits , 1000 ) self . assertEqual ( self . customer . pending_charges , 0 ) tests . test_customer . TestCustomer . test_calculate_refund_above_max_refund ( self ) Source code in tests/test_customer.py def test_calculate_refund_above_max_refund ( self ): charge = Charge ( id = \"ch_111111\" , customer = self . customer , amount = decimal . Decimal ( \"500.00\" ) ) self . assertEqual ( charge . _calculate_refund_amount ( amount = decimal . Decimal ( \"600.00\" )), 50000 ) tests . test_customer . TestCustomer . test_calculate_refund_amount_partial_refund ( self ) Source code in tests/test_customer.py def test_calculate_refund_amount_partial_refund ( self ): charge = Charge ( id = \"ch_111111\" , customer = self . customer , amount = decimal . Decimal ( \"500.00\" ) ) self . assertEqual ( charge . _calculate_refund_amount ( amount = decimal . Decimal ( \"300.00\" )), 30000 ) tests . test_customer . TestCustomer . test_can_charge ( self ) Source code in tests/test_customer.py def test_can_charge ( self ): self . assertTrue ( self . customer . can_charge ()) tests . test_customer . TestCustomer . test_cannot_charge ( self , customer_retrieve_fake ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_cannot_charge ( self , customer_retrieve_fake ): self . customer . delete () self . assertFalse ( self . customer . can_charge ()) tests . test_customer . TestCustomer . test_charge_accepts_only_decimals ( self ) Source code in tests/test_customer.py def test_charge_accepts_only_decimals ( self ): with self . assertRaises ( ValueError ): self . customer . charge ( 10 ) tests . test_customer . TestCustomer . test_charge_card_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.create\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_charge_card_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"invoice\" : None }) charge_create_mock . return_value = fake_charge_copy charge_retrieve_mock . return_value = fake_charge_copy fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent self . customer . charge ( amount = decimal . Decimal ( \"10.00\" ), source = self . card ) tests . test_customer . TestCustomer . test_charge_converts_dollars_into_cents ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.create\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_charge_converts_dollars_into_cents ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"invoice\" : None , \"amount\" : 1000 }) charge_create_mock . return_value = fake_charge_copy charge_retrieve_mock . return_value = fake_charge_copy fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent self . customer . charge ( amount = decimal . Decimal ( \"10.00\" )) _ , kwargs = charge_create_mock . call_args self . assertEqual ( kwargs [ \"amount\" ], 1000 ) tests . test_customer . TestCustomer . test_charge_doesnt_require_invoice ( self , subscription_retrieve_mock , product_retrieve_mock , invoice_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.create\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_charge_doesnt_require_invoice ( self , subscription_retrieve_mock , product_retrieve_mock , invoice_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ( { \"invoice\" : FAKE_INVOICE [ \"id\" ], \"amount\" : FAKE_INVOICE [ \"amount_due\" ]} ) fake_invoice_copy = deepcopy ( FAKE_INVOICE ) charge_create_mock . return_value = fake_charge_copy charge_retrieve_mock . return_value = fake_charge_copy invoice_retrieve_mock . return_value = fake_invoice_copy try : self . customer . charge ( amount = decimal . Decimal ( \"20.00\" )) except Invoice . DoesNotExist : self . fail ( msg = \"Stripe Charge shouldn't throw Invoice DoesNotExist.\" ) tests . test_customer . TestCustomer . test_charge_passes_extra_arguments ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.create\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_charge_passes_extra_arguments ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"invoice\" : None }) charge_create_mock . return_value = fake_charge_copy charge_retrieve_mock . return_value = fake_charge_copy fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent self . customer . charge ( amount = decimal . Decimal ( \"10.00\" ), capture = True , destination = FAKE_ACCOUNT [ \"id\" ], ) _ , kwargs = charge_create_mock . call_args self . assertEqual ( kwargs [ \"capture\" ], True ) self . assertEqual ( kwargs [ \"destination\" ], FAKE_ACCOUNT [ \"id\" ]) tests . test_customer . TestCustomer . test_charge_string_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.create\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_charge_string_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"invoice\" : None }) charge_create_mock . return_value = fake_charge_copy charge_retrieve_mock . return_value = fake_charge_copy fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent self . customer . charge ( amount = decimal . Decimal ( \"10.00\" ), source = self . card . id ) tests . test_customer . TestCustomer . test_customer_create_metadata_disabled ( self , customer_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.create\" , autospec = True ) def test_customer_create_metadata_disabled ( self , customer_mock ): user = get_user_model () . objects . create_user ( username = \"test_user_create_metadata_disabled\" ) fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"id\" ] = \"cus_test_create_metadata_disabled\" customer_mock . return_value = fake_customer djstripe_settings . SUBSCRIBER_CUSTOMER_KEY = \"\" customer = Customer . create ( user ) djstripe_settings . SUBSCRIBER_CUSTOMER_KEY = \"djstripe_subscriber\" customer_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , email = \"\" , idempotency_key = None , metadata = {}, stripe_account = None , ) self . assertEqual ( customer . metadata , None ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , }, ) tests . test_customer . TestCustomer . test_customer_dashboard_url ( self ) Source code in tests/test_customer.py def test_customer_dashboard_url ( self ): expected_url = \"https://dashboard.stripe.com/test/customers/ {} \" . format ( self . customer . id ) self . assertEqual ( self . customer . get_stripe_dashboard_url (), expected_url ) self . customer . livemode = True expected_url = \"https://dashboard.stripe.com/customers/ {} \" . format ( self . customer . id ) self . assertEqual ( self . customer . get_stripe_dashboard_url (), expected_url ) unsaved_customer = Customer () self . assertEqual ( unsaved_customer . get_stripe_dashboard_url (), \"\" ) tests . test_customer . TestCustomer . test_customer_delete_raises_unexpected_exception ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) def test_customer_delete_raises_unexpected_exception ( self , customer_retrieve_mock ): customer_retrieve_mock . side_effect = InvalidRequestError ( \"Unexpected Exception\" , \"blah\" ) with self . assertRaisesMessage ( InvalidRequestError , \"Unexpected Exception\" ): self . customer . purge () customer_retrieve_mock . assert_called_once_with ( id = self . customer . id , api_key = STRIPE_SECRET_KEY , expand = ANY , stripe_account = None , ) tests . test_customer . TestCustomer . test_customer_delete_same_as_purge ( self , customer_retrieve_fake ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) def test_customer_delete_same_as_purge ( self , customer_retrieve_fake ): self . customer . delete () customer = Customer . objects . get ( id = self . customer . id ) self . assertTrue ( customer . subscriber is None ) self . assertTrue ( customer . default_source is None ) self . assertTrue ( not customer . legacy_cards . all ()) self . assertTrue ( not customer . sources . all ()) self . assertTrue ( get_user_model () . objects . filter ( pk = self . user . pk ) . exists ()) tests . test_customer . TestCustomer . test_customer_purge_deletes_idempotency_key ( self , customer_api_create_fake ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.create\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True ) def test_customer_purge_deletes_idempotency_key ( self , customer_api_create_fake ): # We need to call Customer.get_or_create (which setUp doesn't) # to get an idempotency key user = get_user_model () . objects . create_user ( username = \"blah\" , email = FAKE_CUSTOMER_II [ \"email\" ] ) idempotency_key_action = \"customer:create: {} \" . format ( user . pk ) self . assertFalse ( IdempotencyKey . objects . filter ( action = idempotency_key_action ) . exists () ) customer , created = Customer . get_or_create ( user ) self . assertTrue ( IdempotencyKey . objects . filter ( action = idempotency_key_action ) . exists () ) with patch ( \"stripe.Customer.retrieve\" , autospec = True ): customer . purge () self . assertFalse ( IdempotencyKey . objects . filter ( action = idempotency_key_action ) . exists () ) tests . test_customer . TestCustomer . test_customer_purge_detaches_sources ( self , customer_api_create_fake ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.create\" , autospec = True ) def test_customer_purge_detaches_sources ( self , customer_api_create_fake ): fake_customer = deepcopy ( FAKE_CUSTOMER_III ) customer_api_create_fake . return_value = fake_customer user = get_user_model () . objects . create_user ( username = \"blah\" , email = FAKE_CUSTOMER_III [ \"email\" ] ) Customer . get_or_create ( user ) customer = Customer . sync_from_stripe_data ( deepcopy ( FAKE_CUSTOMER_III )) self . assertIsNotNone ( customer . default_source ) self . assertNotEqual ( customer . sources . count (), 0 ) with patch ( \"stripe.Customer.retrieve\" , autospec = True ), patch ( \"stripe.Source.retrieve\" , return_value = deepcopy ( FAKE_SOURCE ), autospec = True ): customer . purge () self . assertIsNone ( customer . default_source ) self . assertEqual ( customer . sources . count (), 0 ) tests . test_customer . TestCustomer . test_customer_purge_leaves_customer_record ( self , customer_retrieve_fake ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) def test_customer_purge_leaves_customer_record ( self , customer_retrieve_fake ): self . customer . purge () customer = Customer . objects . get ( id = self . customer . id ) self . assertTrue ( customer . subscriber is None ) self . assertTrue ( customer . default_source is None ) self . assertTrue ( not customer . legacy_cards . all ()) self . assertTrue ( not customer . sources . all ()) self . assertTrue ( get_user_model () . objects . filter ( pk = self . user . pk ) . exists ()) tests . test_customer . TestCustomer . test_customer_purge_raises_customer_exception ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) def test_customer_purge_raises_customer_exception ( self , customer_retrieve_mock ): customer_retrieve_mock . side_effect = InvalidRequestError ( \"No such customer:\" , \"blah\" ) self . customer . purge () customer = Customer . objects . get ( id = self . customer . id ) self . assertTrue ( customer . subscriber is None ) self . assertTrue ( customer . default_source is None ) self . assertTrue ( not customer . legacy_cards . all ()) self . assertTrue ( not customer . sources . all ()) self . assertTrue ( get_user_model () . objects . filter ( pk = self . user . pk ) . exists ()) customer_retrieve_mock . assert_called_with ( id = self . customer . id , api_key = STRIPE_SECRET_KEY , expand = ANY , stripe_account = None , ) self . assertEqual ( 3 , customer_retrieve_mock . call_count ) tests . test_customer . TestCustomer . test_customer_sync_add_tax_id_to_existing_customer ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_WITH_TAX_ID )) def test_customer_sync_add_tax_id_to_existing_customer ( self , customer_retrieve_mock ): customer = Customer . sync_from_stripe_data ( deepcopy ( FAKE_CUSTOMER_BEFORE_TAX_ID )) self . assertEqual ( customer . tax_ids . count (), 0 ) Customer . sync_from_stripe_data ( deepcopy ( FAKE_CUSTOMER_WITH_TAX_ID )) self . assertEqual ( customer . tax_ids . count (), 1 ) self . assertEqual ( customer . tax_ids . last () . value , \"DE123456789\" ) self . assertEqual ( customer . tax_ids . last () . type , \"eu_vat\" ) tests . test_customer . TestCustomer . test_customer_sync_bank_account_source ( self , bank_account_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.BankAccount.retrieve\" , return_value = FAKE_CUSTOMER_IV [ \"default_source\" ], autospec = True , ) def test_customer_sync_bank_account_source ( self , bank_account_retrieve_mock ): fake_customer = deepcopy ( FAKE_CUSTOMER_IV ) user = get_user_model () . objects . create_user ( username = \"test_user_sync_bank_account_source\" ) customer = fake_customer . create_for_user ( user ) self . assertEqual ( customer . sources . count (), 0 ) self . assertEqual ( customer . legacy_cards . count (), 0 ) self . assertEqual ( customer . bank_account . count (), 1 ) self . assertEqual ( customer . default_source . id , fake_customer [ \"default_source\" ][ \"id\" ] ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_create_customer_and_tax_ids ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_WITH_TAX_ID )) def test_customer_sync_create_customer_and_tax_ids ( self , customer_retrieve_mock ): customer = Customer . sync_from_stripe_data ( customer_retrieve_mock . return_value ) self . assertEqual ( customer . tax_ids . count (), 1 ) self . assertEqual ( customer . tax_ids . last () . value , \"DE123456789\" ) self . assertEqual ( customer . tax_ids . last () . type , \"eu_vat\" ) tests . test_customer . TestCustomer . test_customer_sync_default_payment_method_string ( self , attach_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I ) ) def test_customer_sync_default_payment_method_string ( self , attach_mock , customer_retrieve_mock ): Customer . objects . all () . delete () PaymentMethod . objects . all () . delete () customer_fake = deepcopy ( FAKE_CUSTOMER ) customer_fake [ \"invoice_settings\" ][ \"default_payment_method\" ] = FAKE_PAYMENT_METHOD_I [ \"id\" ] customer_retrieve_mock . return_value = customer_fake customer = Customer . sync_from_stripe_data ( customer_fake ) self . assertEqual ( customer . default_payment_method . id , customer_fake [ \"invoice_settings\" ][ \"default_payment_method\" ], ) self . assertEqual ( customer . payment_methods . count (), 1 ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.subscriber\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_default_source_string ( self ) Source code in tests/test_customer.py def test_customer_sync_default_source_string ( self ): Customer . objects . all () . delete () Card . objects . all () . delete () customer_fake = deepcopy ( FAKE_CUSTOMER ) customer_fake [ \"default_source\" ] = customer_fake [ \"sources\" ][ \"data\" ][ 0 ][ \"id\" ] = \"card_sync_source_string\" customer = Customer . sync_from_stripe_data ( customer_fake ) self . assertEqual ( customer . default_source . id , customer_fake [ \"default_source\" ]) self . assertEqual ( customer . legacy_cards . count (), 2 ) self . assertEqual ( len ( list ( customer . customer_payment_methods )), 2 ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_has_bad_subscriber_metadata ( self ) Source code in tests/test_customer.py def test_customer_sync_has_bad_subscriber_metadata ( self ): fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"id\" ] = \"cus_sync_has_bad_subscriber_metadata\" fake_customer [ \"metadata\" ] = { \"djstripe_subscriber\" : \"does_not_exist\" } customer = Customer . sync_from_stripe_data ( fake_customer ) self . assertEqual ( customer . subscriber , None ) self . assertEqual ( customer . metadata , { \"djstripe_subscriber\" : \"does_not_exist\" }) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_has_subscriber_metadata ( self ) Source code in tests/test_customer.py def test_customer_sync_has_subscriber_metadata ( self ): user = get_user_model () . objects . create ( username = \"test_metadata\" , id = 12345 ) fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"id\" ] = \"cus_sync_has_subscriber_metadata\" fake_customer [ \"metadata\" ] = { \"djstripe_subscriber\" : \"12345\" } customer = Customer . sync_from_stripe_data ( fake_customer ) self . assertEqual ( customer . subscriber , user ) self . assertEqual ( customer . metadata , { \"djstripe_subscriber\" : \"12345\" }) tests . test_customer . TestCustomer . test_customer_sync_has_subscriber_metadata_disabled ( self ) Source code in tests/test_customer.py def test_customer_sync_has_subscriber_metadata_disabled ( self ): user = get_user_model () . objects . create ( username = \"test_metadata_disabled\" , id = 98765 ) fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"id\" ] = \"cus_test_metadata_disabled\" fake_customer [ \"metadata\" ] = { \"djstripe_subscriber\" : \"98765\" } with patch ( \"djstripe.settings.SUBSCRIBER_CUSTOMER_KEY\" , return_value = \"\" , autospec = True ): customer = Customer . sync_from_stripe_data ( fake_customer ) self . assertNotEqual ( customer . subscriber , user ) self . assertNotEqual ( customer . subscriber_id , 98765 ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_no_sources ( self , customer_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.create\" , autospec = True ) def test_customer_sync_no_sources ( self , customer_mock ): fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"id\" ] = \"cus_test_sync_no_sources\" fake_customer [ \"default_source\" ] = None fake_customer [ \"sources\" ] = None customer_mock . return_value = fake_customer user = get_user_model () . objects . create_user ( username = \"test_user_sync_non_local_card\" ) customer = Customer . create ( user ) self . assertEqual ( customer_mock . call_args_list [ 0 ][ 1 ] . get ( \"metadata\" ), { \"djstripe_subscriber\" : user . pk }, ) self . assertEqual ( customer . sources . count (), 0 ) self . assertEqual ( customer . legacy_cards . count (), 0 ) self . assertEqual ( customer . default_source , None ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_non_local_card ( self , card_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Card.retrieve\" , return_value = FAKE_CUSTOMER_II [ \"default_source\" ], autospec = True , ) def test_customer_sync_non_local_card ( self , card_retrieve_mock ): fake_customer = deepcopy ( FAKE_CUSTOMER_II ) fake_customer [ \"id\" ] = fake_customer [ \"sources\" ][ \"data\" ][ 0 ][ \"customer\" ] = \"cus_test_sync_non_local_card\" user = get_user_model () . objects . create_user ( username = \"test_user_sync_non_local_card\" ) customer = fake_customer . create_for_user ( user ) self . assertEqual ( customer . sources . count (), 0 ) self . assertEqual ( customer . legacy_cards . count (), 1 ) self . assertEqual ( customer . default_source . id , fake_customer [ \"default_source\" ][ \"id\" ] ) tests . test_customer . TestCustomer . test_customer_sync_unsupported_source ( self ) Source code in tests/test_customer.py def test_customer_sync_unsupported_source ( self ): fake_customer = deepcopy ( FAKE_CUSTOMER_II ) fake_customer [ \"default_source\" ][ \"object\" ] = fake_customer [ \"sources\" ][ \"data\" ][ 0 ][ \"object\" ] = \"fish\" user = get_user_model () . objects . create_user ( username = \"test_user_sync_unsupported_source\" ) synced_customer = fake_customer . create_for_user ( user ) self . assertEqual ( 0 , synced_customer . legacy_cards . count ()) self . assertEqual ( 0 , synced_customer . sources . count ()) self . assertEqual ( synced_customer . default_source , DjstripePaymentMethod . objects . get ( id = fake_customer [ \"default_source\" ][ \"id\" ]), ) tests . test_customer . TestCustomer . test_delete_subscriber_without_customer_is_noop ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) def test_delete_subscriber_without_customer_is_noop ( self , customer_retrieve_mock ): self . user . delete () for customer in self . user . djstripe_customers . all (): self . assertIsNone ( customer . date_purged ) tests . test_customer . TestCustomer . test_has_active_subscription_with_unspecified_price_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_has_active_subscription_with_unspecified_price_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . assert_fks ( price , expected_blank_fks = {}) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_fake_duplicate = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake_duplicate [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_fake_duplicate [ \"id\" ] = \"sub_6lsC8pt7IcF8jd\" subscription_create_mock . side_effect = [ subscription_fake , subscription_fake_duplicate , ] self . customer . subscribe ( price = price , charge_immediately = False ) self . customer . subscribe ( price = price , charge_immediately = False ) self . assertEqual ( 2 , self . customer . subscriptions . count ()) with self . assertRaises ( TypeError ): self . customer . has_active_subscription () tests . test_customer . TestCustomer . test_is_subscribed_to_with_product ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_is_subscribed_to_with_product ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) product = Product . sync_from_stripe_data ( deepcopy ( FAKE_PRODUCT )) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_create_mock . return_value = subscription_fake self . customer . subscribe ( price = price , charge_immediately = False ) assert self . customer . is_subscribed_to ( product ) tests . test_customer . TestCustomer . test_is_subscribed_to_with_product_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_is_subscribed_to_with_product_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) product = Product . sync_from_stripe_data ( deepcopy ( FAKE_PRODUCT )) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_create_mock . return_value = subscription_fake self . customer . subscribe ( price = price , charge_immediately = False ) assert self . customer . is_subscribed_to ( product . id ) tests . test_customer . TestCustomer . test_refund_charge ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_refund_charge ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_no_invoice = deepcopy ( FAKE_CHARGE ) fake_charge_no_invoice . update ({ \"invoice\" : None }) charge_retrieve_mock . return_value = fake_charge_no_invoice fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent charge , created = Charge . _get_or_create_from_stripe_object ( fake_charge_no_invoice ) self . assertTrue ( created ) self . assert_fks ( charge , expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , }, ) charge . refund () refunded_charge , created2 = Charge . _get_or_create_from_stripe_object ( fake_charge_no_invoice ) self . assertFalse ( created2 ) self . assertEqual ( refunded_charge . refunded , True ) self . assertEqual ( refunded_charge . amount_refunded , decimal . Decimal ( \"20.00\" )) self . assert_fks ( refunded_charge , expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , }, ) tests . test_customer . TestCustomer . test_refund_charge_object_returned ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_refund_charge_object_returned ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_no_invoice = deepcopy ( FAKE_CHARGE ) fake_charge_no_invoice . update ({ \"invoice\" : None }) charge_retrieve_mock . return_value = fake_charge_no_invoice fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent charge , created = Charge . _get_or_create_from_stripe_object ( fake_charge_no_invoice ) self . assertTrue ( created ) self . assert_fks ( charge , expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , }, ) refunded_charge = charge . refund () self . assertEqual ( refunded_charge . refunded , True ) self . assertEqual ( refunded_charge . amount_refunded , decimal . Decimal ( \"20.00\" )) self . assert_fks ( refunded_charge , expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , }, ) tests . test_customer . TestCustomer . test_retry_unpaid_invoices ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_INVOICE ), deepcopy ( FAKE_INVOICE_III )] ), autospec = True , ) @patch ( \"djstripe.models.Invoice.retry\" , autospec = True ) def test_retry_unpaid_invoices ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account self . customer . retry_unpaid_invoices () invoice = Invoice . objects . get ( id = FAKE_INVOICE_III [ \"id\" ]) invoice_retry_mock . assert_called_once_with ( invoice ) tests . test_customer . TestCustomer . test_retry_unpaid_invoices_expected_exception ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_INVOICE_III )]), ) @patch ( \"djstripe.models.Invoice.retry\" , autospec = True ) def test_retry_unpaid_invoices_expected_exception ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_retry_mock . side_effect = InvalidRequestError ( \"Invoice is already paid\" , \"blah\" ) try : self . customer . retry_unpaid_invoices () except Exception : self . fail ( \"Exception was unexpectedly raised.\" ) tests . test_customer . TestCustomer . test_retry_unpaid_invoices_none_unpaid ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_INVOICE )]), autospec = True , ) @patch ( \"djstripe.models.Invoice.retry\" , autospec = True ) def test_retry_unpaid_invoices_none_unpaid ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account self . customer . retry_unpaid_invoices () self . assertFalse ( invoice_retry_mock . called ) tests . test_customer . TestCustomer . test_retry_unpaid_invoices_unexpected_exception ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_INVOICE_III )]), ) @patch ( \"djstripe.models.Invoice.retry\" , autospec = True ) def test_retry_unpaid_invoices_unexpected_exception ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_retry_mock . side_effect = InvalidRequestError ( \"This should fail!\" , \"blah\" ) with self . assertRaisesMessage ( InvalidRequestError , \"This should fail!\" ): self . customer . retry_unpaid_invoices () tests . test_customer . TestCustomer . test_send_invoice_failure ( self , invoice_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Invoice.create\" , autospec = True ) def test_send_invoice_failure ( self , invoice_create_mock ): invoice_create_mock . side_effect = InvalidRequestError ( \"Invoice creation failed.\" , \"blah\" ) return_status = self . customer . send_invoice () self . assertFalse ( return_status ) invoice_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , customer = self . customer . id ) tests . test_customer . TestCustomer . test_send_invoice_success ( self , invoice_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Invoice.create\" , autospec = True ) def test_send_invoice_success ( self , invoice_create_mock ): return_status = self . customer . send_invoice () self . assertTrue ( return_status ) invoice_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , customer = self . customer . id ) tests . test_customer . TestCustomer . test_str ( self ) Source code in tests/test_customer.py def test_str ( self ): self . assertEqual ( str ( self . customer ), str ( self . user )) self . customer . subscriber = None self . assertEqual ( str ( self . customer ), self . customer . description ) tests . test_customer . TestCustomer . test_subscribe_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . assert_fks ( price , expected_blank_fks = {}) self . customer . subscribe ( price = price , charge_immediately = True ) self . assertTrue ( send_invoice_mock . called ) tests . test_customer . TestCustomer . test_subscribe_not_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_not_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . customer . subscribe ( price = price , charge_immediately = False ) self . assertFalse ( send_invoice_mock . called ) tests . test_customer . TestCustomer . test_subscribe_price_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_price_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . assert_fks ( price , expected_blank_fks = {}) self . customer . subscribe ( price = price . id , charge_immediately = True ) self . assertTrue ( send_invoice_mock . called ) tests . test_customer . TestCustomer . test_subscription_shortcut_with_invalid_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscription_shortcut_with_invalid_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . assert_fks ( price , expected_blank_fks = {}) fake_subscriptions = [ deepcopy ( FAKE_SUBSCRIPTION ), deepcopy ( FAKE_SUBSCRIPTION ), deepcopy ( FAKE_SUBSCRIPTION ), ] # update the status of all but one to be invalid, # we need to also change the id for sync to work fake_subscriptions [ 1 ][ \"status\" ] = \"canceled\" fake_subscriptions [ 1 ][ \"id\" ] = fake_subscriptions [ 1 ][ \"id\" ] + \"foo1\" fake_subscriptions [ 2 ][ \"status\" ] = \"incomplete_expired\" fake_subscriptions [ 2 ][ \"id\" ] = fake_subscriptions [ 2 ][ \"id\" ] + \"foo2\" for fake_subscription in fake_subscriptions : with patch ( \"stripe.Subscription.create\" , autospec = True , side_effect = [ fake_subscription ], ): self . customer . subscribe ( price = price , charge_immediately = False ) self . assertEqual ( 3 , self . customer . subscriptions . count ()) self . assertEqual ( 1 , len ( self . customer . valid_subscriptions )) self . assertEqual ( self . customer . valid_subscriptions [ 0 ], self . customer . subscription ) self . assertEqual ( fake_subscriptions [ 0 ][ \"id\" ], self . customer . subscription . id ) tests . test_customer . TestCustomer . test_subscription_shortcut_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscription_shortcut_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . assert_fks ( price , expected_blank_fks = {}) subscription_fake_duplicate = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake_duplicate [ \"id\" ] = \"sub_6lsC8pt7IcF8jd\" subscription_create_mock . side_effect = [ deepcopy ( FAKE_SUBSCRIPTION ), subscription_fake_duplicate , ] self . customer . subscribe ( price = price , charge_immediately = False ) self . customer . subscribe ( price = price , charge_immediately = False ) self . assertEqual ( 2 , self . customer . subscriptions . count ()) self . assertEqual ( 2 , len ( self . customer . valid_subscriptions )) with self . assertRaises ( MultipleSubscriptionException ): self . customer . subscription tests . test_customer . TestCustomer . test_sync_charges ( self , customer_retrieve_mock , charge_list_mock , charge_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Charge.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Charge.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_CHARGE )]), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_charges ( self , customer_retrieve_mock , charge_list_mock , charge_sync_mock ): self . customer . _sync_charges () self . assertEqual ( 1 , charge_sync_mock . call_count ) tests . test_customer . TestCustomer . test_sync_charges_none ( self , customer_retrieve_mock , charge_list_mock , charge_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Charge.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Charge.list\" , return_value = StripeList ( data = []), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_charges_none ( self , customer_retrieve_mock , charge_list_mock , charge_sync_mock ): self . customer . _sync_charges () self . assertEqual ( 0 , charge_sync_mock . call_count ) tests . test_customer . TestCustomer . test_sync_customer_delete_discount ( self ) Source code in tests/test_customer.py def test_sync_customer_delete_discount ( self ): test_coupon = Coupon . sync_from_stripe_data ( FAKE_COUPON ) self . customer . coupon = test_coupon self . customer . save () self . assertEqual ( self . customer . coupon . id , FAKE_COUPON [ \"id\" ]) customer = Customer . sync_from_stripe_data ( FAKE_CUSTOMER ) self . assertEqual ( customer . coupon , None ) tests . test_customer . TestCustomer . test_sync_customer_discount_already_present ( self , coupon_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Coupon.retrieve\" , return_value = deepcopy ( FAKE_COUPON ), autospec = True ) def test_sync_customer_discount_already_present ( self , coupon_retrieve_mock ): fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"discount\" ] = deepcopy ( FAKE_DISCOUNT_CUSTOMER ) # Set the customer's coupon to be what we'll sync customer = Customer . objects . get ( id = FAKE_CUSTOMER [ \"id\" ]) customer . coupon = Coupon . sync_from_stripe_data ( FAKE_COUPON ) customer . save () customer = Customer . sync_from_stripe_data ( fake_customer ) self . assertEqual ( customer . coupon . id , FAKE_COUPON [ \"id\" ]) tests . test_customer . TestCustomer . test_sync_customer_with_discount ( self , coupon_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Coupon.retrieve\" , return_value = deepcopy ( FAKE_COUPON ), autospec = True ) def test_sync_customer_with_discount ( self , coupon_retrieve_mock ): self . assertIsNone ( self . customer . coupon ) fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"discount\" ] = deepcopy ( FAKE_DISCOUNT_CUSTOMER ) customer = Customer . sync_from_stripe_data ( fake_customer ) self . assertEqual ( customer . coupon . id , FAKE_COUPON [ \"id\" ]) self . assertIsNotNone ( customer . coupon_start ) self . assertIsNone ( customer . coupon_end ) tests . test_customer . TestCustomer . test_sync_invoices ( self , customer_retrieve_mock , invoice_list_mock , invoice_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Invoice.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_INVOICE ), deepcopy ( FAKE_INVOICE_III )] ), ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_invoices ( self , customer_retrieve_mock , invoice_list_mock , invoice_sync_mock ): self . customer . _sync_invoices () self . assertEqual ( 2 , invoice_sync_mock . call_count ) tests . test_customer . TestCustomer . test_sync_invoices_none ( self , customer_retrieve_mock , invoice_list_mock , invoice_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Invoice.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = []), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_invoices_none ( self , customer_retrieve_mock , invoice_list_mock , invoice_sync_mock ): self . customer . _sync_invoices () self . assertEqual ( 0 , invoice_sync_mock . call_count ) tests . test_customer . TestCustomer . test_sync_subscriptions ( self , customer_retrieve_mock , subscription_list_mock , subscription_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Subscription.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Subscription.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_SUBSCRIPTION ), deepcopy ( FAKE_SUBSCRIPTION_II )] ), ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_subscriptions ( self , customer_retrieve_mock , subscription_list_mock , subscription_sync_mock ): self . customer . _sync_subscriptions () self . assertEqual ( 2 , subscription_sync_mock . call_count ) tests . test_customer . TestCustomer . test_sync_subscriptions_none ( self , customer_retrieve_mock , subscription_list_mock , subscription_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Subscription.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Subscription.list\" , return_value = StripeList ( data = []), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_subscriptions_none ( self , customer_retrieve_mock , subscription_list_mock , subscription_sync_mock ): self . customer . _sync_subscriptions () self . assertEqual ( 0 , subscription_sync_mock . call_count ) tests . test_customer . TestCustomer . test_upcoming_invoice_plan ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.upcoming\" , return_value = deepcopy ( FAKE_UPCOMING_INVOICE ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_upcoming_invoice_plan ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): invoice = self . customer . upcoming_invoice () self . assertIsNotNone ( invoice ) self . assertIsNone ( invoice . id ) self . assertIsNone ( invoice . save ()) subscription_retrieve_mock . assert_called_once_with ( api_key = ANY , expand = ANY , id = FAKE_SUBSCRIPTION [ \"id\" ], stripe_account = None ) plan_retrieve_mock . assert_not_called () items = invoice . invoiceitems . all () self . assertEqual ( 1 , len ( items )) self . assertEqual ( FAKE_SUBSCRIPTION [ \"id\" ], items [ 0 ] . id ) self . assertIsNotNone ( invoice . plan ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) invoice . _invoiceitems = [] items = invoice . invoiceitems . all () self . assertEqual ( 0 , len ( items )) self . assertIsNotNone ( invoice . plan ) tests.test_customer.TestCustomerLegacy Methods tests . test_customer . TestCustomerLegacy . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_customer.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . payment_method , _ = DjstripePaymentMethod . _get_or_create_source ( FAKE_CARD , \"card\" ) self . card = self . payment_method . resolve () self . customer . default_source = self . payment_method self . customer . save () self . account = default_account () tests . test_customer . TestCustomerLegacy . test_has_active_subscription_with_plan ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_has_active_subscription_with_plan ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_create_mock . return_value = subscription_fake self . customer . subscribe ( plan = plan , charge_immediately = False ) self . customer . has_active_subscription ( plan = plan ) tests . test_customer . TestCustomerLegacy . test_has_active_subscription_with_plan_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_has_active_subscription_with_plan_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_create_mock . return_value = subscription_fake self . customer . subscribe ( plan = plan , charge_immediately = False ) self . customer . has_active_subscription ( plan = plan . id ) tests . test_customer . TestCustomerLegacy . test_has_active_subscription_with_unspecified_plan_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_has_active_subscription_with_unspecified_plan_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . assert_fks ( plan , expected_blank_fks = {}) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_fake_duplicate = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake_duplicate [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_fake_duplicate [ \"id\" ] = \"sub_6lsC8pt7IcF8jd\" subscription_create_mock . side_effect = [ subscription_fake , subscription_fake_duplicate , ] self . customer . subscribe ( plan = plan , charge_immediately = False ) self . customer . subscribe ( plan = plan , charge_immediately = False ) self . assertEqual ( 2 , self . customer . subscriptions . count ()) with self . assertRaises ( TypeError ): self . customer . has_active_subscription () tests . test_customer . TestCustomerLegacy . test_subscribe_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . assert_fks ( plan , expected_blank_fks = {}) self . customer . subscribe ( plan = plan , charge_immediately = True ) self . assertTrue ( send_invoice_mock . called ) tests . test_customer . TestCustomerLegacy . test_subscribe_not_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_not_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . customer . subscribe ( plan = plan , charge_immediately = False ) self . assertFalse ( send_invoice_mock . called ) tests . test_customer . TestCustomerLegacy . test_subscribe_plan_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_plan_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . assert_fks ( plan , expected_blank_fks = {}) self . customer . subscribe ( plan = plan . id , charge_immediately = True ) self . assertTrue ( send_invoice_mock . called ) tests . test_customer . TestCustomerLegacy . test_subscription_shortcut_with_invalid_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscription_shortcut_with_invalid_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . assert_fks ( plan , expected_blank_fks = {}) fake_subscriptions = [ deepcopy ( FAKE_SUBSCRIPTION ), deepcopy ( FAKE_SUBSCRIPTION ), deepcopy ( FAKE_SUBSCRIPTION ), ] # update the status of all but one to be invalid, # we need to also change the id for sync to work fake_subscriptions [ 1 ][ \"status\" ] = \"canceled\" fake_subscriptions [ 1 ][ \"id\" ] = fake_subscriptions [ 1 ][ \"id\" ] + \"foo1\" fake_subscriptions [ 2 ][ \"status\" ] = \"incomplete_expired\" fake_subscriptions [ 2 ][ \"id\" ] = fake_subscriptions [ 2 ][ \"id\" ] + \"foo2\" for fake_subscription in fake_subscriptions : with patch ( \"stripe.Subscription.create\" , autospec = True , side_effect = [ fake_subscription ], ): self . customer . subscribe ( plan = plan , charge_immediately = False ) self . assertEqual ( 3 , self . customer . subscriptions . count ()) self . assertEqual ( 1 , len ( self . customer . valid_subscriptions )) self . assertEqual ( self . customer . valid_subscriptions [ 0 ], self . customer . subscription ) self . assertEqual ( fake_subscriptions [ 0 ][ \"id\" ], self . customer . subscription . id ) tests . test_customer . TestCustomerLegacy . test_subscription_shortcut_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscription_shortcut_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . assert_fks ( plan , expected_blank_fks = {}) subscription_fake_duplicate = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake_duplicate [ \"id\" ] = \"sub_6lsC8pt7IcF8jd\" subscription_create_mock . side_effect = [ deepcopy ( FAKE_SUBSCRIPTION ), subscription_fake_duplicate , ] self . customer . subscribe ( plan = plan , charge_immediately = False ) self . customer . subscribe ( plan = plan , charge_immediately = False ) self . assertEqual ( 2 , self . customer . subscriptions . count ()) self . assertEqual ( 2 , len ( self . customer . valid_subscriptions )) with self . assertRaises ( MultipleSubscriptionException ): self . customer . subscription tests . test_customer . TestCustomerLegacy . test_upcoming_invoice ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.upcoming\" , return_value = deepcopy ( FAKE_UPCOMING_INVOICE ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_upcoming_invoice ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): invoice = self . customer . upcoming_invoice () self . assertIsNotNone ( invoice ) self . assertIsNone ( invoice . id ) self . assertIsNone ( invoice . save ()) subscription_retrieve_mock . assert_called_once_with ( api_key = ANY , expand = ANY , id = FAKE_SUBSCRIPTION [ \"id\" ], stripe_account = None ) plan_retrieve_mock . assert_not_called () items = invoice . invoiceitems . all () self . assertEqual ( 1 , len ( items )) self . assertEqual ( FAKE_SUBSCRIPTION [ \"id\" ], items [ 0 ] . id ) self . assertIsNotNone ( invoice . plan ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) invoice . _invoiceitems = [] items = invoice . invoiceitems . all () self . assertEqual ( 0 , len ( items )) self . assertIsNotNone ( invoice . plan ) tests.test_decorators dj-stripe Decorator Tests. Classes tests.test_decorators.TestSubscriptionPaymentRequired Methods tests . test_decorators . TestSubscriptionPaymentRequired . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_decorators.py def setUp ( self ): self . settings ( ROOT_URLCONF = \"tests.urls\" ) self . factory = RequestFactory () @subscription_payment_required def test_view ( request ): return HttpResponse () @subscription_payment_required ( pay_page = None ) def test_view_bad ( request ): return HttpResponse () self . test_view = test_view self . test_view_bad = test_view_bad tests . test_decorators . TestSubscriptionPaymentRequired . test_anonymous ( self ) Source code in tests/test_decorators.py def test_anonymous ( self ): request = self . factory . get ( \"/account/\" ) request . user = AnonymousUser () with self . assertRaises ( ImproperlyConfigured ): self . test_view ( request ) tests . test_decorators . TestSubscriptionPaymentRequired . test_direct ( self ) Source code in tests/test_decorators.py def test_direct ( self ): subscription_payment_required ( function = None ) tests . test_decorators . TestSubscriptionPaymentRequired . test_user_active_subscription ( self , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_decorators.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_user_active_subscription ( self , product_retrieve_mock , plan_retrieve_mock ): user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER . create_for_user ( user ) subscription = Subscription . sync_from_stripe_data ( deepcopy ( FAKE_SUBSCRIPTION )) subscription . current_period_end = FUTURE_DATE subscription . save () request = self . factory . get ( \"/account/\" ) request . user = user response = self . test_view ( request ) self . assertEqual ( response . status_code , 200 ) tests . test_decorators . TestSubscriptionPaymentRequired . test_user_unpaid ( self ) Source code in tests/test_decorators.py def test_user_unpaid ( self ): user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER . create_for_user ( user ) request = self . factory . get ( \"/account/\" ) request . user = user response = self . test_view ( request ) self . assertEqual ( response . status_code , 302 ) with self . assertRaises ( ImproperlyConfigured ): self . test_view_bad ( request ) tests.test_django tests.test_django.TestRunManagePyCheck tests . test_django . TestRunManagePyCheck . test_manage_py_check ( self ) Source code in tests/test_django.py def test_manage_py_check ( self ): call_command ( \"check\" ) tests.test_enums tests.test_enums.TestEnumMetaClass tests . test_enums . TestEnumMetaClass . test_python2_prepare ( self ) Source code in tests/test_enums.py def test_python2_prepare ( self ): # Python 2 hack to ensure __prepare__ is called... self . assertEqual ( EnumMetaClass . __prepare__ ( None , None ), OrderedDict ()) tests.test_event dj-stripe Event Model Tests. Classes tests.test_event.EventRaceConditionTest tests . test_event . EventRaceConditionTest . test_process_event_race_condition ( self , transfer_retrieve_mock ) Source code in tests/test_event.py @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) def test_process_event_race_condition ( self , transfer_retrieve_mock ): transfer = Transfer . sync_from_stripe_data ( deepcopy ( FAKE_TRANSFER )) transfer_retrieve_mock . reset_mock () event_data = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) # emulate the race condition in _get_or_create_from_stripe_object where # an object is created by a different request during the call # # Sequence of events: # 1) first Transfer.stripe_objects.get fails with DoesNotExist # (due to it not existing in reality, but due to our side_effect in the test) # 2) object is really created by a different request in reality # 3) Transfer._create_from_stripe_object fails with IntegrityError due to # duplicate id # 4) second Transfer.stripe_objects.get succeeds # (due to being created by step 2 in reality, due to side effect in the test) side_effect = [ Transfer . DoesNotExist (), transfer ] with patch ( \"djstripe.models.Transfer.stripe_objects.get\" , side_effect = side_effect , autospec = True , ) as transfer_objects_get_mock : Event . process ( event_data ) self . assertEqual ( transfer_objects_get_mock . call_count , 2 ) self . assertEqual ( transfer_retrieve_mock . call_count , 1 ) tests.test_event.EventTest Methods tests . test_event . EventTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_event.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) patcher = patch . object ( webhooks , \"call_handlers\" ) self . addCleanup ( patcher . stop ) self . call_handlers = patcher . start () tests . test_event . EventTest . test_invoke_webhook_handlers_event_when_invalid ( self ) Source code in tests/test_event.py def test_invoke_webhook_handlers_event_when_invalid ( self ): event = self . _create_event ( FAKE_EVENT_TRANSFER_CREATED ) event . valid = False event . invoke_webhook_handlers () tests . test_event . EventTest . test_invoke_webhook_handlers_event_with_log_stripe_error ( self ) Source code in tests/test_event.py def test_invoke_webhook_handlers_event_with_log_stripe_error ( self ): event = self . _create_event ( FAKE_EVENT_TRANSFER_CREATED ) self . call_handlers . side_effect = StripeError ( \"Boom!\" ) with self . assertRaises ( StripeError ): event . invoke_webhook_handlers () tests . test_event . EventTest . test_invoke_webhook_handlers_event_with_raise_stripe_error ( self ) Source code in tests/test_event.py def test_invoke_webhook_handlers_event_with_raise_stripe_error ( self ): event = self . _create_event ( FAKE_EVENT_TRANSFER_CREATED ) self . call_handlers . side_effect = StripeError ( \"Boom!\" ) with self . assertRaises ( StripeError ): event . invoke_webhook_handlers () tests . test_event . EventTest . test_process_event ( self , mock_objects , mock__create_from_stripe_object , mock_atomic ) Test that process event creates a new event and invokes webhooks when the event doesn't already exist. Source code in tests/test_event.py @patch ( target = \"djstripe.models.core.transaction.atomic\" , autospec = True ) @patch . object ( target = Event , attribute = \"_create_from_stripe_object\" , autospec = True ) @patch . object ( target = Event , attribute = \"objects\" , autospec = True ) def test_process_event ( self , mock_objects , mock__create_from_stripe_object , mock_atomic ): \"\"\"Test that process event creates a new event and invokes webhooks when the event doesn't already exist. \"\"\" # Set up mocks mock_objects . filter . return_value . exists . return_value = False mock_data = { \"id\" : \"foo_id\" , \"other_stuff\" : \"more_things\" } result = Event . process ( data = mock_data ) # Check that all the expected work was performed mock_objects . filter . assert_called_once_with ( id = mock_data [ \"id\" ]) mock_objects . filter . return_value . exists . assert_called_once_with () mock_atomic . return_value . __enter__ . assert_called_once_with () mock__create_from_stripe_object . assert_called_once_with ( mock_data ) ( mock__create_from_stripe_object . return_value . invoke_webhook_handlers ) . assert_called_once_with () # Make sure the event was returned. self . assertEqual ( mock__create_from_stripe_object . return_value , result ) tests . test_event . EventTest . test_process_event_exists ( self , mock_objects , mock__create_from_stripe_object , mock_atomic ) Test that process event returns the existing event and skips webhook processing when the event already exists. Source code in tests/test_event.py @patch ( target = \"djstripe.models.core.transaction.atomic\" , autospec = True ) @patch . object ( target = Event , attribute = \"_create_from_stripe_object\" , autospec = True ) @patch . object ( target = Event , attribute = \"objects\" , autospec = True ) def test_process_event_exists ( self , mock_objects , mock__create_from_stripe_object , mock_atomic ): \"\"\" Test that process event returns the existing event and skips webhook processing when the event already exists. \"\"\" # Set up mocks mock_objects . filter . return_value . exists . return_value = True mock_data = { \"id\" : \"foo_id\" , \"other_stuff\" : \"more_things\" } result = Event . process ( data = mock_data ) # Make sure that the db was queried and the existing results used. mock_objects . filter . assert_called_once_with ( id = mock_data [ \"id\" ]) mock_objects . filter . return_value . exists . assert_called_once_with () mock_objects . filter . return_value . first . assert_called_once_with () # Make sure the webhook actions and event object creation were not performed. mock_atomic . return_value . __enter__ . assert_not_called () mock__create_from_stripe_object . assert_not_called () ( mock__create_from_stripe_object . return_value . invoke_webhook_handlers ) . assert_not_called () # Make sure the existing event was returned. self . assertEqual ( mock_objects . filter . return_value . first . return_value , result ) tests . test_event . EventTest . test_process_event_failure_rolls_back ( self , invoke_webhook_handlers_mock ) Test that process event rolls back event creation on error Source code in tests/test_event.py @patch ( \"djstripe.models.Event.invoke_webhook_handlers\" , autospec = True ) def test_process_event_failure_rolls_back ( self , invoke_webhook_handlers_mock ): \"\"\"Test that process event rolls back event creation on error\"\"\" class HandlerException ( Exception ): pass invoke_webhook_handlers_mock . side_effect = HandlerException real_create_from_stripe_object = Event . _create_from_stripe_object def side_effect ( * args , ** kwargs ): return real_create_from_stripe_object ( * args , ** kwargs ) event_data = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) self . assertFalse ( Event . objects . filter ( id = FAKE_EVENT_TRANSFER_CREATED [ \"id\" ]) . exists () ) with self . assertRaises ( HandlerException ), patch ( \"djstripe.models.Event._create_from_stripe_object\" , side_effect = side_effect , autospec = True , ) as create_from_stripe_object_mock : Event . process ( data = event_data ) create_from_stripe_object_mock . assert_called_once_with ( event_data ) self . assertFalse ( Event . objects . filter ( id = FAKE_EVENT_TRANSFER_CREATED [ \"id\" ]) . exists () ) tests . test_event . EventTest . test_str ( self ) Source code in tests/test_event.py def test_str ( self ): event = self . _create_event ( FAKE_EVENT_TRANSFER_CREATED ) self . assertEqual ( \"<type= {type} , id= {id} >\" . format ( type = FAKE_EVENT_TRANSFER_CREATED [ \"type\" ], id = FAKE_EVENT_TRANSFER_CREATED [ \"id\" ], ), str ( event ), ) tests.test_event_handlers dj-stripe Event Handler tests Classes tests.test_event_handlers.EventTestCase tests.test_event_handlers.TestAccountEvents tests . test_event_handlers . TestAccountEvents . test_account_deauthorized_event ( self , event_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_account_deauthorized_event ( self , event_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_ACCOUNT_APPLICATION_DEAUTHORIZED ) event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () tests.test_event_handlers.TestChargeEvents Methods tests . test_event_handlers . TestChargeEvents . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_event_handlers.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) tests . test_event_handlers . TestChargeEvents . test_charge_created ( self , subscription_retrieve_mock , product_retrieve_mock , invoice_retrieve_mock , event_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_charge_created ( self , subscription_retrieve_mock , product_retrieve_mock , invoice_retrieve_mock , event_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , account_mock , ): FAKE_CUSTOMER . create_for_user ( self . user ) fake_stripe_event = deepcopy ( FAKE_EVENT_CHARGE_SUCCEEDED ) event_retrieve_mock . return_value = fake_stripe_event charge_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] account_mock . return_value = default_account () event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () charge = Charge . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( charge . amount , fake_stripe_event [ \"data\" ][ \"object\" ][ \"amount\" ] / Decimal ( \"100\" ), ) self . assertEqual ( charge . status , fake_stripe_event [ \"data\" ][ \"object\" ][ \"status\" ]) tests.test_event_handlers.TestCustomerEvents Methods tests . test_event_handlers . TestCustomerEvents . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_event_handlers.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_event_handlers . TestCustomerEvents . test_customer_bogus_event_type ( self , event_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_customer_bogus_event_type ( self , event_retrieve_mock , customer_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_CREATED ) fake_stripe_event [ \"data\" ][ \"object\" ][ \"customer\" ] = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] fake_stripe_event [ \"type\" ] = \"customer.praised\" event_retrieve_mock . return_value = fake_stripe_event customer_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () tests . test_event_handlers . TestCustomerEvents . test_customer_card_created ( self , event_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Customer.retrieve\" , return_value = FAKE_CUSTOMER , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_customer_card_created ( self , event_retrieve_mock , customer_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_SOURCE_CREATED ) event_retrieve_mock . return_value = fake_stripe_event event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () card = Card . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertIn ( card , self . customer . legacy_cards . all ()) self . assertEqual ( card . brand , fake_stripe_event [ \"data\" ][ \"object\" ][ \"brand\" ]) self . assertEqual ( card . last4 , fake_stripe_event [ \"data\" ][ \"object\" ][ \"last4\" ]) tests . test_event_handlers . TestCustomerEvents . test_customer_created ( self , event_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Customer.retrieve\" , return_value = FAKE_CUSTOMER , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_customer_created ( self , event_retrieve_mock , customer_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_CREATED ) event_retrieve_mock . return_value = fake_stripe_event event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () customer = Customer . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( customer . balance , fake_stripe_event [ \"data\" ][ \"object\" ][ \"balance\" ] ) self . assertEqual ( customer . currency , fake_stripe_event [ \"data\" ][ \"object\" ][ \"currency\" ] ) tests . test_event_handlers . TestCustomerEvents . test_customer_default_source_deleted ( self ) Source code in tests/test_event_handlers.py def test_customer_default_source_deleted ( self ): self . customer . default_source = DjstripePaymentMethod . objects . get ( id = FAKE_CARD [ \"id\" ] ) self . customer . save () self . assertIsNotNone ( self . customer . default_source ) self . assertTrue ( self . customer . has_valid_source ()) event = self . _create_event ( FAKE_EVENT_CUSTOMER_SOURCE_DELETED ) event . invoke_webhook_handlers () customer = Customer . objects . get ( id = FAKE_CUSTOMER [ \"id\" ]) self . assertIsNone ( customer . default_source ) self . assertFalse ( customer . has_valid_source ()) tests . test_event_handlers . TestCustomerEvents . test_customer_deleted ( self , customer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Customer.retrieve\" , return_value = FAKE_CUSTOMER , autospec = True ) def test_customer_deleted ( self , customer_retrieve_mock ): FAKE_CUSTOMER . create_for_user ( self . user ) event = self . _create_event ( FAKE_EVENT_CUSTOMER_CREATED ) event . invoke_webhook_handlers () event = self . _create_event ( FAKE_EVENT_CUSTOMER_DELETED ) event . invoke_webhook_handlers () customer = Customer . objects . get ( id = FAKE_CUSTOMER [ \"id\" ]) self . assertIsNotNone ( customer . date_purged ) tests . test_event_handlers . TestCustomerEvents . test_customer_discount_created ( self , event_retrieve_mock , coupon_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Coupon.retrieve\" , return_value = FAKE_COUPON , autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = FAKE_EVENT_CUSTOMER_DISCOUNT_CREATED , autospec = True , ) def test_customer_discount_created ( self , event_retrieve_mock , coupon_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_DISCOUNT_CREATED ) event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () self . assertIsNotNone ( event . customer ) self . assertEqual ( event . customer . id , FAKE_CUSTOMER [ \"id\" ]) self . assertIsNotNone ( event . customer . coupon ) tests . test_event_handlers . TestCustomerEvents . test_customer_discount_deleted ( self , event_retrieve_mock , coupon_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Coupon.retrieve\" , return_value = FAKE_COUPON , autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = FAKE_EVENT_CUSTOMER_DISCOUNT_DELETED , autospec = True , ) def test_customer_discount_deleted ( self , event_retrieve_mock , coupon_retrieve_mock ): coupon = Coupon . sync_from_stripe_data ( FAKE_COUPON ) self . customer . coupon = coupon fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_DISCOUNT_DELETED ) event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () self . assertIsNotNone ( event . customer ) self . assertEqual ( event . customer . id , FAKE_CUSTOMER [ \"id\" ]) self . assertIsNone ( event . customer . coupon ) tests . test_event_handlers . TestCustomerEvents . test_customer_source_double_delete ( self ) Source code in tests/test_event_handlers.py def test_customer_source_double_delete ( self ): event = self . _create_event ( FAKE_EVENT_CUSTOMER_SOURCE_DELETED ) event . invoke_webhook_handlers () event = self . _create_event ( FAKE_EVENT_CUSTOMER_SOURCE_DELETED_DUPE ) event . invoke_webhook_handlers () tests . test_event_handlers . TestCustomerEvents . test_customer_subscription_created ( self , event_retrieve_mock , product_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_customer_subscription_created ( self , event_retrieve_mock , product_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock , ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED ) event_retrieve_mock . return_value = fake_stripe_event event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () subscription = Subscription . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assertIn ( subscription , self . customer . subscriptions . all ()) self . assertEqual ( subscription . status , fake_stripe_event [ \"data\" ][ \"object\" ][ \"status\" ] ) self . assertEqual ( subscription . quantity , fake_stripe_event [ \"data\" ][ \"object\" ][ \"quantity\" ] ) tests . test_event_handlers . TestCustomerEvents . test_customer_subscription_deleted ( self , customer_retrieve_mock , product_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_customer_subscription_deleted ( self , customer_retrieve_mock , product_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock , ): event = self . _create_event ( FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED ) event . invoke_webhook_handlers () sub = Subscription . objects . get ( id = FAKE_SUBSCRIPTION [ \"id\" ]) self . assertEqual ( sub . status , SubscriptionStatus . active ) subscription_retrieve_mock . return_value = deepcopy ( FAKE_SUBSCRIPTION_CANCELED ) event = self . _create_event ( FAKE_EVENT_CUSTOMER_SUBSCRIPTION_DELETED ) event . invoke_webhook_handlers () sub = Subscription . objects . get ( id = FAKE_SUBSCRIPTION [ \"id\" ]) # Check that Subscription is canceled and not deleted self . assertEqual ( sub . status , SubscriptionStatus . canceled ) self . assertIsNotNone ( sub . canceled_at ) tests . test_event_handlers . TestCustomerEvents . test_customer_unknown_source_created ( self , event_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_customer_unknown_source_created ( self , event_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_SOURCE_CREATED ) fake_stripe_event [ \"data\" ][ \"object\" ][ \"object\" ] = \"unknown\" fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] = \"card_xxx_test_customer_unk_source_created\" event_retrieve_mock . return_value = fake_stripe_event FAKE_CUSTOMER . create_for_user ( self . user ) event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () self . assertFalse ( Card . objects . filter ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) . exists () ) tests.test_event_handlers.TestDisputeEvents tests . test_event_handlers . TestDisputeEvents . test_dispute_created ( self , event_retrieve_mock , dispute_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Dispute.retrieve\" , return_value = deepcopy ( FAKE_DISPUTE ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_DISPUTE_CREATED ), autospec = True , ) def test_dispute_created ( self , event_retrieve_mock , dispute_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_DISPUTE_CREATED ) event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () dispute = Dispute . objects . get () self . assertEqual ( dispute . id , FAKE_DISPUTE [ \"id\" ]) tests.test_event_handlers.TestInvoiceEvents tests . test_event_handlers . TestInvoiceEvents . test_invoice_created ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , event_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_created ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , event_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = default_account () user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER . create_for_user ( user ) fake_stripe_event = deepcopy ( FAKE_EVENT_INVOICE_CREATED ) event_retrieve_mock . return_value = fake_stripe_event invoice_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () invoice = Invoice . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( invoice . amount_due , fake_stripe_event [ \"data\" ][ \"object\" ][ \"amount_due\" ] / Decimal ( \"100\" ), ) self . assertEqual ( invoice . paid , fake_stripe_event [ \"data\" ][ \"object\" ][ \"paid\" ]) tests . test_event_handlers . TestInvoiceEvents . test_invoice_created_no_existing_customer ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , event_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_created_no_existing_customer ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , event_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = default_account () fake_stripe_event = deepcopy ( FAKE_EVENT_INVOICE_CREATED ) event_retrieve_mock . return_value = fake_stripe_event invoice_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () self . assertEqual ( Customer . objects . count (), 1 ) customer = Customer . objects . get () self . assertEqual ( customer . subscriber , None ) tests . test_event_handlers . TestInvoiceEvents . test_invoice_deleted ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_deleted ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = default_account () user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER . create_for_user ( user ) event = self . _create_event ( FAKE_EVENT_INVOICE_CREATED ) event . invoke_webhook_handlers () Invoice . objects . get ( id = FAKE_INVOICE [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_INVOICE_DELETED ) event . invoke_webhook_handlers () with self . assertRaises ( Invoice . DoesNotExist ): Invoice . objects . get ( id = FAKE_INVOICE [ \"id\" ]) tests . test_event_handlers . TestInvoiceEvents . test_invoice_upcoming ( self ) Source code in tests/test_event_handlers.py def test_invoice_upcoming ( self ): # Ensure that invoice upcoming events are processed - No actual # process occurs so the operation is an effective no-op. event = self . _create_event ( FAKE_EVENT_INVOICE_UPCOMING ) event . invoke_webhook_handlers () tests.test_event_handlers.TestInvoiceItemEvents tests . test_event_handlers . TestInvoiceItemEvents . test_invoiceitem_created ( self , product_retrieve_mock , event_retrieve_mock , invoiceitem_retrieve_mock , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) @patch ( \"stripe.InvoiceItem.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoiceitem_created ( self , product_retrieve_mock , event_retrieve_mock , invoiceitem_retrieve_mock , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = default_account () user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER_II . create_for_user ( user ) fake_stripe_event = deepcopy ( FAKE_EVENT_INVOICEITEM_CREATED ) event_retrieve_mock . return_value = fake_stripe_event invoiceitem_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () invoiceitem = InvoiceItem . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assertEqual ( invoiceitem . amount , fake_stripe_event [ \"data\" ][ \"object\" ][ \"amount\" ] / Decimal ( \"100\" ), ) tests . test_event_handlers . TestInvoiceItemEvents . test_invoiceitem_deleted ( self , product_retrieve_mock , invoiceitem_retrieve_mock , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) @patch ( \"stripe.InvoiceItem.retrieve\" , return_value = deepcopy ( FAKE_INVOICEITEM ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoiceitem_deleted ( self , product_retrieve_mock , invoiceitem_retrieve_mock , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = default_account () user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER_II . create_for_user ( user ) event = self . _create_event ( FAKE_EVENT_INVOICEITEM_CREATED ) event . invoke_webhook_handlers () InvoiceItem . objects . get ( id = FAKE_INVOICEITEM [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_INVOICEITEM_DELETED ) event . invoke_webhook_handlers () with self . assertRaises ( InvoiceItem . DoesNotExist ): InvoiceItem . objects . get ( id = FAKE_INVOICEITEM [ \"id\" ]) tests.test_event_handlers.TestPaymentIntentEvents Test case for payment intent event handling. Methods tests . test_event_handlers . TestPaymentIntentEvents . test_payment_intent_succeeded_with_destination_charge ( self , customer_retrieve_mock , account_retrieve_mock , file_upload_retrieve_mock , payment_intent_retrieve_mock , payment_method_retrieve_mock ) Test that the payment intent succeeded event can create all related objects. This should exercise the machinery to set stripe_account when recursing into objects related to a connect Account . Source code in tests/test_event_handlers.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Account.retrieve\" , return_value = deepcopy ( FAKE_ACCOUNT ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.FileUpload.retrieve\" , side_effect = ( deepcopy ( FAKE_FILEUPLOAD_ICON ), deepcopy ( FAKE_FILEUPLOAD_LOGO )), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_DESTINATION_CHARGE ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I ), autospec = True , ) def test_payment_intent_succeeded_with_destination_charge ( self , customer_retrieve_mock , account_retrieve_mock , file_upload_retrieve_mock , payment_intent_retrieve_mock , payment_method_retrieve_mock , ): \"\"\"Test that the payment intent succeeded event can create all related objects. This should exercise the machinery to set `stripe_account` when recursing into objects related to a connect `Account`. \"\"\" event = self . _create_event ( FAKE_EVENT_PAYMENT_INTENT_SUCCEEDED_DESTINATION_CHARGE ) event . invoke_webhook_handlers () # Make sure the file uploads were retrieved using the account ID. file_upload_retrieve_mock . assert_has_calls ( ( call ( id = FAKE_FILEUPLOAD_ICON [ \"id\" ], api_key = ANY , expand = ANY , stripe_account = FAKE_ACCOUNT [ \"id\" ], ), call ( id = FAKE_FILEUPLOAD_LOGO [ \"id\" ], api_key = ANY , expand = ANY , stripe_account = FAKE_ACCOUNT [ \"id\" ], ), ) ) tests.test_event_handlers.TestPaymentMethodEvents Methods tests . test_event_handlers . TestPaymentMethodEvents . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_event_handlers.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"fake_customer_1\" , email = FAKE_CUSTOMER [ \"email\" ] ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_event_handlers . TestPaymentMethodEvents . test_card_payment_method_attached ( self , event_retrieve_mock , payment_method_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.PaymentMethod.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_card_payment_method_attached ( self , event_retrieve_mock , payment_method_retrieve_mock ): # Attach of a legacy id=\"card_xxx\" payment method should behave exactly # as per a normal \"native\" id=\"pm_yyy\" payment_method. fake_stripe_event = deepcopy ( FAKE_EVENT_CARD_PAYMENT_METHOD_ATTACHED ) event_retrieve_mock . return_value = fake_stripe_event payment_method_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () payment_method = PaymentMethod . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_event_handlers . TestPaymentMethodEvents . test_card_payment_method_detached ( self , event_retrieve_mock , payment_method_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.PaymentMethod.retrieve\" , side_effect = InvalidRequestError ( message = \"No such payment_method: card_xxxx\" , param = \"payment_method\" , code = \"resource_missing\" , ), autospec = True , ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_card_payment_method_detached ( self , event_retrieve_mock , payment_method_retrieve_mock ): # Detach of a legacy id=\"card_xxx\" payment method is handled specially, # since the card is deleted by Stripe and therefore PaymetMethod.retrieve fails fake_stripe_event = deepcopy ( FAKE_EVENT_CARD_PAYMENT_METHOD_DETACHED ) event_retrieve_mock . return_value = fake_stripe_event payment_method_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () self . assertEqual ( PaymentMethod . objects . filter ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) . count (), 0 , \"Detach of a 'card_' payment_method should delete it\" , ) tests . test_event_handlers . TestPaymentMethodEvents . test_payment_method_attached ( self , event_retrieve_mock , payment_method_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.PaymentMethod.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_payment_method_attached ( self , event_retrieve_mock , payment_method_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_PAYMENT_METHOD_ATTACHED ) event_retrieve_mock . return_value = fake_stripe_event payment_method_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () payment_method = PaymentMethod . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_event_handlers . TestPaymentMethodEvents . test_payment_method_detached ( self , event_retrieve_mock , payment_method_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.PaymentMethod.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_payment_method_detached ( self , event_retrieve_mock , payment_method_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_PAYMENT_METHOD_DETACHED ) event_retrieve_mock . return_value = fake_stripe_event payment_method_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () payment_method = PaymentMethod . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assertIsNone ( payment_method . customer , \"Detach of a payment_method should set customer to null\" , ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.PaymentMethod.customer\" } ) tests.test_event_handlers.TestPlanEvents tests . test_event_handlers . TestPlanEvents . test_plan_created ( self , product_retrieve_mock , event_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_plan_created ( self , product_retrieve_mock , event_retrieve_mock , plan_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_PLAN_CREATED ) event_retrieve_mock . return_value = fake_stripe_event plan_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () plan = Plan . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( plan . nickname , fake_stripe_event [ \"data\" ][ \"object\" ][ \"nickname\" ]) tests . test_event_handlers . TestPlanEvents . test_plan_deleted ( self , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Plan.retrieve\" , return_value = FAKE_PLAN , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_plan_deleted ( self , product_retrieve_mock , plan_retrieve_mock ): event = self . _create_event ( FAKE_EVENT_PLAN_CREATED ) event . invoke_webhook_handlers () Plan . objects . get ( id = FAKE_PLAN [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_PLAN_DELETED ) event . invoke_webhook_handlers () with self . assertRaises ( Plan . DoesNotExist ): Plan . objects . get ( id = FAKE_PLAN [ \"id\" ]) tests . test_event_handlers . TestPlanEvents . test_plan_updated_request_object ( self , product_retrieve_mock , event_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Plan.retrieve\" , return_value = FAKE_PLAN , autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = FAKE_EVENT_PLAN_REQUEST_IS_OBJECT , autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_plan_updated_request_object ( self , product_retrieve_mock , event_retrieve_mock , plan_retrieve_mock ): plan_retrieve_mock . return_value = FAKE_EVENT_PLAN_REQUEST_IS_OBJECT [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( FAKE_EVENT_PLAN_REQUEST_IS_OBJECT ) event . invoke_webhook_handlers () plan = Plan . objects . get ( id = FAKE_EVENT_PLAN_REQUEST_IS_OBJECT [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assertEqual ( plan . nickname , FAKE_EVENT_PLAN_REQUEST_IS_OBJECT [ \"data\" ][ \"object\" ][ \"nickname\" ], ) tests.test_event_handlers.TestPriceEvents tests . test_event_handlers . TestPriceEvents . test_price_created ( self , product_retrieve_mock , event_retrieve_mock , price_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Price.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_price_created ( self , product_retrieve_mock , event_retrieve_mock , price_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_PRICE_CREATED ) event_retrieve_mock . return_value = fake_stripe_event price_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () price = Price . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( price . nickname , fake_stripe_event [ \"data\" ][ \"object\" ][ \"nickname\" ] ) tests . test_event_handlers . TestPriceEvents . test_price_deleted ( self , product_retrieve_mock , price_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Price.retrieve\" , return_value = FAKE_PRICE , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_price_deleted ( self , product_retrieve_mock , price_retrieve_mock ): event = self . _create_event ( FAKE_EVENT_PRICE_CREATED ) event . invoke_webhook_handlers () Price . objects . get ( id = FAKE_PRICE [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_PRICE_DELETED ) event . invoke_webhook_handlers () with self . assertRaises ( Price . DoesNotExist ): Price . objects . get ( id = FAKE_PRICE [ \"id\" ]) tests . test_event_handlers . TestPriceEvents . test_price_updated ( self , product_retrieve_mock , event_retrieve_mock , price_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Price.retrieve\" , return_value = FAKE_PRICE , autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = FAKE_EVENT_PRICE_UPDATED , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_price_updated ( self , product_retrieve_mock , event_retrieve_mock , price_retrieve_mock ): price_retrieve_mock . return_value = FAKE_EVENT_PRICE_UPDATED [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( FAKE_EVENT_PRICE_UPDATED ) event . invoke_webhook_handlers () price = Price . objects . get ( id = FAKE_EVENT_PRICE_UPDATED [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( price . unit_amount , FAKE_EVENT_PRICE_UPDATED [ \"data\" ][ \"object\" ][ \"unit_amount\" ], ) self . assertEqual ( price . unit_amount_decimal , Decimal ( FAKE_EVENT_PRICE_UPDATED [ \"data\" ][ \"object\" ][ \"unit_amount_decimal\" ]), ) tests.test_event_handlers.TestSubscriptionScheduleEvents tests . test_event_handlers . TestSubscriptionScheduleEvents . test_subscription_schedule_canceled ( self , customer_retrieve_mock , schedule_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.SubscriptionSchedule.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) def test_subscription_schedule_canceled ( self , customer_retrieve_mock , schedule_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED ) fake_stripe_event [ \"data\" ][ \"object\" ][ \"canceled_at\" ] = 1605058030 fake_stripe_event [ \"data\" ][ \"object\" ][ \"status\" ] = \"canceled\" fake_stripe_event [ \"data\" ][ \"previous_attributes\" ] = { \"canceled_at\" : None , \"status\" : \"not_started\" , } schedule_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () schedule = SubscriptionSchedule . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) assert schedule . status == \"canceled\" assert schedule . canceled_at is not None schedule_retrieve_mock . return_value = FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CANCELED [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CANCELED ) event . invoke_webhook_handlers () schedule . refresh_from_db () assert schedule . status == \"canceled\" assert schedule . canceled_at is not None tests . test_event_handlers . TestSubscriptionScheduleEvents . test_subscription_schedule_created ( self , customer_retrieve_mock , schedule_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.SubscriptionSchedule.retrieve\" , return_value = FAKE_SUBSCRIPTION_SCHEDULE , autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) def test_subscription_schedule_created ( self , customer_retrieve_mock , schedule_retrieve_mock ): event = Event . sync_from_stripe_data ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED ) event . invoke_webhook_handlers () schedule = SubscriptionSchedule . objects . get ( id = FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED [ \"data\" ][ \"object\" ][ \"id\" ] ) assert ( schedule . id == FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED [ \"data\" ][ \"object\" ][ \"id\" ] ) assert schedule . status == \"not_started\" tests . test_event_handlers . TestSubscriptionScheduleEvents . test_subscription_schedule_released ( self , customer_retrieve_mock , schedule_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.SubscriptionSchedule.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) def test_subscription_schedule_released ( self , customer_retrieve_mock , schedule_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED ) fake_stripe_event [ \"data\" ][ \"object\" ][ \"released_at\" ] = 1605058030 fake_stripe_event [ \"data\" ][ \"object\" ][ \"status\" ] = \"released\" fake_stripe_event [ \"data\" ][ \"previous_attributes\" ] = { \"released_at\" : None , \"status\" : \"not_started\" , } schedule_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () schedule = SubscriptionSchedule . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) assert schedule . status == \"released\" assert schedule . released_at is not None schedule_retrieve_mock . return_value = FAKE_EVENT_SUBSCRIPTION_SCHEDULE_RELEASED [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_RELEASED ) event . invoke_webhook_handlers () schedule . refresh_from_db () assert schedule . status == \"released\" assert schedule . released_at is not None tests . test_event_handlers . TestSubscriptionScheduleEvents . test_subscription_schedule_updated ( self , customer_retrieve_mock , schedule_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.SubscriptionSchedule.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) def test_subscription_schedule_updated ( self , customer_retrieve_mock , schedule_retrieve_mock ): schedule_retrieve_mock . return_value = FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED ) event . invoke_webhook_handlers () schedule = SubscriptionSchedule . objects . get ( id = FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED [ \"data\" ][ \"object\" ][ \"id\" ] ) assert schedule . status == \"not_started\" assert schedule . released_at is None fake_stripe_event = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED ) fake_stripe_event [ \"data\" ][ \"object\" ][ \"released_at\" ] = 1605058030 fake_stripe_event [ \"data\" ][ \"object\" ][ \"status\" ] = \"released\" fake_stripe_event [ \"data\" ][ \"previous_attributes\" ] = { \"released_at\" : None , \"status\" : \"not_started\" , } schedule_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () schedule = SubscriptionSchedule . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) assert schedule . status == \"released\" assert schedule . released_at is not None tests.test_event_handlers.TestTransferEvents tests . test_event_handlers . TestTransferEvents . test_transfer_created ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Transfer.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_transfer_created ( self , event_retrieve_mock , transfer_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) event_retrieve_mock . return_value = fake_stripe_event transfer_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () transfer = Transfer . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( transfer . amount , fake_stripe_event [ \"data\" ][ \"object\" ][ \"amount\" ] / Decimal ( \"100\" ), ) tests . test_event_handlers . TestTransferEvents . test_transfer_deleted ( self , transfer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Transfer.retrieve\" , return_value = FAKE_TRANSFER , autospec = True ) def test_transfer_deleted ( self , transfer_retrieve_mock ): event = self . _create_event ( FAKE_EVENT_TRANSFER_CREATED ) event . invoke_webhook_handlers () Transfer . objects . get ( id = FAKE_TRANSFER [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_TRANSFER_DELETED ) event . invoke_webhook_handlers () with self . assertRaises ( Transfer . DoesNotExist ): Transfer . objects . get ( id = FAKE_TRANSFER [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_TRANSFER_DELETED ) event . invoke_webhook_handlers () tests.test_fields dj-stripe Custom Field Tests. tests.test_fields.TestStripeCurrencyField tests . test_fields . TestStripeCurrencyField . noval tests . test_fields . TestStripeCurrencyField . test_stripe_to_db_none_val ( self ) Source code in tests/test_fields.py def test_stripe_to_db_none_val ( self ): self . assertEqual ( None , self . noval . stripe_to_db ({ \"noval\" : None })) tests.test_file_upload Functions tests . test_file_upload . test_file_upload_api_retrieve ( mock_file_upload_retrieve ) Expect file_upload to use the ID of the account referring to it to retrieve itself. Source code in tests/test_file_upload.py @pytest . mark . django_db @patch ( target = \"stripe.FileUpload.retrieve\" , autospec = True , return_value = deepcopy ( FAKE_FILEUPLOAD_ICON ), ) def test_file_upload_api_retrieve ( mock_file_upload_retrieve ): \"\"\"Expect file_upload to use the ID of the account referring to it to retrieve itself. \"\"\" # Create files icon_file = FileUpload . _get_or_create_from_stripe_object ( data = FAKE_FILEUPLOAD_ICON )[ 0 ] logo_file = FileUpload . _get_or_create_from_stripe_object ( data = FAKE_FILEUPLOAD_LOGO )[ 0 ] # Create account to associate the files to it account = Account . _get_or_create_from_stripe_object ( data = FAKE_ACCOUNT )[ 0 ] # Call the API retrieve methods. icon_file . api_retrieve () logo_file . api_retrieve () # Ensure the correct Account ID was used in retrieval mock_file_upload_retrieve . assert_has_calls ( ( call ( id = icon_file . id , api_key = ANY , expand = ANY , stripe_account = account . id ), call ( id = logo_file . id , api_key = ANY , expand = ANY , stripe_account = account . id ), ) ) tests.test_idempotency_keys tests.test_idempotency_keys.IdempotencyKeyTest tests . test_idempotency_keys . IdempotencyKeyTest . test_clear_expired_idempotency_keys ( self ) Source code in tests/test_idempotency_keys.py def test_clear_expired_idempotency_keys ( self ): expired_key = get_idempotency_key ( \"customer\" , \"create:1\" , False ) expired_key_obj = IdempotencyKey . objects . get ( uuid = expired_key ) expired_key_obj . created = now () - timedelta ( hours = 25 ) expired_key_obj . save () valid_key = get_idempotency_key ( \"customer\" , \"create:2\" , False ) self . assertEqual ( IdempotencyKey . objects . count (), 2 ) clear_expired_idempotency_keys () self . assertEqual ( IdempotencyKey . objects . count (), 1 ) self . assertEqual ( str ( IdempotencyKey . objects . get () . uuid ), valid_key ) tests . test_idempotency_keys . IdempotencyKeyTest . test_generate_idempotency_key ( self ) Source code in tests/test_idempotency_keys.py def test_generate_idempotency_key ( self ): key1 = get_idempotency_key ( \"customer\" , \"create:1\" , False ) key2 = get_idempotency_key ( \"customer\" , \"create:1\" , False ) self . assertTrue ( key1 == key2 ) key3 = get_idempotency_key ( \"customer\" , \"create:2\" , False ) self . assertTrue ( key1 != key3 ) key4 = get_idempotency_key ( \"charge\" , \"create:1\" , False ) self . assertTrue ( key1 != key4 ) self . assertEqual ( IdempotencyKey . objects . count (), 3 ) key1_obj = IdempotencyKey . objects . get ( action = \"customer:create:1\" , livemode = False ) self . assertFalse ( key1_obj . is_expired ) self . assertEqual ( str ( key1_obj ), str ( key1_obj . uuid )) tests.test_integrations special tests.test_invoice dj-stripe Invoice Model Tests. Classes tests.test_invoice.InvoiceTest Methods tests . test_invoice . InvoiceTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_invoice.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . default_expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Invoice.default_payment_method\" , \"djstripe.Invoice.default_source\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , \"djstripe.Subscription.default_payment_method\" , \"djstripe.Subscription.default_source\" , \"djstripe.Subscription.pending_setup_intent\" , \"djstripe.Subscription.schedule\" , } tests . test_invoice . InvoiceTest . test_billing_reason_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_billing_reason_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_invoice = deepcopy ( FAKE_INVOICE ) for billing_reason in ( \"subscription_cycle\" , \"subscription_create\" , \"subscription_update\" , \"subscription\" , \"manual\" , \"upcoming\" , \"subscription_threshold\" , ): fake_invoice [ \"billing_reason\" ] = billing_reason invoice = Invoice . sync_from_stripe_data ( fake_invoice ) self . assertEqual ( invoice . billing_reason , billing_reason ) # trigger model field validation (including enum value choices check) invoice . full_clean () tests . test_invoice . InvoiceTest . test_invoice_plan_from_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_plan_from_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertIsNotNone ( invoice . plan ) # retrieved from invoice item self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_invoice_plan_from_subscription ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_plan_from_subscription ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data [ \"lines\" ][ \"data\" ][ 0 ][ \"plan\" ] = None invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertIsNotNone ( invoice . plan ) # retrieved from subscription self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_invoice_status_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_status_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_invoice = deepcopy ( FAKE_INVOICE ) for status in ( \"draft\" , \"open\" , \"paid\" , \"uncollectible\" , \"void\" , ): fake_invoice [ \"status\" ] = status invoice = Invoice . sync_from_stripe_data ( fake_invoice ) self . assertEqual ( invoice . status , status ) # trigger model field validation (including enum value choices check) invoice . full_clean () tests . test_invoice . InvoiceTest . test_invoice_with_no_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_with_no_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data [ \"lines\" ] = [] invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertIsNotNone ( invoice . plan ) # retrieved from invoice item self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_invoice_with_non_subscription_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_with_non_subscription_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data [ \"lines\" ][ \"data\" ] . append ( deepcopy ( FAKE_INVOICEITEM_II )) invoice_data [ \"lines\" ][ \"total_count\" ] += 1 invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertIsNotNone ( invoice ) self . assertEqual ( 2 , len ( invoice . invoiceitems . all ())) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_invoice_with_subscription_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_with_subscription_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice = Invoice . sync_from_stripe_data ( invoice_data ) items = invoice . invoiceitems . all () self . assertEqual ( 1 , len ( items )) # Previously the test asserted item_id=\"{invoice_id}-{subscription_id}\", # but this doesn't match what I'm seeing from Stripe # I'm not sure if it's possible to predict the whole item id now, # sli seems to not reference anything item_id_prefix = \" {invoice_id} -il_\" . format ( invoice_id = invoice . id ) self . assertTrue ( items [ 0 ] . id . startswith ( item_id_prefix )) self . assertEqual ( items [ 0 ] . subscription . id , FAKE_SUBSCRIPTION [ \"id\" ]) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_invoice_without_plan ( self , product_retrieve_mock , charge_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_without_plan ( self , product_retrieve_mock , charge_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data [ \"lines\" ][ \"data\" ][ 0 ][ \"plan\" ] = None invoice_data [ \"lines\" ][ \"data\" ][ 0 ][ \"subscription\" ] = None invoice_data [ \"subscription\" ] = None invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertIsNone ( invoice . plan ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Invoice.subscription\" }, ) tests . test_invoice . InvoiceTest . test_no_upcoming_invoices ( self , invoice_upcoming_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Invoice.upcoming\" , side_effect = InvalidRequestError ( \"Nothing to invoice for customer\" , None ), ) def test_no_upcoming_invoices ( self , invoice_upcoming_mock ): invoice = Invoice . upcoming () self . assertIsNone ( invoice ) tests . test_invoice . InvoiceTest . test_retry_false ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , invoice_retrieve_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_retry_false ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , invoice_retrieve_mock , ): default_account_mock . return_value = self . account fake_invoice = deepcopy ( FAKE_INVOICE ) invoice_retrieve_mock . return_value = fake_invoice invoice = Invoice . sync_from_stripe_data ( fake_invoice ) return_value = invoice . retry () self . assertFalse ( invoice_retrieve_mock . called ) self . assertFalse ( return_value ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_retry_true ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , invoice_retrieve_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_retry_true ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , invoice_retrieve_mock , ): default_account_mock . return_value = self . account fake_invoice = deepcopy ( FAKE_INVOICE ) fake_invoice . update ({ \"paid\" : False , \"status\" : \"open\" }) fake_invoice . update ({ \"auto_advance\" : True }) invoice_retrieve_mock . return_value = fake_invoice invoice = Invoice . sync_from_stripe_data ( fake_invoice ) return_value = invoice . retry () invoice_retrieve_mock . assert_called_once_with ( id = invoice . id , api_key = STRIPE_SECRET_KEY , expand = [], stripe_account = None ) self . assertTrue ( return_value ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_status_draft ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_draft ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data . update ({ \"paid\" : False , \"status\" : \"draft\" }) invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertEqual ( InvoiceStatus . draft , invoice . status ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_status_open ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_open ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data . update ({ \"paid\" : False , \"status\" : \"open\" }) invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertEqual ( InvoiceStatus . open , invoice . status ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_status_paid ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_paid ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice = Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) self . assertEqual ( InvoiceStatus . paid , invoice . status ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_status_uncollectible ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_uncollectible ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data . update ({ \"paid\" : False , \"status\" : \"uncollectible\" }) invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertEqual ( InvoiceStatus . uncollectible , invoice . status ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_status_void ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_void ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data . update ({ \"paid\" : False , \"status\" : \"void\" }) invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertEqual ( InvoiceStatus . void , invoice . status ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_sync_from_stripe_data ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_sync_from_stripe_data ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice = Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) self . assertEqual ( invoice . get_stripe_dashboard_url (), self . customer . get_stripe_dashboard_url () ) self . assertEqual ( str ( invoice ), \"Invoice # {} \" . format ( FAKE_INVOICE [ \"number\" ])) self . assertGreater ( len ( invoice . status_transitions . keys ()), 1 ) self . assertTrue ( bool ( invoice . account_country )) self . assertTrue ( bool ( invoice . account_name )) self . assertTrue ( bool ( invoice . collection_method )) self . assertEqual ( invoice . default_tax_rates . count (), 1 ) self . assertEqual ( invoice . default_tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( invoice . total_tax_amounts . count (), 1 ) first_tax_amount = invoice . total_tax_amounts . first () self . assertEqual ( first_tax_amount . tax_rate . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( first_tax_amount . inclusive , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"inclusive\" ] ) self . assertEqual ( first_tax_amount . amount , 261 ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_sync_from_stripe_data_default_payment_method ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_sync_from_stripe_data_default_payment_method ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_invoice = deepcopy ( FAKE_INVOICE ) fake_invoice [ \"default_payment_method\" ] = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ) invoice = Invoice . sync_from_stripe_data ( fake_invoice ) self . assertEqual ( invoice . default_payment_method . id , FAKE_CARD_AS_PAYMENT_METHOD [ \"id\" ] ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks - { \"djstripe.Invoice.default_payment_method\" }, ) tests . test_invoice . InvoiceTest . test_sync_from_stripe_data_update_total_tax_amounts ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_sync_from_stripe_data_update_total_tax_amounts ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice = Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) # as per basic sync test self . assertEqual ( invoice . default_tax_rates . count (), 1 ) self . assertEqual ( invoice . default_tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( invoice . total_tax_amounts . count (), 1 ) first_tax_amount = invoice . total_tax_amounts . first () self . assertEqual ( first_tax_amount . tax_rate . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( first_tax_amount . inclusive , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"inclusive\" ] ) self . assertEqual ( first_tax_amount . amount , 261 ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) # Now update with a different tax rate # TODO - should update tax rate in invoice items etc as well, # but here we're mainly testing that invoice.total_tax_rates is # correctly updated fake_updated_invoice = deepcopy ( FAKE_INVOICE ) fake_tax_rate_2 = deepcopy ( FAKE_TAX_RATE_EXAMPLE_2_SALES ) new_tax_amount = int ( fake_updated_invoice [ \"total\" ] * fake_tax_rate_2 [ \"percentage\" ] / 100 ) fake_updated_invoice . update ( { \"default_tax_rates\" : [ fake_tax_rate_2 ], \"tax\" : new_tax_amount , \"total\" : fake_updated_invoice [ \"total\" ] + new_tax_amount , \"total_tax_amounts\" : [ { \"amount\" : new_tax_amount , \"inclusive\" : False , \"tax_rate\" : fake_tax_rate_2 [ \"id\" ], } ], } ) invoice_updated = Invoice . sync_from_stripe_data ( fake_updated_invoice ) self . assertEqual ( invoice_updated . default_tax_rates . count (), 1 ) self . assertEqual ( invoice_updated . default_tax_rates . first () . id , fake_tax_rate_2 [ \"id\" ] ) self . assertEqual ( invoice_updated . total_tax_amounts . count (), 1 ) first_tax_amount = invoice_updated . total_tax_amounts . first () self . assertEqual ( first_tax_amount . tax_rate . id , fake_tax_rate_2 [ \"id\" ]) self . assertEqual ( first_tax_amount . inclusive , fake_tax_rate_2 [ \"inclusive\" ]) self . assertEqual ( first_tax_amount . amount , new_tax_amount ) self . assert_fks ( invoice_updated , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_sync_no_subscription ( self , product_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_sync_no_subscription ( self , product_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data . update ({ \"subscription\" : None }) invoice_data [ \"lines\" ][ \"data\" ][ 0 ][ \"subscription\" ] = None invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertEqual ( None , invoice . subscription ) self . assertEqual ( FAKE_CHARGE [ \"id\" ], invoice . charge . id ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) # charge_retrieve_mock.assert_not_called() plan_retrieve_mock . assert_not_called () subscription_retrieve_mock . assert_not_called () self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Invoice.subscription\" }, ) tests . test_invoice . InvoiceTest . test_upcoming_invoice ( self , product_retrieve_mock , invoice_upcoming_mock , subscription_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.upcoming\" , return_value = deepcopy ( FAKE_UPCOMING_INVOICE ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_upcoming_invoice ( self , product_retrieve_mock , invoice_upcoming_mock , subscription_retrieve_mock , plan_retrieve_mock , ): invoice = UpcomingInvoice . upcoming () self . assertIsNotNone ( invoice ) self . assertIsNone ( invoice . id ) self . assertIsNone ( invoice . save ()) self . assertEqual ( invoice . get_stripe_dashboard_url (), \"\" ) invoice . id = \"foo\" self . assertIsNone ( invoice . id ) subscription_retrieve_mock . assert_called_once_with ( api_key = ANY , expand = ANY , id = FAKE_SUBSCRIPTION [ \"id\" ], stripe_account = None ) plan_retrieve_mock . assert_not_called () items = invoice . invoiceitems . all () self . assertEqual ( 1 , len ( items )) self . assertEqual ( FAKE_SUBSCRIPTION [ \"id\" ], items [ 0 ] . id ) # delete/update should do nothing self . assertEqual ( invoice . invoiceitems . update (), 0 ) self . assertEqual ( invoice . invoiceitems . delete (), 0 ) self . assertIsNotNone ( invoice . plan ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) invoice . _invoiceitems = [] items = invoice . invoiceitems . all () self . assertEqual ( 0 , len ( items )) self . assertIsNotNone ( invoice . plan ) self . assertEqual ( invoice . default_tax_rates . count (), 1 ) self . assertEqual ( invoice . default_tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( invoice . total_tax_amounts . count (), 1 ) first_tax_amount = invoice . total_tax_amounts . first () self . assertEqual ( first_tax_amount . tax_rate . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( first_tax_amount . inclusive , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"inclusive\" ] ) self . assertEqual ( first_tax_amount . amount , 261 ) tests . test_invoice . InvoiceTest . test_upcoming_invoice_error ( self , invoice_upcoming_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Invoice.upcoming\" , side_effect = InvalidRequestError ( \"Some other error\" , None ), ) def test_upcoming_invoice_error ( self , invoice_upcoming_mock ): with self . assertRaises ( InvalidRequestError ): Invoice . upcoming () tests . test_invoice . InvoiceTest . test_upcoming_invoice_with_subscription ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.upcoming\" , return_value = deepcopy ( FAKE_UPCOMING_INVOICE ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_upcoming_invoice_with_subscription ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): invoice = Invoice . upcoming ( subscription = Subscription ( id = FAKE_SUBSCRIPTION [ \"id\" ]) ) self . assertIsNotNone ( invoice ) self . assertIsNone ( invoice . id ) self . assertIsNone ( invoice . save ()) subscription_retrieve_mock . assert_called_once_with ( api_key = ANY , expand = ANY , id = FAKE_SUBSCRIPTION [ \"id\" ], stripe_account = None ) plan_retrieve_mock . assert_not_called () self . assertIsNotNone ( invoice . plan ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) tests . test_invoice . InvoiceTest . test_upcoming_invoice_with_subscription_plan ( self , product_retrieve_mock , invoice_upcoming_mock , subscription_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.upcoming\" , return_value = deepcopy ( FAKE_UPCOMING_INVOICE ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_upcoming_invoice_with_subscription_plan ( self , product_retrieve_mock , invoice_upcoming_mock , subscription_retrieve_mock , plan_retrieve_mock , ): invoice = Invoice . upcoming ( subscription_plan = Plan ( id = FAKE_PLAN [ \"id\" ])) self . assertIsNotNone ( invoice ) self . assertIsNone ( invoice . id ) self . assertIsNone ( invoice . save ()) subscription_retrieve_mock . assert_called_once_with ( api_key = ANY , expand = ANY , id = FAKE_SUBSCRIPTION [ \"id\" ], stripe_account = None ) plan_retrieve_mock . assert_not_called () self . assertIsNotNone ( invoice . plan ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) tests.test_invoiceitem dj-stripe InvoiceItem Model Tests. Classes tests.test_invoiceitem.InvoiceItemTest Methods tests . test_invoiceitem . InvoiceItemTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_invoiceitem.py def setUp ( self ): self . account = default_account () self . default_expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , \"djstripe.Invoice.default_payment_method\" , \"djstripe.Invoice.default_source\" , \"djstripe.Invoice.payment_intent\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , \"djstripe.Subscription.default_payment_method\" , \"djstripe.Subscription.default_source\" , \"djstripe.Subscription.pending_setup_intent\" , \"djstripe.Subscription.schedule\" , } tests . test_invoiceitem . InvoiceItemTest . test_str ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) def test_str ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM ) invoiceitem_data [ \"plan\" ] = FAKE_PLAN_II invoiceitem_data [ \"price\" ] = FAKE_PRICE_II invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assertEqual ( invoiceitem . get_stripe_dashboard_url (), invoiceitem . invoice . get_stripe_dashboard_url (), ) assert str ( invoiceitem ) == invoiceitem . description tests . test_invoiceitem . InvoiceItemTest . test_sync_expanded_invoice_with_subscription ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) def test_sync_expanded_invoice_with_subscription ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM ) # Expand the Invoice data invoiceitem_data . update ( { \"subscription\" : FAKE_SUBSCRIPTION_III [ \"id\" ], \"invoice\" : deepcopy ( dict ( FAKE_INVOICE_II )), } ) invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.InvoiceItem.plan\" , \"djstripe.InvoiceItem.price\" , } self . assert_fks ( invoiceitem , expected_blank_fks = expected_blank_fks ) # Coverage of sync of existing data invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assert_fks ( invoiceitem , expected_blank_fks = expected_blank_fks ) tests . test_invoiceitem . InvoiceItemTest . test_sync_null_invoice ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , price_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Price.retrieve\" , return_value = deepcopy ( FAKE_PRICE_II ), autospec = True ) @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN_II ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) def test_sync_null_invoice ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , price_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM ) invoiceitem_data . update ( { \"proration\" : True , \"plan\" : FAKE_PLAN_II [ \"id\" ], \"price\" : FAKE_PRICE_II [ \"id\" ], \"invoice\" : None , } ) invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assertEqual ( FAKE_PLAN_II [ \"id\" ], invoiceitem . plan . id ) self . assertEqual ( FAKE_PRICE_II [ \"id\" ], invoiceitem . price . id ) self . assert_fks ( invoiceitem , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.InvoiceItem.invoice\" , \"djstripe.InvoiceItem.subscription\" }, ) tests . test_invoiceitem . InvoiceItemTest . test_sync_proration ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , price_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Price.retrieve\" , return_value = deepcopy ( FAKE_PRICE_II ), autospec = True ) @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN_II ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) def test_sync_proration ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , price_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM ) invoiceitem_data . update ( { \"proration\" : True , \"plan\" : FAKE_PLAN_II [ \"id\" ], \"price\" : FAKE_PRICE_II [ \"id\" ], } ) invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assertEqual ( FAKE_PLAN_II [ \"id\" ], invoiceitem . plan . id ) self . assertEqual ( FAKE_PRICE_II [ \"id\" ], invoiceitem . price . id ) self . assert_fks ( invoiceitem , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.InvoiceItem.subscription\" }, ) tests . test_invoiceitem . InvoiceItemTest . test_sync_with_subscription ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) def test_sync_with_subscription ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM ) invoiceitem_data . update ({ \"subscription\" : FAKE_SUBSCRIPTION_III [ \"id\" ]}) invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.InvoiceItem.plan\" , \"djstripe.InvoiceItem.price\" , } self . assert_fks ( invoiceitem , expected_blank_fks = expected_blank_fks ) # Coverage of sync of existing data invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assert_fks ( invoiceitem , expected_blank_fks = expected_blank_fks ) invoice_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_INVOICE_II [ \"id\" ], stripe_account = None , ) tests . test_invoiceitem . InvoiceItemTest . test_sync_with_taxes ( self , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) def test_sync_with_taxes ( self , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM_III ) invoiceitem_data [ \"plan\" ] = FAKE_PLAN_II invoiceitem_data [ \"price\" ] = FAKE_PRICE_II invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assertEqual ( invoiceitem . tax_rates . count (), 1 ) self . assertEqual ( invoiceitem . tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) tests.test_managers dj-stripe Model Manager Tests. Classes tests.test_managers.ChargeManagerTest Methods tests . test_managers . ChargeManagerTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_managers.py def setUp ( self ): customer = Customer . objects . create ( id = \"cus_XXXXXXX\" , livemode = False , balance = 0 , delinquent = False ) self . march_charge = Charge . objects . create ( id = \"ch_XXXXMAR1\" , customer = customer , created = datetime . datetime ( 2015 , 3 , 31 , tzinfo = timezone . utc ), amount = 0 , amount_refunded = 0 , currency = \"usd\" , status = \"pending\" , ) self . april_charge_1 = Charge . objects . create ( id = \"ch_XXXXAPR1\" , customer = customer , created = datetime . datetime ( 2015 , 4 , 1 , tzinfo = timezone . utc ), amount = decimal . Decimal ( \"20.15\" ), amount_refunded = 0 , currency = \"usd\" , status = \"succeeded\" , paid = True , ) self . april_charge_2 = Charge . objects . create ( id = \"ch_XXXXAPR2\" , customer = customer , created = datetime . datetime ( 2015 , 4 , 18 , tzinfo = timezone . utc ), amount = decimal . Decimal ( \"10.35\" ), amount_refunded = decimal . Decimal ( \"5.35\" ), currency = \"usd\" , status = \"succeeded\" , paid = True , ) self . april_charge_3 = Charge . objects . create ( id = \"ch_XXXXAPR3\" , customer = customer , created = datetime . datetime ( 2015 , 4 , 30 , tzinfo = timezone . utc ), amount = decimal . Decimal ( \"100.00\" ), amount_refunded = decimal . Decimal ( \"80.00\" ), currency = \"usd\" , status = \"pending\" , paid = False , ) self . may_charge = Charge . objects . create ( id = \"ch_XXXXMAY1\" , customer = customer , created = datetime . datetime ( 2015 , 5 , 1 , tzinfo = timezone . utc ), amount = 0 , amount_refunded = 0 , currency = \"usd\" , status = \"pending\" , ) self . november_charge = Charge . objects . create ( id = \"ch_XXXXNOV1\" , customer = customer , created = datetime . datetime ( 2015 , 11 , 16 , tzinfo = timezone . utc ), amount = 0 , amount_refunded = 0 , currency = \"usd\" , status = \"pending\" , ) self . charge_2014 = Charge . objects . create ( id = \"ch_XXXX20141\" , customer = customer , created = datetime . datetime ( 2014 , 12 , 31 , tzinfo = timezone . utc ), amount = 0 , amount_refunded = 0 , currency = \"usd\" , status = \"pending\" , ) self . charge_2016 = Charge . objects . create ( id = \"ch_XXXX20161\" , customer = customer , created = datetime . datetime ( 2016 , 1 , 1 , tzinfo = timezone . utc ), amount = 0 , amount_refunded = 0 , currency = \"usd\" , status = \"pending\" , ) tests . test_managers . ChargeManagerTest . test_get_paid_totals_for_april_2015 ( self ) Source code in tests/test_managers.py def test_get_paid_totals_for_april_2015 ( self ): paid_totals = Charge . objects . paid_totals_for ( year = 2015 , month = 4 ) self . assertEqual ( decimal . Decimal ( \"30.50\" ), paid_totals [ \"total_amount\" ], \"Total amount is not correct.\" , ) self . assertEqual ( decimal . Decimal ( \"5.35\" ), paid_totals [ \"total_refunded\" ], \"Total amount refunded is not correct.\" , ) tests . test_managers . ChargeManagerTest . test_is_during_april_2015 ( self ) Source code in tests/test_managers.py def test_is_during_april_2015 ( self ): raw_charges = Charge . objects . during ( year = 2015 , month = 4 ) charges = [ charge . id for charge in raw_charges ] self . assertIn ( self . april_charge_1 . id , charges , \"April charge 1 not in charges.\" ) self . assertIn ( self . april_charge_2 . id , charges , \"April charge 2 not in charges.\" ) self . assertIn ( self . april_charge_3 . id , charges , \"April charge 3 not in charges.\" ) self . assertNotIn ( self . march_charge . id , charges , \"March charge unexpectedly in charges.\" ) self . assertNotIn ( self . may_charge . id , charges , \"May charge unexpectedly in charges.\" ) self . assertNotIn ( self . november_charge . id , charges , \"November charge unexpectedly in charges.\" ) self . assertNotIn ( self . charge_2014 . id , charges , \"2014 charge unexpectedly in charges.\" ) self . assertNotIn ( self . charge_2016 . id , charges , \"2016 charge unexpectedly in charges.\" ) tests.test_managers.SubscriptionManagerTest Methods tests . test_managers . SubscriptionManagerTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_managers.py def setUp ( self ): # create customers and current subscription records period_start = datetime . datetime ( 2013 , 4 , 1 , tzinfo = timezone . utc ) period_end = datetime . datetime ( 2013 , 4 , 30 , tzinfo = timezone . utc ) start = datetime . datetime ( 2013 , 1 , 1 , 0 , 0 , 1 , tzinfo = timezone . utc ) # more realistic start with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . plan = Plan . sync_from_stripe_data ( FAKE_PLAN ) self . plan2 = Plan . sync_from_stripe_data ( FAKE_PLAN_II ) for i in range ( 10 ): user = get_user_model () . objects . create_user ( username = \"patrick {0} \" . format ( i ), email = \"patrick {0} @example.com\" . format ( i ), ) customer = Customer . objects . create ( subscriber = user , id = \"cus_xxxxxxxxxxxxxx {0} \" . format ( i ), livemode = False , balance = 0 , delinquent = False , ) Subscription . objects . create ( id = \"sub_xxxxxxxxxxxxxx {0} \" . format ( i ), customer = customer , plan = self . plan , current_period_start = period_start , current_period_end = period_end , status = \"active\" , start_date = start , quantity = 1 , ) user = get_user_model () . objects . create_user ( username = \"patrick {0} \" . format ( 11 ), email = \"patrick {0} @example.com\" . format ( 11 ) ) customer = Customer . objects . create ( subscriber = user , id = \"cus_xxxxxxxxxxxxxx {0} \" . format ( 11 ), livemode = False , balance = 0 , delinquent = False , ) Subscription . objects . create ( id = \"sub_xxxxxxxxxxxxxx {0} \" . format ( 11 ), customer = customer , plan = self . plan , current_period_start = period_start , current_period_end = period_end , status = \"canceled\" , canceled_at = period_end , start_date = start , quantity = 1 , ) user = get_user_model () . objects . create_user ( username = \"patrick {0} \" . format ( 12 ), email = \"patrick {0} @example.com\" . format ( 12 ) ) customer = Customer . objects . create ( subscriber = user , id = \"cus_xxxxxxxxxxxxxx {0} \" . format ( 12 ), livemode = False , balance = 0 , delinquent = False , ) Subscription . objects . create ( id = \"sub_xxxxxxxxxxxxxx {0} \" . format ( 12 ), customer = customer , plan = self . plan2 , current_period_start = period_start , current_period_end = period_end , status = \"active\" , start_date = start , quantity = 1 , ) tests . test_managers . SubscriptionManagerTest . test_active_all ( self ) Source code in tests/test_managers.py def test_active_all ( self ): self . assertEqual ( Subscription . objects . active () . count (), 11 ) tests . test_managers . SubscriptionManagerTest . test_active_plan_summary ( self ) Source code in tests/test_managers.py def test_active_plan_summary ( self ): for plan in Subscription . objects . active_plan_summary (): if plan [ \"plan\" ] == self . plan : self . assertEqual ( plan [ \"count\" ], 10 ) if plan [ \"plan\" ] == self . plan2 : self . assertEqual ( plan [ \"count\" ], 1 ) tests . test_managers . SubscriptionManagerTest . test_canceled_all ( self ) Source code in tests/test_managers.py def test_canceled_all ( self ): self . assertEqual ( Subscription . objects . canceled () . count (), 1 ) tests . test_managers . SubscriptionManagerTest . test_canceled_during ( self ) Source code in tests/test_managers.py def test_canceled_during ( self ): self . assertEqual ( Subscription . objects . canceled_during ( 2013 , 4 ) . count (), 1 ) tests . test_managers . SubscriptionManagerTest . test_canceled_plan_summary ( self ) Source code in tests/test_managers.py def test_canceled_plan_summary ( self ): for plan in Subscription . objects . canceled_plan_summary_for ( 2013 , 1 ): if plan [ \"plan\" ] == self . plan : self . assertEqual ( plan [ \"count\" ], 1 ) if plan [ \"plan\" ] == self . plan2 : self . assertEqual ( plan [ \"count\" ], 0 ) tests . test_managers . SubscriptionManagerTest . test_churn ( self ) Source code in tests/test_managers.py def test_churn ( self ): self . assertEqual ( Subscription . objects . churn (), decimal . Decimal ( \"1\" ) / decimal . Decimal ( \"11\" ) ) tests . test_managers . SubscriptionManagerTest . test_started_during_has_records ( self ) Source code in tests/test_managers.py def test_started_during_has_records ( self ): self . assertEqual ( Subscription . objects . started_during ( 2013 , 1 ) . count (), 12 ) tests . test_managers . SubscriptionManagerTest . test_started_during_no_records ( self ) Source code in tests/test_managers.py def test_started_during_no_records ( self ): self . assertEqual ( Subscription . objects . started_during ( 2013 , 4 ) . count (), 0 ) tests . test_managers . SubscriptionManagerTest . test_started_plan_summary ( self ) Source code in tests/test_managers.py def test_started_plan_summary ( self ): for plan in Subscription . objects . started_plan_summary_for ( 2013 , 1 ): if plan [ \"plan\" ] == self . plan : self . assertEqual ( plan [ \"count\" ], 11 ) if plan [ \"plan\" ] == self . plan2 : self . assertEqual ( plan [ \"count\" ], 1 ) tests.test_managers.TransferManagerTest tests . test_managers . TransferManagerTest . test_transfer_summary ( self ) Source code in tests/test_managers.py def test_transfer_summary ( self ): Transfer . sync_from_stripe_data ( deepcopy ( FAKE_TRANSFER )) Transfer . sync_from_stripe_data ( deepcopy ( FAKE_TRANSFER_II )) Transfer . sync_from_stripe_data ( deepcopy ( FAKE_TRANSFER_III )) self . assertEqual ( Transfer . objects . during ( 2015 , 8 ) . count (), 2 ) totals = Transfer . objects . paid_totals_for ( 2015 , 12 ) self . assertEqual ( totals [ \"total_amount\" ], decimal . Decimal ( \"190.10\" )) tests.test_middleware dj-stripe Middleware Tests. Classes tests.test_middleware.MiddlewareLogicTest tests . test_middleware . MiddlewareLogicTest . urlconf Methods tests . test_middleware . MiddlewareLogicTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_middleware.py def setUp ( self ): self . settings ( ROOT_URLCONF = self . urlconf ) self . factory = RequestFactory () self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = Customer . sync_from_stripe_data ( FAKE_CUSTOMER ) self . customer . subscriber = self . user self . customer . save () with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . subscription = Subscription . sync_from_stripe_data ( FAKE_SUBSCRIPTION ) self . middleware = SubscriptionPaymentMiddleware ( lambda r : r ) tests . test_middleware . MiddlewareLogicTest . test_anonymous ( self ) Source code in tests/test_middleware.py def test_anonymous ( self ): request = self . factory . get ( \"/djstripe/webhook/\" ) request . user = AnonymousUser () request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareLogicTest . test_customer_has_active_subscription ( self ) Source code in tests/test_middleware.py def test_customer_has_active_subscription ( self ): self . subscription . current_period_end = FUTURE_DATE self . subscription . save () request = self . factory . get ( \"/testapp_content/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareLogicTest . test_customer_has_inactive_subscription ( self ) Source code in tests/test_middleware.py def test_customer_has_inactive_subscription ( self ): with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . subscription = Subscription . sync_from_stripe_data ( FAKE_SUBSCRIPTION_NOT_PERIOD_CURRENT ) request = self . factory . get ( \"/testapp_content/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response . status_code , 302 ) tests . test_middleware . MiddlewareLogicTest . test_is_staff ( self ) Source code in tests/test_middleware.py def test_is_staff ( self ): self . user . is_staff = True self . user . save () request = self . factory . get ( \"/djstripe/webhook/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareLogicTest . test_is_superuser ( self ) Source code in tests/test_middleware.py def test_is_superuser ( self ): self . user . is_superuser = True self . user . save () request = self . factory . get ( \"/djstripe/webhook/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests.test_middleware.MiddlewareURLTest tests . test_middleware . MiddlewareURLTest . urlconf Methods tests . test_middleware . MiddlewareURLTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_middleware.py def setUp ( self ): self . settings ( ROOT_URLCONF = self . urlconf ) self . factory = RequestFactory () self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . middleware = SubscriptionPaymentMiddleware ( lambda r : r ) tests . test_middleware . MiddlewareURLTest . test_appname ( self ) Source code in tests/test_middleware.py def test_appname ( self ): request = self . factory . get ( \"/admin/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareURLTest . test_djdt ( self ) Source code in tests/test_middleware.py @override_settings ( DEBUG = True ) def test_djdt ( self ): request = self . factory . get ( \"/__debug__/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareURLTest . test_fnmatch ( self ) Source code in tests/test_middleware.py def test_fnmatch ( self ): request = self . factory . get ( \"/test_fnmatch/extra_text/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareURLTest . test_middleware_loads ( self ) Check that the middleware can be loaded by django's middleware handlers. This is to check for compatibility across the change to django's middleware class structure. See https://docs.djangoproject.com/en/1.10/topics/http/middleware/#upgrading-pre-django-1-10-style-middleware Source code in tests/test_middleware.py @override_settings ( DEBUG = True ) @modify_settings ( MIDDLEWARE = { \"append\" : [ \"djstripe.middleware.SubscriptionPaymentMiddleware\" ]} ) def test_middleware_loads ( self ): \"\"\"Check that the middleware can be loaded by django's middleware handlers. This is to check for compatibility across the change to django's middleware class structure. See https://docs.djangoproject.com/en/1.10/topics/http/middleware/#upgrading-pre-django-1-10-style-middleware \"\"\" self . client . get ( \"/__debug__\" ) tests . test_middleware . MiddlewareURLTest . test_namespace ( self ) Source code in tests/test_middleware.py def test_namespace ( self ): request = self . factory . get ( \"/djstripe/webhook/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareURLTest . test_namespace_and_url ( self ) Source code in tests/test_middleware.py def test_namespace_and_url ( self ): request = self . factory . get ( \"/testapp_namespaced/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareURLTest . test_url ( self ) Source code in tests/test_middleware.py def test_url ( self ): request = self . factory . get ( \"/testapp/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests.test_mixins dj-stripe Mixin Tests. Classes tests.test_mixins.TestPaymentsContextMixin tests . test_mixins . TestPaymentsContextMixin . test_get_context_data ( self ) Source code in tests/test_mixins.py def test_get_context_data ( self ): class TestSuperView ( object ): def get_context_data ( self ): return {} class TestView ( PaymentsContextMixin , TestSuperView ): pass context = TestView () . get_context_data () self . assertIn ( \"STRIPE_PUBLIC_KEY\" , context , \"STRIPE_PUBLIC_KEY missing from context.\" ) self . assertEqual ( context [ \"STRIPE_PUBLIC_KEY\" ], STRIPE_PUBLIC_KEY , \"Incorrect STRIPE_PUBLIC_KEY.\" , ) self . assertIn ( \"plans\" , context , \"pans missing from context.\" ) self . assertEqual ( list ( Plan . objects . all ()), list ( context [ \"plans\" ]), \"Incorrect plans.\" ) tests.test_mixins.TestSubscriptionMixin Methods tests . test_mixins . TestSubscriptionMixin . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_mixins.py def setUp ( self ): with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN_II )) tests . test_mixins . TestSubscriptionMixin . test_get_context_data ( self , stripe_create_customer_mock ) Source code in tests/test_mixins.py @patch ( \"stripe.Customer.create\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_get_context_data ( self , stripe_create_customer_mock ): class TestSuperView ( object ): def get_context_data ( self ): return {} class TestView ( SubscriptionMixin , TestSuperView ): pass test_view = TestView () test_view . request = RequestFactory () test_view . request . user = get_user_model () . objects . create ( username = \"x\" , email = \"user@test.com\" ) context = test_view . get_context_data () self . assertIn ( \"is_plans_plural\" , context , \"is_plans_plural missing from context.\" ) self . assertTrue ( context [ \"is_plans_plural\" ], \"Incorrect is_plans_plural.\" ) self . assertIn ( \"customer\" , context , \"customer missing from context.\" ) tests.test_payment_intent dj-stripe PaymentIntent Model Tests. tests.test_payment_intent.PaymentIntentTest tests . test_payment_intent . PaymentIntentTest . test_canceled_intent ( self , customer_retrieve_mock ) Source code in tests/test_payment_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_canceled_intent ( self , customer_retrieve_mock ): fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent [ \"status\" ] = \"canceled\" fake_payment_intent [ \"canceled_at\" ] = 1567524169 for reason in ( None , \"duplicate\" , \"fraudulent\" , \"requested_by_customer\" , \"abandoned\" , \"failed_invoice\" , \"void_invoice\" , \"automatic\" , ): fake_payment_intent [ \"cancellation_reason\" ] = reason payment_intent = PaymentIntent . sync_from_stripe_data ( fake_payment_intent ) if reason is None : # enums nulls are coerced to \"\" by StripeModel._stripe_object_to_record self . assertEqual ( payment_intent . cancellation_reason , \"\" ) else : self . assertEqual ( payment_intent . cancellation_reason , reason ) # trigger model field validation (including enum value choices check) payment_intent . full_clean () tests . test_payment_intent . PaymentIntentTest . test_status_enum ( self , customer_retrieve_mock ) Source code in tests/test_payment_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_status_enum ( self , customer_retrieve_mock ): fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) for status in ( \"requires_payment_method\" , \"requires_confirmation\" , \"requires_action\" , \"processing\" , \"requires_capture\" , \"canceled\" , \"succeeded\" , ): fake_payment_intent [ \"status\" ] = status payment_intent = PaymentIntent . sync_from_stripe_data ( fake_payment_intent ) # trigger model field validation (including enum value choices check) payment_intent . full_clean () tests . test_payment_intent . PaymentIntentTest . test_sync_from_stripe_data ( self , customer_retrieve_mock ) Source code in tests/test_payment_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_from_stripe_data ( self , customer_retrieve_mock ): fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) payment_intent = PaymentIntent . sync_from_stripe_data ( fake_payment_intent ) self . assert_fks ( payment_intent , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , }, ) # TODO - PaymentIntent should probably sync invoice (reverse OneToOneField) # self.assertIsNotNone(payment_intent.invoice) tests.test_payment_method dj-stripe PaymenthMethod Model Tests. Classes tests.test_payment_method.PaymentMethodTest Methods tests . test_payment_method . PaymentMethodTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_payment_method.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"testuser\" , email = \"djstripe@example.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_payment_method . PaymentMethodTest . test_attach ( self , attach_mock ) Source code in tests/test_payment_method.py @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_attach ( self , attach_mock ): payment_method = PaymentMethod . attach ( FAKE_PAYMENT_METHOD_I [ \"id\" ], customer = FAKE_CUSTOMER [ \"id\" ] ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_payment_method . PaymentMethodTest . test_attach_obj ( self , attach_mock ) Source code in tests/test_payment_method.py @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_attach_obj ( self , attach_mock ): pm = PaymentMethod . sync_from_stripe_data ( FAKE_PAYMENT_METHOD_I ) payment_method = PaymentMethod . attach ( pm , customer = self . customer ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_payment_method . PaymentMethodTest . test_attach_synced ( self , attach_mock ) Source code in tests/test_payment_method.py @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_attach_synced ( self , attach_mock ): fake_payment_method = deepcopy ( FAKE_PAYMENT_METHOD_I ) fake_payment_method [ \"customer\" ] = None payment_method = PaymentMethod . sync_from_stripe_data ( fake_payment_method ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.PaymentMethod.customer\" } ) payment_method = PaymentMethod . attach ( payment_method . id , customer = FAKE_CUSTOMER [ \"id\" ] ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_payment_method . PaymentMethodTest . test_detach ( self ) Source code in tests/test_payment_method.py def test_detach ( self ): original_detach = PaymentMethodDict . detach def mocked_detach ( * args , ** kwargs ): return original_detach ( * args , ** kwargs ) with patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I ), autospec = True , ): PaymentMethod . sync_from_stripe_data ( deepcopy ( FAKE_PAYMENT_METHOD_I )) self . assertEqual ( 1 , self . customer . payment_methods . count ()) payment_method = self . customer . payment_methods . first () with patch ( \"tests.PaymentMethodDict.detach\" , side_effect = mocked_detach , autospec = True ) as mock_detach , patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I ), autospec = True , ): self . assertTrue ( payment_method . detach ()) self . assertEqual ( 0 , self . customer . payment_methods . count ()) self . assertIsNone ( self . customer . default_payment_method ) self . assertIsNone ( payment_method . customer ) if sys . version_info >= ( 3 , 6 ): # this mock isn't working on py34, py35, but it's not strictly necessary # for the test mock_detach . assert_called () self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.PaymentMethod.customer\" } ) with patch ( \"tests.PaymentMethodDict.detach\" , side_effect = InvalidRequestError ( message = \"A source must be attached to a customer to be used \" \"as a `payment_method`\" , param = \"payment_method\" , ), autospec = True , ) as mock_detach , patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I ), autospec = True , ) as payment_method_retrieve_mock : payment_method_retrieve_mock . return_value [ \"customer\" ] = None self . assertFalse ( payment_method . detach (), \"Second call to detach should return false\" ) tests . test_payment_method . PaymentMethodTest . test_detach_card ( self ) Source code in tests/test_payment_method.py def test_detach_card ( self ): original_detach = PaymentMethodDict . detach # \"card_\" payment methods are deleted after detach deleted_card_exception = InvalidRequestError ( message = \"No such payment_method: card_xxxx\" , param = \"payment_method\" , code = \"resource_missing\" , ) def mocked_detach ( * args , ** kwargs ): return original_detach ( * args , ** kwargs ) with patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ): PaymentMethod . sync_from_stripe_data ( deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD )) self . assertEqual ( 1 , self . customer . payment_methods . count ()) payment_method = self . customer . payment_methods . first () self . assertTrue ( payment_method . id . startswith ( \"card_\" ), \"We expect this to be a 'card_'\" ) with patch ( \"tests.PaymentMethodDict.detach\" , side_effect = mocked_detach , autospec = True ) as mock_detach , patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ): self . assertTrue ( payment_method . detach ()) self . assertEqual ( 0 , self . customer . payment_methods . count ()) self . assertIsNone ( self . customer . default_payment_method ) self . assertEqual ( PaymentMethod . objects . filter ( id = payment_method . id ) . count (), 0 , \"We expect PaymentMethod id = card_* to be deleted\" , ) if sys . version_info >= ( 3 , 6 ): # this mock isn't working on py34, py35, but it's not strictly necessary # for the test mock_detach . assert_called () with patch ( \"tests.PaymentMethodDict.detach\" , side_effect = InvalidRequestError ( message = \"A source must be attached to a customer to be used \" \"as a `payment_method`\" , param = \"payment_method\" , ), autospec = True , ) as mock_detach , patch ( \"stripe.PaymentMethod.retrieve\" , side_effect = deleted_card_exception , autospec = True , ) as payment_method_retrieve_mock : payment_method_retrieve_mock . return_value [ \"customer\" ] = None self . assertFalse ( payment_method . detach (), \"Second call to detach should return false\" ) tests . test_payment_method . PaymentMethodTest . test_sync_null_customer ( self ) Source code in tests/test_payment_method.py def test_sync_null_customer ( self ): payment_method = PaymentMethod . sync_from_stripe_data ( deepcopy ( FAKE_PAYMENT_METHOD_I ) ) self . assertIsNotNone ( payment_method . customer ) # simulate remote detach fake_payment_method_no_customer = deepcopy ( FAKE_PAYMENT_METHOD_I ) fake_payment_method_no_customer [ \"customer\" ] = None payment_method = PaymentMethod . sync_from_stripe_data ( fake_payment_method_no_customer ) self . assertIsNone ( payment_method . customer ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.PaymentMethod.customer\" } ) tests.test_plan dj-stripe Plan Model Tests. Classes tests.test_plan.HumanReadablePlanTest tests . test_plan . HumanReadablePlanTest . test_human_readable_10_usd_2weeks ( self ) Source code in tests/test_plan.py def test_human_readable_10_usd_2weeks ( self ): plan = Plan . objects . create ( id = \"plan-test-10-usd-2w\" , active = True , amount = 10 , currency = \"usd\" , interval = \"week\" , interval_count = 2 , ) self . assertEqual ( plan . human_readable_price , \"$10.00 USD every 2 weeks\" ) tests . test_plan . HumanReadablePlanTest . test_human_readable_10_usd_weekly ( self ) Source code in tests/test_plan.py def test_human_readable_10_usd_weekly ( self ): plan = Plan . objects . create ( id = \"plan-test-10-usd-weekly\" , active = True , amount = 10 , currency = \"usd\" , interval = \"week\" , interval_count = 1 , ) self . assertEqual ( plan . human_readable_price , \"$10.00 USD/week\" ) tests . test_plan . HumanReadablePlanTest . test_human_readable_10_usd_yearly ( self ) Source code in tests/test_plan.py def test_human_readable_10_usd_yearly ( self ): plan = Plan . objects . create ( id = \"plan-test-10-usd-yearly\" , active = True , amount = 10 , currency = \"usd\" , interval = \"year\" , interval_count = 1 , ) self . assertEqual ( plan . human_readable_price , \"$10.00 USD/year\" ) tests . test_plan . HumanReadablePlanTest . test_human_readable_25_usd_6months ( self ) Source code in tests/test_plan.py def test_human_readable_25_usd_6months ( self ): plan = Plan . objects . create ( id = \"plan-test-25-usd-6m\" , active = True , amount = 25 , currency = \"usd\" , interval = \"month\" , interval_count = 6 , ) self . assertEqual ( plan . human_readable_price , \"$25.00 USD every 6 months\" ) tests . test_plan . HumanReadablePlanTest . test_human_readable_499_usd_monthly ( self ) Source code in tests/test_plan.py def test_human_readable_499_usd_monthly ( self ): plan = Plan . objects . create ( id = \"plan-test-499-usd-monthly\" , active = True , amount = Decimal ( \"4.99\" ), currency = \"usd\" , interval = \"month\" , interval_count = 1 , ) self . assertEqual ( plan . human_readable_price , \"$4.99 USD/month\" ) tests . test_plan . HumanReadablePlanTest . test_human_readable_free_usd_daily ( self ) Source code in tests/test_plan.py def test_human_readable_free_usd_daily ( self ): plan = Plan . objects . create ( id = \"plan-test-free-usd-daily\" , active = True , amount = 0 , currency = \"usd\" , interval = \"day\" , interval_count = 1 , ) self . assertEqual ( plan . human_readable_price , \"$0.00 USD/day\" ) tests.test_plan.PlanCreateTest Methods tests . test_plan . PlanCreateTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_plan.py def setUp ( self ): with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . stripe_product = Product ( id = FAKE_PRODUCT [ \"id\" ]) . api_retrieve () tests . test_plan . PlanCreateTest . test_create_from_djstripe_product ( self , plan_create_mock , product_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Plan.create\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) def test_create_from_djstripe_product ( self , plan_create_mock , product_retrieve_mock ): fake_plan = deepcopy ( FAKE_PLAN ) fake_plan [ \"product\" ] = Product . sync_from_stripe_data ( self . stripe_product ) fake_plan [ \"amount\" ] = fake_plan [ \"amount\" ] / 100 self . assertIsInstance ( fake_plan [ \"product\" ], Product ) plan = Plan . create ( ** fake_plan ) plan_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** FAKE_PLAN ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_plan . PlanCreateTest . test_create_from_product_id ( self , plan_create_mock , product_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Plan.create\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) def test_create_from_product_id ( self , plan_create_mock , product_retrieve_mock ): fake_plan = deepcopy ( FAKE_PLAN ) fake_plan [ \"amount\" ] = fake_plan [ \"amount\" ] / 100 self . assertIsInstance ( fake_plan [ \"product\" ], str ) plan = Plan . create ( ** fake_plan ) expected_create_kwargs = deepcopy ( FAKE_PLAN ) expected_create_kwargs [ \"api_key\" ] = STRIPE_SECRET_KEY plan_create_mock . assert_called_once_with ( ** expected_create_kwargs ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_plan . PlanCreateTest . test_create_from_stripe_product ( self , plan_create_mock , product_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Plan.create\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) def test_create_from_stripe_product ( self , plan_create_mock , product_retrieve_mock ): fake_plan = deepcopy ( FAKE_PLAN ) fake_plan [ \"product\" ] = self . stripe_product fake_plan [ \"amount\" ] = fake_plan [ \"amount\" ] / 100 self . assertIsInstance ( fake_plan [ \"product\" ], dict ) plan = Plan . create ( ** fake_plan ) expected_create_kwargs = deepcopy ( FAKE_PLAN ) expected_create_kwargs [ \"product\" ] = self . stripe_product plan_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** expected_create_kwargs ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_plan . PlanCreateTest . test_create_with_metadata ( self , plan_create_mock , product_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Plan.create\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) def test_create_with_metadata ( self , plan_create_mock , product_retrieve_mock ): metadata = { \"other_data\" : \"more_data\" } fake_plan = deepcopy ( FAKE_PLAN ) fake_plan [ \"amount\" ] = fake_plan [ \"amount\" ] / 100 fake_plan [ \"metadata\" ] = metadata self . assertIsInstance ( fake_plan [ \"product\" ], str ) plan = Plan . create ( ** fake_plan ) expected_create_kwargs = deepcopy ( FAKE_PLAN ) expected_create_kwargs [ \"metadata\" ] = metadata plan_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** expected_create_kwargs ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests.test_plan.PlanTest Methods tests . test_plan . PlanTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_plan.py def setUp ( self ): self . plan_data = deepcopy ( FAKE_PLAN ) with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . plan = Plan . sync_from_stripe_data ( self . plan_data ) tests . test_plan . PlanTest . test_str ( self ) Source code in tests/test_plan.py def test_str ( self ): self . assertEqual ( str ( self . plan ), self . plan_data [ \"nickname\" ]) tests . test_plan . PlanTest . test_stripe_metered_plan ( self , plan_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) def test_stripe_metered_plan ( self , plan_retrieve_mock ): plan_data = deepcopy ( FAKE_PLAN_METERED ) plan = Plan . sync_from_stripe_data ( plan_data ) self . assertEqual ( plan . id , plan_data [ \"id\" ]) self . assertEqual ( plan . usage_type , PriceUsageType . metered ) self . assertIsNotNone ( plan . amount ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_plan . PlanTest . test_stripe_plan ( self , plan_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Plan.retrieve\" , return_value = FAKE_PLAN , autospec = True ) def test_stripe_plan ( self , plan_retrieve_mock ): stripe_plan = self . plan . api_retrieve () plan_retrieve_mock . assert_called_once_with ( id = self . plan_data [ \"id\" ], api_key = STRIPE_SECRET_KEY , expand = [], stripe_account = None , ) plan = Plan . sync_from_stripe_data ( stripe_plan ) assert plan . amount_in_cents == plan . amount * 100 assert isinstance ( plan . amount_in_cents , int ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_plan . PlanTest . test_stripe_plan_null_product ( self , product_retrieve_mock ) assert that plan.Product can be null for backwards compatibility though note that it is a Stripe required field Source code in tests/test_plan.py @patch ( \"stripe.Product.retrieve\" , autospec = True ) def test_stripe_plan_null_product ( self , product_retrieve_mock ): \"\"\" assert that plan.Product can be null for backwards compatibility though note that it is a Stripe required field \"\"\" plan_data = deepcopy ( FAKE_PLAN_II ) del plan_data [ \"product\" ] plan = Plan . sync_from_stripe_data ( plan_data ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Plan.product\" }, ) tests . test_plan . PlanTest . test_stripe_tier_plan ( self , plan_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) def test_stripe_tier_plan ( self , plan_retrieve_mock ): tier_plan_data = deepcopy ( FAKE_TIER_PLAN ) plan = Plan . sync_from_stripe_data ( tier_plan_data ) self . assertEqual ( plan . id , tier_plan_data [ \"id\" ]) self . assertIsNone ( plan . amount ) self . assertIsNotNone ( plan . tiers ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests.test_price dj-stripe Price model tests Classes tests.test_price.HumanReadablePriceTest Methods tests . test_price . HumanReadablePriceTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_price.py def setUp ( self ): product_data = deepcopy ( FAKE_PRODUCT ) self . stripe_product = Product . sync_from_stripe_data ( product_data ) tests . test_price . HumanReadablePriceTest . test_human_readable_10_usd_2weeks ( self ) Source code in tests/test_price.py def test_human_readable_10_usd_2weeks ( self ): price = Price . objects . create ( id = \"price-test-10-usd-2w\" , active = True , unit_amount = 1000 , currency = \"usd\" , product = self . stripe_product , recurring = { \"interval\" : \"week\" , \"interval_count\" : 2 , }, ) assert price . human_readable_price == \"$10.00 USD every 2 weeks\" tests . test_price . HumanReadablePriceTest . test_human_readable_10_usd_weekly ( self ) Source code in tests/test_price.py def test_human_readable_10_usd_weekly ( self ): price = Price . objects . create ( id = \"price-test-10-usd-weekly\" , active = True , unit_amount = 1000 , currency = \"usd\" , product = self . stripe_product , recurring = dict ( interval = \"week\" , interval_count = 1 , ), ) assert price . human_readable_price == \"$10.00 USD/week\" tests . test_price . HumanReadablePriceTest . test_human_readable_10_usd_yearly ( self ) Source code in tests/test_price.py def test_human_readable_10_usd_yearly ( self ): price = Price . objects . create ( id = \"price-test-10-usd-yearly\" , active = True , unit_amount = 1000 , currency = \"usd\" , product = self . stripe_product , recurring = dict ( interval = \"year\" , interval_count = 1 , ), ) assert price . human_readable_price == \"$10.00 USD/year\" tests . test_price . HumanReadablePriceTest . test_human_readable_25_usd_6months ( self ) Source code in tests/test_price.py def test_human_readable_25_usd_6months ( self ): price = Price . objects . create ( id = \"price-test-25-usd-6m\" , active = True , unit_amount = 2500 , currency = \"usd\" , product = self . stripe_product , recurring = dict ( interval = \"month\" , interval_count = 6 , ), ) assert price . human_readable_price == \"$25.00 USD every 6 months\" tests . test_price . HumanReadablePriceTest . test_human_readable_499_usd_monthly ( self ) Source code in tests/test_price.py def test_human_readable_499_usd_monthly ( self ): price = Price . objects . create ( id = \"price-test-499-usd-monthly\" , active = True , unit_amount = 499 , currency = \"usd\" , product = self . stripe_product , recurring = dict ( interval = \"month\" , interval_count = 1 , ), ) assert price . human_readable_price == \"$4.99 USD/month\" tests . test_price . HumanReadablePriceTest . test_human_readable_free_usd_daily ( self ) Source code in tests/test_price.py def test_human_readable_free_usd_daily ( self ): price = Price . objects . create ( id = \"price-test-free-usd-daily\" , active = True , unit_amount = 0 , currency = \"usd\" , product = self . stripe_product , recurring = dict ( interval = \"day\" , interval_count = 1 , ), ) assert price . human_readable_price == \"$0.00 USD/day\" tests . test_price . HumanReadablePriceTest . test_human_readable_one_time ( self ) Source code in tests/test_price.py def test_human_readable_one_time ( self ): price = Price . objects . create ( id = \"price-test-one-time\" , active = True , unit_amount = 2000 , currency = \"usd\" , product = self . stripe_product , ) assert price . human_readable_price == \"$20.00 USD (one time)\" tests.test_price.PriceCreateTest Methods tests . test_price . PriceCreateTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_price.py def setUp ( self ): with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . stripe_product = Product ( id = FAKE_PRODUCT [ \"id\" ]) . api_retrieve () tests . test_price . PriceCreateTest . test_create_from_djstripe_product ( self , price_create_mock , product_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Price.create\" , return_value = deepcopy ( FAKE_PRICE ), autospec = True ) def test_create_from_djstripe_product ( self , price_create_mock , product_retrieve_mock ): fake_price = deepcopy ( FAKE_PRICE ) fake_price [ \"product\" ] = Product . sync_from_stripe_data ( self . stripe_product ) fake_price [ \"unit_amount\" ] /= 100 assert isinstance ( fake_price [ \"product\" ], Product ) price = Price . create ( ** fake_price ) price_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** FAKE_PRICE ) self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_price . PriceCreateTest . test_create_from_product_id ( self , price_create_mock , product_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Price.create\" , return_value = deepcopy ( FAKE_PRICE ), autospec = True ) def test_create_from_product_id ( self , price_create_mock , product_retrieve_mock ): fake_price = deepcopy ( FAKE_PRICE ) fake_price [ \"unit_amount\" ] /= 100 assert isinstance ( fake_price [ \"product\" ], str ) price = Price . create ( ** fake_price ) expected_create_kwargs = deepcopy ( FAKE_PRICE ) expected_create_kwargs [ \"api_key\" ] = STRIPE_SECRET_KEY price_create_mock . assert_called_once_with ( ** expected_create_kwargs ) self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_price . PriceCreateTest . test_create_from_stripe_product ( self , price_create_mock , product_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Price.create\" , return_value = deepcopy ( FAKE_PRICE ), autospec = True ) def test_create_from_stripe_product ( self , price_create_mock , product_retrieve_mock ): fake_price = deepcopy ( FAKE_PRICE ) fake_price [ \"product\" ] = self . stripe_product fake_price [ \"unit_amount\" ] /= 100 assert isinstance ( fake_price [ \"product\" ], dict ) price = Price . create ( ** fake_price ) expected_create_kwargs = deepcopy ( FAKE_PRICE ) expected_create_kwargs [ \"product\" ] = self . stripe_product price_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** expected_create_kwargs ) self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_price . PriceCreateTest . test_create_with_metadata ( self , price_create_mock , product_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Price.create\" , return_value = deepcopy ( FAKE_PRICE ), autospec = True ) def test_create_with_metadata ( self , price_create_mock , product_retrieve_mock ): metadata = { \"other_data\" : \"more_data\" } fake_price = deepcopy ( FAKE_PRICE ) fake_price [ \"unit_amount\" ] /= 100 fake_price [ \"metadata\" ] = metadata assert isinstance ( fake_price [ \"product\" ], str ) price = Price . create ( ** fake_price ) expected_create_kwargs = deepcopy ( FAKE_PRICE ) expected_create_kwargs [ \"metadata\" ] = metadata price_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** expected_create_kwargs ) self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests.test_price.PriceTest Methods tests . test_price . PriceTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_price.py def setUp ( self ): self . price_data = deepcopy ( FAKE_PRICE ) with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . price = Price . sync_from_stripe_data ( self . price_data ) tests . test_price . PriceTest . test_price_name ( self ) Source code in tests/test_price.py def test_price_name ( self ): price = Price ( id = \"price_xxxx\" , nickname = \"Price Test\" ) assert str ( price ) == \"Price Test\" price . nickname = \"\" assert str ( price ) == \"price_xxxx\" tests . test_price . PriceTest . test_str ( self ) Source code in tests/test_price.py def test_str ( self ): assert str ( self . price ) == self . price_data [ \"nickname\" ] tests . test_price . PriceTest . test_stripe_metered_price ( self , price_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Price.retrieve\" , autospec = True ) def test_stripe_metered_price ( self , price_retrieve_mock ): price_data = deepcopy ( FAKE_PRICE_METERED ) price = Price . sync_from_stripe_data ( price_data ) assert price . id == price_data [ \"id\" ] assert price . recurring [ \"usage_type\" ] == PriceUsageType . metered assert price . unit_amount is not None self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_price . PriceTest . test_stripe_onetime_price ( self , price_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Price.retrieve\" , autospec = True ) def test_stripe_onetime_price ( self , price_retrieve_mock ): price_data = deepcopy ( FAKE_PRICE_ONETIME ) price = Price . sync_from_stripe_data ( price_data ) assert price . id == price_data [ \"id\" ] assert price . unit_amount is not None assert not price . recurring assert price . type == PriceType . one_time self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_price . PriceTest . test_stripe_price ( self , price_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Price.retrieve\" , return_value = FAKE_PRICE , autospec = True ) def test_stripe_price ( self , price_retrieve_mock ): stripe_price = self . price . api_retrieve () price_retrieve_mock . assert_called_once_with ( id = self . price_data [ \"id\" ], api_key = STRIPE_SECRET_KEY , expand = [ \"tiers\" ], stripe_account = None , ) price = Price . sync_from_stripe_data ( stripe_price ) self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) assert price . human_readable_price == \"$20.00 USD/month\" tests . test_price . PriceTest . test_stripe_tier_price ( self , price_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Price.retrieve\" , autospec = True ) def test_stripe_tier_price ( self , price_retrieve_mock ): price_data = deepcopy ( FAKE_PRICE_TIER ) price = Price . sync_from_stripe_data ( price_data ) assert price . id == price_data [ \"id\" ] assert price . unit_amount is None assert price . tiers is not None self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests.test_refund dj-stripe Charge Model Tests. Classes tests.test_refund.RefundTest Methods tests . test_refund . RefundTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_refund.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . default_expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.refund\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Invoice.default_payment_method\" , \"djstripe.Invoice.default_source\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , \"djstripe.Subscription.default_payment_method\" , \"djstripe.Subscription.default_source\" , \"djstripe.Subscription.pending_setup_intent\" , \"djstripe.Subscription.schedule\" , \"djstripe.Refund.failure_balance_transaction\" , } tests . test_refund . RefundTest . test_reason_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_refund.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_reason_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account # TODO - remove invoice sync Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) balance_transaction_retrieve_mock . return_value = deepcopy ( FAKE_BALANCE_TRANSACTION_REFUND ) fake_refund = deepcopy ( FAKE_REFUND ) for reason in ( \"duplicate\" , \"fraudulent\" , \"requested_by_customer\" , \"expired_uncaptured_charge\" , ): fake_refund [ \"reason\" ] = reason refund = Refund . sync_from_stripe_data ( fake_refund ) self . assertEqual ( refund . reason , reason ) # trigger model field validation (including enum value choices check) refund . full_clean () self . assert_fks ( refund , expected_blank_fks = self . default_expected_blank_fks ) tests . test_refund . RefundTest . test_status_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_refund.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account # TODO - remove invoice sync Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) balance_transaction_retrieve_mock . return_value = deepcopy ( FAKE_BALANCE_TRANSACTION_REFUND ) fake_refund = deepcopy ( FAKE_REFUND ) for status in ( \"pending\" , \"succeeded\" , \"failed\" , \"canceled\" , ): fake_refund [ \"status\" ] = status refund = Refund . sync_from_stripe_data ( fake_refund ) self . assertEqual ( refund . status , status ) # trigger model field validation (including enum value choices check) refund . full_clean () self . assert_fks ( refund , expected_blank_fks = self . default_expected_blank_fks ) tests . test_refund . RefundTest . test_sync_from_stripe_data ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_refund.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_sync_from_stripe_data ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account # TODO - remove invoice sync Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) fake_refund = deepcopy ( FAKE_REFUND ) balance_transaction_retrieve_mock . return_value = deepcopy ( FAKE_BALANCE_TRANSACTION_REFUND ) refund = Refund . sync_from_stripe_data ( fake_refund ) self . assert_fks ( refund , expected_blank_fks = self . default_expected_blank_fks ) tests.test_session dj-stripe Session Model Tests. tests.test_session.SessionTest tests . test_session . SessionTest . test_sync_from_stripe_data ( self , payment_intent_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_session.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) def test_sync_from_stripe_data ( self , payment_intent_retrieve_mock , customer_retrieve_mock ): fake_payment_intent = deepcopy ( FAKE_SESSION_I ) session = Session . sync_from_stripe_data ( fake_payment_intent ) self . assert_fks ( session , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , \"djstripe.Session.subscription\" , }, ) tests.test_settings dj-stripe Settings Tests. tests.test_settings.TestGetStripeApiVersion tests . test_settings . TestGetStripeApiVersion . test_with_default ( self ) Source code in tests/test_settings.py def test_with_default ( self ): self . assertEqual ( djstripe_settings . DEFAULT_STRIPE_API_VERSION , get_stripe_api_version () ) tests . test_settings . TestGetStripeApiVersion . test_with_override ( self ) Source code in tests/test_settings.py @override_settings ( STRIPE_API_VERSION = \"2016-03-07\" ) def test_with_override ( self ): self . assertEqual ( \"2016-03-07\" , get_stripe_api_version ()) tests.test_settings.TestSetStripeApiVersion tests . test_settings . TestSetStripeApiVersion . test_with_default ( self ) Source code in tests/test_settings.py def test_with_default ( self ): djstripe_settings . set_stripe_api_version () self . assertEqual ( djstripe_settings . DEFAULT_STRIPE_API_VERSION , stripe . api_version ) tests . test_settings . TestSetStripeApiVersion . test_with_invalid_date ( self ) Source code in tests/test_settings.py def test_with_invalid_date ( self ): with self . assertRaises ( ValueError ): set_stripe_api_version ( version = \"foobar\" ) tests . test_settings . TestSetStripeApiVersion . test_with_invalid_date_and_no_validation ( self ) Source code in tests/test_settings.py def test_with_invalid_date_and_no_validation ( self ): set_stripe_api_version ( version = \"foobar\" , validate = False ) self . assertEqual ( \"foobar\" , stripe . api_version ) tests . test_settings . TestSetStripeApiVersion . test_with_valid_date ( self ) Source code in tests/test_settings.py def test_with_valid_date ( self ): djstripe_settings . set_stripe_api_version ( version = \"2016-03-07\" ) self . assertEqual ( \"2016-03-07\" , stripe . api_version ) tests.test_settings.TestSubscriberModelRetrievalMethod tests . test_settings . TestSubscriberModelRetrievalMethod . test_bad_callback ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.Organization\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = 5 , ) def test_bad_callback ( self ): self . assertRaisesMessage ( ImproperlyConfigured , \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be callable.\" , get_subscriber_model , ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_bad_model_name ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testappStaticEmailOrganization\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = ( lambda request : request . org ), ) def test_bad_model_name ( self ): self . assertRaisesMessage ( ImproperlyConfigured , \"DJSTRIPE_SUBSCRIBER_MODEL must be of the form 'app_label.model_name'.\" , get_subscriber_model , ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_get_callback_function_ ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_TEST_CALLBACK = \"foo.non_existant_callback\" ) def test_get_callback_function_ ( self ): with self . assertRaises ( ImportError ): get_callback_function ( \"DJSTRIPE_TEST_CALLBACK\" ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_get_callback_function_import_error ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_TEST_CALLBACK = \"foo.non_existant_callback\" ) def test_get_callback_function_import_error ( self ): with self . assertRaises ( ImportError ): get_callback_function ( \"DJSTRIPE_TEST_CALLBACK\" ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_get_callback_function_with_non_callable_string ( self , import_string_mock ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_TEST_CALLBACK = \"foo.invalid_callback\" ) @patch . object ( djstripe_settings , \"import_string\" , return_value = \"not_callable\" ) def test_get_callback_function_with_non_callable_string ( self , import_string_mock ): with self . assertRaises ( ImproperlyConfigured ): get_callback_function ( \"DJSTRIPE_TEST_CALLBACK\" ) import_string_mock . assert_called_with ( \"foo.invalid_callback\" ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_get_callback_function_with_valid_func_callable ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_TEST_CALLBACK = ( lambda : \"ok\" )) def test_get_callback_function_with_valid_func_callable ( self ): func = get_callback_function ( \"DJSTRIPE_TEST_CALLBACK\" ) self . assertEqual ( \"ok\" , func ()) tests . test_settings . TestSubscriberModelRetrievalMethod . test_get_callback_function_with_valid_string_callable ( self , import_string_mock ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_TEST_CALLBACK = \"foo.valid_callback\" ) @patch . object ( djstripe_settings , \"import_string\" , return_value = ( lambda : \"ok\" )) def test_get_callback_function_with_valid_string_callable ( self , import_string_mock ): func = get_callback_function ( \"DJSTRIPE_TEST_CALLBACK\" ) self . assertEqual ( \"ok\" , func ()) import_string_mock . assert_called_with ( \"foo.valid_callback\" ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_no_callback ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.Organization\" ) def test_no_callback ( self ): self . assertRaisesMessage ( ImproperlyConfigured , \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be implemented \" \"if a DJSTRIPE_SUBSCRIBER_MODEL is defined.\" , get_subscriber_model , ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_no_email_model ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.NoEmailOrganization\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = ( lambda request : request . org ), ) def test_no_email_model ( self ): self . assertRaisesMessage ( ImproperlyConfigured , \"DJSTRIPE_SUBSCRIBER_MODEL must have an email attribute.\" , get_subscriber_model , ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_unknown_model ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.UnknownModel\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = ( lambda request : request . org ), ) def test_unknown_model ( self ): self . assertRaisesMessage ( ImproperlyConfigured , \"DJSTRIPE_SUBSCRIBER_MODEL refers to model 'testapp.UnknownModel' \" \"that has not been installed.\" , get_subscriber_model , ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_with_org ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.Organization\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = ( lambda request : request . org ), ) def test_with_org ( self ): org_model = get_subscriber_model () self . assertTrue ( isinstance ( org_model , ModelBase )) tests . test_settings . TestSubscriberModelRetrievalMethod . test_with_org_static ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.StaticEmailOrganization\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = ( lambda request : request . org ), ) def test_with_org_static ( self ): org_model = get_subscriber_model () self . assertTrue ( isinstance ( org_model , ModelBase )) tests . test_settings . TestSubscriberModelRetrievalMethod . test_with_user ( self ) Source code in tests/test_settings.py def test_with_user ( self ): user_model = get_subscriber_model () self . assertTrue ( isinstance ( user_model , ModelBase )) tests.test_setup_intent dj-stripe SetupIntent Model Tests. tests.test_setup_intent.SetupIntentTest tests . test_setup_intent . SetupIntentTest . test_canceled_intent ( self , customer_retrieve_mock ) Source code in tests/test_setup_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_canceled_intent ( self , customer_retrieve_mock ): fake_setup_intent = deepcopy ( FAKE_SETUP_INTENT_I ) fake_setup_intent [ \"status\" ] = \"canceled\" fake_setup_intent [ \"canceled_at\" ] = 1567524169 for reason in ( None , \"abandoned\" , \"requested_by_customer\" , \"duplicate\" ): fake_setup_intent [ \"cancellation_reason\" ] = reason setup_intent = SetupIntent . sync_from_stripe_data ( fake_setup_intent ) if reason is None : # enums nulls are coerced to \"\" by StripeModel._stripe_object_to_record self . assertEqual ( setup_intent . cancellation_reason , \"\" ) else : self . assertEqual ( setup_intent . cancellation_reason , reason ) # trigger model field validation (including enum value choices check) setup_intent . full_clean () tests . test_setup_intent . SetupIntentTest . test_status_enum ( self , customer_retrieve_mock ) Source code in tests/test_setup_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_status_enum ( self , customer_retrieve_mock ): fake_setup_intent = deepcopy ( FAKE_SETUP_INTENT_I ) for status in ( \"requires_payment_method\" , \"requires_confirmation\" , \"requires_action\" , \"processing\" , \"canceled\" , \"succeeded\" , ): fake_setup_intent [ \"status\" ] = status setup_intent = SetupIntent . sync_from_stripe_data ( fake_setup_intent ) # trigger model field validation (including enum value choices check) setup_intent . full_clean () tests . test_setup_intent . SetupIntentTest . test_sync_from_stripe_data ( self , customer_retrieve_mock ) Source code in tests/test_setup_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_from_stripe_data ( self , customer_retrieve_mock ): fake_payment_intent = deepcopy ( FAKE_SETUP_INTENT_I ) setup_intent = SetupIntent . sync_from_stripe_data ( fake_payment_intent ) self . assertEqual ( setup_intent . payment_method_types , [ \"card\" ]) self . assert_fks ( setup_intent , expected_blank_fks = { \"djstripe.SetupIntent.customer\" , \"djstripe.SetupIntent.on_behalf_of\" , \"djstripe.SetupIntent.payment_method\" , }, ) tests.test_source dj-stripe Card Model Tests. Classes tests.test_source.SourceTest Methods tests . test_source . SourceTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_source.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"testuser\" , email = \"djstripe@example.com\" ) self . customer = FAKE_CUSTOMER_III . create_for_user ( self . user ) self . customer . sources . all () . delete () self . customer . legacy_cards . all () . delete () tests . test_source . SourceTest . test_attach_objects_hook_without_customer ( self ) Source code in tests/test_source.py def test_attach_objects_hook_without_customer ( self ): source = Source . sync_from_stripe_data ( deepcopy ( FAKE_SOURCE_II )) self . assertEqual ( source . customer , None ) self . assert_fks ( source , expected_blank_fks = { \"djstripe.Source.customer\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_source . SourceTest . test_detach ( self , source_retrieve_mock ) Source code in tests/test_source.py @patch ( \"stripe.Source.retrieve\" , return_value = deepcopy ( FAKE_SOURCE ), autospec = True ) def test_detach ( self , source_retrieve_mock ): original_detach = SourceDict . detach def mocked_detach ( self ): return original_detach ( self ) Source . sync_from_stripe_data ( deepcopy ( FAKE_SOURCE )) self . assertEqual ( 0 , self . customer . legacy_cards . count ()) self . assertEqual ( 1 , self . customer . sources . count ()) source = self . customer . sources . first () with patch ( \"tests.SourceDict.detach\" , side_effect = mocked_detach , autospec = True ) as mock_detach : source . detach () self . assertEqual ( 0 , self . customer . sources . count ()) # need to refresh_from_db since default_source was cleared with a query self . customer . refresh_from_db () self . assertIsNone ( self . customer . default_source ) # need to refresh_from_db due to the implementation of Source.detach() - # see TODO in method source . refresh_from_db () self . assertIsNone ( source . customer ) self . assertEqual ( source . status , \"consumed\" ) if sys . version_info >= ( 3 , 6 ): # this mock isn't working on py34, py35, but it's not strictly necessary # for the test mock_detach . assert_called () self . assert_fks ( source , expected_blank_fks = { \"djstripe.Source.customer\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_source . SourceTest . test_str ( self ) Source code in tests/test_source.py def test_str ( self ): fake_source = deepcopy ( FAKE_SOURCE ) source = Source . sync_from_stripe_data ( fake_source ) self . assertEqual ( \"<id= {} >\" . format ( fake_source [ \"id\" ]), str ( source )) self . assert_fks ( source , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_source . SourceTest . test_sync_source_finds_customer ( self ) Source code in tests/test_source.py def test_sync_source_finds_customer ( self ): source = Source . sync_from_stripe_data ( deepcopy ( FAKE_SOURCE )) self . assertEqual ( self . customer , source . customer ) self . assert_fks ( source , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests.test_stripe_model dj-stripe StripeModel Model Tests. Classes tests.test_stripe_model.StripeModelExceptionsTest tests . test_stripe_model . StripeModelExceptionsTest . test_bad_object_value ( self ) Source code in tests/test_stripe_model.py def test_bad_object_value ( self ): with self . assertRaises ( ValueError ): # Errors because the object is not correct Customer . _stripe_object_to_record ( { \"id\" : \"test_XXXXXXXX\" , \"livemode\" : False , \"object\" : \"not_a_customer\" } ) tests . test_stripe_model . StripeModelExceptionsTest . test_no_object_value ( self ) Source code in tests/test_stripe_model.py def test_no_object_value ( self ): # Instantiate a stripeobject model class class BasicModel ( StripeModel ): pass with self . assertRaises ( ValueError ): # Errors because there's no object value BasicModel . _stripe_object_to_record ( { \"id\" : \"test_XXXXXXXX\" , \"livemode\" : False } ) tests.test_stripe_model.TestStripeModel TestStripeModel(djstripe_id, id, djstripe_owner_account, livemode, created, metadata, description, djstripe_created, djstripe_updated) tests . test_stripe_model . TestStripeModel . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] tests.test_stripe_model.TestStripeModel.DoesNotExist tests.test_stripe_model.TestStripeModel.MultipleObjectsReturned tests . test_stripe_model . TestStripeModel . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in tests/test_stripe_model.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) tests . test_stripe_model . TestStripeModel . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in tests/test_stripe_model.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) tests . test_stripe_model . TestStripeModel . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in tests/test_stripe_model.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) tests . test_stripe_model . TestStripeModel . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in tests/test_stripe_model.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) Functions tests . test_stripe_model . test__api_delete ( mock_api_retrieve , stripe_account , api_key , expected_api_key , extra_kwargs ) Test that API delete properly uses the passed in parameters. Source code in tests/test_stripe_model.py @pytest . mark . parametrize ( \"stripe_account\" , ( None , \"acct_fakefakefakefake001\" )) @pytest . mark . parametrize ( \"api_key, expected_api_key\" , (( None , STRIPE_SECRET_KEY ), ( \"sk_fakefakefake01\" , \"sk_fakefakefake01\" )), ) @pytest . mark . parametrize ( \"extra_kwargs\" , ({}, { \"foo\" : \"bar\" })) @patch . object ( target = StripeModel , attribute = \"api_retrieve\" , autospec = True ) def test__api_delete ( mock_api_retrieve , stripe_account , api_key , expected_api_key , extra_kwargs ): \"\"\"Test that API delete properly uses the passed in parameters.\"\"\" test_model = TestStripeModel () test_model . _api_delete ( api_key = api_key , stripe_account = stripe_account , ** extra_kwargs ) # Assert the chained calls happened as expected, since it should # call api_retrieve() followed by delete() assert ( mock_api_retrieve . mock_calls == call ( test_model , api_key = expected_api_key , stripe_account = stripe_account ) . delete ( ** extra_kwargs ) . call_list () ) tests . test_stripe_model . test_api_retrieve ( mock_stripe_class , stripe_account , api_key , expected_api_key , expand_fields ) Test that API delete properly uses the passed in parameters. Source code in tests/test_stripe_model.py @pytest . mark . parametrize ( \"stripe_account\" , ( None , \"acct_fakefakefakefake001\" )) @pytest . mark . parametrize ( \"api_key, expected_api_key\" , (( None , STRIPE_SECRET_KEY ), ( \"sk_fakefakefake01\" , \"sk_fakefakefake01\" )), ) @pytest . mark . parametrize ( \"expand_fields\" , ([], [ \"foo\" , \"bar\" ])) @patch . object ( target = StripeModel , attribute = \"stripe_class\" ) def test_api_retrieve ( mock_stripe_class , stripe_account , api_key , expected_api_key , expand_fields ): \"\"\"Test that API delete properly uses the passed in parameters.\"\"\" test_model = TestStripeModel () mock_id = \"id_fakefakefakefake01\" test_model . id = mock_id test_model . expand_fields = expand_fields test_model . api_retrieve ( api_key = api_key , stripe_account = stripe_account ) mock_stripe_class . retrieve . assert_called_once_with ( id = mock_id , api_key = expected_api_key , stripe_account = stripe_account , expand = expand_fields , ) tests . test_stripe_model . test_api_retrieve_reverse_foreign_key_lookup ( mock_stripe_class ) Test that the reverse foreign key lookup finds the correct fields. Source code in tests/test_stripe_model.py @patch . object ( target = StripeModel , attribute = \"stripe_class\" ) def test_api_retrieve_reverse_foreign_key_lookup ( mock_stripe_class ): \"\"\"Test that the reverse foreign key lookup finds the correct fields.\"\"\" # Set up some mock fields that shouldn't be used for reverse lookups mock_field_1 = MagicMock () mock_field_1 . is_relation = False mock_field_2 = MagicMock () mock_field_2 . is_relation = True mock_field_2 . one_to_many = False # Set up a mock reverse foreign key field mock_reverse_foreign_key = MagicMock () mock_reverse_foreign_key . is_relation = True mock_reverse_foreign_key . one_to_many = True mock_reverse_foreign_key . related_model = Account mock_reverse_foreign_key . get_accessor_name . return_value = \"foo_account_reverse_attr\" # Set up a mock account for the reverse foreign key query to return. mock_account = MagicMock () mock_account_reverse_manager = MagicMock () # Make first return the mock account. mock_account_reverse_manager . first . return_value = mock_account test_model = TestStripeModel () mock_id = \"id_fakefakefakefake01\" test_model . id = mock_id # Set mock reverse manager on the model. test_model . foo_account_reverse_attr = mock_account_reverse_manager # Set the mocked _meta.get_fields to return some mock fields, including the mock # reverse foreign key above. test_model . _meta = MagicMock () test_model . _meta . get_fields . return_value = ( mock_field_1 , mock_field_2 , mock_reverse_foreign_key , ) # Call the function with API key set because we mocked _meta mock_api_key = \"sk_fakefakefakefake01\" test_model . api_retrieve ( api_key = mock_api_key ) # Expect the retrieve to be done with the reverse look up of the Account ID. mock_stripe_class . retrieve . assert_called_once_with ( id = mock_id , api_key = mock_api_key , stripe_account = mock_account . id , expand = [] ) mock_reverse_foreign_key . get_accessor_name . assert_called_once_with () mock_account_reverse_manager . first . assert_called_once_with () tests.test_subscription dj-stripe Subscription Model Tests. Classes tests.test_subscription.SubscriptionTest Methods tests . test_subscription . SubscriptionTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_subscription.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . default_expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Subscription.default_payment_method\" , \"djstripe.Subscription.default_source\" , \"djstripe.Subscription.pending_setup_intent\" , \"djstripe.Subscription.schedule\" , } tests . test_subscription . SubscriptionTest . test_cancel_already_canceled ( self , subscription_retrieve_mock , product_retrieve_mock , subscription_delete_mock ) Source code in tests/test_subscription.py @patch ( \"djstripe.models.Subscription._api_delete\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_CANCELED ), ) def test_cancel_already_canceled ( self , subscription_retrieve_mock , product_retrieve_mock , subscription_delete_mock , ): subscription_delete_mock . side_effect = InvalidRequestError ( \"No such subscription: sub_xxxx\" , \"blah\" ) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertEqual ( Subscription . objects . filter ( status = \"canceled\" ) . count (), 0 ) subscription . cancel ( at_period_end = False ) self . assertEqual ( Subscription . objects . filter ( status = \"canceled\" ) . count (), 1 ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_cancel_and_reactivate ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_cancel_and_reactivate ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . current_period_end = current_period_end subscription . save () canceled_subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) canceled_subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( current_period_end ) canceled_subscription_fake [ \"canceled_at\" ] = datetime_to_unix ( timezone . now ()) subscription_retrieve_mock . return_value = canceled_subscription_fake self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) new_subscription = subscription . cancel ( at_period_end = True ) self . assertEqual ( new_subscription . cancel_at_period_end , True ) new_subscription . reactivate () subscription_reactivate_fake = deepcopy ( FAKE_SUBSCRIPTION ) reactivated_subscription = Subscription . sync_from_stripe_data ( subscription_reactivate_fake ) self . assertEqual ( reactivated_subscription . cancel_at_period_end , False ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_cancel_at_period_end ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_cancel_at_period_end ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . current_period_end = current_period_end subscription . save () canceled_subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) canceled_subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( current_period_end ) canceled_subscription_fake [ \"canceled_at\" ] = datetime_to_unix ( timezone . now ()) subscription_retrieve_mock . return_value = ( canceled_subscription_fake # retrieve().delete() ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assertEqual ( self . customer . active_subscriptions . count (), 1 ) self . assertTrue ( subscription in self . customer . active_subscriptions ) new_subscription = subscription . cancel ( at_period_end = True ) self . assertEqual ( self . customer . active_subscriptions . count (), 1 ) self . assertTrue ( new_subscription in self . customer . active_subscriptions ) self . assertEqual ( SubscriptionStatus . active , new_subscription . status ) self . assertEqual ( True , new_subscription . cancel_at_period_end ) self . assertNotEqual ( new_subscription . canceled_at , new_subscription . ended_at ) self . assertTrue ( new_subscription . is_valid ()) self . assertTrue ( new_subscription . is_status_temporarily_current ()) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_cancel_during_trial_sets_at_period_end ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_cancel_during_trial_sets_at_period_end ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . trial_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription . save () cancel_timestamp = datetime_to_unix ( timezone . now ()) canceled_subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) canceled_subscription_fake [ \"status\" ] = SubscriptionStatus . canceled canceled_subscription_fake [ \"canceled_at\" ] = cancel_timestamp canceled_subscription_fake [ \"ended_at\" ] = cancel_timestamp subscription_retrieve_mock . return_value = ( canceled_subscription_fake # retrieve().delete() ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) new_subscription = subscription . cancel ( at_period_end = False ) self . assertEqual ( SubscriptionStatus . canceled , new_subscription . status ) self . assertEqual ( False , new_subscription . cancel_at_period_end ) self . assertEqual ( new_subscription . canceled_at , new_subscription . ended_at ) self . assertFalse ( new_subscription . is_valid ()) self . assertFalse ( self . customer . has_active_subscription ()) self . assertFalse ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertFalse ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_cancel_error_in_cancel ( self , product_retrieve_mock , subscription_delete_mock ) Source code in tests/test_subscription.py @patch ( \"djstripe.models.Subscription._api_delete\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_cancel_error_in_cancel ( self , product_retrieve_mock , subscription_delete_mock ): subscription_delete_mock . side_effect = InvalidRequestError ( \"Unexpected error\" , \"blah\" ) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) with self . assertRaises ( InvalidRequestError ): subscription . cancel ( at_period_end = False ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_cancel_now ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_cancel_now ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription . save () cancel_timestamp = datetime_to_unix ( timezone . now ()) canceled_subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) canceled_subscription_fake [ \"status\" ] = SubscriptionStatus . canceled canceled_subscription_fake [ \"canceled_at\" ] = cancel_timestamp canceled_subscription_fake [ \"ended_at\" ] = cancel_timestamp subscription_retrieve_mock . return_value = ( canceled_subscription_fake # retrieve().delete() ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertEqual ( self . customer . active_subscriptions . count (), 1 ) self . assertTrue ( self . customer . has_any_active_subscription ()) new_subscription = subscription . cancel ( at_period_end = False ) self . assertEqual ( SubscriptionStatus . canceled , new_subscription . status ) self . assertEqual ( False , new_subscription . cancel_at_period_end ) self . assertEqual ( new_subscription . canceled_at , new_subscription . ended_at ) self . assertFalse ( new_subscription . is_valid ()) self . assertFalse ( new_subscription . is_status_temporarily_current ()) self . assertFalse ( new_subscription in self . customer . active_subscriptions ) self . assertFalse ( self . customer . has_active_subscription ()) self . assertFalse ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertFalse ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_extend ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_extend ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () - timezone . timedelta ( days = 20 ) ) subscription_retrieve_mock . return_value = subscription_fake subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertFalse ( subscription in self . customer . active_subscriptions ) self . assertEqual ( self . customer . active_subscriptions . count (), 0 ) delta = timezone . timedelta ( days = 30 ) extended_subscription = subscription . extend ( delta ) product = Product . sync_from_stripe_data ( deepcopy ( FAKE_PRODUCT )) self . assertNotEqual ( None , extended_subscription . trial_end ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( product )) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_extend_negative_delta ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_extend_negative_delta ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_NOT_PERIOD_CURRENT ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) with self . assertRaises ( ValueError ): subscription . extend ( timezone . timedelta ( days =- 30 )) self . assertFalse ( self . customer . has_active_subscription ()) self . assertFalse ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertFalse ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_extend_with_trial ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_extend_with_trial ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . trial_end = timezone . now () + timezone . timedelta ( days = 5 ) subscription . save () delta = timezone . timedelta ( days = 30 ) new_trial_end = subscription . trial_end + delta extended_subscription = subscription . extend ( delta ) self . assertEqual ( new_trial_end . replace ( microsecond = 0 ), extended_subscription . trial_end ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_is_status_temporarily_current ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_is_status_temporarily_current ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ): product = Product . sync_from_stripe_data ( deepcopy ( FAKE_PRODUCT )) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . canceled_at = timezone . now () + timezone . timedelta ( days = 7 ) subscription . current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription . cancel_at_period_end = True subscription . save () self . assertTrue ( subscription . is_status_current ()) self . assertTrue ( subscription . is_status_temporarily_current ()) self . assertTrue ( subscription . is_valid ()) self . assertTrue ( subscription in self . customer . active_subscriptions ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( product )) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_is_status_temporarily_current_false ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_is_status_temporarily_current_false ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription . save () self . assertTrue ( subscription . is_status_current ()) self . assertFalse ( subscription . is_status_temporarily_current ()) self . assertTrue ( subscription . is_valid ()) self . assertTrue ( subscription in self . customer . active_subscriptions ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_is_status_temporarily_current_false_and_canceled ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_is_status_temporarily_current_false_and_canceled ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . status = SubscriptionStatus . canceled subscription . current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription . save () self . assertFalse ( subscription . is_status_current ()) self . assertFalse ( subscription . is_status_temporarily_current ()) self . assertFalse ( subscription . is_valid ()) self . assertFalse ( subscription in self . customer . active_subscriptions ) self . assertFalse ( self . customer . has_active_subscription ()) self . assertFalse ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertFalse ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_remove_all_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ), ) def test_remove_all_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertIsNone ( subscription . plan ) self . assertIsNone ( subscription . quantity ) items = subscription . items . all () self . assertEqual ( 2 , len ( items )) # Simulate a webhook received with no more plan del subscription_fake [ \"items\" ][ \"data\" ][ 1 ] del subscription_fake [ \"items\" ][ \"data\" ][ 0 ] subscription_fake [ \"items\" ][ \"total_count\" ] = 0 subscription = Subscription . sync_from_stripe_data ( subscription_fake ) items = subscription . items . all () self . assertEqual ( 0 , len ( items )) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Customer.subscriber\" , \"djstripe.Subscription.plan\" }, ) tests . test_subscription . SubscriptionTest . test_sync_from_stripe_data ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_from_stripe_data ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"cancel_at\" ] = 1624553655 subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertEqual ( str ( subscription ), f \" { self . user } on { subscription . plan } \" ) self . assertEqual ( subscription . default_tax_rates . count (), 1 ) self . assertEqual ( subscription . default_tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) self . assertEqual ( datetime_to_unix ( subscription . cancel_at ), 1624553655 ) tests . test_subscription . SubscriptionTest . test_sync_items_with_tax_rates ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN_II ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_items_with_tax_rates ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_II ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) self . assertEqual ( subscription . default_tax_rates . count (), 0 ) first_item = subscription . items . first () self . assertEqual ( first_item . tax_rates . count (), 1 ) self . assertEqual ( first_item . tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) tests . test_subscription . SubscriptionTest . test_sync_metered_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_METERED ) ) def test_sync_metered_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_METERED ) self . assertNotIn ( \"quantity\" , subscription_fake [ \"items\" ][ \"data\" ], \"Expect Metered plan SubscriptionItem to have no quantity\" , ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) items = subscription . items . all () self . assertEqual ( 1 , len ( items )) item = items [ 0 ] self . assertEqual ( subscription . quantity , 1 ) # Note that subscription.quantity is 1, # but item.quantity isn't set on metered plans self . assertIsNone ( item . quantity ) self . assertEqual ( item . plan . id , FAKE_PLAN_METERED [ \"id\" ]) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_sync_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ), ) def test_sync_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertIsNone ( subscription . plan ) self . assertIsNone ( subscription . quantity ) items = subscription . items . all () self . assertEqual ( 2 , len ( items )) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Customer.subscriber\" , \"djstripe.Subscription.plan\" }, ) tests . test_subscription . SubscriptionTest . test_update ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_update ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertEqual ( 1 , subscription . quantity ) new_subscription = subscription . update ( quantity = 4 ) self . assertEqual ( 4 , new_subscription . quantity ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_update_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ), ) def test_update_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertIsNone ( subscription . plan ) self . assertIsNone ( subscription . quantity ) items = subscription . items . all () self . assertEqual ( 2 , len ( items )) # Simulate a webhook received with one plan that has been removed del subscription_fake [ \"items\" ][ \"data\" ][ 1 ] subscription_fake [ \"items\" ][ \"total_count\" ] = 1 subscription = Subscription . sync_from_stripe_data ( subscription_fake ) items = subscription . items . all () self . assertEqual ( 1 , len ( items )) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Customer.subscriber\" , \"djstripe.Subscription.plan\" }, ) tests . test_subscription . SubscriptionTest . test_update_set_empty_value ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_update_set_empty_value ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake . update ({ \"tax_percent\" : Decimal ( 20.0 )}) subscription_retrieve_mock . return_value = subscription_fake subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertEqual ( Decimal ( 20.0 ), subscription . tax_percent ) new_subscription = subscription . update ( tax_percent = Decimal ( 0.0 )) self . assertEqual ( Decimal ( 0.0 ), new_subscription . tax_percent ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_update_with_plan_model ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_update_with_plan_model ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) new_plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN_II )) self . assertEqual ( FAKE_PLAN [ \"id\" ], subscription . plan . id ) new_subscription = subscription . update ( plan = new_plan ) self . assertEqual ( FAKE_PLAN_II [ \"id\" ], new_subscription . plan . id ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) self . assert_fks ( new_plan , expected_blank_fks = {}) tests.test_subscription_schedule dj-stripe SubscriptionSchedule model tests. Classes tests.test_subscription_schedule.SubscriptionScheduleTest Methods tests . test_subscription_schedule . SubscriptionScheduleTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_subscription_schedule.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER_II . create_for_user ( self . user ) self . default_expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.SubscriptionSchedule.released_subscription\" , } tests . test_subscription_schedule . SubscriptionScheduleTest . test_sync_from_stripe_data ( self , customer_retrieve_mock ) Source code in tests/test_subscription_schedule.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) def test_sync_from_stripe_data ( self , customer_retrieve_mock ): canceled_schedule_fake = deepcopy ( FAKE_SUBSCRIPTION_SCHEDULE ) canceled_schedule_fake [ \"canceled_at\" ] = 1624553655 canceled_schedule_fake [ \"status\" ] = SubscriptionScheduleStatus . canceled schedule = SubscriptionSchedule . sync_from_stripe_data ( canceled_schedule_fake ) self . assert_fks ( schedule , expected_blank_fks = self . default_expected_blank_fks ) self . assertEqual ( datetime_to_unix ( schedule . canceled_at ), 1624553655 ) tests.test_sync dj-stripe Sync Method Tests. Classes tests.test_sync.TestSyncSubscriber Methods tests . test_sync . TestSyncSubscriber . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_sync.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"testuser\" , email = \"test@example.com\" , password = \"123\" ) tests . test_sync . TestSyncSubscriber . test_sync_fail ( self , stripe_customer_create_mock , api_retrieve_mock ) Source code in tests/test_sync.py @patch ( \"djstripe.models.Customer.api_retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True , ) @patch ( \"stripe.Customer.create\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_fail ( self , stripe_customer_create_mock , api_retrieve_mock ): api_retrieve_mock . side_effect = InvalidRequestError ( \"No such customer:\" , \"blah\" ) with capture_stdout () as stdout : sync_subscriber ( self . user ) self . assertEqual ( \"ERROR: No such customer:\" , stdout . getvalue () . strip ()) tests . test_sync . TestSyncSubscriber . test_sync_success ( self , stripe_customer_create_mock , api_retrieve_mock , _sync_subscriptions_mock , _sync_invoices_mock , _sync_charges_mock ) Source code in tests/test_sync.py @patch ( \"djstripe.models.Customer._sync_charges\" , autospec = True ) @patch ( \"djstripe.models.Customer._sync_invoices\" , autospec = True ) @patch ( \"djstripe.models.Customer._sync_subscriptions\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Customer.create\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_success ( self , stripe_customer_create_mock , api_retrieve_mock , _sync_subscriptions_mock , _sync_invoices_mock , _sync_charges_mock , ): sync_subscriber ( self . user ) self . assertEqual ( 1 , Customer . objects . count ()) self . assertEqual ( FAKE_CUSTOMER [ \"id\" ], Customer . objects . get ( subscriber = self . user ) . api_retrieve ()[ \"id\" ], ) _sync_subscriptions_mock . assert_called_once_with ( Customer . objects . first ()) _sync_invoices_mock . assert_called_once_with ( Customer . objects . first ()) _sync_charges_mock . assert_called_once_with ( Customer . objects . first ()) tests . test_sync . capture_stdout () Source code in tests/test_sync.py @contextlib . contextmanager def capture_stdout (): import sys from io import StringIO old_stdout = sys . stdout sys . stdout = StringIO () try : yield sys . stdout finally : sys . stdout = old_stdout tests.test_tax_ids dj-stripe TaxId Model Tests. tests.test_tax_ids.TaxIdTest tests . test_tax_ids . TaxIdTest . test_api_list_invalid ( self ) Source code in tests/test_tax_ids.py def test_api_list_invalid ( self ): with pytest . raises ( StripeObjectManipulationException ) as e : TaxId . api_list ( customer = \"Iamastring\" ) assert ( str ( e . value ) == \"TaxIds must be manipulated through a Customer. Pass a Customer object into this call.\" ) tests . test_tax_ids . TaxIdTest . test_api_list_success ( self , customer_mock ) Source code in tests/test_tax_ids.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_WITH_TAX_ID )) def test_api_list_success ( self , customer_mock ): customer = Customer . sync_from_stripe_data ( customer_mock . return_value ) self . assertEqual ( customer . tax_ids . count (), 1 ) tax_ids = TaxId . api_list ( customer = customer ) self . assertEqual ( customer . tax_ids . last () . value , tax_ids [ \"data\" ][ 0 ][ \"value\" ]) tests . test_tax_ids . TaxIdTest . test_sync_from_stripe_data ( self , customer_mock ) Source code in tests/test_tax_ids.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_WITHOUT_TAX_ID ) ) def test_sync_from_stripe_data ( self , customer_mock ): customer = Customer . sync_from_stripe_data ( FAKE_CUSTOMER_WITHOUT_TAX_ID ) self . assertEqual ( customer . tax_ids . count (), 0 ) tax_id = TaxId . sync_from_stripe_data ( deepcopy ( FAKE_TAX_ID )) self . assertEqual ( tax_id . type , \"eu_vat\" ) self . assertEqual ( tax_id . value , \"DE123456789\" ) self . assertEqual ( customer . tax_ids . last (), tax_id ) tests.test_tax_rates dj-stripe SetupIntent Model Tests. tests.test_tax_rates.TaxRateTest tests . test_tax_rates . TaxRateTest . test_sync_from_stripe_data ( self ) Source code in tests/test_tax_rates.py def test_sync_from_stripe_data ( self ): tax_rate = TaxRate . sync_from_stripe_data ( deepcopy ( FAKE_TAX_RATE_EXAMPLE_1_VAT )) # need to refresh to load percentage as decimal tax_rate . refresh_from_db () self . assertIsInstance ( tax_rate . percentage , Decimal ) self . assertEqual ( tax_rate . percentage , Decimal ( \"15.0\" )) tests . test_tax_rates . TaxRateTest . test_sync_from_stripe_data_non_integer ( self ) Source code in tests/test_tax_rates.py def test_sync_from_stripe_data_non_integer ( self ): # an example non-integer taxrate tax_rate = TaxRate . sync_from_stripe_data ( deepcopy ( FAKE_TAX_RATE_EXAMPLE_2_SALES ) ) # need to refresh to load percentage as decimal tax_rate . refresh_from_db () self . assertIsInstance ( tax_rate . percentage , Decimal ) self . assertEqual ( tax_rate . percentage , Decimal ( \"4.25\" )) tests.test_utils dj-stripe Utilities Tests. tests . test_utils . TZ_IS_UTC Classes tests.test_utils.TestGetSupportedCurrencyChoices tests . test_utils . TestGetSupportedCurrencyChoices . test_get_choices ( self , stripe_account_retrieve_mock , stripe_countryspec_retrieve_mock ) Source code in tests/test_utils.py @patch ( \"stripe.CountrySpec.retrieve\" , return_value = { \"supported_payment_currencies\" : [ \"usd\" , \"cad\" , \"eur\" ]}, ) @patch ( \"stripe.Account.retrieve\" , return_value = { \"country\" : \"US\" }, autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_get_choices ( self , stripe_account_retrieve_mock , stripe_countryspec_retrieve_mock ): # Simple test to test sure that at least one currency choice tuple is returned. currency_choices = get_supported_currency_choices ( None ) stripe_account_retrieve_mock . assert_called_once_with () stripe_countryspec_retrieve_mock . assert_called_once_with ( \"US\" ) self . assertGreaterEqual ( len ( currency_choices ), 1 , \"Currency choices pull returned an empty list.\" ) self . assertEqual ( tuple , type ( currency_choices [ 0 ]), \"Currency choices are not tuples.\" ) self . assertIn (( \"usd\" , \"USD\" ), currency_choices , \"USD not in currency choices.\" ) tests.test_utils.TestTimestampConversion tests . test_utils . TestTimestampConversion . test_conversion ( self ) Source code in tests/test_utils.py def test_conversion ( self ): stamp = convert_tstamp ( 1365567407 ) self . assertEqual ( stamp , datetime ( 2013 , 4 , 10 , 4 , 16 , 47 , tzinfo = timezone . utc )) tests . test_utils . TestTimestampConversion . test_conversion_no_tz ( self ) Source code in tests/test_utils.py @skipIf ( not TZ_IS_UTC , \"Skipped because timezone is not UTC.\" ) @override_settings ( USE_TZ = False ) def test_conversion_no_tz ( self ): stamp = convert_tstamp ( 1365567407 ) self . assertEqual ( stamp , datetime ( 2013 , 4 , 10 , 4 , 16 , 47 )) tests.test_utils.TestUserHasActiveSubscription Methods tests . test_utils . TestUserHasActiveSubscription . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_utils.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_utils . TestUserHasActiveSubscription . test_anonymous_user ( self ) This needs to throw an ImproperlyConfigured error so the developer can be guided to properly protect the subscription content. Source code in tests/test_utils.py def test_anonymous_user ( self ): \"\"\" This needs to throw an ImproperlyConfigured error so the developer can be guided to properly protect the subscription content. \"\"\" anon_user = AnonymousUser () with self . assertRaises ( ImproperlyConfigured ): subscriber_has_active_subscription ( anon_user ) tests . test_utils . TestUserHasActiveSubscription . test_custom_subscriber ( self ) subscriber_has_active_subscription attempts to create a customer object for the current user. This causes a ValueError in this test because the database has already been established with auth.User. Source code in tests/test_utils.py def test_custom_subscriber ( self ): \"\"\" ``subscriber_has_active_subscription`` attempts to create a customer object for the current user. This causes a ValueError in this test because the database has already been established with auth.User. \"\"\" subscriber = Organization . objects . create ( email = \"email@test.com\" ) self . assertRaises ( ValueError , subscriber_has_active_subscription , subscriber ) tests . test_utils . TestUserHasActiveSubscription . test_staff_user ( self ) Source code in tests/test_utils.py def test_staff_user ( self ): self . user . is_staff = True self . user . save () self . assertTrue ( subscriber_has_active_subscription ( self . user )) tests . test_utils . TestUserHasActiveSubscription . test_superuser ( self ) Source code in tests/test_utils.py def test_superuser ( self ): self . user . is_superuser = True self . user . save () self . assertTrue ( subscriber_has_active_subscription ( self . user )) tests . test_utils . TestUserHasActiveSubscription . test_user_has_active_subscription ( self , product_retrieve_mock ) Source code in tests/test_utils.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_user_has_active_subscription ( self , product_retrieve_mock ): subscription = Subscription . sync_from_stripe_data ( deepcopy ( FAKE_SUBSCRIPTION )) subscription . current_period_end = timezone . now () + timezone . timedelta ( days = 10 ) subscription . save () # Assert that the customer's subscription is valid self . assertTrue ( subscriber_has_active_subscription ( self . user )) tests . test_utils . TestUserHasActiveSubscription . test_user_has_inactive_subscription ( self ) Source code in tests/test_utils.py def test_user_has_inactive_subscription ( self ): self . assertFalse ( subscriber_has_active_subscription ( self . user )) tests.test_utils.TestUtils tests . test_utils . TestUtils . test_get_friendly_currency_amount ( self ) Source code in tests/test_utils.py def test_get_friendly_currency_amount ( self ): self . assertEqual ( get_friendly_currency_amount ( Decimal ( \"1.001\" ), \"usd\" ), \"$1.00 USD\" ) self . assertEqual ( get_friendly_currency_amount ( Decimal ( \"10\" ), \"usd\" ), \"$10.00 USD\" ) self . assertEqual ( get_friendly_currency_amount ( Decimal ( \"10.50\" ), \"usd\" ), \"$10.50 USD\" ) self . assertEqual ( get_friendly_currency_amount ( Decimal ( \"10.51\" ), \"cad\" ), \"$10.51 CAD\" ) self . assertEqual ( get_friendly_currency_amount ( Decimal ( \"9.99\" ), \"eur\" ), \"\u20ac9.99 EUR\" ) tests.test_webhooks dj-stripe Webhook Tests. Classes tests.test_webhooks.TestWebhook Methods tests . test_webhooks . TestWebhook . tearDown ( self ) Hook method for deconstructing the test fixture after testing it. Source code in tests/test_webhooks.py def tearDown ( self ): reload ( djstripe_settings ) tests . test_webhooks . TestWebhook . test_webhook_error ( self , event_retrieve_mock , transfer_retrieve_mock , mock_invoke_webhook_handlers ) Test the case where webhook processing fails to ensure we rollback and do not commit the Event object to the database. Source code in tests/test_webhooks.py @patch . object ( target = Event , attribute = \"invoke_webhook_handlers\" , autospec = True ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_webhook_error ( self , event_retrieve_mock , transfer_retrieve_mock , mock_invoke_webhook_handlers ): \"\"\"Test the case where webhook processing fails to ensure we rollback and do not commit the Event object to the database. \"\"\" mock_invoke_webhook_handlers . side_effect = KeyError ( \"Test error\" ) djstripe_settings . WEBHOOK_SECRET = \"\" fake_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) event_retrieve_mock . return_value = fake_event with self . assertRaises ( KeyError ): self . _send_event ( fake_event ) self . assertEqual ( Event . objects . count (), 0 ) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertEqual ( event_trigger . is_test_event , False ) self . assertEqual ( event_trigger . exception , \"'Test error'\" ) tests . test_webhooks . TestWebhook . test_webhook_good ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_webhooks.py @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_webhook_good ( self , event_retrieve_mock , transfer_retrieve_mock ): djstripe_settings . WEBHOOK_SECRET = \"\" fake_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) event_retrieve_mock . return_value = fake_event resp = self . _send_event ( fake_event ) self . assertEqual ( resp . status_code , 200 ) self . assertEqual ( Event . objects . count (), 1 ) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertEqual ( event_trigger . is_test_event , False ) tests . test_webhooks . TestWebhook . test_webhook_invalid_verify_signature_fail ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_webhooks.py @override_settings ( DJSTRIPE_WEBHOOK_VALIDATION = \"verify_signature\" , DJSTRIPE_WEBHOOK_SECRET = \"whsec_XXXXX\" , ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ), autospec = True , ) def test_webhook_invalid_verify_signature_fail ( self , event_retrieve_mock , transfer_retrieve_mock ): reload ( djstripe_settings ) invalid_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) invalid_event [ \"id\" ] = \"evt_invalid\" invalid_event [ \"data\" ][ \"valid\" ] = \"not really\" resp = self . _send_event ( invalid_event ) self . assertEqual ( resp . status_code , 400 ) self . assertFalse ( Event . objects . filter ( id = \"evt_invalid\" ) . exists ()) tests . test_webhooks . TestWebhook . test_webhook_no_signature ( self ) Source code in tests/test_webhooks.py def test_webhook_no_signature ( self ): self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) resp = Client () . post ( reverse ( \"djstripe:webhook\" ), \" {} \" , content_type = \"application/json\" ) self . assertEqual ( resp . status_code , 400 ) self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) tests . test_webhooks . TestWebhook . test_webhook_no_validation_pass ( self , event_retrieve_mock , transfer_retrieve_mock , verify_header_mock ) Source code in tests/test_webhooks.py @override_settings ( DJSTRIPE_WEBHOOK_VALIDATION = None ) @patch ( \"stripe.WebhookSignature.verify_header\" , autospec = True ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ), autospec = True , ) def test_webhook_no_validation_pass ( self , event_retrieve_mock , transfer_retrieve_mock , verify_header_mock ): reload ( djstripe_settings ) invalid_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) invalid_event [ \"id\" ] = \"evt_invalid\" invalid_event [ \"data\" ][ \"valid\" ] = \"not really\" resp = self . _send_event ( invalid_event ) self . assertEqual ( resp . status_code , 200 ) self . assertTrue ( Event . objects . filter ( id = \"evt_invalid\" ) . exists ()) event_retrieve_mock . assert_not_called () verify_header_mock . assert_not_called () tests . test_webhooks . TestWebhook . test_webhook_remote_addr_is_empty_string ( self ) Source code in tests/test_webhooks.py def test_webhook_remote_addr_is_empty_string ( self ): self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) with warnings . catch_warnings (): warnings . simplefilter ( \"ignore\" ) Client () . post ( reverse ( \"djstripe:webhook\" ), \" {} \" , content_type = \"application/json\" , HTTP_STRIPE_SIGNATURE = \"PLACEHOLDER\" , REMOTE_ADDR = \"\" , ) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertEqual ( event_trigger . remote_ip , \"0.0.0.0\" ) tests . test_webhooks . TestWebhook . test_webhook_remote_addr_is_none ( self ) Source code in tests/test_webhooks.py def test_webhook_remote_addr_is_none ( self ): self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) with warnings . catch_warnings (): warnings . simplefilter ( \"ignore\" ) Client () . post ( reverse ( \"djstripe:webhook\" ), \" {} \" , content_type = \"application/json\" , HTTP_STRIPE_SIGNATURE = \"PLACEHOLDER\" , REMOTE_ADDR = None , ) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertEqual ( event_trigger . remote_ip , \"0.0.0.0\" ) tests . test_webhooks . TestWebhook . test_webhook_reraise_exception ( self , webhook_event_process_mock , webhook_event_validate_mock ) Source code in tests/test_webhooks.py @patch ( \"djstripe.models.WebhookEventTrigger.validate\" , return_value = True , autospec = True ) @patch ( \"djstripe.models.WebhookEventTrigger.process\" , autospec = True ) def test_webhook_reraise_exception ( self , webhook_event_process_mock , webhook_event_validate_mock ): class ProcessException ( Exception ): pass exception_message = \"process fail\" webhook_event_process_mock . side_effect = ProcessException ( exception_message ) self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) fake_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) with self . assertRaisesMessage ( ProcessException , exception_message ): self . _send_event ( fake_event ) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertEqual ( event_trigger . exception , exception_message ) tests . test_webhooks . TestWebhook . test_webhook_retrieve_event_fail ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_webhooks.py @override_settings ( DJSTRIPE_WEBHOOK_VALIDATION = \"retrieve_event\" ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ), autospec = True , ) def test_webhook_retrieve_event_fail ( self , event_retrieve_mock , transfer_retrieve_mock ): reload ( djstripe_settings ) invalid_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) invalid_event [ \"id\" ] = \"evt_invalid\" invalid_event [ \"data\" ][ \"valid\" ] = \"not really\" resp = self . _send_event ( invalid_event ) self . assertEqual ( resp . status_code , 400 ) self . assertFalse ( Event . objects . filter ( id = \"evt_invalid\" ) . exists ()) tests . test_webhooks . TestWebhook . test_webhook_retrieve_event_pass ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_webhooks.py @override_settings ( DJSTRIPE_WEBHOOK_VALIDATION = \"retrieve_event\" ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ), autospec = True , ) def test_webhook_retrieve_event_pass ( self , event_retrieve_mock , transfer_retrieve_mock ): reload ( djstripe_settings ) resp = self . _send_event ( FAKE_EVENT_TRANSFER_CREATED ) self . assertEqual ( resp . status_code , 200 ) event_retrieve_mock . assert_called_once_with ( api_key = djstripe_settings . STRIPE_SECRET_KEY , id = FAKE_EVENT_TRANSFER_CREATED [ \"id\" ], ) tests . test_webhooks . TestWebhook . test_webhook_test_event ( self ) Source code in tests/test_webhooks.py def test_webhook_test_event ( self ): self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) resp = self . _send_event ( FAKE_EVENT_TEST_CHARGE_SUCCEEDED ) self . assertEqual ( resp . status_code , 200 ) self . assertFalse ( Event . objects . filter ( id = TEST_EVENT_ID ) . exists ()) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertTrue ( event_trigger . is_test_event ) tests . test_webhooks . TestWebhook . test_webhook_verify_signature_pass ( self , event_retrieve_mock , transfer_retrieve_mock , verify_header_mock ) Source code in tests/test_webhooks.py @override_settings ( DJSTRIPE_WEBHOOK_VALIDATION = \"verify_signature\" , DJSTRIPE_WEBHOOK_SECRET = \"whsec_XXXXX\" , ) @patch ( \"stripe.WebhookSignature.verify_header\" , return_value = True , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ), autospec = True , ) def test_webhook_verify_signature_pass ( self , event_retrieve_mock , transfer_retrieve_mock , verify_header_mock ): reload ( djstripe_settings ) resp = self . _send_event ( FAKE_EVENT_TRANSFER_CREATED ) self . assertEqual ( resp . status_code , 200 ) self . assertFalse ( Event . objects . filter ( id = \"evt_invalid\" ) . exists ()) verify_header_mock . assert_called_once_with ( json . dumps ( FAKE_EVENT_TRANSFER_CREATED ), \"PLACEHOLDER\" , djstripe_settings . WEBHOOK_SECRET , djstripe_settings . WEBHOOK_TOLERANCE , ) event_retrieve_mock . assert_not_called () tests . test_webhooks . TestWebhook . test_webhook_with_custom_callback ( self , event_retrieve_mock , transfer_retrieve_mock , webhook_event_callback_mock ) Source code in tests/test_webhooks.py @patch . object ( djstripe_settings , \"WEBHOOK_EVENT_CALLBACK\" , return_value = mock_webhook_handler ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_webhook_with_custom_callback ( self , event_retrieve_mock , transfer_retrieve_mock , webhook_event_callback_mock ): fake_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) event_retrieve_mock . return_value = fake_event djstripe_settings . WEBHOOK_SECRET = \"\" resp = self . _send_event ( fake_event ) self . assertEqual ( resp . status_code , 200 ) webhook_event_trigger = WebhookEventTrigger . objects . get () webhook_event_callback_mock . called_once_with ( webhook_event_trigger ) tests . test_webhooks . TestWebhook . test_webhook_with_transfer_event_duplicate ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_webhooks.py @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_webhook_with_transfer_event_duplicate ( self , event_retrieve_mock , transfer_retrieve_mock ): fake_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) event_retrieve_mock . return_value = fake_event djstripe_settings . WEBHOOK_SECRET = \"\" resp = self . _send_event ( fake_event ) self . assertEqual ( resp . status_code , 200 ) self . assertTrue ( Event . objects . filter ( type = \"transfer.created\" ) . exists ()) self . assertEqual ( 1 , Event . objects . filter ( type = \"transfer.created\" ) . count ()) # Duplication resp = self . _send_event ( fake_event ) self . assertEqual ( resp . status_code , 200 ) self . assertEqual ( 1 , Event . objects . filter ( type = \"transfer.created\" ) . count ()) tests.test_webhooks.TestWebhookHandlers Methods tests . test_webhooks . TestWebhookHandlers . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_webhooks.py def setUp ( self ): # Reset state of registrations per test patcher = patch . object ( webhooks , \"registrations\" , new_callable = ( lambda : defaultdict ( list )) ) self . addCleanup ( patcher . stop ) self . registrations = patcher . start () patcher = patch . object ( webhooks , \"registrations_global\" , new_callable = list ) self . addCleanup ( patcher . stop ) self . registrations_global = patcher . start () tests . test_webhooks . TestWebhookHandlers . test_event_handle_registation_with_list_of_strings ( self ) Source code in tests/test_webhooks.py def test_event_handle_registation_with_list_of_strings ( self ): func_mock = Mock () handler ( \"foo\" , \"bar\" )( func_mock ) event1 = self . _call_handlers ( \"foo.bar\" , { \"data\" : \"foo\" }) # handled event2 = self . _call_handlers ( \"bar.foo\" , { \"data\" : \"bar\" }) # handled self . assertEqual ( 2 , func_mock . call_count ) func_mock . assert_has_calls ([ call ( event = event1 ), call ( event = event2 )]) tests . test_webhooks . TestWebhookHandlers . test_event_handle_registation_with_string ( self ) Source code in tests/test_webhooks.py def test_event_handle_registation_with_string ( self ): func_mock = Mock () handler ( \"foo\" )( func_mock ) event = self . _call_handlers ( \"foo.bar\" , { \"data\" : \"foo\" }) # handled self . assertEqual ( 1 , func_mock . call_count ) func_mock . assert_called_with ( event = event ) tests . test_webhooks . TestWebhookHandlers . test_event_handler_registration ( self ) Source code in tests/test_webhooks.py def test_event_handler_registration ( self ): global_func_mock = Mock () handler_all ()( global_func_mock ) func_mock = Mock () handler ( \"foo\" )( func_mock ) event = self . _call_handlers ( \"foo.bar\" , { \"data\" : \"foo\" }) # handled self . _call_handlers ( \"bar.foo\" , { \"data\" : \"foo\" }) # not handled self . assertEqual ( 2 , global_func_mock . call_count ) # called each time self . assertEqual ( 1 , func_mock . call_count ) func_mock . assert_called_with ( event = event ) tests . test_webhooks . TestWebhookHandlers . test_event_subtype_handler_registration ( self ) Source code in tests/test_webhooks.py def test_event_subtype_handler_registration ( self ): global_func_mock = Mock () handler_all ()( global_func_mock ) func_mock = Mock () handler ( \"foo.bar\" )( func_mock ) event1 = self . _call_handlers ( \"foo.bar\" , { \"data\" : \"foo\" }) # handled event2 = self . _call_handlers ( \"foo.bar.wib\" , { \"data\" : \"foo\" }) # handled self . _call_handlers ( \"foo.baz\" , { \"data\" : \"foo\" }) # not handled self . assertEqual ( 3 , global_func_mock . call_count ) # called each time self . assertEqual ( 2 , func_mock . call_count ) func_mock . assert_has_calls ([ call ( event = event1 ), call ( event = event2 )]) tests . test_webhooks . TestWebhookHandlers . test_global_handler_registration ( self ) Source code in tests/test_webhooks.py def test_global_handler_registration ( self ): func_mock = Mock () handler_all ()( func_mock ) event = self . _call_handlers ( \"wib.ble\" , { \"data\" : \"foo\" }) # handled self . assertEqual ( 1 , func_mock . call_count ) func_mock . assert_called_with ( event = event ) tests . test_webhooks . TestWebhookHandlers . test_global_handler_registration_with_function ( self ) Source code in tests/test_webhooks.py def test_global_handler_registration_with_function ( self ): func_mock = Mock () handler_all ( func_mock ) event = self . _call_handlers ( \"wib.ble\" , { \"data\" : \"foo\" }) # handled self . assertEqual ( 1 , func_mock . call_count ) func_mock . assert_called_with ( event = event ) tests . test_webhooks . TestWebhookHandlers . test_webhook_event_trigger_invalid_body ( self ) Source code in tests/test_webhooks.py def test_webhook_event_trigger_invalid_body ( self ): trigger = WebhookEventTrigger ( remote_ip = \"127.0.0.1\" , body = \"invalid json\" ) assert not trigger . json_body tests . test_webhooks . mock_webhook_handler ( webhook_event_trigger ) Source code in tests/test_webhooks.py def mock_webhook_handler ( webhook_event_trigger ): webhook_event_trigger . process () tests.test_zz_jsonfield Tests for JSONField Due to their nature messing with subclassing, these tests must be run last. Classes tests.test_zz_jsonfield.TestFallbackJSONField Methods tests . test_zz_jsonfield . TestFallbackJSONField . tearDown ( self ) Hook method for deconstructing the test fixture after testing it. Source code in tests/test_zz_jsonfield.py def tearDown ( self ): reload ( djstripe_settings ) reload ( fields ) tests . test_zz_jsonfield . TestFallbackJSONField . test_jsonfield_inheritance ( self ) Source code in tests/test_zz_jsonfield.py def test_jsonfield_inheritance ( self ): reload ( djstripe_settings ) reload ( fields ) self . assertTrue ( issubclass ( fields . JSONField , UglyJSONField )) tests.test_zz_jsonfield.TestNativeJSONField Methods tests . test_zz_jsonfield . TestNativeJSONField . tearDown ( self ) Hook method for deconstructing the test fixture after testing it. Source code in tests/test_zz_jsonfield.py def tearDown ( self ): reload ( djstripe_settings ) reload ( fields ) tests . test_zz_jsonfield . TestNativeJSONField . test_jsonfield_inheritance ( self ) Source code in tests/test_zz_jsonfield.py def test_jsonfield_inheritance ( self ): reload ( djstripe_settings ) reload ( fields ) self . assertTrue ( issubclass ( fields . JSONField , DjangoJSONField )) tests.urls tests . urls . urlpatterns tests . urls . empty_view ( request ) Source code in tests/urls.py def empty_view ( request ): return HttpResponse ()","title":"Project"},{"location":"reference/project/#djstripe.models.__all__","text":"","title":"__all__"},{"location":"reference/project/#djstripe.models-modules","text":"","title":"Modules"},{"location":"reference/project/#djstripe.models.account","text":"","title":"account"},{"location":"reference/project/#djstripe.models.account-classes","text":"","title":"Classes"},{"location":"reference/project/#djstripe.models.account.Account","text":"Stripe documentation: https://stripe.com/docs/api#account","title":"Account"},{"location":"reference/project/#djstripe.models.account.Account-attributes","text":"djstripe . models . account . Account . branding_icon property readonly djstripe . models . account . Account . branding_logo property readonly djstripe . models . account . Account . business_profile djstripe . models . account . Account . business_type djstripe . models . account . Account . business_url : str property readonly The business\u2019s publicly available website. djstripe . models . account . Account . charges_enabled djstripe . models . account . Account . company djstripe . models . account . Account . country djstripe . models . account . Account . default_api_key : str property readonly djstripe . models . account . Account . default_currency djstripe . models . account . Account . details_submitted djstripe . models . account . Account . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . account . Account . email djstripe . models . account . Account . individual djstripe . models . account . Account . payouts_enabled djstripe . models . account . Account . product_description djstripe . models . account . Account . requirements djstripe . models . account . Account . settings djstripe . models . account . Account . tos_acceptance djstripe . models . account . Account . type djstripe.models.account.Account.DoesNotExist djstripe.models.account.Account.MultipleObjectsReturned djstripe.models.account.Account.stripe_class djstripe . models . account . Account . stripe_class . OBJECT_NAME djstripe . models . account . Account . stripe_class . capabilitys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . capabilitys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . create_external_account ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_login_link ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . create_person ( id , ** params ) classmethod Source code in djstripe/models/account.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . deauthorize ( self , ** params ) Source code in djstripe/models/account.py def deauthorize ( self , ** params ): params [ \"stripe_user_id\" ] = self . id return oauth . OAuth . deauthorize ( ** params ) djstripe . models . account . Account . stripe_class . delete_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . delete_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . account . Account . stripe_class . external_accounts_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . external_accounts_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . instance_url ( self ) Source code in djstripe/models/account.py def instance_url ( self ): return self . _build_instance_url ( self . get ( \"id\" )) djstripe . models . account . Account . stripe_class . list_capabilities ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_external_accounts ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . list_persons ( id , ** params ) classmethod Source code in djstripe/models/account.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . login_links_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . login_links_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . modify ( id = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def modify ( cls , id = None , ** params ): url = cls . _build_instance_url ( id ) return cls . _static_request ( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . modify_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . account . Account . stripe_class . persons ( self , ** params ) Source code in djstripe/models/account.py def persons ( self , ** params ): return self . request ( \"get\" , self . instance_url () + \"/persons\" , params ) djstripe . models . account . Account . stripe_class . persons_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/account.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . account . Account . stripe_class . persons_url ( id , nested_id = None ) classmethod Source code in djstripe/models/account.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . account . Account . stripe_class . reject ( self , idempotency_key = None , ** params ) Source code in djstripe/models/account.py def reject ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reject\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . account . Account . stripe_class . retrieve ( id = None , api_key = None , ** params ) classmethod Source code in djstripe/models/account.py @classmethod def retrieve ( cls , id = None , api_key = None , ** params ): instance = cls ( id , api_key , ** params ) instance . refresh () return instance djstripe . models . account . Account . stripe_class . retrieve_capability ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_external_account ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . retrieve_person ( id , nested_id , ** params ) classmethod Source code in djstripe/models/account.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . account . Account . stripe_class . serialize ( self , previous ) Source code in djstripe/models/account.py def serialize ( self , previous ): params = super ( Account , self ) . serialize ( previous ) previous = previous or self . _previous or {} for k , v in six . iteritems ( self ): if ( k == \"individual\" and isinstance ( v , stripe . api_resources . Person ) and k not in params ): params [ k ] = v . serialize ( previous . get ( k , None )) return params djstripe . models . account . Account . __str__ ( self ) special Source code in djstripe/models/account.py def __str__ ( self ): settings = self . settings or {} business_profile = self . business_profile or {} return ( settings . get ( \"dashboard\" , {}) . get ( \"display_name\" ) or business_profile . get ( \"name\" ) or super () . __str__ () ) djstripe . models . account . Account . get_business_type_display ( self , * , field =< djstripe . fields . StripeEnumField : business_type > ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_connected_account_from_token ( access_token ) classmethod Source code in djstripe/models/account.py @classmethod def get_connected_account_from_token ( cls , access_token ): warnings . warn ( \"Account.get_connected_account_from_token is deprecated.\" \"Use Account.get_or_retrieve_for_api_key() instead.\" , DeprecationWarning , ) account_data = cls . stripe_class . retrieve ( api_key = access_token ) return cls . _get_or_create_from_stripe_object ( account_data )[ 0 ] djstripe . models . account . Account . get_default_account () classmethod Source code in djstripe/models/account.py @classmethod def get_default_account ( cls ): # As of API version 2020-03-02, there is no permission that can allow # restricted keys to call GET /v1/account if djstripe_settings . STRIPE_SECRET_KEY . startswith ( \"rk_\" ): return None account_data = cls . stripe_class . retrieve ( api_key = djstripe_settings . STRIPE_SECRET_KEY ) return cls . _get_or_create_from_stripe_object ( account_data )[ 0 ] djstripe . models . account . Account . get_default_api_key ( self ) Source code in djstripe/models/account.py def get_default_api_key ( self ) -> str : api_key = APIKey . objects . filter ( djstripe_owner_account = self , type = APIKeyType . secret ) . first () if api_key : return api_key . secret return djstripe_settings . get_default_api_key ( self . livemode ) djstripe . models . account . Account . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_or_retrieve_for_api_key ( api_key ) classmethod Source code in djstripe/models/account.py @classmethod def get_or_retrieve_for_api_key ( cls , api_key : str ): with transaction . atomic (): apikey_instance , _ = APIKey . objects . get_or_create_by_api_key ( api_key ) if not apikey_instance . djstripe_owner_account : apikey_instance . refresh_account () return apikey_instance . djstripe_owner_account djstripe . models . account . Account . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . account . Account . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/account.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Attributes"},{"location":"reference/project/#djstripe.models.api","text":"","title":"api"},{"location":"reference/project/#djstripe.models.api.API_KEY_REGEX","text":"","title":"API_KEY_REGEX"},{"location":"reference/project/#djstripe.models.api-classes","text":"","title":"Classes"},{"location":"reference/project/#djstripe.models.api.APIKey","text":"APIKey(djstripe_id, djstripe_owner_account, created, djstripe_created, djstripe_updated, id, type, name, secret, livemode)","title":"APIKey"},{"location":"reference/project/#djstripe.models.api.APIKey-attributes","text":"djstripe . models . api . APIKey . description djstripe . models . api . APIKey . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . api . APIKey . metadata djstripe . models . api . APIKey . name djstripe . models . api . APIKey . object djstripe . models . api . APIKey . objects djstripe . models . api . APIKey . secret djstripe . models . api . APIKey . secret_redacted : str property readonly Returns a redacted version of the secret, suitable for display purposes. Same algorithm used on the Stripe dashboard. djstripe . models . api . APIKey . type djstripe.models.api.APIKey.DoesNotExist djstripe.models.api.APIKey.MultipleObjectsReturned","title":"Attributes"},{"location":"reference/project/#djstripe.models.api.APIKey-methods","text":"djstripe . models . api . APIKey . __str__ ( self ) special Source code in djstripe/models/api.py def __str__ ( self ): return self . name or self . secret_redacted djstripe . models . api . APIKey . clean ( self ) Hook for doing any extra model-wide validation after clean() has been called on every field by self.clean_fields. Any ValidationError raised by this method will not be associated with a particular field; it will have a special-case association with the field defined by NON_FIELD_ERRORS. Source code in djstripe/models/api.py def clean ( self ): self . _clean_livemode_and_type () if not self . djstripe_owner_account : self . refresh_account () return super () . clean () djstripe . models . api . APIKey . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/api.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . api . APIKey . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/api.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . api . APIKey . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/api.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . api . APIKey . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/api.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . api . APIKey . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/api.py def get_stripe_dashboard_url ( self ): return self . _get_base_stripe_dashboard_url () + \"apikeys\" djstripe . models . api . APIKey . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/api.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . api . APIKey . refresh_account ( self , commit = True ) Source code in djstripe/models/api.py def refresh_account ( self , commit = True ): from .account import Account if self . type != APIKeyType . secret : return account_data = Account . stripe_class . retrieve ( api_key = self . secret ) # NOTE: Do not immediately use _get_or_create_from_stripe_object() here. # Account needs to exist for things to work. Make a stub if necessary. account , created = Account . objects . get_or_create ( id = account_data [ \"id\" ], defaults = { \"charges_enabled\" : False , \"details_submitted\" : False }, ) if created : # If it's just been created, now we can sync the account. Account . sync_from_stripe_data ( account_data ) self . djstripe_owner_account = account if commit : self . save () djstripe . models . api . APIKey . save ( self , * args , ** kwargs ) Save the current instance. Override this in a subclass if you want to control the saving process. The 'force_insert' and 'force_update' parameters can be used to insist that the \"save\" must be an SQL insert or update (or equivalent for non-SQL backends), respectively. Normally, they should not be set. Source code in djstripe/models/api.py def save ( self , * args , ** kwargs ): self . _clean_livemode_and_type () if not self . djstripe_owner_account : self . refresh_account ( commit = False ) return super () . save ( * args , ** kwargs )","title":"Methods"},{"location":"reference/project/#djstripe.models.api.APIKeyManager","text":"djstripe . models . api . APIKeyManager . get_or_create_by_api_key ( self , secret ) Source code in djstripe/models/api.py def get_or_create_by_api_key ( self , secret : str ): key_type , livemode = get_api_key_details_by_prefix ( secret ) return super () . get_or_create ( secret = secret , defaults = { \"type\" : key_type , \"livemode\" : livemode } )","title":"APIKeyManager"},{"location":"reference/project/#djstripe.models.api.generate_api_key_id","text":"Source code in djstripe/models/api.py def generate_api_key_id () -> str : b64_id = b64encode ( uuid4 () . bytes ) . decode () generated_id = b64_id . rstrip ( \"=\" ) . replace ( \"+\" , \"\" ) . replace ( \"/\" , \"\" ) return f \"djstripe_mk_ { generated_id } \"","title":"generate_api_key_id()"},{"location":"reference/project/#djstripe.models.api.get_api_key_details_by_prefix","text":"Source code in djstripe/models/api.py def get_api_key_details_by_prefix ( api_key : str ): sre = re . match ( API_KEY_REGEX , api_key ) if not sre : raise ValueError ( f \"Invalid API key: { api_key !r} \" ) key_type = { \"pk\" : APIKeyType . publishable , \"sk\" : APIKeyType . secret , \"rk\" : APIKeyType . restricted , } . get ( sre . group ( 1 ), \"\" ) livemode = { \"test\" : False , \"live\" : True } . get ( sre . group ( 2 )) return key_type , livemode","title":"get_api_key_details_by_prefix()"},{"location":"reference/project/#djstripe.models.base","text":"","title":"base"},{"location":"reference/project/#djstripe.models.base.logger","text":"","title":"logger"},{"location":"reference/project/#djstripe.models.base-classes","text":"","title":"Classes"},{"location":"reference/project/#djstripe.models.base.IdempotencyKey","text":"IdempotencyKey(uuid, action, livemode, created) djstripe . models . base . IdempotencyKey . action djstripe . models . base . IdempotencyKey . created djstripe . models . base . IdempotencyKey . is_expired : bool property readonly djstripe . models . base . IdempotencyKey . livemode djstripe . models . base . IdempotencyKey . uuid djstripe.models.base.IdempotencyKey.DoesNotExist djstripe.models.base.IdempotencyKey.MultipleObjectsReturned djstripe . models . base . IdempotencyKey . __str__ ( self ) special Source code in djstripe/models/base.py def __str__ ( self ): return str ( self . uuid ) djstripe . models . base . IdempotencyKey . get_next_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = True , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . base . IdempotencyKey . get_previous_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = False , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"IdempotencyKey"},{"location":"reference/project/#djstripe.models.base.StripeModel","text":"djstripe . models . base . StripeModel . created djstripe . models . base . StripeModel . default_api_key : str property readonly djstripe . models . base . StripeModel . description djstripe . models . base . StripeModel . djstripe_created djstripe . models . base . StripeModel . djstripe_id djstripe . models . base . StripeModel . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . base . StripeModel . djstripe_updated djstripe . models . base . StripeModel . expand_fields : List [ str ] djstripe . models . base . StripeModel . id djstripe . models . base . StripeModel . livemode djstripe . models . base . StripeModel . metadata djstripe . models . base . StripeModel . objects djstripe . models . base . StripeModel . stripe_class : Optional [ stripe . api_resources . abstract . api_resource . APIResource ] djstripe . models . base . StripeModel . stripe_dashboard_item_name djstripe . models . base . StripeModel . stripe_objects djstripe.models.base.StripeModel.Meta djstripe . models . base . StripeModel . Meta . abstract djstripe . models . base . StripeModel . Meta . get_latest_by","title":"StripeModel"},{"location":"reference/project/#djstripe.models.base.StripeModel-methods","text":"djstripe . models . base . StripeModel . __str__ ( self ) special Source code in djstripe/models/base.py def __str__ ( self ): return smart_str ( \"< {list} >\" . format ( list = \", \" . join ( self . str_parts ()))) djstripe . models . base . StripeModel . api_list ( api_key = 'sk_test_123' , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/base.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): \"\"\" Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. \\ Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query \"\"\" return cls . stripe_class . list ( api_key = api_key , ** kwargs ) . auto_paging_iter () djstripe . models . base . StripeModel . api_retrieve ( self , api_key = None , stripe_account = None ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/base.py def api_retrieve ( self , api_key = None , stripe_account = None ): \"\"\" Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. \\ Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account \\ for which this request is being made. :type stripe_account: string \"\"\" # Prefer passed in stripe_account if set. if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) return self . stripe_class . retrieve ( id = self . id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , ) djstripe . models . base . StripeModel . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . base . StripeModel . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . base . StripeModel . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . base . StripeModel . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/base.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . base . StripeModel . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/base.py def get_stripe_dashboard_url ( self ) -> str : \"\"\"Get the stripe dashboard url for this object.\"\"\" if not self . stripe_dashboard_item_name or not self . id : return \"\" else : return \" {base_url}{item} / {id} \" . format ( base_url = self . _get_base_stripe_dashboard_url (), item = self . stripe_dashboard_item_name , id = self . id , ) djstripe . models . base . StripeModel . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/base.py @classmethod def is_valid_object ( cls , data ): \"\"\" Returns whether the data is a valid object for the class \"\"\" return \"object\" in data and data [ \"object\" ] == cls . stripe_class . OBJECT_NAME djstripe . models . base . StripeModel . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/base.py def str_parts ( self ) -> List [ str ]: \"\"\" Extend this to add information to the string representation of the object \"\"\" return [ \"id= {id} \" . format ( id = self . id )] djstripe . models . base . StripeModel . sync_from_stripe_data ( data ) classmethod Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls Source code in djstripe/models/base.py @classmethod def sync_from_stripe_data ( cls , data ): \"\"\" Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls \"\"\" current_ids = set () data_id = data . get ( \"id\" ) if data_id : # stop nested objects from trying to retrieve this object before # initial sync is complete current_ids . add ( data_id ) instance , created = cls . _get_or_create_from_stripe_object ( data , current_ids = current_ids ) if not created : record_data = cls . _stripe_object_to_record ( data ) for attr , value in record_data . items (): setattr ( instance , attr , value ) instance . _attach_objects_hook ( cls , data , current_ids = current_ids ) instance . save () instance . _attach_objects_post_save_hook ( cls , data ) return instance","title":"Methods"},{"location":"reference/project/#djstripe.models.billing","text":"","title":"billing"},{"location":"reference/project/#djstripe.models.billing-classes","text":"","title":"Classes"},{"location":"reference/project/#djstripe.models.billing.BaseInvoice","text":"The abstract base model shared by Invoice and UpcomingInvoice Note: Most fields are defined on BaseInvoice so they're available to both models. ManyToManyFields are an exception, since UpcomingInvoice doesn't exist in the db.","title":"BaseInvoice"},{"location":"reference/project/#djstripe.models.billing.BaseInvoice-attributes","text":"djstripe . models . billing . BaseInvoice . account_country djstripe . models . billing . BaseInvoice . account_name djstripe . models . billing . BaseInvoice . amount_due djstripe . models . billing . BaseInvoice . amount_paid djstripe . models . billing . BaseInvoice . amount_remaining djstripe . models . billing . BaseInvoice . application_fee_amount djstripe . models . billing . BaseInvoice . attempt_count djstripe . models . billing . BaseInvoice . attempted djstripe . models . billing . BaseInvoice . auto_advance djstripe . models . billing . BaseInvoice . billing_reason djstripe . models . billing . BaseInvoice . charge djstripe . models . billing . BaseInvoice . collection_method djstripe . models . billing . BaseInvoice . currency djstripe . models . billing . BaseInvoice . customer djstripe . models . billing . BaseInvoice . customer_address djstripe . models . billing . BaseInvoice . customer_email djstripe . models . billing . BaseInvoice . customer_name djstripe . models . billing . BaseInvoice . customer_phone djstripe . models . billing . BaseInvoice . customer_shipping djstripe . models . billing . BaseInvoice . customer_tax_exempt djstripe . models . billing . BaseInvoice . default_payment_method djstripe . models . billing . BaseInvoice . discount djstripe . models . billing . BaseInvoice . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . BaseInvoice . due_date djstripe . models . billing . BaseInvoice . ending_balance djstripe . models . billing . BaseInvoice . footer djstripe . models . billing . BaseInvoice . hosted_invoice_url djstripe . models . billing . BaseInvoice . invoice_pdf djstripe . models . billing . BaseInvoice . next_payment_attempt djstripe . models . billing . BaseInvoice . number djstripe . models . billing . BaseInvoice . paid djstripe . models . billing . BaseInvoice . payment_intent djstripe . models . billing . BaseInvoice . period_end djstripe . models . billing . BaseInvoice . period_start djstripe . models . billing . BaseInvoice . plan : Optional [ Plan ] property readonly Gets the associated plan for this invoice. In order to provide a consistent view of invoices, the plan object should be taken from the first invoice item that has one, rather than using the plan associated with the subscription. Subscriptions (and their associated plan) are updated by the customer and represent what is current, but invoice items are immutable within the invoice and stay static/unchanged. In other words, a plan retrieved from an invoice item will represent the plan as it was at the time an invoice was issued. The plan retrieved from the subscription will be the currently active plan. :returns: The associated plan for the invoice. djstripe . models . billing . BaseInvoice . post_payment_credit_notes_amount djstripe . models . billing . BaseInvoice . pre_payment_credit_notes_amount djstripe . models . billing . BaseInvoice . receipt_number djstripe . models . billing . BaseInvoice . starting_balance djstripe . models . billing . BaseInvoice . statement_descriptor djstripe . models . billing . BaseInvoice . status djstripe . models . billing . BaseInvoice . status_transitions djstripe . models . billing . BaseInvoice . stripe_dashboard_item_name djstripe . models . billing . BaseInvoice . subscription djstripe . models . billing . BaseInvoice . subscription_proration_date djstripe . models . billing . BaseInvoice . subtotal djstripe . models . billing . BaseInvoice . tax djstripe . models . billing . BaseInvoice . tax_percent djstripe . models . billing . BaseInvoice . threshold_reason djstripe . models . billing . BaseInvoice . total djstripe . models . billing . BaseInvoice . webhooks_delivered_at djstripe.models.billing.BaseInvoice.Meta djstripe . models . billing . BaseInvoice . Meta . abstract djstripe . models . billing . BaseInvoice . Meta . ordering djstripe.models.billing.BaseInvoice.stripe_class djstripe . models . billing . BaseInvoice . stripe_class . OBJECT_NAME djstripe . models . billing . BaseInvoice . stripe_class . finalize_invoice ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def finalize_invoice ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/finalize\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . BaseInvoice . stripe_class . mark_uncollectible ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def mark_uncollectible ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/mark_uncollectible\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . BaseInvoice . stripe_class . pay ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def pay ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/pay\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . BaseInvoice . stripe_class . send_invoice ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def send_invoice ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/send\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . BaseInvoice . stripe_class . upcoming ( api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def upcoming ( cls , api_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) url = cls . class_url () + \"/upcoming\" response , api_key = requestor . request ( \"get\" , url , params ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . BaseInvoice . stripe_class . void_invoice ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def void_invoice ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/void\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"Attributes"},{"location":"reference/project/#djstripe.models.billing.BaseInvoice-methods","text":"djstripe . models . billing . BaseInvoice . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return \"Invoice # {number} \" . format ( number = self . number or self . receipt_number or self . id ) djstripe . models . billing . BaseInvoice . get_billing_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_reason > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_customer_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : customer_tax_exempt > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . BaseInvoice . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return self . customer . get_stripe_dashboard_url () djstripe . models . billing . BaseInvoice . retry ( self ) Retry payment on this invoice if it isn't paid or uncollectible. Source code in djstripe/models/billing.py def retry ( self ): \"\"\"Retry payment on this invoice if it isn't paid or uncollectible.\"\"\" if ( self . status != enums . InvoiceStatus . paid and self . status != enums . InvoiceStatus . uncollectible and self . auto_advance ): stripe_invoice = self . api_retrieve () updated_stripe_invoice = ( stripe_invoice . pay () ) # pay() throws an exception if the charge is not successful. type ( self ) . sync_from_stripe_data ( updated_stripe_invoice ) return True return False djstripe . models . billing . BaseInvoice . upcoming ( api_key = 'sk_test_123' , customer = None , coupon = None , subscription = None , subscription_plan = None , subscription_prorate = None , subscription_proration_date = None , subscription_quantity = None , subscription_trial_end = None , ** kwargs ) classmethod Gets the upcoming preview invoice (singular) for a customer. At any time, you can preview the upcoming invoice for a customer. This will show you all the charges that are pending, including subscription renewal charges, invoice item charges, etc. It will also show you any discount that is applicable to the customer. (Source: https://stripe.com/docs/api#upcoming_invoice) .. important:: Note that when you are viewing an upcoming invoice, you are simply viewing a preview. :param customer: The identifier of the customer whose upcoming invoice you'd like to retrieve. :type customer: Customer or string (customer ID) :param coupon: The code of the coupon to apply. :type coupon: str :param subscription: The identifier of the subscription to retrieve an invoice for. :type subscription: Subscription or string (subscription ID) :param subscription_plan: If set, the invoice returned will preview updating the subscription given to this plan, or creating a new subscription to this plan if no subscription is given. :type subscription_plan: Plan or string (plan ID) :param subscription_prorate: If previewing an update to a subscription, this decides whether the preview will show the result of applying prorations or not. :type subscription_prorate: bool :param subscription_proration_date: If previewing an update to a subscription, and doing proration, subscription_proration_date forces the proration to be calculated as though the update was done at the specified time. :type subscription_proration_date: datetime :param subscription_quantity: If provided, the invoice returned will preview updating or creating a subscription with that quantity. :type subscription_quantity: int :param subscription_trial_end: If provided, the invoice returned will preview updating or creating a subscription with that trial end. :type subscription_trial_end: datetime :returns: The upcoming preview invoice. Source code in djstripe/models/billing.py @classmethod def upcoming ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , customer = None , coupon = None , subscription = None , subscription_plan = None , subscription_prorate = None , subscription_proration_date = None , subscription_quantity = None , subscription_trial_end = None , ** kwargs , ) -> Optional [ \"UpcomingInvoice\" ]: \"\"\" Gets the upcoming preview invoice (singular) for a customer. At any time, you can preview the upcoming invoice for a customer. This will show you all the charges that are pending, including subscription renewal charges, invoice item charges, etc. It will also show you any discount that is applicable to the customer. (Source: https://stripe.com/docs/api#upcoming_invoice) .. important:: Note that when you are viewing an upcoming invoice, you are simply viewing a preview. :param customer: The identifier of the customer whose upcoming invoice \\ you'd like to retrieve. :type customer: Customer or string (customer ID) :param coupon: The code of the coupon to apply. :type coupon: str :param subscription: The identifier of the subscription to retrieve an \\ invoice for. :type subscription: Subscription or string (subscription ID) :param subscription_plan: If set, the invoice returned will preview \\ updating the subscription given to this plan, or creating a new \\ subscription to this plan if no subscription is given. :type subscription_plan: Plan or string (plan ID) :param subscription_prorate: If previewing an update to a subscription, \\ this decides whether the preview will show the result of applying \\ prorations or not. :type subscription_prorate: bool :param subscription_proration_date: If previewing an update to a \\ subscription, and doing proration, subscription_proration_date forces \\ the proration to be calculated as though the update was done at the \\ specified time. :type subscription_proration_date: datetime :param subscription_quantity: If provided, the invoice returned will \\ preview updating or creating a subscription with that quantity. :type subscription_quantity: int :param subscription_trial_end: If provided, the invoice returned will \\ preview updating or creating a subscription with that trial end. :type subscription_trial_end: datetime :returns: The upcoming preview invoice. \"\"\" # Convert Customer to id if customer is not None and isinstance ( customer , StripeModel ): customer = customer . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id # Convert Plan to id if subscription_plan is not None and isinstance ( subscription_plan , StripeModel ): subscription_plan = subscription_plan . id try : upcoming_stripe_invoice = cls . stripe_class . upcoming ( api_key = api_key , customer = customer , coupon = coupon , subscription = subscription , subscription_plan = subscription_plan , subscription_prorate = subscription_prorate , subscription_proration_date = subscription_proration_date , subscription_quantity = subscription_quantity , subscription_trial_end = subscription_trial_end , ** kwargs , ) except InvalidRequestError as exc : if str ( exc ) != \"Nothing to invoice for customer\" : raise return None # Workaround for \"id\" being missing (upcoming invoices don't persist). upcoming_stripe_invoice [ \"id\" ] = \"upcoming\" return UpcomingInvoice . _create_from_stripe_object ( upcoming_stripe_invoice , save = False )","title":"Methods"},{"location":"reference/project/#djstripe.models.billing.Coupon","text":"Coupon(djstripe_id, djstripe_owner_account, livemode, created, metadata, description, djstripe_created, djstripe_updated, id, amount_off, currency, duration, duration_in_months, max_redemptions, name, percent_off, redeem_by, times_redeemed) djstripe . models . billing . Coupon . amount_off djstripe . models . billing . Coupon . currency djstripe . models . billing . Coupon . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Coupon . duration djstripe . models . billing . Coupon . duration_in_months djstripe . models . billing . Coupon . human_readable property readonly djstripe . models . billing . Coupon . human_readable_amount property readonly djstripe . models . billing . Coupon . max_redemptions djstripe . models . billing . Coupon . name djstripe . models . billing . Coupon . percent_off djstripe . models . billing . Coupon . redeem_by djstripe . models . billing . Coupon . stripe_dashboard_item_name djstripe . models . billing . Coupon . times_redeemed djstripe.models.billing.Coupon.DoesNotExist djstripe.models.billing.Coupon.MultipleObjectsReturned djstripe.models.billing.Coupon.stripe_class djstripe . models . billing . Coupon . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): if self . name : return self . name return self . human_readable djstripe . models . billing . Coupon . get_duration_display ( self , * , field =< djstripe . fields . StripeEnumField : duration > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Coupon . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Coupon"},{"location":"reference/project/#djstripe.models.billing.DjstripeInvoiceTotalTaxAmount","text":"An internal model that holds the value of elements of Invoice.total_tax_amounts Note that this is named with the prefix Djstripe to avoid potential collision with a Stripe API object name. djstripe . models . billing . DjstripeInvoiceTotalTaxAmount . amount djstripe . models . billing . DjstripeInvoiceTotalTaxAmount . inclusive djstripe . models . billing . DjstripeInvoiceTotalTaxAmount . invoice djstripe . models . billing . DjstripeInvoiceTotalTaxAmount . tax_rate djstripe.models.billing.DjstripeInvoiceTotalTaxAmount.DoesNotExist djstripe.models.billing.DjstripeInvoiceTotalTaxAmount.MultipleObjectsReturned","title":"DjstripeInvoiceTotalTaxAmount"},{"location":"reference/project/#djstripe.models.billing.DjstripeUpcomingInvoiceTotalTaxAmount","text":"As per DjstripeInvoiceTotalTaxAmount, except for UpcomingInvoice djstripe . models . billing . DjstripeUpcomingInvoiceTotalTaxAmount . amount djstripe . models . billing . DjstripeUpcomingInvoiceTotalTaxAmount . inclusive djstripe . models . billing . DjstripeUpcomingInvoiceTotalTaxAmount . invoice djstripe . models . billing . DjstripeUpcomingInvoiceTotalTaxAmount . tax_rate djstripe.models.billing.DjstripeUpcomingInvoiceTotalTaxAmount.DoesNotExist djstripe.models.billing.DjstripeUpcomingInvoiceTotalTaxAmount.MultipleObjectsReturned","title":"DjstripeUpcomingInvoiceTotalTaxAmount"},{"location":"reference/project/#djstripe.models.billing.Invoice","text":"Invoices are statements of what a customer owes for a particular billing period, including subscriptions, invoice items, and any automatic proration adjustments if necessary. Once an invoice is created, payment is automatically attempted. Note that the payment, while automatic, does not happen exactly at the time of invoice creation. If you have configured webhooks, the invoice will wait until one hour after the last webhook is successfully sent (or the last webhook times out after failing). Any customer credit on the account is applied before determining how much is due for that invoice (the amount that will be actually charged). If the amount due for the invoice is less than 50 cents (the minimum for a charge), we add the amount to the customer's running account balance to be added to the next invoice. If this amount is negative, it will act as a credit to offset the next invoice. Note that the customer account balance does not include unpaid invoices; it only includes balances that need to be taken into account when calculating the amount due for the next invoice. Stripe documentation: https://stripe.com/docs/api/python#invoices djstripe . models . billing . Invoice . charge djstripe . models . billing . Invoice . customer djstripe . models . billing . Invoice . default_payment_method djstripe . models . billing . Invoice . default_source djstripe . models . billing . Invoice . default_tax_rates djstripe . models . billing . Invoice . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Invoice . payment_intent djstripe . models . billing . Invoice . subscription djstripe.models.billing.Invoice.DoesNotExist djstripe.models.billing.Invoice.MultipleObjectsReturned djstripe . models . billing . Invoice . get_billing_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_reason > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_customer_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : customer_tax_exempt > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Invoice . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Invoice"},{"location":"reference/project/#djstripe.models.billing.InvoiceItem","text":"Sometimes you want to add a charge or credit to a customer but only actually charge the customer's card at the end of a regular billing cycle. This is useful for combining several charges to minimize per-transaction fees or having Stripe tabulate your usage-based billing totals. Stripe documentation: https://stripe.com/docs/api/python#invoiceitems djstripe . models . billing . InvoiceItem . amount djstripe . models . billing . InvoiceItem . currency djstripe . models . billing . InvoiceItem . customer djstripe . models . billing . InvoiceItem . date djstripe . models . billing . InvoiceItem . discountable djstripe . models . billing . InvoiceItem . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . InvoiceItem . invoice djstripe . models . billing . InvoiceItem . period djstripe . models . billing . InvoiceItem . period_end djstripe . models . billing . InvoiceItem . period_start djstripe . models . billing . InvoiceItem . plan djstripe . models . billing . InvoiceItem . price djstripe . models . billing . InvoiceItem . proration djstripe . models . billing . InvoiceItem . quantity djstripe . models . billing . InvoiceItem . subscription djstripe . models . billing . InvoiceItem . tax_rates djstripe . models . billing . InvoiceItem . unit_amount djstripe . models . billing . InvoiceItem . unit_amount_decimal djstripe.models.billing.InvoiceItem.DoesNotExist djstripe.models.billing.InvoiceItem.MultipleObjectsReturned djstripe.models.billing.InvoiceItem.stripe_class","title":"InvoiceItem"},{"location":"reference/project/#djstripe.models.billing.InvoiceItem-methods","text":"djstripe . models . billing . InvoiceItem . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return self . description djstripe . models . billing . InvoiceItem . api_retrieve ( self , * args , ** kwargs ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , * args , ** kwargs ): if \"-il_\" in self . id : warnings . warn ( f \"Attempting to retrieve InvoiceItem with id= { self . id !r} \" \" will most likely fail. \" \"Run manage.py djstripe_update_invoiceitem_ids if this is a problem.\" ) return super () . api_retrieve ( * args , ** kwargs ) djstripe . models . billing . InvoiceItem . get_next_by_date ( self , * , field =< djstripe . fields . StripeDateTimeField : date > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_date ( self , * , field =< djstripe . fields . StripeDateTimeField : date > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . InvoiceItem . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return self . invoice . get_stripe_dashboard_url () djstripe . models . billing . InvoiceItem . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/billing.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"invoiceitem\" , \"line_item\" ) djstripe . models . billing . InvoiceItem . sync_from_stripe_data ( data ) classmethod Syncs this object from the stripe data provided. Foreign keys will also be retrieved and synced recursively. :param data: stripe object :type data: dict :rtype: cls Source code in djstripe/models/billing.py @classmethod def sync_from_stripe_data ( cls , data ): invoice_data = data . get ( \"invoice\" ) if invoice_data : # sync the Invoice first if it doesn't yet exist in our DB # to avoid recursive Charge/Invoice loop invoice_id = cls . _id_from_data ( invoice_data ) if not Invoice . objects . filter ( id = invoice_id ) . exists (): if invoice_id == invoice_data : # we only have the id, fetch the full data invoice_data = Invoice ( id = invoice_id ) . api_retrieve () Invoice . sync_from_stripe_data ( data = invoice_data ) return super () . sync_from_stripe_data ( data )","title":"Methods"},{"location":"reference/project/#djstripe.models.billing.Plan","text":"A subscription plan contains the pricing information for different products and feature levels on your site. Stripe documentation: https://stripe.com/docs/api/plans NOTE: The Stripe Plans API has been deprecated in favor of the Prices API. You may want to upgrade to use the Price model instead of the Plan model. djstripe . models . billing . Plan . active djstripe . models . billing . Plan . aggregate_usage djstripe . models . billing . Plan . amount djstripe . models . billing . Plan . amount_decimal djstripe . models . billing . Plan . amount_in_cents property readonly djstripe . models . billing . Plan . billing_scheme djstripe . models . billing . Plan . currency djstripe . models . billing . Plan . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Plan . human_readable_price property readonly djstripe . models . billing . Plan . interval djstripe . models . billing . Plan . interval_count djstripe . models . billing . Plan . nickname djstripe . models . billing . Plan . product djstripe . models . billing . Plan . stripe_dashboard_item_name djstripe . models . billing . Plan . tiers djstripe . models . billing . Plan . tiers_mode djstripe . models . billing . Plan . transform_usage djstripe . models . billing . Plan . trial_period_days djstripe . models . billing . Plan . usage_type djstripe.models.billing.Plan.DoesNotExist djstripe.models.billing.Plan.MultipleObjectsReturned djstripe.models.billing.Plan.stripe_class","title":"Plan"},{"location":"reference/project/#djstripe.models.billing.Plan-methods","text":"djstripe . models . billing . Plan . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return self . nickname or self . id djstripe . models . billing . Plan . create ( ** kwargs ) classmethod Source code in djstripe/models/billing.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"amount\" ] = int ( api_kwargs [ \"amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_plan = cls . _api_create ( ** api_kwargs ) plan = cls . sync_from_stripe_data ( stripe_plan ) return plan djstripe . models . billing . Plan . get_aggregate_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : aggregate_usage > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_billing_scheme_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_scheme > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_interval_display ( self , * , field =< djstripe . fields . StripeEnumField : interval > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_or_create ( ** kwargs ) classmethod Get or create a Plan. Source code in djstripe/models/billing.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Plan.\"\"\" try : return Plan . objects . get ( id = kwargs [ \"id\" ]), False except Plan . DoesNotExist : return cls . create ( ** kwargs ), True djstripe . models . billing . Plan . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_tiers_mode_display ( self , * , field =< djstripe . fields . StripeEnumField : tiers_mode > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Plan . get_usage_type_display ( self , * , field =< djstripe . fields . StripeEnumField : usage_type > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Methods"},{"location":"reference/project/#djstripe.models.billing.Subscription","text":"Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to a particular plan you've created. A subscription still in its trial period is trialing and moves to active when the trial period is over. When payment to renew the subscription fails, the subscription becomes past_due . After Stripe has exhausted all payment retry attempts, the subscription ends up with a status of either canceled or unpaid depending on your retry settings. Note that when a subscription has a status of unpaid , no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed. Additionally, updating customer card details will not lead to Stripe retrying the latest invoice.). After receiving updated card details from a customer, you may choose to reopen and pay their closed invoices. Stripe documentation: https://stripe.com/docs/api/python#subscriptions djstripe . models . billing . Subscription . application_fee_percent djstripe . models . billing . Subscription . billing_cycle_anchor djstripe . models . billing . Subscription . billing_thresholds djstripe . models . billing . Subscription . cancel_at djstripe . models . billing . Subscription . cancel_at_period_end djstripe . models . billing . Subscription . canceled_at djstripe . models . billing . Subscription . collection_method djstripe . models . billing . Subscription . current_period_end djstripe . models . billing . Subscription . current_period_start djstripe . models . billing . Subscription . customer djstripe . models . billing . Subscription . days_until_due djstripe . models . billing . Subscription . default_payment_method djstripe . models . billing . Subscription . default_source djstripe . models . billing . Subscription . default_tax_rates djstripe . models . billing . Subscription . discount djstripe . models . billing . Subscription . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . Subscription . ended_at djstripe . models . billing . Subscription . next_pending_invoice_item_invoice djstripe . models . billing . Subscription . objects djstripe . models . billing . Subscription . pending_invoice_item_interval djstripe . models . billing . Subscription . pending_setup_intent djstripe . models . billing . Subscription . pending_update djstripe . models . billing . Subscription . plan djstripe . models . billing . Subscription . quantity djstripe . models . billing . Subscription . schedule djstripe . models . billing . Subscription . start_date djstripe . models . billing . Subscription . status djstripe . models . billing . Subscription . stripe_dashboard_item_name djstripe . models . billing . Subscription . tax_percent djstripe . models . billing . Subscription . trial_end djstripe . models . billing . Subscription . trial_start djstripe.models.billing.Subscription.DoesNotExist djstripe.models.billing.Subscription.MultipleObjectsReturned djstripe.models.billing.Subscription.stripe_class djstripe . models . billing . Subscription . stripe_class . OBJECT_NAME djstripe . models . billing . Subscription . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/billing.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True )","title":"Subscription"},{"location":"reference/project/#djstripe.models.billing.Subscription-methods","text":"djstripe . models . billing . Subscription . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return \" {customer} on {plan} \" . format ( customer = str ( self . customer ), plan = str ( self . plan ) ) djstripe . models . billing . Subscription . cancel ( self , at_period_end = True ) Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, the at_period_end flag will be overridden to False so that the trial ends immediately and the customer's card isn't charged. Source code in djstripe/models/billing.py def cancel ( self , at_period_end = djstripe_settings . CANCELLATION_AT_PERIOD_END ): \"\"\" Cancels this subscription. If you set the at_period_end parameter to true, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. By default, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription. Note, however, that any pending invoice items that you've created will still be charged for at the end of the period unless manually deleted. If you've set the subscription to cancel at period end, any pending prorations will also be left in place and collected at the end of the period, but if the subscription is set to cancel immediately, pending prorations will be removed. By default, all unpaid invoices for the customer will be closed upon subscription cancellation. We do this in order to prevent unexpected payment retries once the customer has canceled a subscription. However, you can reopen the invoices manually after subscription cancellation to have us proceed with automatic retries, or you could even re-attempt payment yourself on all unpaid invoices before allowing the customer to cancel the subscription at all. :param at_period_end: A flag that if set to true will delay the cancellation \\ of the subscription until the end of the current period. Default is False. :type at_period_end: boolean .. important:: If a subscription is canceled during a trial period, \\ the ``at_period_end`` flag will be overridden to False so that the trial ends \\ immediately and the customer's card isn't charged. \"\"\" # If plan has trial days and customer cancels before # trial period ends, then end subscription now, # i.e. at_period_end=False if self . trial_end and self . trial_end > timezone . now (): at_period_end = False if at_period_end : stripe_subscription = self . _api_update ( cancel_at_period_end = True ) else : try : stripe_subscription = self . _api_delete () except InvalidRequestError as exc : if \"No such subscription:\" in str ( exc ): # cancel() works by deleting the subscription. The object still # exists in Stripe however, and can still be retrieved. # If the subscription was already canceled (status=canceled), # that api_retrieve() call will fail with \"No such subscription\". # However, this may also happen if the subscription legitimately # does not exist, in which case the following line will re-raise. stripe_subscription = self . api_retrieve () else : raise return Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe . models . billing . Subscription . extend ( self , delta ) Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta Source code in djstripe/models/billing.py def extend ( self , delta ): \"\"\" Extends this subscription by the provided delta. :param delta: The timedelta by which to extend this subscription. :type delta: timedelta \"\"\" if delta . total_seconds () < 0 : raise ValueError ( \"delta must be a positive timedelta.\" ) if self . trial_end is not None and self . trial_end > timezone . now (): period_end = self . trial_end else : period_end = self . current_period_end period_end += delta return self . update ( proration_behavior = \"none\" , trial_end = period_end ) djstripe . models . billing . Subscription . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_current_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_current_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_current_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_current_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : current_period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . Subscription . is_period_current ( self ) Returns True if this subscription's period is current, false otherwise. Source code in djstripe/models/billing.py def is_period_current ( self ): \"\"\" Returns True if this subscription's period is current, false otherwise. \"\"\" return self . current_period_end > timezone . now () or ( self . trial_end and self . trial_end > timezone . now () ) djstripe . models . billing . Subscription . is_status_current ( self ) Returns True if this subscription's status is current (active or trialing), false otherwise. Source code in djstripe/models/billing.py def is_status_current ( self ): \"\"\" Returns True if this subscription's status is current (active or trialing), false otherwise. \"\"\" return self . status in [ \"trialing\" , \"active\" ] djstripe . models . billing . Subscription . is_status_temporarily_current ( self ) A status is temporarily current when the subscription is canceled with the at_period_end flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. Source code in djstripe/models/billing.py def is_status_temporarily_current ( self ): \"\"\" A status is temporarily current when the subscription is canceled with the ``at_period_end`` flag. The subscription is still active, but is technically canceled and we're just waiting for it to run out. You could use this method to give customers limited service after they've canceled. For example, a video on demand service could only allow customers to download their libraries and do nothing else when their subscription is temporarily current. \"\"\" return ( self . canceled_at and self . cancel_at_period_end and timezone . now () < self . current_period_end ) djstripe . models . billing . Subscription . is_valid ( self ) Returns True if this subscription's status and period are current, false otherwise. Source code in djstripe/models/billing.py def is_valid ( self ): \"\"\" Returns True if this subscription's status and period are current, false otherwise. \"\"\" if not self . is_status_current (): return False if not self . is_period_current (): return False return True djstripe . models . billing . Subscription . reactivate ( self ) Reactivates this subscription. If a customer's subscription is canceled with at_period_end set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/subscriptions/canceling-pausing) .. warning:: Reactivating a fully canceled Subscription will fail silently. Be sure to check the returned Subscription's status. Source code in djstripe/models/billing.py def reactivate ( self ): \"\"\" Reactivates this subscription. If a customer's subscription is canceled with ``at_period_end`` set to True and it has not yet reached the end of the billing period, it can be reactivated. Subscriptions canceled immediately cannot be reactivated. (Source: https://stripe.com/docs/subscriptions/canceling-pausing) .. warning:: Reactivating a fully canceled Subscription will fail silently. \\ Be sure to check the returned Subscription's status. \"\"\" stripe_subscription = self . api_retrieve () stripe_subscription . plan = self . plan . id stripe_subscription . cancel_at_period_end = False return Subscription . sync_from_stripe_data ( stripe_subscription . save ()) djstripe . models . billing . Subscription . update ( self , plan = None , prorate = None , ** kwargs ) See Customer.subscribe() <#djstripe.models.Customer.subscribe> __ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. note:: The default value for prorate is the DJSTRIPE_PRORATION_POLICY setting. .. important:: Updating a subscription by changing the plan or quantity creates a new Subscription in Stripe (and dj-stripe). Source code in djstripe/models/billing.py def update ( self , plan : Union [ StripeModel , str ] = None , prorate : bool = None , ** kwargs , ): \"\"\" See `Customer.subscribe() <#djstripe.models.Customer.subscribe>`__ :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) .. note:: The default value for ``prorate`` is the DJSTRIPE_PRORATION_POLICY \\ setting. .. important:: Updating a subscription by changing the plan or quantity \\ creates a new ``Subscription`` in \\ Stripe (and dj-stripe). \"\"\" # Convert Plan to id if plan is not None and isinstance ( plan , StripeModel ): plan = plan . id if \"proration_behavior\" not in kwargs : if prorate is not None : warnings . warn ( \"The `prorate` parameter to Subscription.update() is deprecated \" \"by Stripe. Use `proration_behavior` instead. \\n \" \"Read more: \" \"https://stripe.com/docs/billing/subscriptions/prorations\" ) else : prorate = djstripe_settings . PRORATION_POLICY if prorate : kwargs . setdefault ( \"proration_behavior\" , \"create_prorations\" ) else : kwargs . setdefault ( \"proration_behavior\" , \"none\" ) stripe_subscription = self . _api_update ( plan = plan , ** kwargs ) return Subscription . sync_from_stripe_data ( stripe_subscription )","title":"Methods"},{"location":"reference/project/#djstripe.models.billing.SubscriptionItem","text":"Subscription items allow you to create customer subscriptions with more than one plan, making it easy to represent complex billing relationships. Stripe documentation: https://stripe.com/docs/api#subscription_items djstripe . models . billing . SubscriptionItem . billing_thresholds djstripe . models . billing . SubscriptionItem . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . SubscriptionItem . plan djstripe . models . billing . SubscriptionItem . price djstripe . models . billing . SubscriptionItem . quantity djstripe . models . billing . SubscriptionItem . subscription djstripe . models . billing . SubscriptionItem . tax_rates","title":"SubscriptionItem"},{"location":"reference/project/#djstripe.models.billing.SubscriptionItem-classes","text":"djstripe.models.billing.SubscriptionItem.DoesNotExist djstripe.models.billing.SubscriptionItem.MultipleObjectsReturned djstripe.models.billing.SubscriptionItem.stripe_class djstripe . models . billing . SubscriptionItem . stripe_class . OBJECT_NAME Methods djstripe . models . billing . SubscriptionItem . stripe_class . create_usage_record ( id , ** params ) classmethod Source code in djstripe/models/billing.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . list_usage_record_summaries ( id , ** params ) classmethod Source code in djstripe/models/billing.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summaries ( self , ** params ) usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead. Source code in djstripe/models/billing.py def usage_record_summaries ( self , ** params ): \"\"\"usage_record_summaries is deprecated, use SubscriptionItem.list_usage_record_summaries instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/usage_record_summaries\" , params ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_record_summarys_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . SubscriptionItem . stripe_class . usage_records_url ( id , nested_id = None ) classmethod Source code in djstripe/models/billing.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . billing . SubscriptionItem . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionItem . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Classes"},{"location":"reference/project/#djstripe.models.billing.SubscriptionSchedule","text":"Subscription schedules allow you to create and manage the lifecycle of a subscription by predefining expected changes. Stripe documentation: https://stripe.com/docs/api/subscription_schedules djstripe . models . billing . SubscriptionSchedule . billing_thresholds djstripe . models . billing . SubscriptionSchedule . canceled_at djstripe . models . billing . SubscriptionSchedule . completed_at djstripe . models . billing . SubscriptionSchedule . current_phase djstripe . models . billing . SubscriptionSchedule . customer djstripe . models . billing . SubscriptionSchedule . default_settings djstripe . models . billing . SubscriptionSchedule . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . SubscriptionSchedule . end_behavior djstripe . models . billing . SubscriptionSchedule . phases djstripe . models . billing . SubscriptionSchedule . released_at djstripe . models . billing . SubscriptionSchedule . released_subscription djstripe . models . billing . SubscriptionSchedule . status djstripe.models.billing.SubscriptionSchedule.DoesNotExist djstripe.models.billing.SubscriptionSchedule.MultipleObjectsReturned djstripe.models.billing.SubscriptionSchedule.stripe_class djstripe . models . billing . SubscriptionSchedule . stripe_class . OBJECT_NAME djstripe . models . billing . SubscriptionSchedule . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . SubscriptionSchedule . stripe_class . release ( self , idempotency_key = None , ** params ) Source code in djstripe/models/billing.py def release ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/release\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . billing . SubscriptionSchedule . get_end_behavior_display ( self , * , field =< djstripe . fields . StripeEnumField : end_behavior > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . SubscriptionSchedule . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"SubscriptionSchedule"},{"location":"reference/project/#djstripe.models.billing.TaxId","text":"TaxId(djstripe_id, id, djstripe_owner_account, livemode, created, djstripe_created, djstripe_updated, country, customer, type, value, verification) djstripe . models . billing . TaxId . country djstripe . models . billing . TaxId . customer djstripe . models . billing . TaxId . description djstripe . models . billing . TaxId . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . TaxId . metadata djstripe . models . billing . TaxId . type djstripe . models . billing . TaxId . value djstripe . models . billing . TaxId . verification djstripe.models.billing.TaxId.DoesNotExist djstripe.models.billing.TaxId.MultipleObjectsReturned djstripe.models.billing.TaxId.stripe_class djstripe . models . billing . TaxId . stripe_class . OBJECT_NAME djstripe . models . billing . TaxId . stripe_class . instance_url ( self ) Source code in djstripe/models/billing.py def instance_url ( self ): token = util . utf8 ( self . id ) customer = util . utf8 ( self . customer ) base = Customer . class_url () cust_extn = quote_plus ( customer ) extn = quote_plus ( token ) return \" %s / %s /tax_ids/ %s \" % ( base , cust_extn , extn ) djstripe . models . billing . TaxId . stripe_class . retrieve ( id , api_key = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def retrieve ( cls , id , api_key = None , ** params ): raise NotImplementedError ( \"Can't retrieve a tax id without a customer ID. Use customer.retrieve_tax_id('tax_id')\" )","title":"TaxId"},{"location":"reference/project/#djstripe.models.billing.TaxId-methods","text":"djstripe . models . billing . TaxId . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return self . value djstripe . models . billing . TaxId . api_list ( api_key = 'sk_test_123' , ** kwargs ) classmethod Call the stripe API's list operation for this model. :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string See Stripe documentation for accepted kwargs for each object. :returns: an iterator over all items in the query Source code in djstripe/models/billing.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): # OVERRIDING the parent version of this function # TaxIds must be manipulated through a customer.. from .core import Customer if \"customer\" not in kwargs or not isinstance ( kwargs [ \"customer\" ], Customer ): raise StripeObjectManipulationException ( \"TaxIds must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) customer = kwargs [ \"customer\" ] return customer . api_retrieve ( api_key = api_key ) . tax_ids djstripe . models . billing . TaxId . api_retrieve ( self , api_key = None , stripe_account = None ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/billing.py def api_retrieve ( self , api_key = None , stripe_account = None ): if not stripe_account : stripe_account = self . _get_stripe_account_id ( api_key ) customer = self . customer . api_retrieve ( api_key = api_key or self . default_api_key , stripe_account = stripe_account , ) return customer . retrieve_tax_id ( customer . id , self . id , api_key = api_key or self . default_api_key , expand = self . expand_fields , stripe_account = stripe_account , ) djstripe . models . billing . TaxId . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxId . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Methods"},{"location":"reference/project/#djstripe.models.billing.TaxRate","text":"Tax rates can be applied to invoices and subscriptions to collect tax. Stripe documentation: https://stripe.com/docs/api/tax_rates djstripe . models . billing . TaxRate . active djstripe . models . billing . TaxRate . display_name djstripe . models . billing . TaxRate . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . TaxRate . inclusive djstripe . models . billing . TaxRate . jurisdiction djstripe . models . billing . TaxRate . percentage djstripe.models.billing.TaxRate.DoesNotExist djstripe.models.billing.TaxRate.MultipleObjectsReturned djstripe.models.billing.TaxRate.stripe_class djstripe . models . billing . TaxRate . __str__ ( self ) special Source code in djstripe/models/billing.py def __str__ ( self ): return f \" { self . display_name } \u2013 { self . jurisdiction } at { self . percentage } %\" djstripe . models . billing . TaxRate . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . TaxRate . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"TaxRate"},{"location":"reference/project/#djstripe.models.billing.UpcomingInvoice","text":"The preview of an upcoming invoice - does not exist in the Django database. See BaseInvoice.upcoming() Logically it should be set abstract, but that doesn't quite work since we do actually want to instantiate the model and use relations.","title":"UpcomingInvoice"},{"location":"reference/project/#djstripe.models.billing.UpcomingInvoice-attributes","text":"djstripe . models . billing . UpcomingInvoice . charge djstripe . models . billing . UpcomingInvoice . customer djstripe . models . billing . UpcomingInvoice . default_payment_method djstripe . models . billing . UpcomingInvoice . default_source djstripe . models . billing . UpcomingInvoice . default_tax_rates property readonly Gets the default tax rates associated with this upcoming invoice. :return: djstripe . models . billing . UpcomingInvoice . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . UpcomingInvoice . id property writable djstripe . models . billing . UpcomingInvoice . invoiceitems property readonly Gets the invoice items associated with this upcoming invoice. This differs from normal (non-upcoming) invoices, in that upcoming invoices are in-memory and do not persist to the database. Therefore, all of the data comes from the Stripe API itself. Instead of returning a normal queryset for the invoiceitems, this will return a mock of a queryset, but with the data fetched from Stripe - It will act like a normal queryset, but mutation will silently fail. djstripe . models . billing . UpcomingInvoice . payment_intent djstripe . models . billing . UpcomingInvoice . subscription djstripe . models . billing . UpcomingInvoice . total_tax_amounts property readonly Gets the total tax amounts associated with this upcoming invoice. :return: djstripe.models.billing.UpcomingInvoice.DoesNotExist djstripe.models.billing.UpcomingInvoice.MultipleObjectsReturned","title":"Attributes"},{"location":"reference/project/#djstripe.models.billing.UpcomingInvoice-methods","text":"djstripe . models . billing . UpcomingInvoice . __init__ ( self , * args , ** kwargs ) special Source code in djstripe/models/billing.py def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _invoiceitems = [] self . _default_tax_rates = [] self . _total_tax_amounts = [] djstripe . models . billing . UpcomingInvoice . get_billing_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_reason > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_collection_method_display ( self , * , field =< djstripe . fields . StripeEnumField : collection_method > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_customer_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : customer_tax_exempt > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_next_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_period_end ( self , * , field =< djstripe . fields . StripeDateTimeField : period_end > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_previous_by_period_start ( self , * , field =< djstripe . fields . StripeDateTimeField : period_start > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UpcomingInvoice . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/billing.py def get_stripe_dashboard_url ( self ): return \"\" djstripe . models . billing . UpcomingInvoice . save ( self , * args , ** kwargs ) Save the current instance. Override this in a subclass if you want to control the saving process. The 'force_insert' and 'force_update' parameters can be used to insist that the \"save\" must be an SQL insert or update (or equivalent for non-SQL backends), respectively. Normally, they should not be set. Source code in djstripe/models/billing.py def save ( self , * args , ** kwargs ): return # noop","title":"Methods"},{"location":"reference/project/#djstripe.models.billing.UsageRecord","text":"Usage records allow you to continually report usage and metrics to Stripe for metered billing of plans. Stripe documentation: https://stripe.com/docs/api#usage_records djstripe . models . billing . UsageRecord . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . billing . UsageRecord . quantity djstripe . models . billing . UsageRecord . subscription_item djstripe.models.billing.UsageRecord.DoesNotExist djstripe.models.billing.UsageRecord.MultipleObjectsReturned djstripe.models.billing.UsageRecord.stripe_class djstripe . models . billing . UsageRecord . stripe_class . OBJECT_NAME djstripe . models . billing . UsageRecord . stripe_class . create ( api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/billing.py @classmethod def create ( cls , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): if \"subscription_item\" not in params : raise ValueError ( \"Params must have a subscription_item key\" ) subscription_item = params . pop ( \"subscription_item\" ) requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) url = \"/v1/subscription_items/ %s /usage_records\" % subscription_item headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . billing . UsageRecord . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . billing . UsageRecord . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/billing.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"UsageRecord"},{"location":"reference/project/#djstripe.models.checkout","text":"","title":"checkout"},{"location":"reference/project/#djstripe.models.checkout-classes","text":"","title":"Classes"},{"location":"reference/project/#djstripe.models.checkout.Session","text":"A Checkout Session represents your customer's session as they pay for one-time purchases or subscriptions through Checkout. djstripe . models . checkout . Session . billing_address_collection djstripe . models . checkout . Session . cancel_url djstripe . models . checkout . Session . client_reference_id djstripe . models . checkout . Session . customer djstripe . models . checkout . Session . customer_email djstripe . models . checkout . Session . display_items djstripe . models . checkout . Session . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . checkout . Session . locale djstripe . models . checkout . Session . mode djstripe . models . checkout . Session . payment_intent djstripe . models . checkout . Session . payment_method_types djstripe . models . checkout . Session . submit_type djstripe . models . checkout . Session . subscription djstripe . models . checkout . Session . success_url djstripe.models.checkout.Session.DoesNotExist djstripe.models.checkout.Session.MultipleObjectsReturned djstripe.models.checkout.Session.stripe_class djstripe . models . checkout . Session . stripe_class . OBJECT_NAME djstripe . models . checkout . Session . stripe_class . expire ( self , idempotency_key = None , ** params ) Source code in djstripe/models/checkout.py def expire ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/expire\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . checkout . Session . stripe_class . line_items_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/checkout.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . checkout . Session . stripe_class . line_items_url ( id , nested_id = None ) classmethod Source code in djstripe/models/checkout.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . checkout . Session . stripe_class . list_line_items ( id , ** params ) classmethod Source code in djstripe/models/checkout.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . checkout . Session . get_billing_address_collection_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_address_collection > ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_mode_display ( self , * , field =< djstripe . fields . StripeEnumField : mode > ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . checkout . Session . get_submit_type_display ( self , * , field =< djstripe . fields . StripeEnumField : submit_type > ) Source code in djstripe/models/checkout.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Session"},{"location":"reference/project/#djstripe.models.connect","text":"","title":"connect"},{"location":"reference/project/#djstripe.models.connect-classes","text":"","title":"Classes"},{"location":"reference/project/#djstripe.models.connect.ApplicationFee","text":"When you collect a transaction fee on top of a charge made for your user (using Connect), an ApplicationFee is created in your account. Stripe documentation: https://stripe.com/docs/api#application_fees djstripe . models . connect . ApplicationFee . amount djstripe . models . connect . ApplicationFee . amount_refunded djstripe . models . connect . ApplicationFee . balance_transaction djstripe . models . connect . ApplicationFee . charge djstripe . models . connect . ApplicationFee . currency djstripe . models . connect . ApplicationFee . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . ApplicationFee . refunded djstripe.models.connect.ApplicationFee.DoesNotExist djstripe.models.connect.ApplicationFee.MultipleObjectsReturned djstripe.models.connect.ApplicationFee.stripe_class djstripe . models . connect . ApplicationFee . stripe_class . OBJECT_NAME djstripe . models . connect . ApplicationFee . stripe_class . create_refund ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . list_refunds ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . modify_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . ApplicationFee . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def refund ( self , idempotency_key = None , ** params ): headers = util . populate_headers ( idempotency_key ) url = self . instance_url () + \"/refund\" self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . ApplicationFee . stripe_class . refunds_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . ApplicationFee . stripe_class . refunds_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . connect . ApplicationFee . stripe_class . retrieve_refund ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . ApplicationFee . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFee . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"ApplicationFee"},{"location":"reference/project/#djstripe.models.connect.ApplicationFeeRefund","text":"ApplicationFeeRefund objects allow you to refund an ApplicationFee that has previously been created but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected. Stripe documentation: https://stripe.com/docs/api#fee_refunds djstripe . models . connect . ApplicationFeeRefund . amount djstripe . models . connect . ApplicationFeeRefund . balance_transaction djstripe . models . connect . ApplicationFeeRefund . currency djstripe . models . connect . ApplicationFeeRefund . description djstripe . models . connect . ApplicationFeeRefund . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . ApplicationFeeRefund . fee djstripe.models.connect.ApplicationFeeRefund.DoesNotExist djstripe.models.connect.ApplicationFeeRefund.MultipleObjectsReturned djstripe . models . connect . ApplicationFeeRefund . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . ApplicationFeeRefund . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"ApplicationFeeRefund"},{"location":"reference/project/#djstripe.models.connect.CountrySpec","text":"Stripe documentation: https://stripe.com/docs/api#country_specs djstripe . models . connect . CountrySpec . created djstripe . models . connect . CountrySpec . default_currency djstripe . models . connect . CountrySpec . description djstripe . models . connect . CountrySpec . djstripe_id djstripe . models . connect . CountrySpec . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . CountrySpec . livemode djstripe . models . connect . CountrySpec . metadata djstripe . models . connect . CountrySpec . supported_bank_account_currencies djstripe . models . connect . CountrySpec . supported_payment_currencies djstripe . models . connect . CountrySpec . supported_payment_methods djstripe . models . connect . CountrySpec . supported_transfer_countries djstripe . models . connect . CountrySpec . verification_fields djstripe.models.connect.CountrySpec.DoesNotExist djstripe.models.connect.CountrySpec.MultipleObjectsReturned djstripe.models.connect.CountrySpec.stripe_class djstripe . models . connect . CountrySpec . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . CountrySpec . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"CountrySpec"},{"location":"reference/project/#djstripe.models.connect.Transfer","text":"When Stripe sends you money or you initiate a transfer to a bank account, debit card, or connected Stripe account, a transfer object will be created. Stripe documentation: https://stripe.com/docs/api/python#transfers djstripe . models . connect . Transfer . amount djstripe . models . connect . Transfer . amount_reversed djstripe . models . connect . Transfer . balance_transaction djstripe . models . connect . Transfer . currency djstripe . models . connect . Transfer . destination djstripe . models . connect . Transfer . destination_payment djstripe . models . connect . Transfer . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . Transfer . expand_fields : List [ str ] djstripe . models . connect . Transfer . fee property readonly djstripe . models . connect . Transfer . objects djstripe . models . connect . Transfer . reversed djstripe . models . connect . Transfer . source_transaction djstripe . models . connect . Transfer . source_type djstripe . models . connect . Transfer . stripe_dashboard_item_name djstripe . models . connect . Transfer . transfer_group djstripe.models.connect.Transfer.DoesNotExist djstripe.models.connect.Transfer.MultipleObjectsReturned djstripe.models.connect.Transfer.stripe_class djstripe . models . connect . Transfer . stripe_class . OBJECT_NAME djstripe . models . connect . Transfer . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . Transfer . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . Transfer . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . Transfer . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"Transfer"},{"location":"reference/project/#djstripe.models.connect.Transfer-methods","text":"djstripe . models . connect . Transfer . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . get_source_type_display ( self , * , field =< djstripe . fields . StripeEnumField : source_type > ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . Transfer . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/connect.py def str_parts ( self ): return [ \"amount= {amount} \" . format ( amount = self . amount )] + super () . str_parts ()","title":"Methods"},{"location":"reference/project/#djstripe.models.connect.TransferReversal","text":"Stripe documentation: https://stripe.com/docs/api#transfer_reversals djstripe . models . connect . TransferReversal . amount djstripe . models . connect . TransferReversal . balance_transaction djstripe . models . connect . TransferReversal . currency djstripe . models . connect . TransferReversal . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . connect . TransferReversal . transfer djstripe.models.connect.TransferReversal.DoesNotExist djstripe.models.connect.TransferReversal.MultipleObjectsReturned djstripe.models.connect.TransferReversal.stripe_class djstripe . models . connect . TransferReversal . stripe_class . OBJECT_NAME djstripe . models . connect . TransferReversal . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/connect.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . connect . TransferReversal . stripe_class . create_reversal ( id , ** params ) classmethod Source code in djstripe/models/connect.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . list_reversals ( id , ** params ) classmethod Source code in djstripe/models/connect.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . modify_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . retrieve_reversal ( id , nested_id , ** params ) classmethod Source code in djstripe/models/connect.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . connect . TransferReversal . stripe_class . reversals_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/connect.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . connect . TransferReversal . stripe_class . reversals_url ( id , nested_id = None ) classmethod Source code in djstripe/models/connect.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . connect . TransferReversal . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . connect . TransferReversal . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/connect.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"TransferReversal"},{"location":"reference/project/#djstripe.models.core","text":"","title":"core"},{"location":"reference/project/#djstripe.models.core-classes","text":"","title":"Classes"},{"location":"reference/project/#djstripe.models.core.BalanceTransaction","text":"A single transaction that updates the Stripe balance. Stripe documentation: https://stripe.com/docs/api#balance_transaction_object djstripe . models . core . BalanceTransaction . amount djstripe . models . core . BalanceTransaction . available_on djstripe . models . core . BalanceTransaction . currency djstripe . models . core . BalanceTransaction . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . BalanceTransaction . exchange_rate djstripe . models . core . BalanceTransaction . fee djstripe . models . core . BalanceTransaction . fee_details djstripe . models . core . BalanceTransaction . net djstripe . models . core . BalanceTransaction . reporting_category djstripe . models . core . BalanceTransaction . source djstripe . models . core . BalanceTransaction . status djstripe . models . core . BalanceTransaction . type djstripe.models.core.BalanceTransaction.DoesNotExist djstripe.models.core.BalanceTransaction.MultipleObjectsReturned djstripe.models.core.BalanceTransaction.stripe_class","title":"BalanceTransaction"},{"location":"reference/project/#djstripe.models.core.BalanceTransaction-methods","text":"djstripe . models . core . BalanceTransaction . get_next_by_available_on ( self , * , field =< djstripe . fields . StripeDateTimeField : available_on > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_available_on ( self , * , field =< djstripe . fields . StripeDateTimeField : available_on > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_reporting_category_display ( self , * , field =< djstripe . fields . StripeEnumField : reporting_category > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_source_class ( self ) Source code in djstripe/models/core.py def get_source_class ( self ): return apps . get_model ( \"djstripe\" , self . type ) djstripe . models . core . BalanceTransaction . get_source_instance ( self ) Source code in djstripe/models/core.py def get_source_instance ( self ): return self . get_source_class () . objects . get ( id = self . source ) djstripe . models . core . BalanceTransaction . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . BalanceTransaction . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . get_source_instance () . get_stripe_dashboard_url () djstripe . models . core . BalanceTransaction . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Methods"},{"location":"reference/project/#djstripe.models.core.Charge","text":"To charge a credit or a debit card, you create a charge object. You can retrieve and refund individual charges as well as list all charges. Charges are identified by a unique random ID. Stripe documentation: https://stripe.com/docs/api/python#charges djstripe . models . core . Charge . account property readonly djstripe . models . core . Charge . amount djstripe . models . core . Charge . amount_captured djstripe . models . core . Charge . amount_refunded djstripe . models . core . Charge . application djstripe . models . core . Charge . application_fee djstripe . models . core . Charge . application_fee_amount djstripe . models . core . Charge . balance_transaction djstripe . models . core . Charge . billing_details djstripe . models . core . Charge . calculated_statement_descriptor djstripe . models . core . Charge . captured djstripe . models . core . Charge . currency djstripe . models . core . Charge . customer djstripe . models . core . Charge . dispute djstripe . models . core . Charge . disputed djstripe . models . core . Charge . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Charge . expand_fields : List [ str ] djstripe . models . core . Charge . failure_code djstripe . models . core . Charge . failure_message djstripe . models . core . Charge . fee property readonly djstripe . models . core . Charge . fraud_details djstripe . models . core . Charge . fraudulent : bool property readonly djstripe . models . core . Charge . human_readable_amount : str property readonly djstripe . models . core . Charge . human_readable_status : str property readonly djstripe . models . core . Charge . invoice djstripe . models . core . Charge . objects djstripe . models . core . Charge . on_behalf_of djstripe . models . core . Charge . outcome djstripe . models . core . Charge . paid djstripe . models . core . Charge . payment_intent djstripe . models . core . Charge . payment_method djstripe . models . core . Charge . payment_method_details djstripe . models . core . Charge . receipt_email djstripe . models . core . Charge . receipt_number djstripe . models . core . Charge . receipt_url djstripe . models . core . Charge . refunded djstripe . models . core . Charge . shipping djstripe . models . core . Charge . source djstripe . models . core . Charge . source_transfer djstripe . models . core . Charge . statement_descriptor djstripe . models . core . Charge . statement_descriptor_suffix djstripe . models . core . Charge . status djstripe . models . core . Charge . stripe_dashboard_item_name djstripe . models . core . Charge . transfer djstripe . models . core . Charge . transfer_data djstripe . models . core . Charge . transfer_group djstripe.models.core.Charge.DoesNotExist djstripe.models.core.Charge.MultipleObjectsReturned djstripe.models.core.Charge.stripe_class djstripe . models . core . Charge . stripe_class . OBJECT_NAME djstripe . models . core . Charge . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . close_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute/close\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute djstripe . models . core . Charge . stripe_class . mark_as_fraudulent ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_fraudulent ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"fraudulent\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . mark_as_safe ( self , idempotency_key = None ) Source code in djstripe/models/core.py def mark_as_safe ( self , idempotency_key = None ): params = { \"fraud_details\" : { \"user_report\" : \"safe\" }} url = self . instance_url () headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . refund ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def refund ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/refund\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Charge . stripe_class . update_dispute ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def update_dispute ( self , idempotency_key = None , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/dispute\" headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( \"post\" , url , params , headers ) self . refresh_from ({ \"dispute\" : response }, api_key , True ) return self . dispute","title":"Charge"},{"location":"reference/project/#djstripe.models.core.Charge-methods","text":"djstripe . models . core . Charge . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): amount = self . human_readable_amount status = self . human_readable_status if not status : return amount return \" {amount} ( {status} )\" . format ( amount = amount , status = status ) djstripe . models . core . Charge . capture ( self , ** kwargs ) Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge Source code in djstripe/models/core.py def capture ( self , ** kwargs ) -> \"Charge\" : \"\"\" Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you created a charge with the capture option set to False. See https://stripe.com/docs/api#capture_charge \"\"\" captured_charge = self . api_retrieve () . capture ( ** kwargs ) return self . __class__ . sync_from_stripe_data ( captured_charge ) djstripe . models . core . Charge . get_failure_code_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_code > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Charge . refund ( self , amount = None , reason = None ) Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are duplicate , fraudulent , and requested_by_customer . Specifying fraudulent as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. Source code in djstripe/models/core.py def refund ( self , amount : Decimal = None , reason : str = None ) -> \"Charge\" : \"\"\" Initiate a refund. Returns the charge object. :param amount: A positive decimal amount representing how much of this charge to refund. If amount is not provided, then this will be a full refund. Can only refund up to the unrefunded amount remaining of the charge. :param reason: String indicating the reason for the refund. If set, possible values are ``duplicate``, ``fraudulent``, and ``requested_by_customer``. Specifying ``fraudulent`` as the reason when you believe the charge to be fraudulent will help Stripe improve their fraud detection algorithms. \"\"\" charge_obj = self . api_retrieve () . refund ( amount = self . _calculate_refund_amount ( amount = amount ), reason = reason ) return self . __class__ . sync_from_stripe_data ( charge_obj )","title":"Methods"},{"location":"reference/project/#djstripe.models.core.Customer","text":"Customer objects allow you to perform recurring charges and track multiple charges that are associated with the same customer. Stripe documentation: https://stripe.com/docs/api/python#customers","title":"Customer"},{"location":"reference/project/#djstripe.models.core.Customer-attributes","text":"djstripe . models . core . Customer . active_subscriptions property readonly Returns active subscriptions (subscriptions with an active status that end in the future). djstripe . models . core . Customer . address djstripe . models . core . Customer . balance djstripe . models . core . Customer . business_vat_id : str property readonly djstripe . models . core . Customer . coupon djstripe . models . core . Customer . coupon_end djstripe . models . core . Customer . coupon_start djstripe . models . core . Customer . credits property readonly The customer is considered to have credits if their balance is below 0. djstripe . models . core . Customer . currency djstripe . models . core . Customer . customer_payment_methods property readonly An iterable of all of the customer's payment methods (sources, then legacy cards) djstripe . models . core . Customer . date_purged djstripe . models . core . Customer . default_payment_method djstripe . models . core . Customer . default_source djstripe . models . core . Customer . delinquent djstripe . models . core . Customer . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Customer . email djstripe . models . core . Customer . expand_fields : List [ str ] djstripe . models . core . Customer . invoice_prefix djstripe . models . core . Customer . invoice_settings djstripe . models . core . Customer . name djstripe . models . core . Customer . pending_charges property readonly The customer is considered to have pending charges if their balance is above 0. djstripe . models . core . Customer . phone djstripe . models . core . Customer . preferred_locales djstripe . models . core . Customer . shipping djstripe . models . core . Customer . stripe_dashboard_item_name djstripe . models . core . Customer . subscriber djstripe . models . core . Customer . subscription property readonly Shortcut to get this customer's subscription. :returns: None if the customer has no subscriptions, the subscription if the customer has a subscription. :raises MultipleSubscriptionException: Raised if the customer has multiple subscriptions. In this case, use Customer.subscriptions instead. djstripe . models . core . Customer . tax_exempt djstripe . models . core . Customer . valid_subscriptions property readonly Returns this customer's valid subscriptions (subscriptions that aren't canceled or incomplete_expired). djstripe.models.core.Customer.DoesNotExist djstripe.models.core.Customer.MultipleObjectsReturned djstripe.models.core.Customer.stripe_class djstripe . models . core . Customer . stripe_class . OBJECT_NAME djstripe . models . core . Customer . stripe_class . balance_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . balance_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . create_balance_transaction ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_source ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . create_tax_id ( id , ** params ) classmethod Source code in djstripe/models/core.py def create_nested_resource ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_discount ( self , ** params ) Source code in djstripe/models/core.py def delete_discount ( self , ** params ): requestor = api_requestor . APIRequestor ( self . api_key , api_version = self . stripe_version , account = self . stripe_account , ) url = self . instance_url () + \"/discount\" _ , api_key = requestor . request ( \"delete\" , url , params ) self . refresh_from ({ \"discount\" : None }, api_key , True ) djstripe . models . core . Customer . stripe_class . delete_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . delete_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def delete_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"delete\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_balance_transactions ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_payment_methods ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def list_payment_methods ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/payment_methods\" headers = util . populate_headers ( idempotency_key ) resp = self . request ( \"get\" , url , params , headers ) stripe_object = util . convert_to_stripe_object ( resp ) stripe_object . _retrieve_params = params return stripe_object djstripe . models . core . Customer . stripe_class . list_sources ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . list_tax_ids ( id , ** params ) classmethod Source code in djstripe/models/core.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . modify_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def modify_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"post\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_balance_transaction ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_source ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . retrieve_tax_id ( id , nested_id , ** params ) classmethod Source code in djstripe/models/core.py def retrieve_nested_resource ( cls , id , nested_id , ** params ): url = getattr ( cls , resource_url_method )( id , nested_id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . core . Customer . stripe_class . sources_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . sources_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url djstripe . models . core . Customer . stripe_class . tax_ids_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . core . Customer . stripe_class . tax_ids_url ( id , nested_id = None ) classmethod Source code in djstripe/models/core.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"Attributes"},{"location":"reference/project/#djstripe.models.core.Customer-methods","text":"djstripe . models . core . Customer . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): if self . subscriber : return str ( self . subscriber ) return self . name or self . description or self . id djstripe . models . core . Customer . add_card ( self , source , set_default = True ) Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean Source code in djstripe/models/core.py def add_card ( self , source , set_default = True ): \"\"\" Adds a card to this customer's account. :param source: Either a token, like the ones returned by our Stripe.js, or a dictionary containing a user's credit card details. Stripe will automatically validate the card. :type source: string, dict :param set_default: Whether or not to set the source as the customer's default source :type set_default: boolean \"\"\" from .payment_methods import DjstripePaymentMethod stripe_customer = self . api_retrieve () new_stripe_payment_method = stripe_customer . sources . create ( source = source ) if set_default : stripe_customer . default_source = new_stripe_payment_method [ \"id\" ] stripe_customer . save () new_payment_method = DjstripePaymentMethod . from_stripe_object ( new_stripe_payment_method ) # Change the default source if set_default : self . default_source = new_payment_method self . save () return new_payment_method . resolve () djstripe . models . core . Customer . add_coupon ( self , coupon , idempotency_key = None ) Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. Source code in djstripe/models/core.py def add_coupon ( self , coupon , idempotency_key = None ): \"\"\" Add a coupon to a Customer. The coupon can be a Coupon object, or a valid Stripe Coupon ID. \"\"\" if isinstance ( coupon , StripeModel ): coupon = coupon . id stripe_customer = self . api_retrieve () stripe_customer [ \"coupon\" ] = coupon stripe_customer . save ( idempotency_key = idempotency_key ) return self . __class__ . sync_from_stripe_data ( stripe_customer ) djstripe . models . core . Customer . add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None ) Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. Use this when adding invoice items in response to an invoice.created webhook. You cannot add an invoice item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using Customer.add_invoice_item() instead of .. Customer.add_invoice_item() , invoice and subscriptions .. can only be strings Source code in djstripe/models/core.py def add_invoice_item ( self , amount , currency , description = None , discountable = None , invoice = None , metadata = None , subscription = None , ): \"\"\" Adds an arbitrary charge or credit to the customer's upcoming invoice. Different than creating a charge. Charges are separate bills that get processed immediately. Invoice items are appended to the customer's next invoice. This is extremely useful when adding surcharges to subscriptions. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param currency: 3-letter ISO code for currency :type currency: string :param description: An arbitrary string. :type description: string :param discountable: Controls whether discounts apply to this invoice item. Defaults to False for prorations or negative invoice items, and True for all other invoice items. :type discountable: boolean :param invoice: An existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming \\ scheduled invoice. \\ Use this when adding invoice items in response to an \\ ``invoice.created`` webhook. You cannot add an invoice \\ item to an invoice that has already been paid, attempted or closed. :type invoice: Invoice or string (invoice ID) :param metadata: A set of key/value pairs useful for storing additional information. :type metadata: dict :param subscription: A subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming \\ scheduled invoice. When set, scheduled invoices for subscriptions other \\ than the specified subscription will ignore the invoice item. \\ Use this when you want to express that an invoice item has been accrued \\ within the context of a particular subscription. :type subscription: Subscription or string (subscription ID) .. Notes: .. if you're using ``Customer.add_invoice_item()`` instead of .. ``Customer.add_invoice_item()``, ``invoice`` and ``subscriptions`` .. can only be strings \"\"\" from .billing import InvoiceItem if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Invoice to id if invoice is not None and isinstance ( invoice , StripeModel ): invoice = invoice . id # Convert Subscription to id if subscription is not None and isinstance ( subscription , StripeModel ): subscription = subscription . id stripe_invoiceitem = InvoiceItem . _api_create ( amount = int ( amount * 100 ), # Convert dollars into cents currency = currency , customer = self . id , description = description , discountable = discountable , invoice = invoice , metadata = metadata , subscription = subscription , ) return InvoiceItem . sync_from_stripe_data ( stripe_invoiceitem ) djstripe . models . core . Customer . add_payment_method ( self , payment_method , set_default = True ) Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod Source code in djstripe/models/core.py def add_payment_method ( self , payment_method , set_default = True ): \"\"\" Adds an already existing payment method to this customer's account :param payment_method: PaymentMethod to be attached to the customer :type payment_method: str, PaymentMethod :param set_default: If true, this will be set as the default_payment_method :type set_default: bool :rtype: PaymentMethod \"\"\" from .payment_methods import PaymentMethod stripe_customer = self . api_retrieve () payment_method = PaymentMethod . attach ( payment_method , stripe_customer ) if set_default : stripe_customer [ \"invoice_settings\" ][ \"default_payment_method\" ] = payment_method . id stripe_customer . save () # Refresh self from the stripe customer, this should have two effects: # 1) sets self.default_payment_method (we rely on logic in # Customer._manipulate_stripe_object_hook to do this) # 2) updates self.invoice_settings.default_payment_methods self . sync_from_stripe_data ( stripe_customer ) self . refresh_from_db () return payment_method djstripe . models . core . Customer . can_charge ( self ) Determines if this customer is able to be charged. Source code in djstripe/models/core.py def can_charge ( self ): \"\"\"Determines if this customer is able to be charged.\"\"\" return ( self . has_valid_source () or self . default_payment_method is not None ) and self . date_purged is None djstripe . models . core . Customer . charge ( self , amount , * , application_fee = None , source = None , ** kwargs ) Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source Source code in djstripe/models/core.py def charge ( self , amount : Decimal , * , application_fee : Decimal = None , source : Union [ str , StripeModel ] = None , ** kwargs ) -> Charge : \"\"\" Creates a charge for this customer. :param amount: The amount to charge. :type amount: Decimal. Precision is 2; anything more will be ignored. :param source: The source to use for this charge. Must be a source attributed to this customer. If None, the customer's default source is used. Can be either the id of the source or the source object itself. :type source: string, Source \"\"\" if not isinstance ( amount , Decimal ): raise ValueError ( \"You must supply a decimal value representing dollars.\" ) # Convert Source to id if source and isinstance ( source , StripeModel ): source = source . id stripe_charge = Charge . _api_create ( customer = self . id , amount = int ( amount * 100 ), # Convert dollars into cents application_fee = int ( application_fee * 100 ) if application_fee else None , # Convert dollars into cents source = source , ** kwargs ) return Charge . sync_from_stripe_data ( stripe_charge ) djstripe . models . core . Customer . create ( subscriber , idempotency_key = None , stripe_account = None ) classmethod Source code in djstripe/models/core.py @classmethod def create ( cls , subscriber , idempotency_key = None , stripe_account = None ): metadata = {} subscriber_key = djstripe_settings . SUBSCRIBER_CUSTOMER_KEY if subscriber_key not in ( \"\" , None ): metadata [ subscriber_key ] = subscriber . pk stripe_customer = cls . _api_create ( email = subscriber . email , idempotency_key = idempotency_key , metadata = metadata , stripe_account = stripe_account , ) customer , created = Customer . objects . get_or_create ( id = stripe_customer [ \"id\" ], defaults = { \"subscriber\" : subscriber , \"livemode\" : stripe_customer [ \"livemode\" ], \"balance\" : stripe_customer . get ( \"balance\" , 0 ), \"delinquent\" : stripe_customer . get ( \"delinquent\" , False ), }, ) return customer djstripe . models . core . Customer . delete ( self , using = None , keep_parents = False ) Overriding the delete method to keep the customer in the records. All identifying information is removed via the purge() method. The only way to delete a customer is to use SQL. Source code in djstripe/models/core.py def delete ( self , using = None , keep_parents = False ): \"\"\" Overriding the delete method to keep the customer in the records. All identifying information is removed via the purge() method. The only way to delete a customer is to use SQL. \"\"\" self . purge () djstripe . models . core . Customer . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_or_create ( subscriber , livemode = False , stripe_account = None ) classmethod Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , subscriber , livemode = djstripe_settings . STRIPE_LIVE_MODE , stripe_account = None , ): \"\"\" Get or create a dj-stripe customer. :param subscriber: The subscriber model instance for which to get or create a customer. :type subscriber: User :param livemode: Whether to get the subscriber in live or test mode. :type livemode: bool \"\"\" try : return Customer . objects . get ( subscriber = subscriber , livemode = livemode ), False except Customer . DoesNotExist : action = \"create: {} \" . format ( subscriber . pk ) idempotency_key = djstripe_settings . get_idempotency_key ( \"customer\" , action , livemode ) return ( cls . create ( subscriber , idempotency_key = idempotency_key , stripe_account = stripe_account , ), True , ) djstripe . models . core . Customer . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . get_tax_exempt_display ( self , * , field =< djstripe . fields . StripeEnumField : tax_exempt > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Customer . has_active_subscription ( self , plan = None ) Checks to see if this customer has an active subscription to the given plan. :param plan: The plan for which to check for an active subscription. If plan is None and there exists only one active subscription, this method will check if that subscription is valid. Calling this method with no plan and multiple valid subscriptions for this customer will throw an exception. :type plan: Plan or string (plan ID) :returns: True if there exists an active subscription, False otherwise. :throws: TypeError if plan is None and more than one active subscription exists for this customer. Source code in djstripe/models/core.py def has_active_subscription ( self , plan = None ): \"\"\" Checks to see if this customer has an active subscription to the given plan. :param plan: The plan for which to check for an active subscription. If plan is None and there exists only one active subscription, this method will check if that subscription is valid. Calling this method with no plan and multiple valid subscriptions for this customer will throw an exception. :type plan: Plan or string (plan ID) :returns: True if there exists an active subscription, False otherwise. :throws: TypeError if ``plan`` is None and more than one active subscription exists for this customer. \"\"\" warnings . warn ( \"has_active_subscription is deprecated in favor of `is_subscribed_to` \" \"and will be removed in a future release.\" , DeprecationWarning , ) if plan is None : valid_subscriptions = self . _get_valid_subscriptions () if len ( valid_subscriptions ) == 0 : return False elif len ( valid_subscriptions ) == 1 : return True else : raise TypeError ( \"plan cannot be None if more than one valid subscription \" \"exists for this customer.\" ) else : # Convert Plan to id if isinstance ( plan , StripeModel ): plan = plan . id return any ( [ subscription . is_valid () for subscription in self . subscriptions . filter ( plan__id = plan ) ] ) djstripe . models . core . Customer . has_any_active_subscription ( self ) Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def has_any_active_subscription ( self ): \"\"\" Checks to see if this customer has an active subscription to any plan. :returns: True if there exists an active subscription, False otherwise. \"\"\" return len ( self . _get_valid_subscriptions ()) != 0 djstripe . models . core . Customer . has_valid_source ( self ) Check whether the customer has a valid payment source. Source code in djstripe/models/core.py def has_valid_source ( self ): \"\"\"Check whether the customer has a valid payment source.\"\"\" return self . default_source is not None djstripe . models . core . Customer . is_subscribed_to ( self , product ) Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. Source code in djstripe/models/core.py def is_subscribed_to ( self , product : Union [ Product , str ]) -> bool : \"\"\" Checks to see if this customer has an active subscription to the given product. :param product: The product for which to check for an active subscription. :type product: Product or string (product ID) :returns: True if there exists an active subscription, False otherwise. \"\"\" if isinstance ( product , StripeModel ): product = product . id for subscription in self . _get_valid_subscriptions (): for item in subscription . items . all (): if item . price and item . price . product . id == product : return True return False djstripe . models . core . Customer . purge ( self ) Source code in djstripe/models/core.py def purge ( self ): try : self . _api_delete () except InvalidRequestError as exc : if \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer was already # deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise if self . subscriber : # Delete the idempotency key used by Customer.create() # So re-creating a customer for this subscriber before the key expires # doesn't return the older Customer data idempotency_key_action = \"customer:create: {} \" . format ( self . subscriber . pk ) IdempotencyKey . objects . filter ( action = idempotency_key_action ) . delete () self . subscriber = None # Remove sources self . default_source = None for source in self . legacy_cards . all (): source . remove () for source in self . sources . all (): source . detach () self . date_purged = timezone . now () self . save () djstripe . models . core . Customer . retry_unpaid_invoices ( self ) Attempt to retry collecting payment on the customer's unpaid invoices. Source code in djstripe/models/core.py def retry_unpaid_invoices ( self ): \"\"\"Attempt to retry collecting payment on the customer's unpaid invoices.\"\"\" self . _sync_invoices () for invoice in self . invoices . filter ( auto_advance = True ) . exclude ( status = \"paid\" ): try : invoice . retry () # Always retry unpaid invoices except InvalidRequestError as exc : if str ( exc ) != \"Invoice is already paid\" : raise djstripe . models . core . Customer . send_invoice ( self ) Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). Source code in djstripe/models/core.py def send_invoice ( self ): \"\"\" Pay and send the customer's latest invoice. :returns: True if an invoice was able to be created and paid, False otherwise (typically if there was nothing to invoice). \"\"\" from .billing import Invoice try : invoice = Invoice . _api_create ( customer = self . id ) invoice . pay () return True except InvalidRequestError : # TODO: Check this for a more # specific error message. return False # There was nothing to invoice djstripe . models . core . Customer . subscribe ( self , price = None , plan = None , charge_immediately = True , ** kwargs ) Subscribes this customer to a price. NOTE: Only one item is supported at the moment. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) :param charge_immediately: Whether or not to charge for the subscription upon creation. If False, an invoice will be created at the end of this period. :type charge_immediately: boolean .. Notes: .. charge_immediately is only available on Customer.subscribe() .. if you're using Customer.subscribe() .. instead of Customer.subscribe() , plan can only be a string Source code in djstripe/models/core.py def subscribe ( self , price = None , plan = None , charge_immediately = True , ** kwargs ): \"\"\" Subscribes this customer to a price. NOTE: Only one item is supported at the moment. :param price: The price to which to subscribe the customer. :type price: Price or string (price ID) :param plan: The plan to which to subscribe the customer. :type plan: Plan or string (plan ID) :param charge_immediately: Whether or not to charge for the subscription upon creation. If False, an invoice will be created at the end of this period. :type charge_immediately: boolean .. Notes: .. ``charge_immediately`` is only available on ``Customer.subscribe()`` .. if you're using ``Customer.subscribe()`` .. instead of ``Customer.subscribe()``, ``plan`` can only be a string \"\"\" from .billing import Subscription if price and plan : raise TypeError ( \"price and plan arguments cannot both be defined.\" ) price = price or plan if not price : raise TypeError ( \"you need to set either price or plan\" ) # Convert Price to id if isinstance ( price , StripeModel ): price = price . id stripe_subscription = Subscription . _api_create ( items = [{ \"price\" : price }], customer = self . id , ** kwargs ) if charge_immediately : self . send_invoice () return Subscription . sync_from_stripe_data ( stripe_subscription ) djstripe . models . core . Customer . upcoming_invoice ( self , ** kwargs ) Gets the upcoming preview invoice (singular) for this customer. See Invoice.upcoming() <#djstripe.Invoice.upcoming> __. The customer argument to the upcoming() call is automatically set by this method. Source code in djstripe/models/core.py def upcoming_invoice ( self , ** kwargs ): \"\"\"Gets the upcoming preview invoice (singular) for this customer. See `Invoice.upcoming() <#djstripe.Invoice.upcoming>`__. The ``customer`` argument to the ``upcoming()`` call is automatically set by this method. \"\"\" from .billing import Invoice kwargs [ \"customer\" ] = self return Invoice . upcoming ( ** kwargs )","title":"Methods"},{"location":"reference/project/#djstripe.models.core.Dispute","text":"Stripe documentation: https://stripe.com/docs/api#disputes djstripe . models . core . Dispute . amount djstripe . models . core . Dispute . currency djstripe . models . core . Dispute . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Dispute . evidence djstripe . models . core . Dispute . evidence_details djstripe . models . core . Dispute . is_charge_refundable djstripe . models . core . Dispute . reason djstripe . models . core . Dispute . status djstripe . models . core . Dispute . stripe_dashboard_item_name djstripe.models.core.Dispute.DoesNotExist djstripe.models.core.Dispute.MultipleObjectsReturned djstripe.models.core.Dispute.stripe_class djstripe . models . core . Dispute . stripe_class . OBJECT_NAME djstripe . models . core . Dispute . stripe_class . close ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def close ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/close\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Dispute . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Dispute . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Dispute"},{"location":"reference/project/#djstripe.models.core.Event","text":"Events are Stripe's way of letting you know when something interesting happens in your account. When an interesting event occurs, a new Event object is created and POSTed to the configured webhook URL if the Event type matches. Stripe documentation: https://stripe.com/docs/api/events djstripe . models . core . Event . api_version djstripe . models . core . Event . customer property readonly djstripe . models . core . Event . data djstripe . models . core . Event . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Event . idempotency_key djstripe . models . core . Event . request_id djstripe . models . core . Event . stripe_dashboard_item_name djstripe . models . core . Event . type djstripe.models.core.Event.DoesNotExist djstripe.models.core.Event.MultipleObjectsReturned djstripe.models.core.Event.stripe_class","title":"Event"},{"location":"reference/project/#djstripe.models.core.Event-methods","text":"djstripe . models . core . Event . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Event . invoke_webhook_handlers ( self ) Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the djstripe.event_handlers module (or handlers registered in djstripe plugins or contrib packages). Source code in djstripe/models/core.py def invoke_webhook_handlers ( self ): \"\"\" Invokes any webhook handlers that have been registered for this event based on event type or event sub-type. See event handlers registered in the ``djstripe.event_handlers`` module (or handlers registered in djstripe plugins or contrib packages). \"\"\" webhooks . call_handlers ( event = self ) signal = WEBHOOK_SIGNALS . get ( self . type ) if signal : return signal . send ( sender = Event , event = self ) djstripe . models . core . Event . process ( data ) classmethod Source code in djstripe/models/core.py @classmethod def process ( cls , data ): qs = cls . objects . filter ( id = data [ \"id\" ]) if qs . exists (): return qs . first () # Rollback any DB operations in the case of failure so # we will retry creating and processing the event the # next time the webhook fires. with transaction . atomic (): ret = cls . _create_from_stripe_object ( data ) ret . invoke_webhook_handlers () return ret djstripe . models . core . Event . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/core.py def str_parts ( self ): return [ \"type= {type} \" . format ( type = self . type )] + super () . str_parts ()","title":"Methods"},{"location":"reference/project/#djstripe.models.core.File","text":"Stripe documentation: https://stripe.com/docs/api#file_uploads djstripe . models . core . File . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . File . filename djstripe . models . core . File . purpose djstripe . models . core . File . size djstripe . models . core . File . type djstripe . models . core . File . url djstripe.models.core.File.DoesNotExist djstripe.models.core.File.MultipleObjectsReturned djstripe.models.core.File.stripe_class djstripe . models . core . File . stripe_class . OBJECT_NAME djstripe . models . core . File . stripe_class . OBJECT_NAME_ALT djstripe . models . core . File . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . File . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account )","title":"File"},{"location":"reference/project/#djstripe.models.core.File-methods","text":"djstripe . models . core . File . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_purpose_display ( self , * , field =< djstripe . fields . StripeEnumField : purpose > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . File . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" )","title":"Methods"},{"location":"reference/project/#djstripe.models.core.FileUpload","text":"Stripe documentation: https://stripe.com/docs/api#file_uploads djstripe . models . core . FileUpload . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . FileUpload . filename djstripe . models . core . FileUpload . purpose djstripe . models . core . FileUpload . size djstripe . models . core . FileUpload . type djstripe . models . core . FileUpload . url djstripe.models.core.FileUpload.DoesNotExist djstripe.models.core.FileUpload.MultipleObjectsReturned djstripe.models.core.FileUpload.stripe_class djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME djstripe . models . core . FileUpload . stripe_class . OBJECT_NAME_ALT djstripe . models . core . FileUpload . stripe_class . class_url () classmethod Source code in djstripe/models/core.py @classmethod def class_url ( cls ): return \"/v1/files\" djstripe . models . core . FileUpload . stripe_class . create ( api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/core.py @classmethod def create ( # 'api_version' is deprecated, please use 'stripe_version' cls , api_key = None , api_version = None , stripe_version = None , stripe_account = None , ** params ): version = api_version or stripe_version requestor = api_requestor . APIRequestor ( api_key , api_base = stripe . upload_api_base , api_version = version , account = stripe_account , ) url = cls . class_url () supplied_headers = { \"Content-Type\" : \"multipart/form-data\" } response , api_key = requestor . request ( \"post\" , url , params = params , headers = supplied_headers ) return util . convert_to_stripe_object ( response , api_key , version , stripe_account )","title":"FileUpload"},{"location":"reference/project/#djstripe.models.core.FileUpload-methods","text":"djstripe . models . core . FileUpload . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_purpose_display ( self , * , field =< djstripe . fields . StripeEnumField : purpose > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . FileUpload . is_valid_object ( data ) classmethod Returns whether the data is a valid object for the class Source code in djstripe/models/core.py @classmethod def is_valid_object ( cls , data ): return \"object\" in data and data [ \"object\" ] in ( \"file\" , \"file_upload\" )","title":"Methods"},{"location":"reference/project/#djstripe.models.core.PaymentIntent","text":"Stripe documentation: https://stripe.com/docs/api#payment_intents djstripe . models . core . PaymentIntent . amount djstripe . models . core . PaymentIntent . amount_capturable djstripe . models . core . PaymentIntent . amount_received djstripe . models . core . PaymentIntent . canceled_at djstripe . models . core . PaymentIntent . cancellation_reason djstripe . models . core . PaymentIntent . capture_method djstripe . models . core . PaymentIntent . client_secret djstripe . models . core . PaymentIntent . confirmation_method djstripe . models . core . PaymentIntent . currency djstripe . models . core . PaymentIntent . customer djstripe . models . core . PaymentIntent . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . PaymentIntent . last_payment_error djstripe . models . core . PaymentIntent . next_action djstripe . models . core . PaymentIntent . on_behalf_of djstripe . models . core . PaymentIntent . payment_method djstripe . models . core . PaymentIntent . payment_method_types djstripe . models . core . PaymentIntent . receipt_email djstripe . models . core . PaymentIntent . setup_future_usage djstripe . models . core . PaymentIntent . shipping djstripe . models . core . PaymentIntent . statement_descriptor djstripe . models . core . PaymentIntent . status djstripe . models . core . PaymentIntent . stripe_dashboard_item_name djstripe . models . core . PaymentIntent . transfer_data djstripe . models . core . PaymentIntent . transfer_group djstripe.models.core.PaymentIntent.DoesNotExist djstripe.models.core.PaymentIntent.MultipleObjectsReturned djstripe.models.core.PaymentIntent.stripe_class djstripe . models . core . PaymentIntent . stripe_class . OBJECT_NAME djstripe . models . core . PaymentIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . capture ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def capture ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/capture\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . PaymentIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"PaymentIntent"},{"location":"reference/project/#djstripe.models.core.PaymentIntent-methods","text":"djstripe . models . core . PaymentIntent . get_cancellation_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : cancellation_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_capture_method_display ( self , * , field =< djstripe . fields . StripeEnumField : capture_method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_confirmation_method_display ( self , * , field =< djstripe . fields . StripeEnumField : confirmation_method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_setup_future_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : setup_future_usage > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . PaymentIntent . update ( self , api_key = None , ** kwargs ) Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string Source code in djstripe/models/core.py def update ( self , api_key = None , ** kwargs ): \"\"\" Call the stripe API's modify operation for this model :param api_key: The api key to use for this request. Defaults to djstripe_settings.STRIPE_SECRET_KEY. :type api_key: string \"\"\" api_key = api_key or self . default_api_key return self . api_retrieve ( api_key = api_key ) . modify ( ** kwargs )","title":"Methods"},{"location":"reference/project/#djstripe.models.core.Payout","text":"A Payout object is created when you receive funds from Stripe, or when you initiate a payout to either a bank account or debit card of a connected Stripe account. Stripe documentation: https://stripe.com/docs/api#payouts djstripe . models . core . Payout . amount djstripe . models . core . Payout . arrival_date djstripe . models . core . Payout . automatic djstripe . models . core . Payout . balance_transaction djstripe . models . core . Payout . currency djstripe . models . core . Payout . destination djstripe . models . core . Payout . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Payout . expand_fields : List [ str ] djstripe . models . core . Payout . failure_balance_transaction djstripe . models . core . Payout . failure_code djstripe . models . core . Payout . failure_message djstripe . models . core . Payout . method djstripe . models . core . Payout . source_type djstripe . models . core . Payout . statement_descriptor djstripe . models . core . Payout . status djstripe . models . core . Payout . stripe_dashboard_item_name djstripe . models . core . Payout . type djstripe.models.core.Payout.DoesNotExist djstripe.models.core.Payout.MultipleObjectsReturned djstripe.models.core.Payout.stripe_class djstripe . models . core . Payout . stripe_class . OBJECT_NAME djstripe . models . core . Payout . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Payout . stripe_class . reverse ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def reverse ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/reverse\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . Payout . get_failure_code_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_code > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_method_display ( self , * , field =< djstripe . fields . StripeEnumField : method > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_arrival_date ( self , * , field =< djstripe . fields . StripeDateTimeField : arrival_date > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_arrival_date ( self , * , field =< djstripe . fields . StripeDateTimeField : arrival_date > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_source_type_display ( self , * , field =< djstripe . fields . StripeEnumField : source_type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Payout . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Payout"},{"location":"reference/project/#djstripe.models.core.Price","text":"Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products. Price and Plan objects are the same, but use a different representation. Creating a recurring Price in Stripe also makes a Plan available, and vice versa. This is not the case for a Price with interval=one_time. Price objects are a more recent API representation, support more features and its usage is encouraged instead of Plan objects. Stripe documentation: - https://stripe.com/docs/api/prices - https://stripe.com/docs/billing/prices-guide djstripe . models . core . Price . active djstripe . models . core . Price . billing_scheme djstripe . models . core . Price . currency djstripe . models . core . Price . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Price . expand_fields : List [ str ] djstripe . models . core . Price . human_readable_price property readonly djstripe . models . core . Price . lookup_key djstripe . models . core . Price . nickname djstripe . models . core . Price . product djstripe . models . core . Price . recurring djstripe . models . core . Price . stripe_dashboard_item_name djstripe . models . core . Price . tiers djstripe . models . core . Price . tiers_mode djstripe . models . core . Price . transform_quantity djstripe . models . core . Price . type djstripe . models . core . Price . unit_amount djstripe . models . core . Price . unit_amount_decimal djstripe.models.core.Price.DoesNotExist djstripe.models.core.Price.MultipleObjectsReturned djstripe.models.core.Price.stripe_class","title":"Price"},{"location":"reference/project/#djstripe.models.core.Price-methods","text":"djstripe . models . core . Price . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return self . nickname or self . id djstripe . models . core . Price . create ( ** kwargs ) classmethod Source code in djstripe/models/core.py @classmethod def create ( cls , ** kwargs ): # A few minor things are changed in the api-version of the create call api_kwargs = dict ( kwargs ) api_kwargs [ \"unit_amount\" ] = int ( api_kwargs [ \"unit_amount\" ] * 100 ) if isinstance ( api_kwargs . get ( \"product\" ), StripeModel ): api_kwargs [ \"product\" ] = api_kwargs [ \"product\" ] . id stripe_price = cls . _api_create ( ** api_kwargs ) price = cls . sync_from_stripe_data ( stripe_price ) return price djstripe . models . core . Price . get_billing_scheme_display ( self , * , field =< djstripe . fields . StripeEnumField : billing_scheme > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_or_create ( ** kwargs ) classmethod Get or create a Price. Source code in djstripe/models/core.py @classmethod def get_or_create ( cls , ** kwargs ): \"\"\"Get or create a Price.\"\"\" try : return Price . objects . get ( id = kwargs [ \"id\" ]), False except Price . DoesNotExist : return cls . create ( ** kwargs ), True djstripe . models . core . Price . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_tiers_mode_display ( self , * , field =< djstripe . fields . StripeEnumField : tiers_mode > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Price . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Methods"},{"location":"reference/project/#djstripe.models.core.Product","text":"Stripe documentation: - https://stripe.com/docs/api#products - https://stripe.com/docs/api#service_products djstripe . models . core . Product . active djstripe . models . core . Product . attributes djstripe . models . core . Product . caption djstripe . models . core . Product . deactivate_on djstripe . models . core . Product . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Product . images djstripe . models . core . Product . name djstripe . models . core . Product . package_dimensions djstripe . models . core . Product . shippable djstripe . models . core . Product . statement_descriptor djstripe . models . core . Product . stripe_dashboard_item_name djstripe . models . core . Product . type djstripe . models . core . Product . unit_label djstripe . models . core . Product . url djstripe.models.core.Product.DoesNotExist djstripe.models.core.Product.MultipleObjectsReturned djstripe.models.core.Product.stripe_class djstripe . models . core . Product . __str__ ( self ) special Source code in djstripe/models/core.py def __str__ ( self ): return self . name djstripe . models . core . Product . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Product . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Product"},{"location":"reference/project/#djstripe.models.core.Refund","text":"Stripe documentation: https://stripe.com/docs/api#refund_object djstripe . models . core . Refund . amount djstripe . models . core . Refund . balance_transaction djstripe . models . core . Refund . charge djstripe . models . core . Refund . currency djstripe . models . core . Refund . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . Refund . failure_balance_transaction djstripe . models . core . Refund . failure_reason djstripe . models . core . Refund . reason djstripe . models . core . Refund . receipt_number djstripe . models . core . Refund . status djstripe.models.core.Refund.DoesNotExist djstripe.models.core.Refund.MultipleObjectsReturned djstripe.models.core.Refund.stripe_class","title":"Refund"},{"location":"reference/project/#djstripe.models.core.Refund-methods","text":"djstripe . models . core . Refund . get_failure_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : failure_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . Refund . get_stripe_dashboard_url ( self ) Get the stripe dashboard url for this object. Source code in djstripe/models/core.py def get_stripe_dashboard_url ( self ): return self . charge . get_stripe_dashboard_url ()","title":"Methods"},{"location":"reference/project/#djstripe.models.core.SetupIntent","text":"A SetupIntent guides you through the process of setting up a customer's payment credentials for future payments. For example, you could use a SetupIntent to set up your customer's card without immediately collecting a payment. Later, you can use PaymentIntents to drive the payment flow. NOTE: You should not maintain long-lived, unconfirmed SetupIntents. For security purposes, SetupIntents older than 24 hours may no longer be valid. Stripe documentation: https://stripe.com/docs/api#setup_intents djstripe . models . core . SetupIntent . application djstripe . models . core . SetupIntent . cancellation_reason djstripe . models . core . SetupIntent . client_secret djstripe . models . core . SetupIntent . customer djstripe . models . core . SetupIntent . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . core . SetupIntent . last_setup_error djstripe . models . core . SetupIntent . next_action djstripe . models . core . SetupIntent . on_behalf_of djstripe . models . core . SetupIntent . payment_method djstripe . models . core . SetupIntent . payment_method_types djstripe . models . core . SetupIntent . status djstripe . models . core . SetupIntent . usage djstripe.models.core.SetupIntent.DoesNotExist djstripe.models.core.SetupIntent.MultipleObjectsReturned djstripe.models.core.SetupIntent.stripe_class djstripe . models . core . SetupIntent . stripe_class . OBJECT_NAME djstripe . models . core . SetupIntent . stripe_class . cancel ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def cancel ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/cancel\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . SetupIntent . stripe_class . confirm ( self , idempotency_key = None , ** params ) Source code in djstripe/models/core.py def confirm ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/confirm\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . core . SetupIntent . get_cancellation_reason_display ( self , * , field =< djstripe . fields . StripeEnumField : cancellation_reason > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . core . SetupIntent . get_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : usage > ) Source code in djstripe/models/core.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"SetupIntent"},{"location":"reference/project/#djstripe.models.fraud","text":"","title":"fraud"},{"location":"reference/project/#djstripe.models.orders","text":"","title":"orders"},{"location":"reference/project/#djstripe.models.payment_methods","text":"","title":"payment_methods"},{"location":"reference/project/#djstripe.models.payment_methods-classes","text":"","title":"Classes"},{"location":"reference/project/#djstripe.models.payment_methods.BankAccount","text":"BankAccount(djstripe_id, id, djstripe_owner_account, livemode, created, metadata, description, djstripe_created, djstripe_updated, account, account_holder_name, account_holder_type, bank_name, country, currency, customer, default_for_currency, fingerprint, last4, routing_number, status) djstripe . models . payment_methods . BankAccount . account djstripe . models . payment_methods . BankAccount . account_holder_name djstripe . models . payment_methods . BankAccount . account_holder_type djstripe . models . payment_methods . BankAccount . bank_name djstripe . models . payment_methods . BankAccount . country djstripe . models . payment_methods . BankAccount . currency djstripe . models . payment_methods . BankAccount . customer : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . BankAccount . default_for_currency djstripe . models . payment_methods . BankAccount . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . BankAccount . fingerprint djstripe . models . payment_methods . BankAccount . last4 djstripe . models . payment_methods . BankAccount . routing_number djstripe . models . payment_methods . BankAccount . status djstripe.models.payment_methods.BankAccount.DoesNotExist djstripe.models.payment_methods.BankAccount.MultipleObjectsReturned djstripe.models.payment_methods.BankAccount.stripe_class djstripe . models . payment_methods . BankAccount . stripe_class . OBJECT_NAME djstripe . models . payment_methods . BankAccount . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether bank_account_id %s is \" \"attached to a customer or an account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . BankAccount . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a bank account without a customer or account ID. \" \"Call save on customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" ) djstripe . models . payment_methods . BankAccount . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a bank account without a customer or account ID. \" \"Use customer.sources.retrieve('bank_account_id') or \" \"account.external_accounts.retrieve('bank_account_id') instead.\" )","title":"BankAccount"},{"location":"reference/project/#djstripe.models.payment_methods.BankAccount-methods","text":"djstripe . models . payment_methods . BankAccount . api_retrieve ( self , ** kwargs ) Call the stripe API's retrieve operation for this model. :param api_key: The api key to use for this request. Defaults to settings.STRIPE_SECRET_KEY. :type api_key: string :param stripe_account: The optional connected account for which this request is being made. :type stripe_account: string Source code in djstripe/models/payment_methods.py def api_retrieve ( self , ** kwargs ): if not self . customer : raise NotImplementedError ( \"Cannot retrieve bank accounts not associated with a customer\" ) return super () . api_retrieve ( ** kwargs ) djstripe . models . payment_methods . BankAccount . get_account_holder_type_display ( self , * , field =< djstripe . fields . StripeEnumField : account_holder_type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . BankAccount . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Methods"},{"location":"reference/project/#djstripe.models.payment_methods.Card","text":"You can store multiple cards on a customer in order to charge the customer later. This is a legacy model which only applies to the \"v2\" Stripe API (eg. Checkout.js). You should strive to use the Stripe \"v3\" API (eg. Stripe Elements). Also see: https://stripe.com/docs/stripe-js/elements/migrating When using Elements, you will not be using Card objects. Instead, you will use Source objects. A Source object of type \"card\" is equivalent to a Card object. However, Card objects cannot be converted into Source objects by Stripe at this time. Stripe documentation: https://stripe.com/docs/api/python#cards djstripe . models . payment_methods . Card . address_city djstripe . models . payment_methods . Card . address_country djstripe . models . payment_methods . Card . address_line1 djstripe . models . payment_methods . Card . address_line1_check djstripe . models . payment_methods . Card . address_line2 djstripe . models . payment_methods . Card . address_state djstripe . models . payment_methods . Card . address_zip djstripe . models . payment_methods . Card . address_zip_check djstripe . models . payment_methods . Card . brand djstripe . models . payment_methods . Card . country djstripe . models . payment_methods . Card . customer : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Card . cvc_check djstripe . models . payment_methods . Card . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Card . dynamic_last4 djstripe . models . payment_methods . Card . exp_month djstripe . models . payment_methods . Card . exp_year djstripe . models . payment_methods . Card . fingerprint djstripe . models . payment_methods . Card . funding djstripe . models . payment_methods . Card . last4 djstripe . models . payment_methods . Card . name djstripe . models . payment_methods . Card . tokenization_method djstripe.models.payment_methods.Card.DoesNotExist djstripe.models.payment_methods.Card.MultipleObjectsReturned djstripe.models.payment_methods.Card.stripe_class djstripe . models . payment_methods . Card . stripe_class . OBJECT_NAME djstripe . models . payment_methods . Card . stripe_class . instance_url ( self ) Source code in djstripe/models/payment_methods.py def instance_url ( self ): token = util . utf8 ( self . id ) extn = quote_plus ( token ) if hasattr ( self , \"customer\" ): customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) class_base = \"sources\" elif hasattr ( self , \"recipient\" ): recipient = util . utf8 ( self . recipient ) base = Recipient . class_url () owner_extn = quote_plus ( recipient ) class_base = \"cards\" elif hasattr ( self , \"account\" ): account = util . utf8 ( self . account ) base = Account . class_url () owner_extn = quote_plus ( account ) class_base = \"external_accounts\" else : raise error . InvalidRequestError ( \"Could not determine whether card_id %s is \" \"attached to a customer, recipient, or \" \"account.\" % token , \"id\" , ) return \" %s / %s / %s / %s \" % ( base , owner_extn , class_base , extn ) djstripe . models . payment_methods . Card . stripe_class . modify ( sid , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def modify ( cls , sid , ** params ): raise NotImplementedError ( \"Can't modify a card without a customer, recipient or account \" \"ID. Call save on customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" ) djstripe . models . payment_methods . Card . stripe_class . retrieve ( id , api_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def retrieve ( cls , id , api_key = None , stripe_version = None , stripe_account = None , ** params ): raise NotImplementedError ( \"Can't retrieve a card without a customer, recipient or account \" \"ID. Use customer.sources.retrieve('card_id'), \" \"recipient.cards.retrieve('card_id'), or \" \"account.external_accounts.retrieve('card_id') instead.\" )","title":"Card"},{"location":"reference/project/#djstripe.models.payment_methods.Card-methods","text":"djstripe . models . payment_methods . Card . create_token ( number , exp_month , exp_year , cvc , api_key = 'sk_test_123' , ** kwargs ) classmethod Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api/python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use Source code in djstripe/models/payment_methods.py @classmethod def create_token ( cls , number : str , exp_month : int , exp_year : int , cvc : str , api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs , ) -> stripe . Token : \"\"\" Creates a single use token that wraps the details of a credit card. This token can be used in place of a credit card dictionary with any API method. These tokens can only be used once: by creating a new charge object, or attaching them to a customer. (Source: https://stripe.com/docs/api/python#create_card_token) :param number: The card number without any separators (no spaces) :param exp_month: The card's expiration month. (two digits) :param exp_year: The card's expiration year. (four digits) :param cvc: Card security code. :param api_key: The API key to use \"\"\" card = { \"number\" : number , \"exp_month\" : exp_month , \"exp_year\" : exp_year , \"cvc\" : cvc , } card . update ( kwargs ) return stripe . Token . create ( api_key = api_key , card = card ) djstripe . models . payment_methods . Card . get_address_line1_check_display ( self , * , field =< djstripe . fields . StripeEnumField : address_line1_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_address_zip_check_display ( self , * , field =< djstripe . fields . StripeEnumField : address_zip_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_brand_display ( self , * , field =< djstripe . fields . StripeEnumField : brand > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_cvc_check_display ( self , * , field =< djstripe . fields . StripeEnumField : cvc_check > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_funding_display ( self , * , field =< djstripe . fields . StripeEnumField : funding > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . get_tokenization_method_display ( self , * , field =< djstripe . fields . StripeEnumField : tokenization_method > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Card . str_parts ( self ) Extend this to add information to the string representation of the object Source code in djstripe/models/payment_methods.py def str_parts ( self ): return [ \"brand= {brand} \" . format ( brand = self . brand ), \"last4= {last4} \" . format ( last4 = self . last4 ), \"exp_month= {exp_month} \" . format ( exp_month = self . exp_month ), \"exp_year= {exp_year} \" . format ( exp_year = self . exp_year ), ] + super () . str_parts ()","title":"Methods"},{"location":"reference/project/#djstripe.models.payment_methods.DjstripePaymentMethod","text":"An internal model that abstracts the legacy Card and BankAccount objects with Source objects. Contains two fields: id and type : - id is the id of the Stripe object. - type can be card , bank_account or source . djstripe . models . payment_methods . DjstripePaymentMethod . id djstripe . models . payment_methods . DjstripePaymentMethod . object_model property readonly djstripe . models . payment_methods . DjstripePaymentMethod . type djstripe.models.payment_methods.DjstripePaymentMethod.DoesNotExist djstripe.models.payment_methods.DjstripePaymentMethod.MultipleObjectsReturned djstripe . models . payment_methods . DjstripePaymentMethod . from_stripe_object ( data ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def from_stripe_object ( cls , data ): source_type = data [ \"object\" ] model = cls . _model_for_type ( source_type ) with transaction . atomic (): model . sync_from_stripe_data ( data ) instance , _ = cls . objects . get_or_create ( id = data [ \"id\" ], defaults = { \"type\" : source_type } ) return instance djstripe . models . payment_methods . DjstripePaymentMethod . resolve ( self ) Source code in djstripe/models/payment_methods.py def resolve ( self ): return self . object_model . objects . get ( id = self . id )","title":"DjstripePaymentMethod"},{"location":"reference/project/#djstripe.models.payment_methods.LegacySourceMixin","text":"Mixin for functionality shared between the legacy Card & BankAccount sources","title":"LegacySourceMixin"},{"location":"reference/project/#djstripe.models.payment_methods.LegacySourceMixin-methods","text":"djstripe . models . payment_methods . LegacySourceMixin . api_list ( api_key = 'sk_test_123' , ** kwargs ) classmethod Source code in djstripe/models/payment_methods.py @classmethod def api_list ( cls , api_key = djstripe_settings . STRIPE_SECRET_KEY , ** kwargs ): # OVERRIDING the parent version of this function # Cards & Bank Accounts must be manipulated through a customer or account. # TODO: When managed accounts are supported, this method needs to # check if either a customer or account is supplied to determine # the correct object to use. customer , clean_kwargs = cls . _get_customer_from_kwargs ( ** kwargs ) return ( customer . api_retrieve ( api_key = api_key ) . sources . list ( object = cls . stripe_class . OBJECT_NAME , ** clean_kwargs ) . auto_paging_iter () ) djstripe . models . payment_methods . LegacySourceMixin . api_retrieve ( self , api_key = None , stripe_account = None ) Source code in djstripe/models/payment_methods.py def api_retrieve ( self , api_key = None , stripe_account = None ): # OVERRIDING the parent version of this function # Cards & Banks Accounts must be manipulated through a customer or account. # TODO: When managed accounts are supported, this method needs to check if # either a customer or account is supplied to determine the # correct object to use. api_key = api_key or self . default_api_key customer = self . customer . api_retrieve ( api_key = api_key , stripe_account = stripe_account ) # If the customer is deleted, the sources attribute will be absent. # eg. {\"id\": \"cus_XXXXXXXX\", \"deleted\": True} if \"sources\" not in customer : # We fake a native stripe InvalidRequestError so that it's caught # like an invalid ID error. raise InvalidRequestError ( f \"No such source: { self . id !r} \" , \"id\" ) # This will retrieve the source using the account ID where the customer resides, # so we don't have to pass `stripe_account`. return customer . sources . retrieve ( self . id , expand = self . expand_fields ) djstripe . models . payment_methods . LegacySourceMixin . get_stripe_dashboard_url ( self ) Source code in djstripe/models/payment_methods.py def get_stripe_dashboard_url ( self ) -> str : if self . customer : return self . customer . get_stripe_dashboard_url () else : return \"\" djstripe . models . payment_methods . LegacySourceMixin . remove ( self ) Removes a legacy source from this customer's account. Source code in djstripe/models/payment_methods.py def remove ( self ): \"\"\" Removes a legacy source from this customer's account. \"\"\" # First, wipe default source on all customers that use this card. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) try : self . _api_delete () except InvalidRequestError as exc : if \"No such source:\" in str ( exc ) or \"No such customer:\" in str ( exc ): # The exception was thrown because the stripe customer or card # was already deleted on the stripe side, ignore the exception pass else : # The exception was raised for another reason, re-raise it raise self . delete ()","title":"Methods"},{"location":"reference/project/#djstripe.models.payment_methods.PaymentMethod","text":"Stripe documentation: https://stripe.com/docs/api#payment_methods djstripe . models . payment_methods . PaymentMethod . alipay djstripe . models . payment_methods . PaymentMethod . au_becs_debit djstripe . models . payment_methods . PaymentMethod . bacs_debit djstripe . models . payment_methods . PaymentMethod . bancontact djstripe . models . payment_methods . PaymentMethod . billing_details djstripe . models . payment_methods . PaymentMethod . card djstripe . models . payment_methods . PaymentMethod . card_present djstripe . models . payment_methods . PaymentMethod . customer djstripe . models . payment_methods . PaymentMethod . description djstripe . models . payment_methods . PaymentMethod . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . PaymentMethod . eps djstripe . models . payment_methods . PaymentMethod . fpx djstripe . models . payment_methods . PaymentMethod . giropay djstripe . models . payment_methods . PaymentMethod . ideal djstripe . models . payment_methods . PaymentMethod . interac_present djstripe . models . payment_methods . PaymentMethod . oxxo djstripe . models . payment_methods . PaymentMethod . p24 djstripe . models . payment_methods . PaymentMethod . sepa_debit djstripe . models . payment_methods . PaymentMethod . sofort djstripe . models . payment_methods . PaymentMethod . type djstripe.models.payment_methods.PaymentMethod.DoesNotExist djstripe.models.payment_methods.PaymentMethod.MultipleObjectsReturned djstripe.models.payment_methods.PaymentMethod.stripe_class djstripe . models . payment_methods . PaymentMethod . stripe_class . OBJECT_NAME djstripe . models . payment_methods . PaymentMethod . stripe_class . attach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def attach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/attach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self djstripe . models . payment_methods . PaymentMethod . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): url = self . instance_url () + \"/detach\" headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"post\" , url , params , headers )) return self","title":"PaymentMethod"},{"location":"reference/project/#djstripe.models.payment_methods.PaymentMethod-methods","text":"djstripe . models . payment_methods . PaymentMethod . attach ( payment_method , customer , api_key = 'sk_test_123' ) classmethod Attach a payment method to a customer Source code in djstripe/models/payment_methods.py @classmethod def attach ( cls , payment_method : Union [ str , \"PaymentMethod\" ], customer : Union [ str , Customer ], api_key : str = djstripe_settings . STRIPE_SECRET_KEY , ) -> \"PaymentMethod\" : \"\"\" Attach a payment method to a customer \"\"\" if isinstance ( payment_method , StripeModel ): payment_method = payment_method . id if isinstance ( customer , StripeModel ): customer = customer . id extra_kwargs = {} if not isinstance ( payment_method , stripe . PaymentMethod ): # send api_key if we're not passing in a Stripe object # avoids \"Received unknown parameter: api_key\" since api uses the # key cached in the Stripe object extra_kwargs = { \"api_key\" : api_key } stripe_payment_method = stripe . PaymentMethod . attach ( payment_method , customer = customer , ** extra_kwargs ) return cls . sync_from_stripe_data ( stripe_payment_method ) djstripe . models . payment_methods . PaymentMethod . detach ( self ) Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, false if it was already detached :rtype: bool Source code in djstripe/models/payment_methods.py def detach ( self ): \"\"\" Detach the payment method from its customer. :return: Returns true if the payment method was newly detached, \\ false if it was already detached :rtype: bool \"\"\" # Find customers that use this customers = Customer . objects . filter ( default_payment_method = self ) . all () changed = True # special handling is needed for legacy \"card\"-type PaymentMethods, # since detaching them deletes them within Stripe. # see https://github.com/dj-stripe/dj-stripe/pull/967 is_legacy_card = self . id . startswith ( \"card_\" ) try : self . sync_from_stripe_data ( self . api_retrieve () . detach ()) # resync customer to update .default_payment_method and # .invoice_settings.default_payment_method for customer in customers : Customer . sync_from_stripe_data ( customer . api_retrieve ()) except ( InvalidRequestError ,): # The source was already detached. Resyncing. if self . pk and not is_legacy_card : self . sync_from_stripe_data ( self . api_retrieve ()) changed = False if self . pk : if is_legacy_card : self . delete () else : self . refresh_from_db () return changed djstripe . models . payment_methods . PaymentMethod . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . PaymentMethod . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Methods"},{"location":"reference/project/#djstripe.models.payment_methods.Source","text":"Stripe documentation: https://stripe.com/docs/api#sources djstripe . models . payment_methods . Source . amount djstripe . models . payment_methods . Source . client_secret djstripe . models . payment_methods . Source . code_verification djstripe . models . payment_methods . Source . currency djstripe . models . payment_methods . Source . customer djstripe . models . payment_methods . Source . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . payment_methods . Source . flow djstripe . models . payment_methods . Source . owner djstripe . models . payment_methods . Source . receiver djstripe . models . payment_methods . Source . redirect djstripe . models . payment_methods . Source . source_data djstripe . models . payment_methods . Source . statement_descriptor djstripe . models . payment_methods . Source . status djstripe . models . payment_methods . Source . stripe_dashboard_item_name djstripe . models . payment_methods . Source . type djstripe . models . payment_methods . Source . usage","title":"Source"},{"location":"reference/project/#djstripe.models.payment_methods.Source-classes","text":"djstripe.models.payment_methods.Source.DoesNotExist djstripe.models.payment_methods.Source.MultipleObjectsReturned djstripe.models.payment_methods.Source.stripe_class djstripe . models . payment_methods . Source . stripe_class . OBJECT_NAME Methods djstripe . models . payment_methods . Source . stripe_class . detach ( self , idempotency_key = None , ** params ) Source code in djstripe/models/payment_methods.py def detach ( self , idempotency_key = None , ** params ): token = util . utf8 ( self . id ) if hasattr ( self , \"customer\" ) and self . customer : extn = quote_plus ( token ) customer = util . utf8 ( self . customer ) base = Customer . class_url () owner_extn = quote_plus ( customer ) url = \" %s / %s /sources/ %s \" % ( base , owner_extn , extn ) headers = util . populate_headers ( idempotency_key ) self . refresh_from ( self . request ( \"delete\" , url , params , headers )) return self else : raise error . InvalidRequestError ( \"Source %s does not appear to be currently attached \" \"to a customer object.\" % token , \"id\" , ) djstripe . models . payment_methods . Source . stripe_class . list_source_transactions ( id , ** params ) classmethod Source code in djstripe/models/payment_methods.py def list_nested_resources ( cls , id , ** params ): url = getattr ( cls , resource_url_method )( id ) return getattr ( cls , resource_request_method )( \"get\" , url , ** params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions ( self , ** params ) source_transactions is deprecated, use Source.list_source_transactions instead. Source code in djstripe/models/payment_methods.py def source_transactions ( self , ** params ): \"\"\"source_transactions is deprecated, use Source.list_source_transactions instead.\"\"\" return self . request ( \"get\" , self . instance_url () + \"/source_transactions\" , params ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_request ( method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_request ( cls , method , url , api_key = None , idempotency_key = None , stripe_version = None , stripe_account = None , ** params ): requestor = api_requestor . APIRequestor ( api_key , api_version = stripe_version , account = stripe_account ) headers = util . populate_headers ( idempotency_key ) response , api_key = requestor . request ( method , url , params , headers ) return util . convert_to_stripe_object ( response , api_key , stripe_version , stripe_account ) djstripe . models . payment_methods . Source . stripe_class . source_transactions_url ( id , nested_id = None ) classmethod Source code in djstripe/models/payment_methods.py def nested_resource_url ( cls , id , nested_id = None ): url = \" %s / %s / %s \" % ( cls . class_url (), quote_plus ( id ), quote_plus ( path ), ) if nested_id is not None : url += \"/ %s \" % quote_plus ( nested_id ) return url","title":"Classes"},{"location":"reference/project/#djstripe.models.payment_methods.Source-methods","text":"djstripe . models . payment_methods . Source . detach ( self ) Detach the source from its customer. Source code in djstripe/models/payment_methods.py def detach ( self ) -> bool : \"\"\" Detach the source from its customer. \"\"\" # First, wipe default source on all customers that use this. Customer . objects . filter ( default_source = self . id ) . update ( default_source = None ) try : # TODO - we could use the return value of sync_from_stripe_data # or call its internals - self._sync/_attach_objects_hook etc here # to update `self` at this point? self . sync_from_stripe_data ( self . api_retrieve () . detach ()) return True except ( InvalidRequestError , NotImplementedError ): # The source was already detached. Resyncing. # NotImplementedError is an artifact of stripe-python<2.0 # https://github.com/stripe/stripe-python/issues/376 self . sync_from_stripe_data ( self . api_retrieve ()) return False djstripe . models . payment_methods . Source . get_flow_display ( self , * , field =< djstripe . fields . StripeEnumField : flow > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_type_display ( self , * , field =< djstripe . fields . StripeEnumField : type > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . payment_methods . Source . get_usage_display ( self , * , field =< djstripe . fields . StripeEnumField : usage > ) Source code in djstripe/models/payment_methods.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"Methods"},{"location":"reference/project/#djstripe.models.sigma","text":"","title":"sigma"},{"location":"reference/project/#djstripe.models.sigma-classes","text":"","title":"Classes"},{"location":"reference/project/#djstripe.models.sigma.ScheduledQueryRun","text":"Stripe documentation: https://stripe.com/docs/api#scheduled_queries djstripe . models . sigma . ScheduledQueryRun . data_load_time djstripe . models . sigma . ScheduledQueryRun . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] djstripe . models . sigma . ScheduledQueryRun . error djstripe . models . sigma . ScheduledQueryRun . file djstripe . models . sigma . ScheduledQueryRun . result_available_until djstripe . models . sigma . ScheduledQueryRun . sql djstripe . models . sigma . ScheduledQueryRun . status djstripe . models . sigma . ScheduledQueryRun . title djstripe.models.sigma.ScheduledQueryRun.DoesNotExist djstripe.models.sigma.ScheduledQueryRun.MultipleObjectsReturned djstripe.models.sigma.ScheduledQueryRun.stripe_class djstripe . models . sigma . ScheduledQueryRun . stripe_class . OBJECT_NAME djstripe . models . sigma . ScheduledQueryRun . stripe_class . class_url () classmethod Source code in djstripe/models/sigma.py @classmethod def class_url ( cls ): return \"/v1/sigma/scheduled_query_runs\" djstripe . models . sigma . ScheduledQueryRun . get_next_by_data_load_time ( self , * , field =< djstripe . fields . StripeDateTimeField : data_load_time > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_next_by_result_available_until ( self , * , field =< djstripe . fields . StripeDateTimeField : result_available_until > , is_next = True , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_data_load_time ( self , * , field =< djstripe . fields . StripeDateTimeField : data_load_time > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_previous_by_result_available_until ( self , * , field =< djstripe . fields . StripeDateTimeField : result_available_until > , is_next = False , ** kwargs ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . sigma . ScheduledQueryRun . get_status_display ( self , * , field =< djstripe . fields . StripeEnumField : status > ) Source code in djstripe/models/sigma.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"ScheduledQueryRun"},{"location":"reference/project/#djstripe.models.webhooks","text":"","title":"webhooks"},{"location":"reference/project/#djstripe.models.webhooks-classes","text":"","title":"Classes"},{"location":"reference/project/#djstripe.models.webhooks.WebhookEventTrigger","text":"An instance of a request that reached the server endpoint for Stripe webhooks. Webhook Events are initially UNTRUSTED , as it is possible for any web entity to post any data to our webhook url. Data posted may be valid Stripe information, garbage, or even malicious. The 'valid' flag in this model monitors this. djstripe . models . webhooks . WebhookEventTrigger . body djstripe . models . webhooks . WebhookEventTrigger . created djstripe . models . webhooks . WebhookEventTrigger . djstripe_version djstripe . models . webhooks . WebhookEventTrigger . event djstripe . models . webhooks . WebhookEventTrigger . exception djstripe . models . webhooks . WebhookEventTrigger . headers djstripe . models . webhooks . WebhookEventTrigger . id djstripe . models . webhooks . WebhookEventTrigger . is_test_event property readonly djstripe . models . webhooks . WebhookEventTrigger . processed djstripe . models . webhooks . WebhookEventTrigger . remote_ip djstripe . models . webhooks . WebhookEventTrigger . traceback djstripe . models . webhooks . WebhookEventTrigger . updated djstripe . models . webhooks . WebhookEventTrigger . valid djstripe.models.webhooks.WebhookEventTrigger.DoesNotExist djstripe.models.webhooks.WebhookEventTrigger.MultipleObjectsReturned","title":"WebhookEventTrigger"},{"location":"reference/project/#djstripe.models.webhooks.WebhookEventTrigger-methods","text":"djstripe . models . webhooks . WebhookEventTrigger . from_request ( request ) classmethod Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). Source code in djstripe/models/webhooks.py @classmethod def from_request ( cls , request ): \"\"\" Create, validate and process a WebhookEventTrigger given a Django request object. The process is three-fold: 1. Create a WebhookEventTrigger object from a Django request. 2. Validate the WebhookEventTrigger as a Stripe event using the API. 3. If valid, process it into an Event object (and child resource). \"\"\" try : body = request . body . decode ( request . encoding or \"utf-8\" ) except Exception : body = \"(error decoding body)\" ip = request . META . get ( \"REMOTE_ADDR\" ) if not ip : warnings . warn ( \"Could not determine remote IP (missing REMOTE_ADDR). \" \"This is likely an issue with your wsgi/server setup.\" ) ip = \"0.0.0.0\" obj = cls . objects . create ( headers = dict ( request . headers ), body = body , remote_ip = ip ) try : obj . valid = obj . validate () if obj . valid : if djstripe_settings . WEBHOOK_EVENT_CALLBACK : # If WEBHOOK_EVENT_CALLBACK, pass it for processing djstripe_settings . WEBHOOK_EVENT_CALLBACK ( obj ) else : # Process the item (do not save it, it'll get saved below) obj . process ( save = False ) except Exception as e : max_length = WebhookEventTrigger . _meta . get_field ( \"exception\" ) . max_length obj . exception = str ( e )[: max_length ] obj . traceback = format_exc () # Send the exception as the webhook_processing_error signal webhook_processing_error . send ( sender = WebhookEventTrigger , exception = e , data = getattr ( e , \"http_body\" , \"\" ), ) # re-raise the exception so Django sees it raise e finally : obj . save () return obj djstripe . models . webhooks . WebhookEventTrigger . get_next_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = True , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_next_by_updated ( self , * , field =< django . db . models . fields . DateTimeField : updated > , is_next = True , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_previous_by_created ( self , * , field =< django . db . models . fields . DateTimeField : created > , is_next = False , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . get_previous_by_updated ( self , * , field =< django . db . models . fields . DateTimeField : updated > , is_next = False , ** kwargs ) Source code in djstripe/models/webhooks.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) djstripe . models . webhooks . WebhookEventTrigger . process ( self , save = True ) Source code in djstripe/models/webhooks.py def process ( self , save = True ): # Reset traceback and exception in case of reprocessing self . exception = \"\" self . traceback = \"\" self . event = Event . process ( self . json_body ) self . processed = True if save : self . save () return self . event djstripe . models . webhooks . WebhookEventTrigger . validate ( self , api_key = None ) The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. Source code in djstripe/models/webhooks.py def validate ( self , api_key = None ): \"\"\" The original contents of the Event message must be confirmed by refetching it and comparing the fetched data with the original data. This function makes an API call to Stripe to redownload the Event data and returns whether or not it matches the WebhookEventTrigger data. \"\"\" local_data = self . json_body if \"id\" not in local_data or \"livemode\" not in local_data : return False if self . is_test_event : logger . info ( \"Test webhook received: {} \" . format ( local_data )) return False if djstripe_settings . WEBHOOK_VALIDATION is None : # validation disabled return True elif ( djstripe_settings . WEBHOOK_VALIDATION == \"verify_signature\" and djstripe_settings . WEBHOOK_SECRET ): # HTTP headers are case-insensitive, but we store them as a dict. headers = CaseInsensitiveMapping ( self . headers ) try : stripe . WebhookSignature . verify_header ( self . body , headers . get ( \"stripe-signature\" ), djstripe_settings . WEBHOOK_SECRET , djstripe_settings . WEBHOOK_TOLERANCE , ) except stripe . error . SignatureVerificationError : return False else : return True livemode = local_data [ \"livemode\" ] api_key = api_key or djstripe_settings . get_default_api_key ( livemode ) # Retrieve the event using the api_version specified in itself with stripe_temporary_api_version ( local_data [ \"api_version\" ], validate = False ): remote_data = Event . stripe_class . retrieve ( id = local_data [ \"id\" ], api_key = api_key ) return local_data [ \"data\" ] == remote_data [ \"data\" ] .. module:: djstripe.management. :synopsis: dj-stripe - management module, contains commands.","title":"Methods"},{"location":"reference/project/#djstripe.management-modules","text":"","title":"Modules"},{"location":"reference/project/#djstripe.management.commands","text":".. module:: djstripe.management.commands. :synopsis: dj-stripe commands.","title":"commands"},{"location":"reference/project/#djstripe.management.commands-modules","text":"","title":"Modules"},{"location":"reference/project/#djstripe.management.commands.djstripe_clear_expired_idempotency_keys","text":"","title":"djstripe_clear_expired_idempotency_keys"},{"location":"reference/project/#djstripe.management.commands.djstripe_clear_expired_idempotency_keys-classes","text":"djstripe.management.commands.djstripe_clear_expired_idempotency_keys.Command djstripe . management . commands . djstripe_clear_expired_idempotency_keys . Command . help Methods djstripe . management . commands . djstripe_clear_expired_idempotency_keys . Command . handle ( self , * args , ** options ) The actual logic of the command. Subclasses must implement this method. Source code in djstripe/management/commands/djstripe_clear_expired_idempotency_keys.py def handle ( self , * args , ** options ): clear_expired_idempotency_keys ()","title":"Classes"},{"location":"reference/project/#djstripe.management.commands.djstripe_init_customers","text":"init_customers command.","title":"djstripe_init_customers"},{"location":"reference/project/#djstripe.management.commands.djstripe_init_customers-classes","text":"djstripe.management.commands.djstripe_init_customers.Command Create customer objects for existing subscribers that don't have one. djstripe . management . commands . djstripe_init_customers . Command . help Methods djstripe . management . commands . djstripe_init_customers . Command . handle ( self , * args , ** options ) Create Customer objects for Subscribers without Customer objects associated. Source code in djstripe/management/commands/djstripe_init_customers.py def handle ( self , * args , ** options ): \"\"\" Create Customer objects for Subscribers without Customer objects associated. \"\"\" for subscriber in get_subscriber_model () . objects . filter ( djstripe_customers = None ): # use get_or_create in case of race conditions on large subscriber bases Customer . get_or_create ( subscriber = subscriber ) print ( \"Created subscriber for {0} \" . format ( subscriber . email ))","title":"Classes"},{"location":"reference/project/#djstripe.management.commands.djstripe_process_events","text":"","title":"djstripe_process_events"},{"location":"reference/project/#djstripe.management.commands.djstripe_process_events-classes","text":"djstripe.management.commands.djstripe_process_events.Command Command to process all Events. Optional arguments are provided to limit the number of Events processed. Note: this is only guaranteed go back at most 30 days based on the current limitation of stripe's events API. See: https://stripe.com/docs/api/events djstripe . management . commands . djstripe_process_events . Command . help Methods djstripe . management . commands . djstripe_process_events . Command . add_arguments ( self , parser ) Add optional arugments to filter Events by. Source code in djstripe/management/commands/djstripe_process_events.py def add_arguments ( self , parser ): \"\"\"Add optional arugments to filter Events by.\"\"\" # Use a mutually exclusive group to prevent multiple arguments being # specified together. group = parser . add_mutually_exclusive_group () group . add_argument ( \"--ids\" , nargs = \"*\" , help = \"An optional space separated list of specific Event IDs to sync.\" , ) group . add_argument ( \"--failed\" , action = \"store_true\" , help = \"Syncs and processes only the events that have failed webhooks.\" , ) group . add_argument ( \"--type\" , help = ( \"A string containing a specific event name,\" \" or group of events using * as a wildcard.\" \" The list will be filtered to include only\" \" events with a matching event property.\" ), ) djstripe . management . commands . djstripe_process_events . Command . handle ( self , * args , ** options ) Try to process Events listed from the API. Source code in djstripe/management/commands/djstripe_process_events.py def handle ( self , * args , ** options ): \"\"\"Try to process Events listed from the API.\"\"\" # Set the verbosity to determine how much we output, if at all. self . set_verbosity ( options ) event_ids = options [ \"ids\" ] failed = options [ \"failed\" ] type_filter = options [ \"type\" ] # Args are mutually exclusive, # so output what we are doing based on that assumption. if failed : self . output ( \"Processing all failed events\" ) elif type_filter : self . output ( \"Processing all events that match {filter} \" . format ( filter = type_filter ) ) elif event_ids : self . output ( \"Processing specific events {events} \" . format ( events = event_ids )) else : self . output ( \"Processing all available events\" ) # Either use the specific event IDs to retrieve data, or use the api_list # if no specific event IDs are specified. if event_ids : listed_events = ( models . Event . stripe_class . retrieve ( id = event_id , api_key = djstripe_settings . STRIPE_SECRET_KEY ) for event_id in event_ids ) else : list_kwargs = {} if failed : list_kwargs [ \"delivery_success\" ] = False if type_filter : list_kwargs [ \"type\" ] = type_filter listed_events = models . Event . api_list ( ** list_kwargs ) self . process_events ( listed_events ) djstripe . management . commands . djstripe_process_events . Command . process_events ( self , listed_events ) Source code in djstripe/management/commands/djstripe_process_events.py def process_events ( self , listed_events ): # Process each listed event. Capture failures and continue, # outputting debug information as verbosity dictates. count = 0 total = 0 for event_data in listed_events : try : total += 1 event = models . Event . process ( data = event_data ) count += 1 self . verbose_output ( \" Synced Event {id} \" . format ( id = event . id )) except Exception as exception : self . verbose_output ( \" Failed processing Event {id} \" . format ( id = event_data [ \"id\" ]) ) self . output ( \" {exception} \" . format ( exception = exception )) self . verbose_traceback () if total == 0 : self . output ( \" (no results)\" ) else : self . output ( \" Processed {count} out of {total} Events\" . format ( count = count , total = total ) )","title":"Classes"},{"location":"reference/project/#djstripe.management.commands.djstripe_sync_customers","text":"sync_customer command.","title":"djstripe_sync_customers"},{"location":"reference/project/#djstripe.management.commands.djstripe_sync_customers-classes","text":"djstripe.management.commands.djstripe_sync_customers.Command Sync subscriber data with stripe. djstripe . management . commands . djstripe_sync_customers . Command . help Methods djstripe . management . commands . djstripe_sync_customers . Command . handle ( self , * args , ** options ) Call sync_subscriber on Subscribers without customers associated to them. Source code in djstripe/management/commands/djstripe_sync_customers.py def handle ( self , * args , ** options ): \"\"\"Call sync_subscriber on Subscribers without customers associated to them.\"\"\" qs = get_subscriber_model () . objects . filter ( djstripe_customers__isnull = True ) count = 0 total = qs . count () for subscriber in qs : count += 1 perc = int ( round ( 100 * ( float ( count ) / float ( total )))) print ( \"[ {0} / {1} {2} %] Syncing {3} [ {4} ]\" . format ( count , total , perc , subscriber . email , subscriber . pk ) ) sync_subscriber ( subscriber )","title":"Classes"},{"location":"reference/project/#djstripe.management.commands.djstripe_sync_models","text":"","title":"djstripe_sync_models"},{"location":"reference/project/#djstripe.management.commands.djstripe_sync_models-classes","text":"djstripe.management.commands.djstripe_sync_models.Command Sync models from stripe. djstripe . management . commands . djstripe_sync_models . Command . help Methods djstripe . management . commands . djstripe_sync_models . Command . add_arguments ( self , parser ) Entry point for subclassed commands to add custom arguments. Source code in djstripe/management/commands/djstripe_sync_models.py def add_arguments ( self , parser ): parser . add_argument ( \"args\" , metavar = \"ModelName\" , nargs = \"*\" , help = \"restricts sync to these model names (default is to sync all \" \"supported models)\" , ) djstripe . management . commands . djstripe_sync_models . Command . get_list_kwargs ( self , model ) Returns a sequence of kwargs dicts to pass to model.api_list This allows us to sync models that require parameters to api_list :param model: :return: Sequence[dict] Source code in djstripe/management/commands/djstripe_sync_models.py def get_list_kwargs ( self , model ): \"\"\" Returns a sequence of kwargs dicts to pass to model.api_list This allows us to sync models that require parameters to api_list :param model: :return: Sequence[dict] \"\"\" all_list_kwargs = ( [{ \"expand\" : [ f \"data. { k } \" for k in model . expand_fields ]}] if model . expand_fields else [] ) if model is models . PaymentMethod : # special case all_list_kwargs . extend ( ( { \"customer\" : stripe_customer . id , \"type\" : \"card\" } for stripe_customer in models . Customer . api_list () ) ) elif model is models . SubscriptionItem : all_list_kwargs . extend ( ( { \"subscription\" : subscription . id } for subscription in models . Subscription . api_list () ) ) elif not all_list_kwargs : all_list_kwargs . append ({}) return all_list_kwargs djstripe . management . commands . djstripe_sync_models . Command . handle ( self , * args , ** options ) The actual logic of the command. Subclasses must implement this method. Source code in djstripe/management/commands/djstripe_sync_models.py def handle ( self , * args , ** options ): app_label = \"djstripe\" app_config = apps . get_app_config ( app_label ) model_list = [] # type: List[models.StripeModel] if args : for model_label in args : try : model = app_config . get_model ( model_label ) except LookupError : raise CommandError ( \"Unknown model: {} . {} \" . format ( app_label , model_label ) ) model_list . append ( model ) else : model_list = app_config . get_models () for model in model_list : self . sync_model ( model ) djstripe . management . commands . djstripe_sync_models . Command . sync_model ( self , model ) Source code in djstripe/management/commands/djstripe_sync_models.py def sync_model ( self , model ): model_name = model . __name__ should_sync , reason = self . _should_sync_model ( model ) if not should_sync : self . stdout . write ( f \"Skipping { model } : { reason } \" ) return self . stdout . write ( \"Syncing {} :\" . format ( model_name )) count = 0 try : for list_kwargs in self . get_list_kwargs ( model ): if model is models . Account : # special case, since own account isn't returned by Account.api_list stripe_obj = models . Account . stripe_class . retrieve ( api_key = settings . STRIPE_SECRET_KEY ) count += 1 djstripe_obj = model . sync_from_stripe_data ( stripe_obj ) self . stdout . write ( \" id= {id} , pk= {pk} ( {djstripe_obj} )\" . format ( id = djstripe_obj . id , pk = djstripe_obj . pk , djstripe_obj = djstripe_obj , ) ) for stripe_obj in model . api_list ( ** list_kwargs ): count += 1 djstripe_obj = model . sync_from_stripe_data ( stripe_obj ) self . stdout . write ( \" id= {id} , pk= {pk} ( {djstripe_obj} )\" . format ( id = djstripe_obj . id , pk = djstripe_obj . pk , djstripe_obj = djstripe_obj , ) ) except Exception as e : self . stderr . write ( str ( e )) if count == 0 : self . stdout . write ( \" (no results)\" ) else : self . stdout . write ( \" Synced {count} {model_name} \" . format ( count = count , model_name = model_name ) )","title":"Classes"},{"location":"reference/project/#djstripe.management.commands.djstripe_sync_plans_from_stripe","text":"sync_plans_from_stripe command.","title":"djstripe_sync_plans_from_stripe"},{"location":"reference/project/#djstripe.management.commands.djstripe_sync_plans_from_stripe-classes","text":"djstripe.management.commands.djstripe_sync_plans_from_stripe.Command Sync prices (and plans) from stripe. djstripe . management . commands . djstripe_sync_plans_from_stripe . Command . help Methods djstripe . management . commands . djstripe_sync_plans_from_stripe . Command . handle ( self , * args , ** options ) The actual logic of the command. Subclasses must implement this method. Source code in djstripe/management/commands/djstripe_sync_plans_from_stripe.py def handle ( self , * args , ** options ): for price_data in Price . api_list (): price = Price . sync_from_stripe_data ( price_data ) self . stdout . write ( f \"Synchronized price { price . id } \" ) for plan_data in Plan . api_list (): plan = Plan . sync_from_stripe_data ( plan_data ) self . stdout . write ( f \"Synchronized plan { plan . id } \" )","title":"Classes"},{"location":"reference/project/#djstripe.management.commands.djstripe_update_invoiceitem_ids","text":"djstripe . management . commands . djstripe_update_invoiceitem_ids . no_results_msg","title":"djstripe_update_invoiceitem_ids"},{"location":"reference/project/#djstripe.management.commands.djstripe_update_invoiceitem_ids-classes","text":"djstripe.management.commands.djstripe_update_invoiceitem_ids.Command djstripe . management . commands . djstripe_update_invoiceitem_ids . Command . help Methods djstripe . management . commands . djstripe_update_invoiceitem_ids . Command . add_arguments ( self , parser ) Add optional arugments to filter Events by. Source code in djstripe/management/commands/djstripe_update_invoiceitem_ids.py def add_arguments ( self , parser ): \"\"\"Add optional arugments to filter Events by.\"\"\" # Use a mutually exclusive group to prevent multiple arguments being # specified together. group = parser . add_mutually_exclusive_group () group . add_argument ( \"--i-understand\" , action = \"store_true\" , help = \"Run the command, once you've read the warning and understand it.\" , ) djstripe . management . commands . djstripe_update_invoiceitem_ids . Command . handle ( self , * args , ** options ) The actual logic of the command. Subclasses must implement this method. Source code in djstripe/management/commands/djstripe_update_invoiceitem_ids.py def handle ( self , * args , ** options ): invoice_items = InvoiceItem . objects . filter ( id__contains = \"-il_\" ) count = invoice_items . count () if not options [ \"i_understand\" ]: self . stderr . write ( \"In Stripe API 2019-12-03, the format of invoice line items changed. \" \"This means that existing InvoiceItem objects with the old ID format \" \"may still be in the database and need to be migrated. \\n \" \"This is a destructive migration, but this command will attempt to \" \"perform it as safely as possible. \\n \" \"More information: https://stripe.com/docs/upgrades#2019-12-03 \\n\\n \" ) if count : first_few_ids = invoice_items [: 10 ] . values_list ( \"id\" , flat = True ) self . stdout . write ( f \"I have found { count } InvoiceItems to migrate:\" ) self . stdout . write ( \" \" + \", \" . join ( first_few_ids ) + f \", \u2026 (and { count - 10 } more)\" if count > 10 else \"\" ) self . stderr . write ( \"To perform this migration, run this again with `--i-understand`.\" ) else : self . stdout . write ( no_results_msg ) return if not count : self . stdout . write ( no_results_msg ) return for ii in invoice_items : old_id = ii . id new_id = old_id . partition ( \"-\" )[ 2 ] if \"-\" in new_id or not new_id . startswith ( \"il_\" ): self . stderr . write ( f \"Don't know how to migrate { old_id !r} . This is a bug. \" \"Could you report it? \\n https://github.com/dj-stripe/dj-stripe\" ) continue self . stdout . write ( f \"Migrating { old_id } => { new_id } \" ) with transaction . atomic (): ii . id = new_id stripe_data = ii . api_retrieve () ii . save () InvoiceItem . sync_from_stripe_data ( stripe_data ) A Fake or multiple fakes for each stripe object. Originally collected using API VERSION 2015-07-28. Updated to API VERSION 2016-03-07 with bogus fields.","title":"Classes"},{"location":"reference/project/#tests.FAKE_ACCOUNT","text":"","title":"FAKE_ACCOUNT"},{"location":"reference/project/#tests.FAKE_BALANCE_TRANSACTION","text":"","title":"FAKE_BALANCE_TRANSACTION"},{"location":"reference/project/#tests.FAKE_BALANCE_TRANSACTION_II","text":"","title":"FAKE_BALANCE_TRANSACTION_II"},{"location":"reference/project/#tests.FAKE_BALANCE_TRANSACTION_III","text":"","title":"FAKE_BALANCE_TRANSACTION_III"},{"location":"reference/project/#tests.FAKE_BALANCE_TRANSACTION_IV","text":"","title":"FAKE_BALANCE_TRANSACTION_IV"},{"location":"reference/project/#tests.FAKE_BALANCE_TRANSACTION_REFUND","text":"","title":"FAKE_BALANCE_TRANSACTION_REFUND"},{"location":"reference/project/#tests.FAKE_BANK_ACCOUNT","text":"","title":"FAKE_BANK_ACCOUNT"},{"location":"reference/project/#tests.FAKE_BANK_ACCOUNT_II","text":"","title":"FAKE_BANK_ACCOUNT_II"},{"location":"reference/project/#tests.FAKE_BANK_ACCOUNT_SOURCE","text":"","title":"FAKE_BANK_ACCOUNT_SOURCE"},{"location":"reference/project/#tests.FAKE_CARD","text":"","title":"FAKE_CARD"},{"location":"reference/project/#tests.FAKE_CARD_AS_PAYMENT_METHOD","text":"","title":"FAKE_CARD_AS_PAYMENT_METHOD"},{"location":"reference/project/#tests.FAKE_CARD_II","text":"","title":"FAKE_CARD_II"},{"location":"reference/project/#tests.FAKE_CARD_III","text":"","title":"FAKE_CARD_III"},{"location":"reference/project/#tests.FAKE_CARD_IV","text":"","title":"FAKE_CARD_IV"},{"location":"reference/project/#tests.FAKE_CARD_V","text":"","title":"FAKE_CARD_V"},{"location":"reference/project/#tests.FAKE_CHARGE","text":"","title":"FAKE_CHARGE"},{"location":"reference/project/#tests.FAKE_CHARGE_II","text":"","title":"FAKE_CHARGE_II"},{"location":"reference/project/#tests.FAKE_CHARGE_REFUNDED","text":"","title":"FAKE_CHARGE_REFUNDED"},{"location":"reference/project/#tests.FAKE_COUPON","text":"","title":"FAKE_COUPON"},{"location":"reference/project/#tests.FAKE_CUSTOMER","text":"","title":"FAKE_CUSTOMER"},{"location":"reference/project/#tests.FAKE_CUSTOMER_BEFORE_TAX_ID","text":"","title":"FAKE_CUSTOMER_BEFORE_TAX_ID"},{"location":"reference/project/#tests.FAKE_CUSTOMER_II","text":"","title":"FAKE_CUSTOMER_II"},{"location":"reference/project/#tests.FAKE_CUSTOMER_III","text":"","title":"FAKE_CUSTOMER_III"},{"location":"reference/project/#tests.FAKE_CUSTOMER_IV","text":"","title":"FAKE_CUSTOMER_IV"},{"location":"reference/project/#tests.FAKE_CUSTOMER_WITHOUT_TAX_ID","text":"","title":"FAKE_CUSTOMER_WITHOUT_TAX_ID"},{"location":"reference/project/#tests.FAKE_CUSTOMER_WITH_TAX_ID","text":"","title":"FAKE_CUSTOMER_WITH_TAX_ID"},{"location":"reference/project/#tests.FAKE_DISCOUNT_CUSTOMER","text":"","title":"FAKE_DISCOUNT_CUSTOMER"},{"location":"reference/project/#tests.FAKE_DISPUTE","text":"","title":"FAKE_DISPUTE"},{"location":"reference/project/#tests.FAKE_EVENT_ACCOUNT_APPLICATION_DEAUTHORIZED","text":"","title":"FAKE_EVENT_ACCOUNT_APPLICATION_DEAUTHORIZED"},{"location":"reference/project/#tests.FAKE_EVENT_CARD_PAYMENT_METHOD_ATTACHED","text":"","title":"FAKE_EVENT_CARD_PAYMENT_METHOD_ATTACHED"},{"location":"reference/project/#tests.FAKE_EVENT_CARD_PAYMENT_METHOD_DETACHED","text":"","title":"FAKE_EVENT_CARD_PAYMENT_METHOD_DETACHED"},{"location":"reference/project/#tests.FAKE_EVENT_CHARGE_SUCCEEDED","text":"","title":"FAKE_EVENT_CHARGE_SUCCEEDED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_CREATED","text":"","title":"FAKE_EVENT_CUSTOMER_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_DELETED","text":"","title":"FAKE_EVENT_CUSTOMER_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_DISCOUNT_CREATED","text":"","title":"FAKE_EVENT_CUSTOMER_DISCOUNT_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_DISCOUNT_DELETED","text":"","title":"FAKE_EVENT_CUSTOMER_DISCOUNT_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_SOURCE_CREATED","text":"","title":"FAKE_EVENT_CUSTOMER_SOURCE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_SOURCE_DELETED","text":"","title":"FAKE_EVENT_CUSTOMER_SOURCE_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_SOURCE_DELETED_DUPE","text":"","title":"FAKE_EVENT_CUSTOMER_SOURCE_DELETED_DUPE"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED","text":"","title":"FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_CUSTOMER_SUBSCRIPTION_DELETED","text":"","title":"FAKE_EVENT_CUSTOMER_SUBSCRIPTION_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_DISPUTE_CREATED","text":"","title":"FAKE_EVENT_DISPUTE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_INVOICEITEM_CREATED","text":"","title":"FAKE_EVENT_INVOICEITEM_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_INVOICEITEM_DELETED","text":"","title":"FAKE_EVENT_INVOICEITEM_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_INVOICE_CREATED","text":"","title":"FAKE_EVENT_INVOICE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_INVOICE_DELETED","text":"","title":"FAKE_EVENT_INVOICE_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_INVOICE_UPCOMING","text":"","title":"FAKE_EVENT_INVOICE_UPCOMING"},{"location":"reference/project/#tests.FAKE_EVENT_PAYMENT_INTENT_SUCCEEDED_DESTINATION_CHARGE","text":"","title":"FAKE_EVENT_PAYMENT_INTENT_SUCCEEDED_DESTINATION_CHARGE"},{"location":"reference/project/#tests.FAKE_EVENT_PAYMENT_METHOD_ATTACHED","text":"","title":"FAKE_EVENT_PAYMENT_METHOD_ATTACHED"},{"location":"reference/project/#tests.FAKE_EVENT_PAYMENT_METHOD_DETACHED","text":"","title":"FAKE_EVENT_PAYMENT_METHOD_DETACHED"},{"location":"reference/project/#tests.FAKE_EVENT_PLAN_CREATED","text":"","title":"FAKE_EVENT_PLAN_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_PLAN_DELETED","text":"","title":"FAKE_EVENT_PLAN_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_PLAN_REQUEST_IS_OBJECT","text":"","title":"FAKE_EVENT_PLAN_REQUEST_IS_OBJECT"},{"location":"reference/project/#tests.FAKE_EVENT_PRICE_CREATED","text":"","title":"FAKE_EVENT_PRICE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_PRICE_DELETED","text":"","title":"FAKE_EVENT_PRICE_DELETED"},{"location":"reference/project/#tests.FAKE_EVENT_PRICE_UPDATED","text":"","title":"FAKE_EVENT_PRICE_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CANCELED","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CANCELED"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_RELEASED","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_RELEASED"},{"location":"reference/project/#tests.FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED","text":"","title":"FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED"},{"location":"reference/project/#tests.FAKE_EVENT_TEST_CHARGE_SUCCEEDED","text":"","title":"FAKE_EVENT_TEST_CHARGE_SUCCEEDED"},{"location":"reference/project/#tests.FAKE_EVENT_TRANSFER_CREATED","text":"","title":"FAKE_EVENT_TRANSFER_CREATED"},{"location":"reference/project/#tests.FAKE_EVENT_TRANSFER_DELETED","text":"","title":"FAKE_EVENT_TRANSFER_DELETED"},{"location":"reference/project/#tests.FAKE_FILEUPLOAD_ICON","text":"","title":"FAKE_FILEUPLOAD_ICON"},{"location":"reference/project/#tests.FAKE_FILEUPLOAD_LOGO","text":"","title":"FAKE_FILEUPLOAD_LOGO"},{"location":"reference/project/#tests.FAKE_INVOICE","text":"","title":"FAKE_INVOICE"},{"location":"reference/project/#tests.FAKE_INVOICEITEM","text":"","title":"FAKE_INVOICEITEM"},{"location":"reference/project/#tests.FAKE_INVOICEITEM_II","text":"","title":"FAKE_INVOICEITEM_II"},{"location":"reference/project/#tests.FAKE_INVOICEITEM_III","text":"","title":"FAKE_INVOICEITEM_III"},{"location":"reference/project/#tests.FAKE_INVOICE_II","text":"","title":"FAKE_INVOICE_II"},{"location":"reference/project/#tests.FAKE_INVOICE_III","text":"","title":"FAKE_INVOICE_III"},{"location":"reference/project/#tests.FAKE_INVOICE_IV","text":"","title":"FAKE_INVOICE_IV"},{"location":"reference/project/#tests.FAKE_PAYMENT_INTENT_DESTINATION_CHARGE","text":"","title":"FAKE_PAYMENT_INTENT_DESTINATION_CHARGE"},{"location":"reference/project/#tests.FAKE_PAYMENT_INTENT_I","text":"","title":"FAKE_PAYMENT_INTENT_I"},{"location":"reference/project/#tests.FAKE_PAYMENT_INTENT_II","text":"","title":"FAKE_PAYMENT_INTENT_II"},{"location":"reference/project/#tests.FAKE_PAYMENT_METHOD_I","text":"","title":"FAKE_PAYMENT_METHOD_I"},{"location":"reference/project/#tests.FAKE_PAYMENT_METHOD_II","text":"","title":"FAKE_PAYMENT_METHOD_II"},{"location":"reference/project/#tests.FAKE_PLAN","text":"","title":"FAKE_PLAN"},{"location":"reference/project/#tests.FAKE_PLAN_II","text":"","title":"FAKE_PLAN_II"},{"location":"reference/project/#tests.FAKE_PLAN_METERED","text":"","title":"FAKE_PLAN_METERED"},{"location":"reference/project/#tests.FAKE_PRICE","text":"","title":"FAKE_PRICE"},{"location":"reference/project/#tests.FAKE_PRICE_II","text":"","title":"FAKE_PRICE_II"},{"location":"reference/project/#tests.FAKE_PRICE_METERED","text":"","title":"FAKE_PRICE_METERED"},{"location":"reference/project/#tests.FAKE_PRICE_ONETIME","text":"","title":"FAKE_PRICE_ONETIME"},{"location":"reference/project/#tests.FAKE_PRICE_TIER","text":"","title":"FAKE_PRICE_TIER"},{"location":"reference/project/#tests.FAKE_PRODUCT","text":"","title":"FAKE_PRODUCT"},{"location":"reference/project/#tests.FAKE_REFUND","text":"","title":"FAKE_REFUND"},{"location":"reference/project/#tests.FAKE_SESSION_I","text":"","title":"FAKE_SESSION_I"},{"location":"reference/project/#tests.FAKE_SETUP_INTENT_I","text":"","title":"FAKE_SETUP_INTENT_I"},{"location":"reference/project/#tests.FAKE_SOURCE","text":"","title":"FAKE_SOURCE"},{"location":"reference/project/#tests.FAKE_SOURCE_II","text":"","title":"FAKE_SOURCE_II"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION","text":"","title":"FAKE_SUBSCRIPTION"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_CANCELED","text":"","title":"FAKE_SUBSCRIPTION_CANCELED"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_CANCELED_AT_PERIOD_END","text":"","title":"FAKE_SUBSCRIPTION_CANCELED_AT_PERIOD_END"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_II","text":"","title":"FAKE_SUBSCRIPTION_II"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_III","text":"","title":"FAKE_SUBSCRIPTION_III"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_METERED","text":"","title":"FAKE_SUBSCRIPTION_METERED"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_MULTI_PLAN","text":"","title":"FAKE_SUBSCRIPTION_MULTI_PLAN"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_NOT_PERIOD_CURRENT","text":"","title":"FAKE_SUBSCRIPTION_NOT_PERIOD_CURRENT"},{"location":"reference/project/#tests.FAKE_SUBSCRIPTION_SCHEDULE","text":"","title":"FAKE_SUBSCRIPTION_SCHEDULE"},{"location":"reference/project/#tests.FAKE_TAX_ID","text":"","title":"FAKE_TAX_ID"},{"location":"reference/project/#tests.FAKE_TAX_RATE_EXAMPLE_1_VAT","text":"","title":"FAKE_TAX_RATE_EXAMPLE_1_VAT"},{"location":"reference/project/#tests.FAKE_TAX_RATE_EXAMPLE_2_SALES","text":"","title":"FAKE_TAX_RATE_EXAMPLE_2_SALES"},{"location":"reference/project/#tests.FAKE_TIER_PLAN","text":"","title":"FAKE_TIER_PLAN"},{"location":"reference/project/#tests.FAKE_TOKEN","text":"","title":"FAKE_TOKEN"},{"location":"reference/project/#tests.FAKE_TRANSFER","text":"","title":"FAKE_TRANSFER"},{"location":"reference/project/#tests.FAKE_TRANSFER_II","text":"","title":"FAKE_TRANSFER_II"},{"location":"reference/project/#tests.FAKE_TRANSFER_III","text":"","title":"FAKE_TRANSFER_III"},{"location":"reference/project/#tests.FAKE_UPCOMING_INVOICE","text":"","title":"FAKE_UPCOMING_INVOICE"},{"location":"reference/project/#tests.FIXTURE_DIR_PATH","text":"","title":"FIXTURE_DIR_PATH"},{"location":"reference/project/#tests.FUTURE_DATE","text":"","title":"FUTURE_DATE"},{"location":"reference/project/#tests.IS_STATICMETHOD_AUTOSPEC_SUPPORTED","text":"","title":"IS_STATICMETHOD_AUTOSPEC_SUPPORTED"},{"location":"reference/project/#tests.logger","text":"","title":"logger"},{"location":"reference/project/#tests-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.AssertStripeFksMixin","text":"","title":"AssertStripeFksMixin"},{"location":"reference/project/#tests.AssertStripeFksMixin-methods","text":"","title":"Methods"},{"location":"reference/project/#tests.AssertStripeFksMixin.assert_fks","text":"Recursively walk through fks on obj, asserting they're not-none :param obj: :param expected_blank_fks: fields that are expected to be None :param processed_stripe_ids: set of objects ids already processed :return: Source code in tests/__init__.py def assert_fks ( self , obj , expected_blank_fks , processed_stripe_ids = None ): \"\"\" Recursively walk through fks on obj, asserting they're not-none :param obj: :param expected_blank_fks: fields that are expected to be None :param processed_stripe_ids: set of objects ids already processed :return: \"\"\" if processed_stripe_ids is None : processed_stripe_ids = set () processed_stripe_ids . add ( obj . id ) for field in obj . _meta . get_fields (): field_str = self . _get_field_str ( field ) if not field_str or field_str . endswith ( \".djstripe_owner_account\" ): continue try : field_value = getattr ( obj , field . name ) except ObjectDoesNotExist : field_value = None if field_str in expected_blank_fks : self . assertIsNone ( field_value , field_str ) else : self . assertIsNotNone ( field_value , field_str ) if field_value . id not in processed_stripe_ids : # recurse into the object if it's not already been checked self . assert_fks ( field_value , expected_blank_fks , processed_stripe_ids ) logger . warning ( \"checked {} \" . format ( field_str ))","title":"assert_fks()"},{"location":"reference/project/#tests.BankAccountDict","text":"","title":"BankAccountDict"},{"location":"reference/project/#tests.CardDict","text":"","title":"CardDict"},{"location":"reference/project/#tests.ChargeDict","text":"","title":"ChargeDict"},{"location":"reference/project/#tests.ChargeDict-methods","text":"","title":"Methods"},{"location":"reference/project/#tests.ChargeDict.__init__","text":"Match Stripe's behavior: return a stripe iterable on charge.refunds . Source code in tests/__init__.py def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `charge.refunds`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . refunds = StripeList ( self . refunds )","title":"__init__()"},{"location":"reference/project/#tests.ChargeDict.capture","text":"Source code in tests/__init__.py def capture ( self ): self . update ({ \"captured\" : True }) return self","title":"capture()"},{"location":"reference/project/#tests.ChargeDict.refund","text":"Source code in tests/__init__.py def refund ( self , amount = None , reason = None ): self . update ({ \"refunded\" : True , \"amount_refunded\" : amount }) return self","title":"refund()"},{"location":"reference/project/#tests.CustomerDict","text":"","title":"CustomerDict"},{"location":"reference/project/#tests.CustomerDict.sources","text":"","title":"sources"},{"location":"reference/project/#tests.CustomerDict.tax_ids","text":"","title":"tax_ids"},{"location":"reference/project/#tests.CustomerDict.__init__","text":"Source code in tests/__init__.py def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self [ \"default_source\" ] = convert_source_dict ( self [ \"default_source\" ]) for n , d in enumerate ( self [ \"sources\" ] . get ( \"data\" , [])): self [ \"sources\" ][ \"data\" ][ n ] = convert_source_dict ( d )","title":"__init__()"},{"location":"reference/project/#tests.CustomerDict.create_for_user","text":"Source code in tests/__init__.py def create_for_user ( self , user ): from djstripe.models import Customer stripe_customer = Customer . sync_from_stripe_data ( self ) stripe_customer . subscriber = user stripe_customer . save () return stripe_customer","title":"create_for_user()"},{"location":"reference/project/#tests.CustomerDict.delete","text":"Source code in tests/__init__.py def delete ( self ): return self","title":"delete()"},{"location":"reference/project/#tests.CustomerDict.save","text":"Source code in tests/__init__.py def save ( self , idempotency_key = None ): return self","title":"save()"},{"location":"reference/project/#tests.InvoiceDict","text":"","title":"InvoiceDict"},{"location":"reference/project/#tests.InvoiceDict-methods","text":"","title":"Methods"},{"location":"reference/project/#tests.InvoiceDict.__init__","text":"Match Stripe's behavior: return a stripe iterable on invoice.lines . Source code in tests/__init__.py def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `invoice.lines`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . lines = StripeList ( self . lines )","title":"__init__()"},{"location":"reference/project/#tests.InvoiceDict.pay","text":"Source code in tests/__init__.py def pay ( self ): return self","title":"pay()"},{"location":"reference/project/#tests.LegacySourceDict","text":"","title":"LegacySourceDict"},{"location":"reference/project/#tests.LegacySourceDict.delete","text":"Source code in tests/__init__.py def delete ( self ): return self","title":"delete()"},{"location":"reference/project/#tests.PaymentMethodDict","text":"","title":"PaymentMethodDict"},{"location":"reference/project/#tests.PaymentMethodDict.detach","text":"Source code in tests/__init__.py def detach ( self ): self . pop ( \"customer\" ) return self","title":"detach()"},{"location":"reference/project/#tests.SourceDict","text":"","title":"SourceDict"},{"location":"reference/project/#tests.SourceDict.detach","text":"Source code in tests/__init__.py def detach ( self ): self . pop ( \"customer\" ) self . update ({ \"status\" : \"consumed\" }) return self","title":"detach()"},{"location":"reference/project/#tests.Sources","text":"","title":"Sources"},{"location":"reference/project/#tests.Sources.__init__","text":"Source code in tests/__init__.py def __init__ ( self , card_fakes ): self . card_fakes = card_fakes","title":"__init__()"},{"location":"reference/project/#tests.Sources.create","text":"Source code in tests/__init__.py def create ( self , source , api_key = None ): for fake_card in self . card_fakes : if fake_card [ \"id\" ] == source : return fake_card","title":"create()"},{"location":"reference/project/#tests.Sources.list","text":"Source code in tests/__init__.py def list ( self , ** kwargs ): return StripeList ( data = self . card_fakes )","title":"list()"},{"location":"reference/project/#tests.Sources.retrieve","text":"Source code in tests/__init__.py def retrieve ( self , id , expand = None ): # noqa for fake_card in self . card_fakes : if fake_card [ \"id\" ] == id : return fake_card","title":"retrieve()"},{"location":"reference/project/#tests.StripeItem","text":"Flexible class built to mock any generic Stripe object. Implements object access + deletion methods to match the behavior of Stripe's library, which allows both object + dictionary access. Has a delete method since (most) Stripe objects can be deleted.","title":"StripeItem"},{"location":"reference/project/#tests.StripeItem-methods","text":"","title":"Methods"},{"location":"reference/project/#tests.StripeItem.__delattr__","text":"Source code in tests/__init__.py def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name )","title":"__delattr__()"},{"location":"reference/project/#tests.StripeItem.__getattr__","text":"Give StripeItem normal object access to match Stripe behavior. Source code in tests/__init__.py def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name )","title":"__getattr__()"},{"location":"reference/project/#tests.StripeItem.__setattr__","text":"Source code in tests/__init__.py def __setattr__ ( self , name , value ): self [ name ] = value","title":"__setattr__()"},{"location":"reference/project/#tests.StripeItem.class_url","text":"Source code in tests/__init__.py @classmethod def class_url ( cls ): return \"/v1/test-items/\"","title":"class_url()"},{"location":"reference/project/#tests.StripeItem.delete","text":"Superficial mock that adds a deleted attribute. Source code in tests/__init__.py def delete ( self ) -> bool : \"\"\"Superficial mock that adds a deleted attribute.\"\"\" self . deleted = True return self . deleted","title":"delete()"},{"location":"reference/project/#tests.StripeItem.instance_url","text":"Superficial mock that emulates instance_url. Source code in tests/__init__.py def instance_url ( self ): \"\"\"Superficial mock that emulates instance_url.\"\"\" id = self . get ( \"id\" ) base = self . class_url () return \" %s / %s \" % ( base , id )","title":"instance_url()"},{"location":"reference/project/#tests.StripeItem.request","text":"Superficial mock that emulates request method. Source code in tests/__init__.py def request ( self , method , url , params ) -> dict : \"\"\"Superficial mock that emulates request method.\"\"\" assert method == \"post\" for key , value in params . items (): self . __setattr__ ( key , value ) return self","title":"request()"},{"location":"reference/project/#tests.StripeList","text":"Mock a generic Stripe Iterable. It has the relevant attributes of a stripe iterable (has_more, data). This mock is important so we can use stripe's list method in our testing. StripeList.list() will return the StripeList. Additionally, iterating over instances of MockStripeIterable will iterate over the data attribute, just like Stripe iterables. Attributes: Name Type Description has_more mock has_more flag. Default False. **kwargs all of the fields of the stripe object, generally as a dictionary.","title":"StripeList"},{"location":"reference/project/#tests.StripeList.has_more","text":"","title":"has_more"},{"location":"reference/project/#tests.StripeList.object","text":"","title":"object"},{"location":"reference/project/#tests.StripeList.total_count","text":"","title":"total_count"},{"location":"reference/project/#tests.StripeList.url","text":"","title":"url"},{"location":"reference/project/#tests.StripeList-methods","text":"","title":"Methods"},{"location":"reference/project/#tests.StripeList.__delattr__","text":"Source code in tests/__init__.py def __delattr__ ( self , name ): if name in self : del self [ name ] else : raise AttributeError ( \"No such attribute: \" + name )","title":"__delattr__()"},{"location":"reference/project/#tests.StripeList.__getattr__","text":"Give StripeItem normal object access to match Stripe behavior. Source code in tests/__init__.py def __getattr__ ( self , name ): \"\"\"Give StripeItem normal object access to match Stripe behavior.\"\"\" if name in self : return self [ name ] else : raise AttributeError ( \"No such attribute: \" + name )","title":"__getattr__()"},{"location":"reference/project/#tests.StripeList.__iter__","text":"Make StripeList an iterable, to match the Stripe iterable behavior. Source code in tests/__init__.py def __iter__ ( self ) -> Any : \"\"\"Make StripeList an iterable, to match the Stripe iterable behavior.\"\"\" self . iter_copy = self . data . copy () return self","title":"__iter__()"},{"location":"reference/project/#tests.StripeList.__next__","text":"Define iteration for StripeList. Source code in tests/__init__.py def __next__ ( self ) -> StripeItem : \"\"\"Define iteration for StripeList.\"\"\" if len ( self . iter_copy ) > 0 : return self . iter_copy . pop ( 0 ) else : raise StopIteration ()","title":"__next__()"},{"location":"reference/project/#tests.StripeList.__setattr__","text":"Source code in tests/__init__.py def __setattr__ ( self , name , value ): self [ name ] = value","title":"__setattr__()"},{"location":"reference/project/#tests.StripeList.auto_paging_iter","text":"Add an auto_paging_iter method to the StripeList which returns itself. The StripeList is an iterable, so this mimics the real behavior. Source code in tests/__init__.py def auto_paging_iter ( self ) -> \"StripeList\" : \"\"\"Add an auto_paging_iter method to the StripeList which returns itself. The StripeList is an iterable, so this mimics the real behavior. \"\"\" return self","title":"auto_paging_iter()"},{"location":"reference/project/#tests.StripeList.list","text":"Add a list method to the StripeList which returns itself. list() accepts arbitrary kwargs, be careful is you expect the argument-accepting functionality of Stripe's list() method. Source code in tests/__init__.py def list ( self , ** kwargs : Any ) -> \"StripeList\" : \"\"\"Add a list method to the StripeList which returns itself. list() accepts arbitrary kwargs, be careful is you expect the argument-accepting functionality of Stripe's list() method. \"\"\" return self","title":"list()"},{"location":"reference/project/#tests.SubscriptionDict","text":"","title":"SubscriptionDict"},{"location":"reference/project/#tests.SubscriptionDict-methods","text":"","title":"Methods"},{"location":"reference/project/#tests.SubscriptionDict.__init__","text":"Match Stripe's behavior: return a stripe iterable on subscription.items . Source code in tests/__init__.py def __init__ ( self , * args , ** kwargs ): \"\"\"Match Stripe's behavior: return a stripe iterable on `subscription.items`.\"\"\" super () . __init__ ( * args , ** kwargs ) self [ \"items\" ] = StripeList ( self [ \"items\" ])","title":"__init__()"},{"location":"reference/project/#tests.SubscriptionDict.__setattr__","text":"Source code in tests/__init__.py def __setattr__ ( self , name , value ): if type ( value ) == datetime : value = datetime_to_unix ( value ) # Special case for price and plan if name == \"price\" : for price in [ FAKE_PRICE , FAKE_PRICE_II , FAKE_PRICE_TIER , FAKE_PRICE_METERED , ]: if value == price [ \"id\" ]: value = price elif name == \"plan\" : for plan in [ FAKE_PLAN , FAKE_PLAN_II , FAKE_TIER_PLAN , FAKE_PLAN_METERED ]: if value == plan [ \"id\" ]: value = plan self [ name ] = value","title":"__setattr__()"},{"location":"reference/project/#tests.SubscriptionDict.delete","text":"Superficial mock that adds a deleted attribute. Source code in tests/__init__.py def delete ( self , ** kwargs ): if \"at_period_end\" in kwargs : self [ \"cancel_at_period_end\" ] = kwargs [ \"at_period_end\" ] return self","title":"delete()"},{"location":"reference/project/#tests.SubscriptionDict.save","text":"Source code in tests/__init__.py def save ( self , idempotency_key = None ): return self","title":"save()"},{"location":"reference/project/#tests.convert_source_dict","text":"Source code in tests/__init__.py def convert_source_dict ( data ): if data : source_type = data [ \"object\" ] if source_type == \"card\" : data = CardDict ( data ) elif source_type == \"bank_account\" : data = BankAccountDict ( data ) elif source_type == \"source\" : data = SourceDict ( data ) else : raise ValueError ( \"Unknown source type: {} \" . format ( source_type )) return data","title":"convert_source_dict()"},{"location":"reference/project/#tests.datetime_to_unix","text":"Source code in tests/__init__.py def datetime_to_unix ( datetime_ ): return int ( dateformat . format ( datetime_ , \"U\" ))","title":"datetime_to_unix()"},{"location":"reference/project/#tests.default_account","text":"Source code in tests/__init__.py def default_account (): from djstripe.models import Account return Account . objects . create ( id = \"acct_TESTXXXXX\" , charges_enabled = True , details_submitted = True , payouts_enabled = True , )","title":"default_account()"},{"location":"reference/project/#tests.load_fixture","text":"Source code in tests/__init__.py def load_fixture ( filename ): with FIXTURE_DIR_PATH . joinpath ( filename ) . open ( \"r\" ) as f : return json . load ( f )","title":"load_fixture()"},{"location":"reference/project/#tests-modules","text":"","title":"Modules"},{"location":"reference/project/#tests.apps","text":"","title":"apps"},{"location":"reference/project/#tests.apps-modules","text":"","title":"Modules"},{"location":"reference/project/#tests.apps.example","text":"","title":"example"},{"location":"reference/project/#tests.apps.example-modules","text":"tests.apps.example.forms tests.apps.example.forms.PaymentIntentForm tests . apps . example . forms . PaymentIntentForm . media property readonly tests.apps.example.forms.PurchaseSubscriptionForm tests . apps . example . forms . PurchaseSubscriptionForm . media property readonly tests.apps.example.management special Modules tests.apps.example.management.commands special Modules tests.apps.example.management.commands.regenerate_test_fixtures tests . apps . example . management . commands . regenerate_test_fixtures . FAKE_ID_METADATA_KEY Classes tests.apps.example.management.commands.regenerate_test_fixtures.Command This does the following: 1) Load existing fixtures from JSON files 2) Attempts to read the corresponding objects from Stripe 3) If found, for types Stripe doesn't allow us to choose ids for, we build a map between the fake ids in the fixtures and real Stripe ids 3) If not found, creates objects in Stripe from the fixtures 4) Save objects back as fixtures, using fake ids if available The rationale for this is so that the fixtures can automatically be updated with Stripe schema changes running this command. This should make keeping our tests and model schema compatible with Stripe schema changes less pain-staking and simplify the process of upgrading the targeted Stripe API version. tests . apps . example . management . commands . regenerate_test_fixtures . Command . fake_data_map tests . apps . example . management . commands . regenerate_test_fixtures . Command . fake_id_map tests . apps . example . management . commands . regenerate_test_fixtures . Command . help Methods tests . apps . example . management . commands . regenerate_test_fixtures . Command . add_arguments ( self , parser ) Entry point for subclassed commands to add custom arguments. Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def add_arguments ( self , parser ): parser . add_argument ( \"--delete-stale\" , action = \"store_true\" , help = \"Delete any untouched fixtures in the directory\" , ) parser . add_argument ( \"--update-sideeffect-fields\" , action = \"store_true\" , help = \"Don't preserve sideeffect fields such as 'created'\" , ) tests . apps . example . management . commands . regenerate_test_fixtures . Command . fake_json_ids ( self , json_str ) Replace real ids with fakes ones in the JSON fixture Do this on the serialized JSON string since it's a simple string replace :param json_str: :return: Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def fake_json_ids ( self , json_str ): \"\"\" Replace real ids with fakes ones in the JSON fixture Do this on the serialized JSON string since it's a simple string replace :param json_str: :return: \"\"\" for fake_id , actual_id in self . fake_id_map . items (): json_str = json_str . replace ( actual_id , fake_id ) return json_str tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_fake_id ( self , obj ) Get a stable fake id from a real Stripe object, we use this so that fixtures are stable :param obj: :return: Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_fake_id ( self , obj ): \"\"\" Get a stable fake id from a real Stripe object, we use this so that fixtures are stable :param obj: :return: \"\"\" fake_id = None if isinstance ( obj , str ): real_id = obj real_id_map = { v : k for k , v in self . fake_id_map . items ()} fake_id = real_id_map . get ( real_id ) elif \"metadata\" in obj : # Note: not all objects have a metadata dict # (eg Account, BalanceTransaction don't) fake_id = obj . get ( \"metadata\" , {}) . get ( FAKE_ID_METADATA_KEY ) elif obj . get ( \"object\" ) == \"balance_transaction\" : # assume for purposes of fixture generation that 1 balance_transaction per # source charge (etc) fake_source_id = self . get_fake_id ( obj [ \"source\" ]) fake_id = \"txn_fake_ {} \" . format ( fake_source_id ) return fake_id tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_account ( self , old_obj , readonly_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_account ( self , old_obj , readonly_fields ): obj = djstripe . models . Account () . api_retrieve () return True , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_balance_transaction ( self , old_obj ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_balance_transaction ( self , old_obj ): source = old_obj [ \"source\" ] if source . startswith ( \"ch_\" ): charge = djstripe . models . Charge ( id = source ) . api_retrieve () id_ = djstripe . models . StripeModel . _id_from_data ( charge [ \"balance_transaction\" ] ) try : obj = djstripe . models . BalanceTransaction ( id = id_ ) . api_retrieve () created = False self . stdout . write ( f \" found { id_ } \" ) except InvalidRequestError : assert False , \"Expected to find balance transaction via source\" return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_bank_account ( self , old_obj , readonly_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_bank_account ( self , old_obj , readonly_fields ): customer = djstripe . models . Customer ( id = old_obj [ \"customer\" ]) . api_retrieve () id_ = old_obj [ \"id\" ] try : obj = customer . sources . retrieve ( id_ ) created = False self . stdout . write ( \" found\" ) except InvalidRequestError : self . stdout . write ( \" creating\" ) create_obj = deepcopy ( old_obj ) # create in Stripe for k in readonly_fields : create_obj . pop ( k , None ) # see https://stripe.com/docs/connect/testing#account-numbers # we've stash the account number in the metadata # so we can regenerate the fixture create_obj [ \"account_number\" ] = old_obj [ \"metadata\" ][ \"djstripe_test_fixture_account_number\" ] create_obj [ \"object\" ] = \"bank_account\" obj = customer . sources . create ( source = create_obj ) created = True return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_card ( self , old_obj , readonly_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_card ( self , old_obj , readonly_fields ): customer = djstripe . models . Customer ( id = old_obj [ \"customer\" ]) . api_retrieve () id_ = old_obj [ \"id\" ] try : obj = customer . sources . retrieve ( id_ ) created = False self . stdout . write ( \" found\" ) except InvalidRequestError : self . stdout . write ( \" creating\" ) create_obj = deepcopy ( old_obj ) # create in Stripe for k in readonly_fields : create_obj . pop ( k , None ) obj = customer . sources . create ( ** { \"source\" : \"tok_visa\" }) for k , v in create_obj . items (): setattr ( obj , k , v ) obj . save () created = True return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_charge ( self , old_obj , writable_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_charge ( self , old_obj , writable_fields ): invoice = djstripe . models . Invoice ( id = old_obj [ \"invoice\" ]) . api_retrieve () id_ = invoice [ \"charge\" ] try : obj = djstripe . models . Charge ( id = id_ ) . api_retrieve () created = False self . stdout . write ( f \" found { id_ } \" ) except InvalidRequestError : assert False , \"Expected to find charge via invoice\" for k in writable_fields : if isinstance ( obj . get ( k ), dict ): # merge dicts (eg metadata) obj [ k ] . update ( old_obj . get ( k , {})) else : obj [ k ] = old_obj [ k ] obj . save () return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_invoice ( self , old_obj , writable_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_invoice ( self , old_obj , writable_fields ): subscription = djstripe . models . Subscription ( id = old_obj [ \"subscription\" ] ) . api_retrieve () id_ = subscription [ \"latest_invoice\" ] try : obj = djstripe . models . Invoice ( id = id_ ) . api_retrieve () created = False self . stdout . write ( f \" found { id_ } \" ) except InvalidRequestError : assert False , \"Expected to find invoice via subscription\" for k in writable_fields : if isinstance ( obj . get ( k ), dict ): # merge dicts (eg metadata) obj [ k ] . update ( old_obj . get ( k , {})) else : obj [ k ] = old_obj [ k ] obj . save () return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_payment_intent ( self , old_obj , writable_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_payment_intent ( self , old_obj , writable_fields ): invoice = djstripe . models . Invoice ( id = old_obj [ \"invoice\" ]) . api_retrieve () id_ = invoice [ \"payment_intent\" ] try : obj = djstripe . models . PaymentIntent ( id = id_ ) . api_retrieve () created = False self . stdout . write ( f \" found { id_ } \" ) except InvalidRequestError : assert False , \"Expected to find payment_intent via invoice\" for k in writable_fields : if isinstance ( obj . get ( k ), dict ): # merge dicts (eg metadata) obj [ k ] . update ( old_obj . get ( k , {})) else : obj [ k ] = old_obj [ k ] obj . save () return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_payment_method ( self , old_obj , writable_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_payment_method ( self , old_obj , writable_fields ): id_ = old_obj [ \"id\" ] customer_id = old_obj [ \"customer\" ] type_ = old_obj [ \"type\" ] try : obj = djstripe . models . PaymentMethod ( id = id_ ) . api_retrieve () created = False self . stdout . write ( \" found\" ) except InvalidRequestError : self . stdout . write ( \" creating\" ) obj = djstripe . models . PaymentMethod () . _api_create ( type = type_ , card = { \"token\" : \"tok_visa\" } ) stripe . PaymentMethod . attach ( obj [ \"id\" ], customer = customer_id , api_key = djstripe . settings . STRIPE_SECRET_KEY , ) for k in writable_fields : if isinstance ( obj . get ( k ), dict ): # merge dicts (eg metadata) obj [ k ] . update ( old_obj . get ( k , {})) else : obj [ k ] = old_obj [ k ] obj . save () created = True return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . get_or_create_stripe_source ( self , old_obj , readonly_fields ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def get_or_create_stripe_source ( self , old_obj , readonly_fields ): customer = djstripe . models . Customer ( id = old_obj [ \"customer\" ]) . api_retrieve () id_ = old_obj [ \"id\" ] try : obj = customer . sources . retrieve ( id_ ) created = False self . stdout . write ( \" found\" ) except InvalidRequestError : self . stdout . write ( \" creating\" ) create_obj = deepcopy ( old_obj ) # create in Stripe for k in readonly_fields : create_obj . pop ( k , None ) source_obj = djstripe . models . Source . _api_create ( ** { \"token\" : \"tok_visa\" , \"type\" : \"card\" } ) obj = customer . sources . create ( ** { \"source\" : source_obj . id }) for k , v in create_obj . items (): setattr ( obj , k , v ) obj . save () created = True return created , obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . handle ( self , * args , ** options ) The actual logic of the command. Subclasses must implement this method. Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def handle ( self , * args , ** options ): do_delete_stale_fixtures = options [ \"delete_stale\" ] do_preserve_sideeffect_fields = not options [ \"update_sideeffect_fields\" ] common_readonly_fields = [ \"object\" , \"created\" , \"updated\" , \"livemode\" ] common_sideeffect_fields = [ \"created\" ] # TODO - is it be possible to get a list of which fields are writable from # the API? maybe using https://github.com/stripe/openapi ? # (though that's only for current version) \"\"\" Fields that we treat as read-only. Most of these will cause an error if sent to the Stripe API. \"\"\" model_extra_readonly_fields = { djstripe . models . Account : [ \"id\" ], djstripe . models . Customer : [ \"account_balance\" , \"currency\" , \"default_source\" , \"delinquent\" , \"invoice_prefix\" , \"subscriptions\" , \"sources\" , ], djstripe . models . BankAccount : [ \"id\" , \"bank_name\" , \"customer\" , \"last4\" , \"fingerprint\" , \"status\" , ], djstripe . models . Card : [ \"id\" , \"address_line1_check\" , \"address_zip_check\" , \"brand\" , \"country\" , \"customer\" , \"cvc_check\" , \"dynamic_last4\" , \"exp_month\" , \"exp_year\" , \"fingerprint\" , \"funding\" , \"last4\" , \"tokenization_method\" , ], djstripe . models . PaymentIntent : [ \"id\" ], djstripe . models . PaymentMethod : [ \"id\" ], djstripe . models . Plan : [ # Can only specify one of amount and amount_decimal \"amount_decimal\" ], djstripe . models . Source : [ \"id\" , \"amount\" , \"card\" , \"client_secret\" , \"currency\" , \"customer\" , \"flow\" , \"owner\" , \"statement_descriptor\" , \"status\" , \"type\" , \"usage\" , ], djstripe . models . Subscription : [ \"id\" , # not actually read-only \"billing_cycle_anchor\" , \"billing\" , \"current_period_end\" , \"current_period_start\" , # workaround for \"the # `invoice_customer_balance_settings[consume_applied_balance_on_void]` # parameter is only supported in API version 2019-11-05 and below. # See # https://stripe.com/docs/api#versioning and # https://stripe.com/docs/upgrades#2019-12-03 for more detail. \"invoice_customer_balance_settings\" , \"latest_invoice\" , \"start\" , \"start_date\" , \"status\" , ], djstripe . models . TaxRate : [ \"id\" ], } # type: Dict[Type[djstripe.models.StripeModel], List[str]] \"\"\" Fields that we don't care about the value of, and that preserving allows us to avoid churn in the fixtures \"\"\" model_sideeffect_fields = { djstripe . models . BalanceTransaction : [ \"available_on\" ], djstripe . models . Source : [ \"client_secret\" ], djstripe . models . Charge : [ \"receipt_url\" ], djstripe . models . Subscription : [ \"billing_cycle_anchor\" , \"current_period_start\" , \"current_period_end\" , \"start\" , \"start_date\" , ], djstripe . models . SubscriptionItem : [ # we don't currently track separate fixtures for SubscriptionItems \"id\" ], djstripe . models . Product : [ \"updated\" ], djstripe . models . Invoice : [ \"date\" , \"finalized_at\" , \"hosted_invoice_url\" , \"invoice_pdf\" , \"webhooks_delivered_at\" , \"period_start\" , \"period_end\" , # we don't currently track separate fixtures for SubscriptionItems \"subscription_item\" , ], } # type: Dict[Type[djstripe.models.StripeModel], List[str]] object_sideeffect_fields = { model . stripe_class . OBJECT_NAME : set ( v ) for model , v in model_sideeffect_fields . items () } # type: Dict[str, Set[str]] self . fake_data_map = { # djstripe.models.Account: [tests.FAKE_ACCOUNT], djstripe . models . Customer : [ tests . FAKE_CUSTOMER , tests . FAKE_CUSTOMER_II , tests . FAKE_CUSTOMER_III , tests . FAKE_CUSTOMER_IV , ], djstripe . models . BankAccount : [ tests . FAKE_BANK_ACCOUNT_SOURCE ], djstripe . models . Card : [ tests . FAKE_CARD , tests . FAKE_CARD_II , tests . FAKE_CARD_V , ], djstripe . models . Source : [ tests . FAKE_SOURCE ], djstripe . models . Plan : [ tests . FAKE_PLAN , tests . FAKE_PLAN_II ], djstripe . models . Price : [ tests . FAKE_PRICE , tests . FAKE_PRICE_II ], djstripe . models . Product : [ tests . FAKE_PRODUCT ], djstripe . models . TaxRate : [ tests . FAKE_TAX_RATE_EXAMPLE_1_VAT , tests . FAKE_TAX_RATE_EXAMPLE_2_SALES , ], djstripe . models . Subscription : [ tests . FAKE_SUBSCRIPTION , tests . FAKE_SUBSCRIPTION_II , tests . FAKE_SUBSCRIPTION_III , tests . FAKE_SUBSCRIPTION_MULTI_PLAN , ], djstripe . models . SubscriptionSchedule : [ tests . FAKE_SUBSCRIPTION_SCHEDULE , ], djstripe . models . Invoice : [ tests . FAKE_INVOICE , tests . FAKE_INVOICE_IV ], djstripe . models . Charge : [ tests . FAKE_CHARGE ], djstripe . models . PaymentIntent : [ tests . FAKE_PAYMENT_INTENT_I ], djstripe . models . PaymentMethod : [ tests . FAKE_PAYMENT_METHOD_I , tests . FAKE_CARD_AS_PAYMENT_METHOD , ], djstripe . models . BalanceTransaction : [ tests . FAKE_BALANCE_TRANSACTION ], } self . init_fake_id_map () objs = [] # Regenerate each of the fixture objects via Stripe # We re-fetch objects in a second pass if they were created during # the first pass, to ensure nested objects are up to date # (eg Customer.subscriptions), for n in range ( 2 ): any_created = False self . stdout . write ( f \"Updating fixture objects, pass { n } \" ) # reset the objects list since we don't want to keep those from # the first pass objs . clear () for model_class , old_objs in self . fake_data_map . items (): readonly_fields = ( common_readonly_fields + model_extra_readonly_fields . get ( model_class , []) ) for old_obj in old_objs : created , obj = self . update_fixture_obj ( old_obj = deepcopy ( old_obj ), model_class = model_class , readonly_fields = readonly_fields , do_preserve_sideeffect_fields = do_preserve_sideeffect_fields , object_sideeffect_fields = object_sideeffect_fields , common_sideeffect_fields = common_sideeffect_fields , ) objs . append ( obj ) any_created = created or any_created if not any_created : # nothing created on this pass, no need to continue break else : self . stderr . write ( \"Warning, unexpected behaviour - some fixtures still being created \" \"in second pass?\" ) # Now the fake_id_map should be complete and the objs should be up to date, # save all the fixtures paths = set () for obj in objs : path = self . save_fixture ( obj ) paths . add ( path ) if do_delete_stale_fixtures : for path in tests . FIXTURE_DIR_PATH . glob ( \"*.json\" ): if path in paths : continue else : self . stdout . write ( \"deleting {} \" . format ( path )) path . unlink () tests . apps . example . management . commands . regenerate_test_fixtures . Command . init_fake_id_map ( self ) Build a mapping between fake ids stored in Stripe metadata and those obj's actual ids We do this so we can have fixtures with stable ids for objects Stripe doesn't allow us to specify an id for (eg Card). Fixtures and tests will use the fake ids, when we talk to stripe we use the real ids :return: Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def init_fake_id_map ( self ): \"\"\" Build a mapping between fake ids stored in Stripe metadata and those obj's actual ids We do this so we can have fixtures with stable ids for objects Stripe doesn't allow us to specify an id for (eg Card). Fixtures and tests will use the fake ids, when we talk to stripe we use the real ids :return: \"\"\" for fake_customer in self . fake_data_map [ djstripe . models . Customer ]: try : # can only access Cards via the customer customer = djstripe . models . Customer ( id = fake_customer [ \"id\" ] ) . api_retrieve () except InvalidRequestError : self . stdout . write ( f \"Fake customer { fake_customer [ 'id' ] } doesn't exist in Stripe yet\" ) return # assume that test customers don't have more than 100 cards... for card in customer . sources . list ( limit = 100 ): self . update_fake_id_map ( card ) for payment_method in djstripe . models . PaymentMethod . api_list ( customer = customer . id , type = \"card\" ): self . update_fake_id_map ( payment_method ) for subscription in customer [ \"subscriptions\" ][ \"data\" ]: self . update_fake_id_map ( subscription ) for tax_rate in djstripe . models . TaxRate . api_list (): self . update_fake_id_map ( tax_rate ) tests . apps . example . management . commands . regenerate_test_fixtures . Command . pre_process_subscription ( self , create_obj ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def pre_process_subscription ( self , create_obj ): # flatten plan/items/tax rates on create items = create_obj . get ( \"items\" , {}) . get ( \"data\" , []) if len ( items ): # don't try and create with both plan and item (list of plans) create_obj . pop ( \"plan\" , None ) create_obj . pop ( \"quantity\" , None ) # TODO - move this to SubscriptionItem handling? subscription_item_create_fields = { \"plan\" , \"billing_thresholds\" , \"metadata\" , \"quantity\" , \"tax_rates\" , } create_items = [] for item in items : create_item = { k : v for k , v in item . items () if k in subscription_item_create_fields } create_item [ \"plan\" ] = djstripe . models . StripeModel . _id_from_data ( create_item [ \"plan\" ] ) if create_item . get ( \"tax_rates\" , []): create_item [ \"tax_rates\" ] = [ djstripe . models . StripeModel . _id_from_data ( t ) for t in create_item [ \"tax_rates\" ] ] create_items . append ( create_item ) create_obj [ \"items\" ] = create_items else : # don't try and send empty items list create_obj . pop ( \"items\" , None ) create_obj [ \"plan\" ] = djstripe . models . StripeModel . _id_from_data ( create_obj [ \"plan\" ] ) if create_obj . get ( \"default_tax_rates\" , []): create_obj [ \"default_tax_rates\" ] = [ djstripe . models . StripeModel . _id_from_data ( t ) for t in create_obj [ \"default_tax_rates\" ] ] # don't send both default_tax_rates and tax_percent create_obj . pop ( \"tax_percent\" , None ) return create_obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . preserve_old_sideeffect_values ( self , old_obj , new_obj , object_sideeffect_fields , common_sideeffect_fields ) Try to preserve values of side-effect fields from old_obj, to reduce churn in fixtures Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def preserve_old_sideeffect_values ( self , old_obj , new_obj , object_sideeffect_fields , common_sideeffect_fields ): \"\"\" Try to preserve values of side-effect fields from old_obj, to reduce churn in fixtures \"\"\" object_name = new_obj . get ( \"object\" ) sideeffect_fields = object_sideeffect_fields . get ( object_name , set ()) . union ( set ( common_sideeffect_fields ) ) old_obj = old_obj or {} for f , old_val in old_obj . items (): try : new_val = new_obj [ f ] except KeyError : continue if isinstance ( new_val , stripe . api_resources . ListObject ): # recursively process nested lists for n , ( old_val_item , new_val_item ) in enumerate ( zip ( old_val . get ( \"data\" , []), new_val . data ) ): new_val . data [ n ] = self . preserve_old_sideeffect_values ( old_obj = old_val_item , new_obj = new_val_item , object_sideeffect_fields = object_sideeffect_fields , common_sideeffect_fields = common_sideeffect_fields , ) elif isinstance ( new_val , stripe . stripe_object . StripeObject ): # recursively process nested objects new_obj [ f ] = self . preserve_old_sideeffect_values ( old_obj = old_val , new_obj = new_val , object_sideeffect_fields = object_sideeffect_fields , common_sideeffect_fields = common_sideeffect_fields , ) elif ( f in sideeffect_fields and type ( old_val ) == type ( new_val ) and old_val != new_val ): # only preserve old values if the type is the same new_obj [ f ] = old_val return new_obj tests . apps . example . management . commands . regenerate_test_fixtures . Command . save_fixture ( self , obj ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def save_fixture ( self , obj ): type_name = obj [ \"object\" ] id_ = self . update_fake_id_map ( obj ) fixture_path = tests . FIXTURE_DIR_PATH . joinpath ( f \" { type_name } _ { id_ } .json\" ) with fixture_path . open ( \"w\" ) as f : json_str = self . fake_json_ids ( json . dumps ( obj , indent = 4 )) f . write ( json_str ) return fixture_path tests . apps . example . management . commands . regenerate_test_fixtures . Command . unfake_json_ids ( self , json_str ) Replace fake ids with actual ones in the JSON fixture Do this on the serialized JSON string since it's a simple string replace :param json_str: :return: Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def unfake_json_ids ( self , json_str ): \"\"\" Replace fake ids with actual ones in the JSON fixture Do this on the serialized JSON string since it's a simple string replace :param json_str: :return: \"\"\" for fake_id , actual_id in self . fake_id_map . items (): json_str = json_str . replace ( fake_id , actual_id ) # special-case: undo the replace for the djstripe_test_fake_id in metadata json_str = json_str . replace ( f '\" { FAKE_ID_METADATA_KEY } \": \" { actual_id } \"' , f '\" { FAKE_ID_METADATA_KEY } \": \" { fake_id } \"' , ) return json_str tests . apps . example . management . commands . regenerate_test_fixtures . Command . update_fake_id_map ( self , obj ) Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def update_fake_id_map ( self , obj ): fake_id = self . get_fake_id ( obj ) actual_id = obj [ \"id\" ] if fake_id : if fake_id in self . fake_id_map : assert self . fake_id_map [ fake_id ] == actual_id , ( f \"Duplicate fake_id { fake_id } - reset your test Stripe data at \" f \"https://dashboard.stripe.com/account/data\" ) self . fake_id_map [ fake_id ] = actual_id return fake_id else : return actual_id tests . apps . example . management . commands . regenerate_test_fixtures . Command . update_fixture_obj ( self , old_obj , model_class , readonly_fields , do_preserve_sideeffect_fields , object_sideeffect_fields , common_sideeffect_fields ) Given a fixture object, update it via stripe :param model_class: :param old_obj: :param readonly_fields: :return: Source code in tests/apps/example/management/commands/regenerate_test_fixtures.py def update_fixture_obj ( # noqa: C901 self , old_obj , model_class , readonly_fields , do_preserve_sideeffect_fields , object_sideeffect_fields , common_sideeffect_fields , ): \"\"\" Given a fixture object, update it via stripe :param model_class: :param old_obj: :param readonly_fields: :return: \"\"\" # restore real ids from Stripe old_obj = json . loads ( self . unfake_json_ids ( json . dumps ( old_obj ))) id_ = old_obj [ \"id\" ] self . stdout . write ( f \" { model_class . __name__ } { id_ } \" , ending = \"\" ) # For objects that we can't directly choose the ids of # (and that will thus vary between stripe accounts) # we fetch the id from a related object if issubclass ( model_class , djstripe . models . Account ): created , obj = self . get_or_create_stripe_account ( old_obj = old_obj , readonly_fields = readonly_fields ) elif issubclass ( model_class , djstripe . models . BankAccount ): created , obj = self . get_or_create_stripe_bank_account ( old_obj = old_obj , readonly_fields = readonly_fields ) elif issubclass ( model_class , djstripe . models . Card ): created , obj = self . get_or_create_stripe_card ( old_obj = old_obj , readonly_fields = readonly_fields ) elif issubclass ( model_class , djstripe . models . Source ): created , obj = self . get_or_create_stripe_source ( old_obj = old_obj , readonly_fields = readonly_fields ) elif issubclass ( model_class , djstripe . models . Invoice ): created , obj = self . get_or_create_stripe_invoice ( old_obj = old_obj , writable_fields = [ \"metadata\" ] ) elif issubclass ( model_class , djstripe . models . Charge ): created , obj = self . get_or_create_stripe_charge ( old_obj = old_obj , writable_fields = [ \"metadata\" ] ) elif issubclass ( model_class , djstripe . models . PaymentIntent ): created , obj = self . get_or_create_stripe_payment_intent ( old_obj = old_obj , writable_fields = [ \"metadata\" ] ) elif issubclass ( model_class , djstripe . models . PaymentMethod ): created , obj = self . get_or_create_stripe_payment_method ( old_obj = old_obj , writable_fields = [ \"metadata\" ] ) elif issubclass ( model_class , djstripe . models . BalanceTransaction ): created , obj = self . get_or_create_stripe_balance_transaction ( old_obj = old_obj ) else : try : # fetch from Stripe, using the active API version # this allows us regenerate the fixtures from Stripe # and hopefully, automatically get schema changes obj = model_class ( id = id_ ) . api_retrieve () created = False self . stdout . write ( \" found\" ) except InvalidRequestError : self . stdout . write ( \" creating\" ) create_obj = deepcopy ( old_obj ) # create in Stripe for k in readonly_fields : create_obj . pop ( k , None ) if issubclass ( model_class , djstripe . models . Subscription ): create_obj = self . pre_process_subscription ( create_obj = create_obj ) obj = model_class . _api_create ( ** create_obj ) created = True self . update_fake_id_map ( obj ) if do_preserve_sideeffect_fields : obj = self . preserve_old_sideeffect_values ( old_obj = old_obj , new_obj = obj , object_sideeffect_fields = object_sideeffect_fields , common_sideeffect_fields = common_sideeffect_fields , ) return created , obj tests.apps.example.urls tests . apps . example . urls . app_name tests . apps . example . urls . urlpatterns tests.apps.example.views tests . apps . example . views . User tests . apps . example . views . logger Classes tests.apps.example.views.PurchaseSubscriptionSuccessView tests . apps . example . views . PurchaseSubscriptionSuccessView . context_object_name tests . apps . example . views . PurchaseSubscriptionSuccessView . queryset tests . apps . example . views . PurchaseSubscriptionSuccessView . slug_field tests . apps . example . views . PurchaseSubscriptionSuccessView . slug_url_kwarg tests . apps . example . views . PurchaseSubscriptionSuccessView . template_name tests.apps.example.views.PurchaseSubscriptionView Example view to demonstrate how to use dj-stripe to: create a Customer add a card to the Customer create a Subscription using that card This does a non-logged in purchase for the user of the provided email tests . apps . example . views . PurchaseSubscriptionView . template_name tests.apps.example.views.PurchaseSubscriptionView.form_class tests . apps . example . views . PurchaseSubscriptionView . form_class . media property readonly Methods tests . apps . example . views . PurchaseSubscriptionView . form_valid ( self , form ) If the form is valid, redirect to the supplied URL. Source code in tests/apps/example/views.py def form_valid ( self , form ): stripe_source = form . cleaned_data [ \"stripe_source\" ] email = form . cleaned_data [ \"email\" ] plan = form . cleaned_data [ \"plan\" ] # Guest checkout with the provided email try : user = User . objects . get ( email = email ) except User . DoesNotExist : user = User . objects . create ( username = email , email = email ) # Create the stripe Customer, by default subscriber Model is User, # this can be overridden with settings.DJSTRIPE_SUBSCRIBER_MODEL customer , created = djstripe . models . Customer . get_or_create ( subscriber = user ) # Add the source as the customer's default card customer . add_card ( stripe_source ) # Using the Stripe API, create a subscription for this customer, # using the customer's default payment source stripe_subscription = stripe . Subscription . create ( customer = customer . id , items = [{ \"plan\" : plan . id }], collection_method = \"charge_automatically\" , # tax_percent=15, api_key = djstripe . settings . STRIPE_SECRET_KEY , ) # Sync the Stripe API return data to the database, # this way we don't need to wait for a webhook-triggered sync subscription = djstripe . models . Subscription . sync_from_stripe_data ( stripe_subscription ) self . request . subscription = subscription return super () . form_valid ( form ) tests . apps . example . views . PurchaseSubscriptionView . get_context_data ( self , ** kwargs ) Insert the form into the context dict. Source code in tests/apps/example/views.py def get_context_data ( self , ** kwargs ): ctx = super () . get_context_data ( ** kwargs ) if djstripe . models . Plan . objects . count () == 0 : raise Exception ( \"No Product Plans in the dj-stripe database - create some in your \" \"stripe account and then \" \"run `./manage.py djstripe_sync_plans_from_stripe` \" \"(or use the dj-stripe webhooks)\" ) ctx [ \"STRIPE_PUBLIC_KEY\" ] = djstripe . settings . STRIPE_PUBLIC_KEY return ctx tests . apps . example . views . PurchaseSubscriptionView . get_success_url ( self ) Return the URL to redirect to after processing a valid form. Source code in tests/apps/example/views.py def get_success_url ( self ): return reverse ( \"djstripe_example:purchase_subscription_success\" , kwargs = { \"id\" : self . request . subscription . id }, ) tests . apps . example . views . create_payment_intent ( request ) Source code in tests/apps/example/views.py def create_payment_intent ( request ): if request . method == \"POST\" : intent = None data = json . loads ( request . body ) try : if \"payment_method_id\" in data : # Create the PaymentIntent intent = stripe . PaymentIntent . create ( payment_method = data [ \"payment_method_id\" ], amount = 1099 , currency = \"usd\" , confirmation_method = \"manual\" , confirm = True , api_key = djstripe . settings . STRIPE_SECRET_KEY , ) elif \"payment_intent_id\" in data : intent = stripe . PaymentIntent . confirm ( data [ \"payment_intent_id\" ], api_key = djstripe . settings . STRIPE_SECRET_KEY , ) except stripe . error . CardError as e : # Display error on client return_data = json . dumps ({ \"error\" : e . user_message }), 200 return HttpResponse ( return_data [ 0 ], content_type = \"application/json\" , status = return_data [ 1 ] ) if ( intent . status == \"requires_action\" and intent . next_action . type == \"use_stripe_sdk\" ): # Tell the client to handle the action return_data = ( json . dumps ( { \"requires_action\" : True , \"payment_intent_client_secret\" : intent . client_secret , } ), 200 , ) elif intent . status == \"succeeded\" : # The payment did not need any additional actions and completed! # Handle post-payment fulfillment return_data = json . dumps ({ \"success\" : True }), 200 else : # Invalid status return_data = json . dumps ({ \"error\" : \"Invalid PaymentIntent status\" }), 500 return HttpResponse ( return_data [ 0 ], content_type = \"application/json\" , status = return_data [ 1 ] ) else : ctx = { \"STRIPE_PUBLIC_KEY\" : djstripe . settings . STRIPE_PUBLIC_KEY } return TemplateResponse ( request , \"payment_intent.html\" , ctx )","title":"Modules"},{"location":"reference/project/#tests.apps.testapp","text":"","title":"testapp"},{"location":"reference/project/#tests.apps.testapp-modules","text":"tests.apps.testapp.models Classes tests.apps.testapp.models.NoEmailOrganization Model used to test the new custom model setting. tests . apps . testapp . models . NoEmailOrganization . name tests.apps.testapp.models.NoEmailOrganization.DoesNotExist tests.apps.testapp.models.NoEmailOrganization.MultipleObjectsReturned tests.apps.testapp.models.Organization Model used to test the new custom model setting. tests . apps . testapp . models . Organization . email tests.apps.testapp.models.Organization.DoesNotExist tests.apps.testapp.models.Organization.MultipleObjectsReturned tests.apps.testapp.models.StaticEmailOrganization Model used to test the new custom model setting. tests . apps . testapp . models . StaticEmailOrganization . email property readonly tests . apps . testapp . models . StaticEmailOrganization . name tests.apps.testapp.models.StaticEmailOrganization.DoesNotExist tests.apps.testapp.models.StaticEmailOrganization.MultipleObjectsReturned tests.apps.testapp.urls tests . apps . testapp . urls . urlpatterns tests . apps . testapp . urls . empty_view ( request ) Source code in tests/apps/testapp/urls.py def empty_view ( request ): return HttpResponse ()","title":"Modules"},{"location":"reference/project/#tests.apps.testapp_content","text":"","title":"testapp_content"},{"location":"reference/project/#tests.apps.testapp_content-modules","text":"tests.apps.testapp_content.models tests.apps.testapp_content.urls Represents protected content tests . apps . testapp_content . urls . urlpatterns tests . apps . testapp_content . urls . testview ( request ) Source code in tests/apps/testapp_content/urls.py def testview ( request ): return HttpResponse ()","title":"Modules"},{"location":"reference/project/#tests.apps.testapp_namespaced","text":"tests.apps.testapp_namespaced.models tests.apps.testapp_namespaced.urls tests . apps . testapp_namespaced . urls . app_name tests . apps . testapp_namespaced . urls . urlpatterns tests . apps . testapp_namespaced . urls . testview ( request ) Source code in tests/apps/testapp_namespaced/urls.py def testview ( request ): return HttpResponse ()","title":"testapp_namespaced"},{"location":"reference/project/#tests.settings","text":"","title":"settings"},{"location":"reference/project/#tests.settings.ALLOWED_HOSTS","text":"","title":"ALLOWED_HOSTS"},{"location":"reference/project/#tests.settings.BASE_DIR","text":"","title":"BASE_DIR"},{"location":"reference/project/#tests.settings.DEBUG","text":"","title":"DEBUG"},{"location":"reference/project/#tests.settings.DEFAULT_AUTO_FIELD","text":"","title":"DEFAULT_AUTO_FIELD"},{"location":"reference/project/#tests.settings.DJSTRIPE_FOREIGN_KEY_TO_FIELD","text":"","title":"DJSTRIPE_FOREIGN_KEY_TO_FIELD"},{"location":"reference/project/#tests.settings.DJSTRIPE_SUBSCRIPTION_REDIRECT","text":"","title":"DJSTRIPE_SUBSCRIPTION_REDIRECT"},{"location":"reference/project/#tests.settings.DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS","text":"","title":"DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS"},{"location":"reference/project/#tests.settings.DJSTRIPE_USE_NATIVE_JSONFIELD","text":"","title":"DJSTRIPE_USE_NATIVE_JSONFIELD"},{"location":"reference/project/#tests.settings.DJSTRIPE_WEBHOOK_SECRET","text":"","title":"DJSTRIPE_WEBHOOK_SECRET"},{"location":"reference/project/#tests.settings.DJSTRIPE_WEBHOOK_VALIDATION","text":"","title":"DJSTRIPE_WEBHOOK_VALIDATION"},{"location":"reference/project/#tests.settings.INSTALLED_APPS","text":"","title":"INSTALLED_APPS"},{"location":"reference/project/#tests.settings.MIDDLEWARE","text":"","title":"MIDDLEWARE"},{"location":"reference/project/#tests.settings.PROJECT_DIR","text":"","title":"PROJECT_DIR"},{"location":"reference/project/#tests.settings.ROOT_URLCONF","text":"","title":"ROOT_URLCONF"},{"location":"reference/project/#tests.settings.SECRET_KEY","text":"","title":"SECRET_KEY"},{"location":"reference/project/#tests.settings.SITE_ID","text":"","title":"SITE_ID"},{"location":"reference/project/#tests.settings.STATIC_URL","text":"","title":"STATIC_URL"},{"location":"reference/project/#tests.settings.STRIPE_LIVE_PUBLIC_KEY","text":"","title":"STRIPE_LIVE_PUBLIC_KEY"},{"location":"reference/project/#tests.settings.STRIPE_LIVE_SECRET_KEY","text":"","title":"STRIPE_LIVE_SECRET_KEY"},{"location":"reference/project/#tests.settings.STRIPE_TEST_PUBLIC_KEY","text":"","title":"STRIPE_TEST_PUBLIC_KEY"},{"location":"reference/project/#tests.settings.STRIPE_TEST_SECRET_KEY","text":"","title":"STRIPE_TEST_SECRET_KEY"},{"location":"reference/project/#tests.settings.TEMPLATES","text":"","title":"TEMPLATES"},{"location":"reference/project/#tests.settings.TIME_ZONE","text":"","title":"TIME_ZONE"},{"location":"reference/project/#tests.settings.USE_TZ","text":"","title":"USE_TZ"},{"location":"reference/project/#tests.settings.test_db_name","text":"","title":"test_db_name"},{"location":"reference/project/#tests.settings.test_db_pass","text":"","title":"test_db_pass"},{"location":"reference/project/#tests.settings.test_db_port","text":"","title":"test_db_port"},{"location":"reference/project/#tests.settings.test_db_user","text":"","title":"test_db_user"},{"location":"reference/project/#tests.settings.test_db_vendor","text":"","title":"test_db_vendor"},{"location":"reference/project/#tests.test_account","text":"dj-stripe Account Tests.","title":"test_account"},{"location":"reference/project/#tests.test_account-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_account.TestAccount","text":"tests . test_account . TestAccount . test_get_connected_account_from_token ( self , fileupload_retrieve_mock , account_retrieve_mock ) Source code in tests/test_account.py @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.FileUpload.retrieve\" , side_effect = [ deepcopy ( FAKE_FILEUPLOAD_ICON ), deepcopy ( FAKE_FILEUPLOAD_LOGO )], autospec = True , ) def test_get_connected_account_from_token ( self , fileupload_retrieve_mock , account_retrieve_mock ): account_retrieve_mock . return_value = deepcopy ( FAKE_ACCOUNT ) account = Account . get_connected_account_from_token ( \"fake_token\" ) account_retrieve_mock . assert_called_once_with ( api_key = \"fake_token\" ) self . assert_fks ( account , expected_blank_fks = {}) tests . test_account . TestAccount . test_get_default_account ( self , fileupload_retrieve_mock , account_retrieve_mock ) Source code in tests/test_account.py @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.FileUpload.retrieve\" , side_effect = [ deepcopy ( FAKE_FILEUPLOAD_ICON ), deepcopy ( FAKE_FILEUPLOAD_LOGO )], autospec = True , ) def test_get_default_account ( self , fileupload_retrieve_mock , account_retrieve_mock ): account_retrieve_mock . return_value = deepcopy ( FAKE_ACCOUNT ) account = Account . get_default_account () account_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY ) self . assertGreater ( len ( account . business_profile ), 0 ) self . assertGreater ( len ( account . settings ), 0 ) self . assertEqual ( account . branding_icon . id , FAKE_FILEUPLOAD_ICON [ \"id\" ]) self . assertEqual ( account . branding_logo . id , FAKE_FILEUPLOAD_LOGO [ \"id\" ]) self . assertEqual ( account . settings [ \"branding\" ][ \"icon\" ], account . branding_icon . id ) self . assertEqual ( account . settings [ \"branding\" ][ \"logo\" ], account . branding_logo . id ) self . assertNotEqual ( account . branding_logo . id , account . branding_icon . id ) self . assert_fks ( account , expected_blank_fks = {}) self . assertEqual ( account . business_url , \"https://example.com\" ) account . business_profile = None self . assertEqual ( account . business_url , \"\" ) tests . test_account . TestAccount . test_get_default_account_null_logo ( self , fileupload_retrieve_mock , account_retrieve_mock ) Source code in tests/test_account.py @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.FileUpload.retrieve\" , return_value = deepcopy ( FAKE_FILEUPLOAD_LOGO ), autospec = True , ) def test_get_default_account_null_logo ( self , fileupload_retrieve_mock , account_retrieve_mock ): fake_account = deepcopy ( FAKE_ACCOUNT ) fake_account [ \"settings\" ][ \"branding\" ][ \"icon\" ] = None fake_account [ \"settings\" ][ \"branding\" ][ \"logo\" ] = None account_retrieve_mock . return_value = fake_account account = Account . get_default_account () account_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY ) self . assert_fks ( account , expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , }, )","title":"TestAccount"},{"location":"reference/project/#tests.test_account.TestAccountRestrictedKeys","text":"","title":"TestAccountRestrictedKeys"},{"location":"reference/project/#tests.test_account.TestAccountRestrictedKeys-methods","text":"tests . test_account . TestAccountRestrictedKeys . tearDown ( self ) Hook method for deconstructing the test fixture after testing it. Source code in tests/test_account.py def tearDown ( self ): reload ( djstripe_settings ) tests . test_account . TestAccountRestrictedKeys . test_account_str_restricted_key ( self , account_retrieve_mock ) Test that we do not attempt to retrieve account ID with restricted keys. Source code in tests/test_account.py @override_settings ( STRIPE_TEST_SECRET_KEY = \"rk_test_blah\" , STRIPE_TEST_PUBLIC_KEY = \"pk_test_foo\" , STRIPE_LIVE_MODE = False , ) @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) def test_account_str_restricted_key ( self , account_retrieve_mock ): \"\"\" Test that we do not attempt to retrieve account ID with restricted keys. \"\"\" reload ( djstripe_settings ) assert djstripe_settings . STRIPE_SECRET_KEY == \"rk_test_blah\" account = Account . get_default_account () assert account is None account_retrieve_mock . assert_not_called ()","title":"Methods"},{"location":"reference/project/#tests.test_account-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.test_account.test__str__null_settings_null_business_profile","text":"Test that str doesn't crash when settings and business_profile are NULL. Source code in tests/test_account.py def test__str__null_settings_null_business_profile (): \"\"\"Test that __str__ doesn't crash when settings and business_profile are NULL.\"\"\" account = Account () account . settings = None account . business_profile = None assert str ( account ) == \"<id=>\"","title":"test__str__null_settings_null_business_profile()"},{"location":"reference/project/#tests.test_account.test_account__create_from_stripe_object","text":"Ensure that we are setting the ID value correctly. Source code in tests/test_account.py @pytest . mark . parametrize ( \"mock_account_id, other_mock_account_id, expected_stripe_account\" , ( ( \"acct_fakefakefakefake001\" , None , \"acct_fakefakefakefake001\" ), ( \"acct_fakefakefakefake001\" , \"acct_fakefakefakefake002\" , \"acct_fakefakefakefake002\" , ), ), ) @patch ( target = \"djstripe.models.connect.StripeModel._create_from_stripe_object\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_account__create_from_stripe_object ( mock_super__create_from_stripe_object , mock_account_id , other_mock_account_id , expected_stripe_account , ): \"\"\"Ensure that we are setting the ID value correctly.\"\"\" mock_data = { \"id\" : mock_account_id } Account . _create_from_stripe_object ( data = mock_data , stripe_account = other_mock_account_id ) mock_super__create_from_stripe_object . assert_called_once_with ( data = mock_data , current_ids = None , pending_relations = None , save = True , stripe_account = expected_stripe_account , )","title":"test_account__create_from_stripe_object()"},{"location":"reference/project/#tests.test_account.test_account_str","text":"Source code in tests/test_account.py @pytest . mark . django_db @pytest . mark . parametrize ( ( \"business_profile_update\" , \"settings_dashboard_update\" , \"expected_account_str\" ), ( ({}, {}, \"dj-stripe\" ), ({}, { \"display_name\" : \"some display name\" }, \"some display name\" ), ({ \"name\" : \"some business name\" }, { \"display_name\" : \"\" }, \"some business name\" ), ({ \"name\" : \"\" }, { \"display_name\" : \"\" }, \"<id=acct_1032D82eZvKYlo2C>\" ), ), ) @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.FileUpload.retrieve\" , return_value = deepcopy ( FAKE_FILEUPLOAD_LOGO ), autospec = True , ) def test_account_str ( fileupload_retrieve_mock , account_retrieve_mock , business_profile_update , settings_dashboard_update , expected_account_str , ): fake_account = deepcopy ( FAKE_ACCOUNT ) fake_account [ \"business_profile\" ] . update ( business_profile_update ) fake_account [ \"settings\" ][ \"dashboard\" ] . update ( settings_dashboard_update ) account_retrieve_mock . return_value = fake_account account = Account . get_default_account () assert str ( account ) == expected_account_str","title":"test_account_str()"},{"location":"reference/project/#tests.test_admin","text":"dj-stripe Admin Tests.","title":"test_admin"},{"location":"reference/project/#tests.test_admin-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_admin.TestAdminSite","text":"","title":"TestAdminSite"},{"location":"reference/project/#tests.test_admin.TestAdminSite-methods","text":"tests . test_admin . TestAdminSite . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_admin.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) tests . test_admin . TestAdminSite . test_search_fields ( self ) Search for errors like this: Bad search field for Customer model. Source code in tests/test_admin.py def test_search_fields ( self ): \"\"\" Search for errors like this: Bad search field <customer__user__username> for Customer model. \"\"\" for _model , model_admin in admin . site . _registry . items (): for search_field in getattr ( model_admin , \"search_fields\" , []): model_name = model_admin . model . __name__ self . assertFalse ( search_field . startswith ( \" {table_name} __\" . format ( table_name = model_name . lower ()) ), \"Bad search field < {search_field} > for {model_name} model.\" . format ( search_field = search_field , model_name = model_name ), )","title":"Methods"},{"location":"reference/project/#tests.test_api_keys","text":"","title":"test_api_keys"},{"location":"reference/project/#tests.test_api_keys-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_api_keys.TestCheckApiKeySettings","text":"","title":"TestCheckApiKeySettings"},{"location":"reference/project/#tests.test_api_keys.TestCheckApiKeySettings-methods","text":"tests . test_api_keys . TestCheckApiKeySettings . tearDown ( self ) Hook method for deconstructing the test fixture after testing it. Source code in tests/test_api_keys.py def tearDown ( self ): reload ( djstripe_settings ) tests . test_api_keys . TestCheckApiKeySettings . test_api_key_live_mode ( self ) Source code in tests/test_api_keys.py @override_settings ( STRIPE_TEST_SECRET_KEY = \"sk_test_foo\" , STRIPE_LIVE_SECRET_KEY = \"sk_live_foo\" , STRIPE_TEST_PUBLIC_KEY = \"pk_test_foo\" , STRIPE_LIVE_PUBLIC_KEY = \"pk_live_foo\" , STRIPE_LIVE_MODE = True , ) def test_api_key_live_mode ( self ): del settings . STRIPE_SECRET_KEY , settings . STRIPE_TEST_SECRET_KEY del settings . STRIPE_PUBLIC_KEY , settings . STRIPE_TEST_PUBLIC_KEY reload ( djstripe_settings ) self . assertEqual ( djstripe_settings . STRIPE_LIVE_MODE , True ) self . assertEqual ( djstripe_settings . STRIPE_SECRET_KEY , \"sk_live_foo\" ) self . assertEqual ( djstripe_settings . STRIPE_PUBLIC_KEY , \"pk_live_foo\" ) self . assertEqual ( djstripe_settings . LIVE_API_KEY , \"sk_live_foo\" ) self . assertEqual ( models . Account ( livemode = True ) . default_api_key , \"sk_live_foo\" ) tests . test_api_keys . TestCheckApiKeySettings . test_global_api_keys_live_mode ( self ) Source code in tests/test_api_keys.py @override_settings ( STRIPE_LIVE_SECRET_KEY = \"sk_live_foo\" , STRIPE_LIVE_PUBLIC_KEY = \"sk_live_foo\" , STRIPE_LIVE_MODE = True , ) def test_global_api_keys_live_mode ( self ): reload ( djstripe_settings ) self . assertEqual ( djstripe_settings . STRIPE_LIVE_MODE , True ) self . assertEqual ( djstripe_settings . STRIPE_SECRET_KEY , \"sk_live_foo\" ) self . assertEqual ( djstripe_settings . LIVE_API_KEY , \"sk_live_foo\" ) self . assertEqual ( models . Account ( livemode = True ) . default_api_key , \"sk_live_foo\" ) tests . test_api_keys . TestCheckApiKeySettings . test_global_api_keys_test_mode ( self ) Source code in tests/test_api_keys.py @override_settings ( STRIPE_TEST_SECRET_KEY = \"sk_test_foo\" , STRIPE_TEST_PUBLIC_KEY = \"pk_test_foo\" , STRIPE_LIVE_MODE = False , ) def test_global_api_keys_test_mode ( self ): reload ( djstripe_settings ) self . assertEqual ( djstripe_settings . STRIPE_LIVE_MODE , False ) self . assertEqual ( djstripe_settings . STRIPE_SECRET_KEY , \"sk_test_foo\" ) self . assertEqual ( djstripe_settings . TEST_API_KEY , \"sk_test_foo\" ) self . assertEqual ( models . Account ( livemode = False ) . default_api_key , \"sk_test_foo\" ) tests . test_api_keys . TestCheckApiKeySettings . test_secret_key_test_mode ( self ) Source code in tests/test_api_keys.py @override_settings ( STRIPE_TEST_SECRET_KEY = \"sk_test_foo\" , STRIPE_LIVE_SECRET_KEY = \"sk_live_foo\" , STRIPE_TEST_PUBLIC_KEY = \"pk_test_foo\" , STRIPE_LIVE_PUBLIC_KEY = \"pk_live_foo\" , STRIPE_LIVE_MODE = False , ) def test_secret_key_test_mode ( self ): del settings . STRIPE_SECRET_KEY del settings . STRIPE_PUBLIC_KEY reload ( djstripe_settings ) self . assertEqual ( djstripe_settings . STRIPE_LIVE_MODE , False ) self . assertEqual ( djstripe_settings . STRIPE_SECRET_KEY , \"sk_test_foo\" ) self . assertEqual ( djstripe_settings . STRIPE_PUBLIC_KEY , \"pk_test_foo\" ) self . assertEqual ( djstripe_settings . TEST_API_KEY , \"sk_test_foo\" ) self . assertEqual ( models . Account ( livemode = False ) . default_api_key , \"sk_test_foo\" )","title":"Methods"},{"location":"reference/project/#tests.test_apikey","text":"dj-stripe APIKey model tests","title":"test_apikey"},{"location":"reference/project/#tests.test_apikey.PK_LIVE","text":"","title":"PK_LIVE"},{"location":"reference/project/#tests.test_apikey.PK_TEST","text":"","title":"PK_TEST"},{"location":"reference/project/#tests.test_apikey.RK_LIVE","text":"","title":"RK_LIVE"},{"location":"reference/project/#tests.test_apikey.RK_TEST","text":"","title":"RK_TEST"},{"location":"reference/project/#tests.test_apikey.SK_LIVE","text":"","title":"SK_LIVE"},{"location":"reference/project/#tests.test_apikey.SK_TEST","text":"","title":"SK_TEST"},{"location":"reference/project/#tests.test_apikey-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_apikey.APIKeyTest","text":"","title":"APIKeyTest"},{"location":"reference/project/#tests.test_apikey.APIKeyTest-methods","text":"tests . test_apikey . APIKeyTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_apikey.py def setUp ( self ): self . account = default_account () self . apikey_test = APIKey . objects . create ( type = APIKeyType . secret , name = \"Test Secret Key\" , secret = SK_TEST , livemode = False , djstripe_owner_account = self . account , ) self . apikey_live = APIKey . objects . create ( type = APIKeyType . secret , name = \"Live Secret Key\" , secret = SK_LIVE , livemode = True , djstripe_owner_account = self . account , ) tests . test_apikey . APIKeyTest . test_get_account_by_api_key ( self ) Source code in tests/test_apikey.py def test_get_account_by_api_key ( self ): account = Account . get_or_retrieve_for_api_key ( self . apikey_test . secret ) assert account == self . account tests . test_apikey . APIKeyTest . test_get_stripe_dashboard_url ( self ) Source code in tests/test_apikey.py def test_get_stripe_dashboard_url ( self ): self . assertEqual ( self . apikey_test . get_stripe_dashboard_url (), \"https://dashboard.stripe.com/acct_TESTXXXXX/test/apikeys\" , ) self . assertEqual ( self . apikey_live . get_stripe_dashboard_url (), \"https://dashboard.stripe.com/acct_TESTXXXXX/apikeys\" , ) tests . test_apikey . APIKeyTest . test_refresh_account ( self , fileupload_retrieve_mock , account_retrieve_mock ) Source code in tests/test_apikey.py @patch ( \"stripe.Account.retrieve\" , return_value = deepcopy ( FAKE_ACCOUNT ), ) @patch ( \"stripe.FileUpload.retrieve\" , return_value = deepcopy ( FAKE_FILEUPLOAD_ICON )) def test_refresh_account ( self , fileupload_retrieve_mock , account_retrieve_mock ): self . apikey_test . djstripe_owner_account = None self . apikey_test . save () self . apikey_test . clean () assert self . apikey_test . djstripe_owner_account . id == FAKE_ACCOUNT [ \"id\" ] tests . test_apikey . APIKeyTest . test_secret_not_in_str ( self ) Source code in tests/test_apikey.py def test_secret_not_in_str ( self ): assert self . apikey_test . secret not in str ( self . apikey_test ) assert self . apikey_live . secret not in str ( self . apikey_live ) tests . test_apikey . APIKeyTest . test_secret_redacted ( self ) Source code in tests/test_apikey.py def test_secret_redacted ( self ): self . assertEqual ( self . apikey_test . secret_redacted , \"sk_test_...1234\" ) self . assertEqual ( self . apikey_live . secret_redacted , \"sk_live_...5678\" )","title":"Methods"},{"location":"reference/project/#tests.test_apikey.test_apikey_detect_livemode_and_type","text":"Source code in tests/test_apikey.py @pytest . mark . django_db @patch ( \"stripe.Account.retrieve\" , return_value = deepcopy ( FAKE_ACCOUNT )) @patch ( \"stripe.FileUpload.retrieve\" , return_value = deepcopy ( FAKE_FILEUPLOAD_ICON )) def test_apikey_detect_livemode_and_type ( fileupload_retrieve_mock , account_retrieve_mock ): keys_and_values = ( ( PK_TEST , False , APIKeyType . publishable ), ( RK_TEST , False , APIKeyType . restricted ), ( SK_TEST , False , APIKeyType . secret ), ( PK_LIVE , True , APIKeyType . publishable ), ( RK_LIVE , True , APIKeyType . restricted ), ( SK_LIVE , True , APIKeyType . secret ), ) for secret , livemode , type in keys_and_values : key = APIKey . objects . create ( secret = secret ) assert key . livemode is livemode assert key . type is type key . clean () assert key . livemode is livemode assert key . type is type","title":"test_apikey_detect_livemode_and_type()"},{"location":"reference/project/#tests.test_apikey.test_clean_public_apikey","text":"Source code in tests/test_apikey.py def test_clean_public_apikey (): key = APIKey ( type = APIKeyType . publishable , livemode = False , secret = PK_TEST ) assert not key . djstripe_owner_account key . clean () assert not key . djstripe_owner_account","title":"test_clean_public_apikey()"},{"location":"reference/project/#tests.test_apikey.test_get_api_key_details_by_prefix","text":"Source code in tests/test_apikey.py def test_get_api_key_details_by_prefix (): assert get_api_key_details_by_prefix ( SK_TEST ) == ( APIKeyType . secret , False ) assert get_api_key_details_by_prefix ( SK_LIVE ) == ( APIKeyType . secret , True ) assert get_api_key_details_by_prefix ( RK_TEST ) == ( APIKeyType . restricted , False ) assert get_api_key_details_by_prefix ( RK_LIVE ) == ( APIKeyType . restricted , True ) assert get_api_key_details_by_prefix ( PK_TEST ) == ( APIKeyType . publishable , False ) assert get_api_key_details_by_prefix ( PK_LIVE ) == ( APIKeyType . publishable , True )","title":"test_get_api_key_details_by_prefix()"},{"location":"reference/project/#tests.test_apikey.test_get_api_key_details_by_prefix_bad_values","text":"Source code in tests/test_apikey.py def test_get_api_key_details_by_prefix_bad_values (): with pytest . raises ( ValueError ): get_api_key_details_by_prefix ( \"pk_a\" ) with pytest . raises ( ValueError ): get_api_key_details_by_prefix ( \"sk_a\" ) with pytest . raises ( ValueError ): get_api_key_details_by_prefix ( \"rk_nope_1234\" )","title":"test_get_api_key_details_by_prefix_bad_values()"},{"location":"reference/project/#tests.test_bank_account","text":"dj-stripe Bank Account Model Tests.","title":"test_bank_account"},{"location":"reference/project/#tests.test_bank_account-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_bank_account.BankAccountTest","text":"","title":"BankAccountTest"},{"location":"reference/project/#tests.test_bank_account.BankAccountTest-methods","text":"tests . test_bank_account . BankAccountTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_bank_account.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"testuser\" , email = \"djstripe@example.com\" ) fake_empty_customer = deepcopy ( FAKE_CUSTOMER_IV ) fake_empty_customer [ \"default_source\" ] = None fake_empty_customer [ \"sources\" ] = [] self . customer = fake_empty_customer . create_for_user ( self . user ) tests . test_bank_account . BankAccountTest . test_api_call_bad_customer ( self ) Source code in tests/test_bank_account.py def test_api_call_bad_customer ( self ): exception_message = ( \"BankAccounts must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): BankAccount . _api_create ( customer = \"fish\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): BankAccount . api_list ( customer = \"fish\" ) tests . test_bank_account . BankAccountTest . test_api_call_no_customer ( self ) Source code in tests/test_bank_account.py def test_api_call_no_customer ( self ): exception_message = ( \"BankAccounts must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): BankAccount . _api_create () with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): BankAccount . api_list () tests . test_bank_account . BankAccountTest . test_api_create ( self , customer_retrieve_mock ) Source code in tests/test_bank_account.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_IV ), autospec = True , ) def test_api_create ( self , customer_retrieve_mock ): stripe_bank_account = BankAccount . _api_create ( customer = self . customer , source = FAKE_BANK_ACCOUNT_SOURCE [ \"id\" ] ) self . assertEqual ( FAKE_BANK_ACCOUNT_SOURCE , stripe_bank_account ) tests . test_bank_account . BankAccountTest . test_api_list ( self , customer_retrieve_mock ) Source code in tests/test_bank_account.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_IV ), autospec = True , ) def test_api_list ( self , customer_retrieve_mock ): bank_account_list = BankAccount . api_list ( customer = self . customer ) self . assertEqual ([ FAKE_BANK_ACCOUNT_SOURCE ], [ i for i in bank_account_list ]) tests . test_bank_account . BankAccountTest . test_create_bank_account_finds_customer ( self ) Source code in tests/test_bank_account.py def test_create_bank_account_finds_customer ( self ): bank_account = BankAccount . sync_from_stripe_data ( deepcopy ( FAKE_BANK_ACCOUNT_SOURCE ) ) self . assertEqual ( self . customer , bank_account . customer ) self . assertEqual ( bank_account . get_stripe_dashboard_url (), self . customer . get_stripe_dashboard_url (), ) self . assert_fks ( bank_account , expected_blank_fks = { \"djstripe.BankAccount.account\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , \"djstripe.Customer.coupon\" , }, ) tests . test_bank_account . BankAccountTest . test_remove ( self , customer_retrieve_mock , bank_account_retrieve_mock , bank_account_delete_mock ) Source code in tests/test_bank_account.py @patch ( \"tests.BankAccountDict.delete\" , autospec = True ) @patch ( \"stripe.BankAccount.retrieve\" , return_value = deepcopy ( FAKE_BANK_ACCOUNT_SOURCE ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_IV ), autospec = True , ) def test_remove ( self , customer_retrieve_mock , bank_account_retrieve_mock , bank_account_delete_mock , ): stripe_bank_account = BankAccount . _api_create ( customer = self . customer , source = FAKE_BANK_ACCOUNT_SOURCE [ \"id\" ] ) BankAccount . sync_from_stripe_data ( stripe_bank_account ) self . assertEqual ( 1 , self . customer . bank_account . count ()) bank_account = self . customer . bank_account . all ()[ 0 ] bank_account . remove () self . assertEqual ( 0 , self . customer . bank_account . count ()) self . assertTrue ( bank_account_delete_mock . called ) tests . test_bank_account . BankAccountTest . test_remove_already_deleted_card ( self , customer_retrieve_mock ) Source code in tests/test_bank_account.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_IV ), autospec = True , ) def test_remove_already_deleted_card ( self , customer_retrieve_mock ): stripe_bank_account = BankAccount . _api_create ( customer = self . customer , source = FAKE_BANK_ACCOUNT_SOURCE [ \"id\" ] ) BankAccount . sync_from_stripe_data ( stripe_bank_account ) self . assertEqual ( self . customer . bank_account . count (), 1 ) bank_account_object = self . customer . bank_account . first () BankAccount . objects . filter ( id = stripe_bank_account [ \"id\" ]) . delete () self . assertEqual ( self . customer . bank_account . count (), 0 ) bank_account_object . remove () self . assertEqual ( self . customer . bank_account . count (), 0 )","title":"Methods"},{"location":"reference/project/#tests.test_card","text":"dj-stripe Card Model Tests.","title":"test_card"},{"location":"reference/project/#tests.test_card-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_card.CardTest","text":"","title":"CardTest"},{"location":"reference/project/#tests.test_card.CardTest-methods","text":"tests . test_card . CardTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_card.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"testuser\" , email = \"djstripe@example.com\" ) fake_empty_customer = deepcopy ( FAKE_CUSTOMER ) fake_empty_customer [ \"default_source\" ] = None fake_empty_customer [ \"sources\" ] = [] self . customer = fake_empty_customer . create_for_user ( self . user ) tests . test_card . CardTest . test_api_call_bad_customer ( self ) Source code in tests/test_card.py def test_api_call_bad_customer ( self ): exception_message = ( \"Cards must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): Card . _api_create ( customer = \"fish\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): Card . api_list ( customer = \"fish\" ) tests . test_card . CardTest . test_api_call_no_customer ( self ) Source code in tests/test_card.py def test_api_call_no_customer ( self ): exception_message = ( \"Cards must be manipulated through a Customer. \" \"Pass a Customer object into this call.\" ) with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): Card . _api_create () with self . assertRaisesMessage ( StripeObjectManipulationException , exception_message ): Card . api_list () tests . test_card . CardTest . test_api_create ( self , customer_retrieve_mock ) Source code in tests/test_card.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_api_create ( self , customer_retrieve_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) self . assertEqual ( FAKE_CARD , stripe_card ) tests . test_card . CardTest . test_api_list ( self , customer_retrieve_mock ) Source code in tests/test_card.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_api_list ( self , customer_retrieve_mock ): card_list = Card . api_list ( customer = self . customer ) self . assertEqual ([ FAKE_CARD , FAKE_CARD_V ], [ i for i in card_list ]) tests . test_card . CardTest . test_attach_objects_hook_without_customer ( self ) Source code in tests/test_card.py def test_attach_objects_hook_without_customer ( self ): card = Card . sync_from_stripe_data ( deepcopy ( FAKE_CARD_III )) self . assertEqual ( card . customer , None ) tests . test_card . CardTest . test_card_create_token ( self , token_create_mock ) Source code in tests/test_card.py @patch ( \"stripe.Token.create\" , autospec = True ) def test_card_create_token ( self , token_create_mock ): card = { \"number\" : \"4242\" , \"exp_month\" : 5 , \"exp_year\" : 2012 , \"cvc\" : 445 } Card . create_token ( ** card ) token_create_mock . assert_called_with ( api_key = ANY , card = card ) tests . test_card . CardTest . test_create_card_finds_customer ( self ) Source code in tests/test_card.py def test_create_card_finds_customer ( self ): card = Card . sync_from_stripe_data ( deepcopy ( FAKE_CARD )) self . assertEqual ( self . customer , card . customer ) self . assertEqual ( card . get_stripe_dashboard_url (), self . customer . get_stripe_dashboard_url () ) self . assert_fks ( card , expected_blank_fks = { \"djstripe.BankAccount.account\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , }, ) tests . test_card . CardTest . test_remove ( self , customer_retrieve_mock , card_retrieve_mock , card_delete_mock ) Source code in tests/test_card.py @patch ( \"tests.CardDict.delete\" , autospec = True ) @patch ( \"stripe.Card.retrieve\" , return_value = deepcopy ( FAKE_CARD ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_remove ( self , customer_retrieve_mock , card_retrieve_mock , card_delete_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) Card . sync_from_stripe_data ( stripe_card ) self . assertEqual ( 1 , self . customer . legacy_cards . count ()) card = self . customer . legacy_cards . all ()[ 0 ] card . remove () self . assertEqual ( 0 , self . customer . legacy_cards . count ()) self . assertTrue ( card_delete_mock . called ) tests . test_card . CardTest . test_remove_already_deleted_card ( self , customer_retrieve_mock ) Source code in tests/test_card.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_remove_already_deleted_card ( self , customer_retrieve_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) Card . sync_from_stripe_data ( stripe_card ) self . assertEqual ( self . customer . legacy_cards . count (), 1 ) card_object = self . customer . legacy_cards . first () Card . objects . filter ( id = stripe_card [ \"id\" ]) . delete () self . assertEqual ( self . customer . legacy_cards . count (), 0 ) card_object . remove () self . assertEqual ( self . customer . legacy_cards . count (), 0 ) tests . test_card . CardTest . test_remove_no_such_customer ( self , customer_retrieve_mock , card_delete_mock ) Source code in tests/test_card.py @patch ( \"djstripe.models.Card._api_delete\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_remove_no_such_customer ( self , customer_retrieve_mock , card_delete_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) Card . sync_from_stripe_data ( stripe_card ) card_delete_mock . side_effect = InvalidRequestError ( \"No such customer:\" , \"blah\" ) self . assertEqual ( 1 , self . customer . legacy_cards . count ()) card = self . customer . legacy_cards . all ()[ 0 ] card . remove () self . assertEqual ( 0 , self . customer . legacy_cards . count ()) self . assertTrue ( card_delete_mock . called ) tests . test_card . CardTest . test_remove_no_such_source ( self , customer_retrieve_mock , card_delete_mock ) Source code in tests/test_card.py @patch ( \"djstripe.models.Card._api_delete\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_remove_no_such_source ( self , customer_retrieve_mock , card_delete_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) Card . sync_from_stripe_data ( stripe_card ) card_delete_mock . side_effect = InvalidRequestError ( \"No such source:\" , \"blah\" ) self . assertEqual ( 1 , self . customer . legacy_cards . count ()) card = self . customer . legacy_cards . all ()[ 0 ] card . remove () self . assertEqual ( 0 , self . customer . legacy_cards . count ()) self . assertTrue ( card_delete_mock . called ) tests . test_card . CardTest . test_remove_unexpected_exception ( self , customer_retrieve_mock , card_delete_mock ) Source code in tests/test_card.py @patch ( \"djstripe.models.Card._api_delete\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_remove_unexpected_exception ( self , customer_retrieve_mock , card_delete_mock ): stripe_card = Card . _api_create ( customer = self . customer , source = FAKE_CARD [ \"id\" ]) Card . sync_from_stripe_data ( stripe_card ) card_delete_mock . side_effect = InvalidRequestError ( \"Unexpected Exception\" , \"blah\" ) self . assertEqual ( 1 , self . customer . legacy_cards . count ()) card = self . customer . legacy_cards . all ()[ 0 ] with self . assertRaisesMessage ( InvalidRequestError , \"Unexpected Exception\" ): card . remove () tests . test_card . CardTest . test_str ( self ) Source code in tests/test_card.py def test_str ( self ): fake_card = deepcopy ( FAKE_CARD ) card = Card . sync_from_stripe_data ( fake_card ) self . assertEqual ( \"<brand= {brand} , last4= {last4} , exp_month= {exp_month} , \" \"exp_year= {exp_year} , id= {id} >\" . format ( brand = fake_card [ \"brand\" ], last4 = fake_card [ \"last4\" ], exp_month = fake_card [ \"exp_month\" ], exp_year = fake_card [ \"exp_year\" ], id = fake_card [ \"id\" ], ), str ( card ), ) self . assert_fks ( card , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , }, )","title":"Methods"},{"location":"reference/project/#tests.test_charge","text":"dj-stripe Charge Model Tests.","title":"test_charge"},{"location":"reference/project/#tests.test_charge-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_charge.ChargeTest","text":"","title":"ChargeTest"},{"location":"reference/project/#tests.test_charge.ChargeTest-methods","text":"tests . test_charge . ChargeTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_charge.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"user\" , email = \"user@example.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . account = default_account () self . default_expected_blank_fks = { \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Invoice.default_payment_method\" , \"djstripe.Invoice.default_source\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , \"djstripe.Subscription.default_payment_method\" , \"djstripe.Subscription.default_source\" , \"djstripe.Subscription.pending_setup_intent\" , \"djstripe.Subscription.schedule\" , } tests . test_charge . ChargeTest . test__attach_objects_hook_missing_source_data ( self , mock_account , mock_payment_method , mock_charge_account , mock_charge_source ) Make sure we handle the case where the source data is empty or insufficient. Source code in tests/test_charge.py @patch . object ( target = Charge , attribute = \"source\" , autospec = True ) @patch . object ( target = Charge , attribute = \"account\" , autospec = True ) @patch ( target = \"djstripe.models.payment_methods.DjstripePaymentMethod\" , autospec = True ) @patch ( target = \"djstripe.models.account.Account\" , autospec = True ) def test__attach_objects_hook_missing_source_data ( self , mock_account , mock_payment_method , mock_charge_account , mock_charge_source ): \"\"\" Make sure we handle the case where the source data is empty or insufficient. \"\"\" charge = Charge ( amount = 50 , currency = \"usd\" , id = \"ch_test\" , status = ChargeStatus . failed , captured = False , paid = False , ) mock_cls = create_autospec ( spec = Charge , spec_set = True ) # Empty data dict works for this test since we only look up the source key and # everything else is mocked. mock_data = {} starting_source = charge . source charge . _attach_objects_hook ( cls = mock_cls , data = mock_data ) # source shouldn't be touched self . assertEqual ( starting_source , charge . source ) mock_payment_method . _get_or_create_source . assert_not_called () # try again with a source key, but no object sub key. mock_data = { \"source\" : { \"foo\" : \"bar\" }} charge . _attach_objects_hook ( cls = mock_cls , data = mock_data ) # source shouldn't be touched self . assertEqual ( starting_source , charge . source ) mock_payment_method . _get_or_create_source . assert_not_called () tests . test_charge . ChargeTest . test_capture_charge ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , balance_transaction_retrieve_mock , charge_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_capture_charge ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , balance_transaction_retrieve_mock , charge_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_no_invoice = deepcopy ( FAKE_CHARGE ) fake_charge_no_invoice . update ({ \"invoice\" : None }) charge_retrieve_mock . return_value = fake_charge_no_invoice # TODO - I think this is needed in line with above? fake_payment_intent_no_invoice = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent_no_invoice . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent_no_invoice charge , created = Charge . _get_or_create_from_stripe_object ( fake_charge_no_invoice ) self . assertTrue ( created ) captured_charge = charge . capture () self . assertTrue ( captured_charge . captured ) self . assertFalse ( captured_charge . fraudulent ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.Plan.product\" , }, ) tests . test_charge . ChargeTest . test_max_size_large_charge_on_decimal_amount ( self , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) By contacting stripe support, some accounts will have their limit raised to 11 digits Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED and IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_max_size_large_charge_on_decimal_amount ( self , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): \"\"\" By contacting stripe support, some accounts will have their limit raised to 11 digits \"\"\" amount = 99999999999 assert len ( str ( amount )) == 11 fake_transaction = deepcopy ( FAKE_BALANCE_TRANSACTION ) fake_transaction . update ({ \"amount\" : amount }) default_account_mock . return_value = self . account balance_transaction_retrieve_mock . return_value = fake_transaction fake_charge = deepcopy ( FAKE_CHARGE ) fake_charge . update ({ \"amount\" : amount }) charge = Charge . sync_from_stripe_data ( fake_charge ) charge_retrieve_mock . assert_not_called () self . assertTrue ( bool ( charge . pk )) self . assertEqual ( charge . amount , Decimal ( \"999999999.99\" )) self . assertEqual ( charge . balance_transaction . amount , 99999999999 ) tests . test_charge . ChargeTest . test_str ( self ) Source code in tests/test_charge.py def test_str ( self ): charge = Charge ( amount = 50 , currency = \"usd\" , id = \"ch_test\" , status = ChargeStatus . failed , captured = False , paid = False , ) self . assertEqual ( str ( charge ), \"$50.00 USD (Uncaptured)\" ) charge . captured = True self . assertEqual ( str ( charge ), \"$50.00 USD (Failed)\" ) charge . status = ChargeStatus . succeeded charge . disputed = True self . assertEqual ( str ( charge ), \"$50.00 USD (Disputed)\" ) charge . disputed = False charge . refunded = True charge . amount_refunded = 50 self . assertEqual ( str ( charge ), \"$50.00 USD (Refunded)\" ) charge . refunded = False self . assertEqual ( str ( charge ), \"$50.00 USD (Partially refunded)\" ) charge . amount_refunded = 0 self . assertEqual ( str ( charge ), \"$50.00 USD\" ) tests . test_charge . ChargeTest . test_sync_from_stripe_data ( self , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED and IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_sync_from_stripe_data ( self , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) charge = Charge . sync_from_stripe_data ( fake_charge_copy ) self . assertEqual ( Decimal ( \"20\" ), charge . amount ) self . assertEqual ( True , charge . paid ) self . assertEqual ( False , charge . refunded ) self . assertEqual ( True , charge . captured ) self . assertEqual ( False , charge . disputed ) self . assertEqual ( \"Subscription creation\" , charge . description ) self . assertEqual ( 0 , charge . amount_refunded ) self . assertEqual ( self . customer . default_source . id , charge . source_id ) self . assertEqual ( charge . source . type , LegacySourceType . card ) self . assertGreater ( len ( charge . receipt_url ), 1 ) self . assertTrue ( charge . payment_method_details [ \"type\" ]) charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_max_amount ( self , default_account_mock , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock ) Source code in tests/test_charge.py @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_sync_from_stripe_data_max_amount ( self , default_account_mock , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) # https://support.stripe.com/questions/what-is-the-maximum-amount-i-can-charge-with-stripe fake_charge_copy . update ({ \"amount\" : 99999999 }) charge = Charge . sync_from_stripe_data ( fake_charge_copy ) self . assertEqual ( Decimal ( \"999999.99\" ), charge . amount ) self . assertEqual ( True , charge . paid ) self . assertEqual ( False , charge . refunded ) self . assertEqual ( True , charge . captured ) self . assertEqual ( False , charge . disputed ) self . assertEqual ( 0 , charge . amount_refunded ) charge_retrieve_mock . assert_not_called () self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_no_customer ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_sync_from_stripe_data_no_customer ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . pop ( \"customer\" , None ) # remove invoice since it requires a customer fake_charge_copy . pop ( \"invoice\" , None ) fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent [ \"invoice\" ] = None payment_intent_retrieve_mock . return_value = fake_payment_intent Charge . sync_from_stripe_data ( fake_charge_copy ) assert Charge . objects . count () == 1 charge = Charge . objects . get () assert charge . customer is None charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.customer\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.Plan.product\" , }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_refunded ( self , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , side_effect = [ deepcopy ( FAKE_BALANCE_TRANSACTION ), deepcopy ( FAKE_BALANCE_TRANSACTION_REFUND ), ], ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_sync_from_stripe_data_refunded ( self , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE_REFUNDED ) charge = Charge . sync_from_stripe_data ( fake_charge_copy ) self . assertEqual ( Decimal ( \"20\" ), charge . amount ) self . assertEqual ( True , charge . paid ) self . assertEqual ( True , charge . refunded ) self . assertEqual ( True , charge . captured ) self . assertEqual ( False , charge . disputed ) self . assertEqual ( \"Subscription creation\" , charge . description ) self . assertEqual ( charge . amount , charge . amount_refunded ) charge_retrieve_mock . assert_not_called () # We expect two calls - for charge and then for charge.refunds balance_transaction_retrieve_mock . assert_has_calls ( [ call ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ), call ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION_REFUND [ \"id\" ], stripe_account = None , ), ] ) refunds = list ( charge . refunds . all ()) self . assertEqual ( len ( refunds ), 1 ) refund = refunds [ 0 ] self . assertEqual ( refund . id , FAKE_REFUND [ \"id\" ]) self . assertNotEqual ( charge . balance_transaction . id , refund . balance_transaction . id ) self . assertEqual ( charge . balance_transaction . id , FAKE_BALANCE_TRANSACTION [ \"id\" ]) self . assertEqual ( refund . balance_transaction . id , FAKE_BALANCE_TRANSACTION_REFUND [ \"id\" ] ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_refunded_on_update ( self , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_sync_from_stripe_data_refunded_on_update ( self , subscription_retrieve_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , default_account_mock , ): # first sync charge (as per test_sync_from_stripe_data) # then sync refunded version, to hit the update code-path instead of insert from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) with patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), ): charge = Charge . sync_from_stripe_data ( fake_charge_copy ) self . assertEqual ( Decimal ( \"20\" ), charge . amount ) self . assertEqual ( True , charge . paid ) self . assertEqual ( False , charge . refunded ) self . assertEqual ( True , charge . captured ) self . assertEqual ( False , charge . disputed ) self . assertEqual ( len ( charge . refunds . all ()), 0 ) fake_charge_refunded_copy = deepcopy ( FAKE_CHARGE_REFUNDED ) with patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION_REFUND ), ) as balance_transaction_retrieve_mock : charge_refunded = Charge . sync_from_stripe_data ( fake_charge_refunded_copy ) self . assertEqual ( charge . id , charge_refunded . id ) self . assertEqual ( Decimal ( \"20\" ), charge_refunded . amount ) self . assertEqual ( True , charge_refunded . paid ) self . assertEqual ( True , charge_refunded . refunded ) self . assertEqual ( True , charge_refunded . captured ) self . assertEqual ( False , charge_refunded . disputed ) self . assertEqual ( \"Subscription creation\" , charge_refunded . description ) self . assertEqual ( charge_refunded . amount , charge_refunded . amount_refunded ) charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION_REFUND [ \"id\" ], stripe_account = None , ) refunds = list ( charge_refunded . refunds . all ()) self . assertEqual ( len ( refunds ), 1 ) refund = refunds [ 0 ] self . assertEqual ( refund . id , FAKE_REFUND [ \"id\" ]) self . assertNotEqual ( charge_refunded . balance_transaction . id , refund . balance_transaction . id ) self . assertEqual ( charge_refunded . balance_transaction . id , FAKE_BALANCE_TRANSACTION [ \"id\" ] ) self . assertEqual ( refund . balance_transaction . id , FAKE_BALANCE_TRANSACTION_REFUND [ \"id\" ] ) self . assert_fks ( charge_refunded , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_unsupported_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_charge.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_sync_from_stripe_data_unsupported_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"source\" : { \"id\" : \"test_id\" , \"object\" : \"unsupported\" }}) charge = Charge . sync_from_stripe_data ( fake_charge_copy ) self . assertEqual ( \"test_id\" , charge . source_id ) self . assertEqual ( \"unsupported\" , charge . source . type ) self . assertEqual ( charge . source , DjstripePaymentMethod . objects . get ( id = \"test_id\" )) charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" }, ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_with_destination ( self , file_retrieve_mock , invoice_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , account_retrieve_mock , charge_retrieve_mock ) Source code in tests/test_charge.py @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Account.retrieve\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.File.retrieve\" , side_effect = [ deepcopy ( FAKE_FILEUPLOAD_ICON ), deepcopy ( FAKE_FILEUPLOAD_LOGO )], autospec = True , ) def test_sync_from_stripe_data_with_destination ( self , file_retrieve_mock , invoice_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , account_retrieve_mock , charge_retrieve_mock , ): from djstripe.settings import STRIPE_SECRET_KEY account_retrieve_mock . return_value = FAKE_ACCOUNT fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"destination\" : FAKE_ACCOUNT [ \"id\" ]}) charge , created = Charge . _get_or_create_from_stripe_object ( fake_charge_copy , current_ids = { fake_charge_copy [ \"id\" ]} ) self . assertTrue ( created ) charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ) self . assert_fks ( charge , expected_blank_fks = self . default_expected_blank_fks ) tests . test_charge . ChargeTest . test_sync_from_stripe_data_with_transfer ( self , default_account_mock , subscription_retrieve_mock , product_retrieve_mock , transfer_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock ) Source code in tests/test_charge.py @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Transfer.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_sync_from_stripe_data_with_transfer ( self , default_account_mock , subscription_retrieve_mock , product_retrieve_mock , transfer_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , invoice_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , ): from djstripe.settings import STRIPE_SECRET_KEY default_account_mock . return_value = self . account fake_transfer = deepcopy ( FAKE_TRANSFER ) fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"transfer\" : fake_transfer [ \"id\" ]}) transfer_retrieve_mock . return_value = fake_transfer charge_retrieve_mock . return_value = fake_charge_copy charge , created = Charge . _get_or_create_from_stripe_object ( fake_charge_copy , current_ids = { fake_charge_copy [ \"id\" ]} ) self . assertTrue ( created ) self . assertNotEqual ( None , charge . transfer ) self . assertEqual ( fake_transfer [ \"id\" ], charge . transfer . id ) charge_retrieve_mock . assert_not_called () balance_transaction_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_BALANCE_TRANSACTION [ \"id\" ], stripe_account = None , ) self . assert_fks ( charge , expected_blank_fks = ( self . default_expected_blank_fks | { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" } ) - { \"djstripe.Charge.transfer\" }, )","title":"Methods"},{"location":"reference/project/#tests.test_context_managers","text":"dj-stripe Context Manager Tests.","title":"test_context_managers"},{"location":"reference/project/#tests.test_context_managers.TestTemporaryVersion","text":"tests . test_context_managers . TestTemporaryVersion . test_basic_with_exception ( self ) Source code in tests/test_context_managers.py def test_basic_with_exception ( self ): version = stripe . api_version with self . assertRaises ( ValueError ): with stripe_temporary_api_version ( \"2016-03-07\" ): self . assertEqual ( stripe . api_version , \"2016-03-07\" ) raise ValueError ( \"Something happened\" ) self . assertEqual ( stripe . api_version , version ) tests . test_context_managers . TestTemporaryVersion . test_basic_without_validation ( self ) Source code in tests/test_context_managers.py def test_basic_without_validation ( self ): version = stripe . api_version with stripe_temporary_api_version ( \"newversion\" , validate = False ): self . assertEqual ( stripe . api_version , \"newversion\" ) self . assertEqual ( stripe . api_version , version )","title":"TestTemporaryVersion"},{"location":"reference/project/#tests.test_contrib","text":"","title":"test_contrib"},{"location":"reference/project/#tests.test_contrib-modules","text":"","title":"Modules"},{"location":"reference/project/#tests.test_contrib.test_rest_framework_permissions","text":"","title":"test_rest_framework_permissions"},{"location":"reference/project/#tests.test_contrib.test_rest_framework_permissions-classes","text":"tests.test_contrib.test_rest_framework_permissions.TestUserHasActiveSubscription Methods tests . test_contrib . test_rest_framework_permissions . TestUserHasActiveSubscription . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_contrib/test_rest_framework_permissions.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_contrib . test_rest_framework_permissions . TestUserHasActiveSubscription . test_no_user_in_request ( self ) Source code in tests/test_contrib/test_rest_framework_permissions.py def test_no_user_in_request ( self ): request = RequestFactory () . get ( \"djstripe/\" ) self . assertFalse ( DJStripeSubscriptionPermission () . has_permission ( request = request , view = None ) ) tests . test_contrib . test_rest_framework_permissions . TestUserHasActiveSubscription . test_user ( self ) Source code in tests/test_contrib/test_rest_framework_permissions.py def test_user ( self ): request = RequestFactory () . get ( \"djstripe/\" ) request . user = self . user self . assertFalse ( DJStripeSubscriptionPermission () . has_permission ( request = request , view = None ) )","title":"Classes"},{"location":"reference/project/#tests.test_contrib.test_serializers","text":".. module:: dj-stripe.tests.test_contrib.test_serializers :synopsis: dj-stripe Serializer Tests.","title":"test_serializers"},{"location":"reference/project/#tests.test_contrib.test_serializers-classes","text":"tests.test_contrib.test_serializers.CreateSubscriptionSerializerTest Methods tests . test_contrib . test_serializers . CreateSubscriptionSerializerTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_contrib/test_serializers.py def setUp ( self ): with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) tests . test_contrib . test_serializers . CreateSubscriptionSerializerTest . test_invalid_serializer ( self ) Source code in tests/test_contrib/test_serializers.py def test_invalid_serializer ( self ): serializer = CreateSubscriptionSerializer ( data = { \"plan\" : self . plan . id }) self . assertFalse ( serializer . is_valid ()) self . assertEqual ( serializer . validated_data , {}) self . assertEqual ( serializer . errors , { \"stripe_token\" : [ \"This field is required.\" ]} ) tests . test_contrib . test_serializers . CreateSubscriptionSerializerTest . test_valid_serializer ( self , stripe_token_mock ) Source code in tests/test_contrib/test_serializers.py @patch ( \"stripe.Token.create\" , return_value = PropertyMock ( id = \"token_test\" ), autospec = True ) def test_valid_serializer ( self , stripe_token_mock ): token = stripe_token_mock ( card = {}) serializer = CreateSubscriptionSerializer ( data = { \"plan\" : self . plan . id , \"stripe_token\" : token . id } ) self . assertTrue ( serializer . is_valid ()) self . assertEqual ( serializer . validated_data [ \"plan\" ], str ( self . plan . id )) self . assertIn ( \"stripe_token\" , serializer . validated_data ) self . assertEqual ( serializer . errors , {}) tests . test_contrib . test_serializers . CreateSubscriptionSerializerTest . test_valid_serializer_non_required_fields ( self , stripe_token_mock ) Test the CreateSubscriptionSerializer is_valid method. Source code in tests/test_contrib/test_serializers.py @patch ( \"stripe.Token.create\" , return_value = PropertyMock ( id = \"token_test\" ), autospec = True ) def test_valid_serializer_non_required_fields ( self , stripe_token_mock ): \"\"\"Test the CreateSubscriptionSerializer is_valid method.\"\"\" token = stripe_token_mock ( card = {}) serializer = CreateSubscriptionSerializer ( data = { \"plan\" : self . plan . id , \"stripe_token\" : token . id , \"charge_immediately\" : True , \"tax_percent\" : 13.00 , } ) self . assertTrue ( serializer . is_valid ()) tests.test_contrib.test_serializers.SubscriptionSerializerTest Methods tests . test_contrib . test_serializers . SubscriptionSerializerTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_contrib/test_serializers.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) tests . test_contrib . test_serializers . SubscriptionSerializerTest . test_invalid_serializer ( self , product_retrieve_mock ) Source code in tests/test_contrib/test_serializers.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invalid_serializer ( self , product_retrieve_mock ): now = timezone . now () serializer = SubscriptionSerializer ( data = { \"id\" : \"sub_6lsC8pt7IcFpjA\" , \"customer\" : self . customer . pk , \"plan\" : self . plan . pk , \"start_date\" : now , \"status\" : SubscriptionStatus . active , \"current_period_end\" : now + timezone . timedelta ( days = 5 ), \"current_period_start\" : now , } ) self . assertFalse ( serializer . is_valid ()) self . assertEqual ( serializer . validated_data , {}) self . assertEqual ( serializer . errors , { \"collection_method\" : [ \"This field is required.\" ]} ) tests . test_contrib . test_serializers . SubscriptionSerializerTest . test_valid_serializer ( self ) Source code in tests/test_contrib/test_serializers.py def test_valid_serializer ( self ): now = timezone . now () serializer = SubscriptionSerializer ( data = { \"id\" : \"sub_6lsC8pt7IcFpjA\" , \"collection_method\" : \"charge_automatically\" , \"customer\" : self . customer . pk , \"plan\" : self . plan . pk , \"quantity\" : 2 , \"start_date\" : now , \"status\" : SubscriptionStatus . active , \"current_period_end\" : now + timezone . timedelta ( days = 5 ), \"current_period_start\" : now , } ) self . assertTrue ( serializer . is_valid ()) self . assertEqual ( serializer . validated_data , { \"id\" : \"sub_6lsC8pt7IcFpjA\" , \"collection_method\" : \"charge_automatically\" , \"customer\" : self . customer , \"plan\" : self . plan , \"quantity\" : 2 , \"start_date\" : now , \"status\" : SubscriptionStatus . active , \"current_period_end\" : now + timezone . timedelta ( days = 5 ), \"current_period_start\" : now , }, ) self . assertEqual ( serializer . errors , {})","title":"Classes"},{"location":"reference/project/#tests.test_contrib.test_views","text":".. module:: dj-stripe.tests.test_contrib.test_views :synopsis: dj-stripe Rest views for Subscription Tests.","title":"test_views"},{"location":"reference/project/#tests.test_contrib.test_views-classes","text":"tests.test_contrib.test_views.RestSubscriptionNotLoggedInTest Test the exceptions thrown by the subscription rest views. Methods tests . test_contrib . test_views . RestSubscriptionNotLoggedInTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_contrib/test_views.py def setUp ( self ): self . url = reverse ( \"rest_djstripe:subscription\" ) tests . test_contrib . test_views . RestSubscriptionNotLoggedInTest . test_create_subscription_not_logged_in ( self ) Source code in tests/test_contrib/test_views.py def test_create_subscription_not_logged_in ( self ): data = { \"plan\" : \"test0\" , \"stripe_token\" : \"cake\" } response = self . client . post ( self . url , data ) self . assertEqual ( response . status_code , status . HTTP_403_FORBIDDEN ) tests.test_contrib.test_views.RestSubscriptionTest Test the REST api for subscriptions. Methods tests . test_contrib . test_views . RestSubscriptionTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_contrib/test_views.py def setUp ( self ): self . url = reverse ( \"rest_djstripe:subscription\" ) self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" , password = \"password\" ) self . assertTrue ( self . client . login ( username = \"pydanny\" , password = \"password\" )) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_contrib . test_views . RestSubscriptionTest . test_cancel_subscription ( self , cancel_subscription_mock ) Test a DELETE to the SubscriptionRestView. Should cancel a Customer objects subscription. Source code in tests/test_contrib/test_views.py @patch ( \"djstripe.models.Subscription.cancel\" , autospec = True ) def test_cancel_subscription ( self , cancel_subscription_mock ): \"\"\"Test a DELETE to the SubscriptionRestView. Should cancel a Customer objects subscription. \"\"\" def _cancel_sub ( * args , ** kwargs ): subscription = Subscription . objects . first () subscription . status = SubscriptionStatus . canceled subscription . canceled_at = timezone . now () subscription . ended_at = timezone . now () subscription . save () return subscription fake_canceled_subscription = deepcopy ( FAKE_SUBSCRIPTION ) with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): Subscription . sync_from_stripe_data ( fake_canceled_subscription ) cancel_subscription_mock . side_effect = _cancel_sub self . assertEqual ( 1 , Subscription . objects . count ()) self . assertEqual ( Subscription . objects . first () . status , SubscriptionStatus . active ) response = self . client . delete ( self . url ) self . assertEqual ( response . status_code , status . HTTP_204_NO_CONTENT ) # Cancelled means flagged as canceled, so it should still be there self . assertEqual ( 1 , Subscription . objects . count ()) self . assertEqual ( Subscription . objects . first () . status , SubscriptionStatus . canceled ) cancel_subscription_mock . assert_called_once_with ( Subscription . objects . first (), at_period_end = djstripe_settings . CANCELLATION_AT_PERIOD_END , ) self . assertTrue ( self . user . is_authenticated ) tests . test_contrib . test_views . RestSubscriptionTest . test_cancel_subscription_exception ( self ) Test a DELETE to the SubscriptionRestView. Should return a 400 when an exception is raised. Source code in tests/test_contrib/test_views.py def test_cancel_subscription_exception ( self ): \"\"\"Test a DELETE to the SubscriptionRestView. Should return a 400 when an exception is raised. \"\"\" response = self . client . delete ( self . url ) self . assertEqual ( response . status_code , status . HTTP_400_BAD_REQUEST ) tests . test_contrib . test_views . RestSubscriptionTest . test_create_subscription ( self , add_card_mock , subscribe_mock ) Test a POST to the SubscriptionRestView. Should Create a Customer object Add a card to the Customer object Subcribe the Customer to a plan Source code in tests/test_contrib/test_views.py @patch ( \"djstripe.models.Customer.subscribe\" , autospec = True ) @patch ( \"djstripe.models.Customer.add_card\" , autospec = True ) def test_create_subscription ( self , add_card_mock , subscribe_mock ): \"\"\"Test a POST to the SubscriptionRestView. Should: - Create a Customer object - Add a card to the Customer object - Subcribe the Customer to a plan \"\"\" data = { \"plan\" : \"test0\" , \"stripe_token\" : \"cake\" } response = self . client . post ( self . url , data ) self . assertEqual ( 1 , Customer . objects . count ()) customer = Customer . objects . get () add_card_mock . assert_called_once_with ( customer , \"cake\" ) subscribe_mock . assert_called_once_with ( customer , \"test0\" , True ) self . assertEqual ( response . status_code , status . HTTP_201_CREATED ) data [ \"charge_immediately\" ] = None self . assertEqual ( response . data , data ) tests . test_contrib . test_views . RestSubscriptionTest . test_create_subscription_charge_immediately ( self , add_card_mock , subscribe_mock ) Test a POST to the SubscriptionRestView. Should be able to accept an charge_immediately. This will not send an invoice to the customer on subscribe. Source code in tests/test_contrib/test_views.py @patch ( \"djstripe.models.Customer.subscribe\" , autospec = True ) @patch ( \"djstripe.models.Customer.add_card\" , autospec = True ) def test_create_subscription_charge_immediately ( self , add_card_mock , subscribe_mock ): \"\"\"Test a POST to the SubscriptionRestView. Should be able to accept an charge_immediately. This will not send an invoice to the customer on subscribe. \"\"\" data = { \"plan\" : \"test0\" , \"stripe_token\" : \"cake\" , \"charge_immediately\" : False } response = self . client . post ( self . url , data ) self . assertEqual ( 1 , Customer . objects . count ()) customer = Customer . objects . get () subscribe_mock . assert_called_once_with ( customer , \"test0\" , False ) self . assertEqual ( response . status_code , status . HTTP_201_CREATED ) self . assertEqual ( response . data , data ) tests . test_contrib . test_views . RestSubscriptionTest . test_create_subscription_exception ( self , add_card_mock , subscribe_mock ) Test a POST to the SubscriptionRestView. Should return a 400 when an Exception is raised. Source code in tests/test_contrib/test_views.py @patch ( \"djstripe.models.Customer.subscribe\" , autospec = True ) @patch ( \"djstripe.models.Customer.add_card\" , autospec = True ) def test_create_subscription_exception ( self , add_card_mock , subscribe_mock ): \"\"\"Test a POST to the SubscriptionRestView. Should return a 400 when an Exception is raised. \"\"\" subscribe_mock . side_effect = Exception data = { \"plan\" : \"test0\" , \"stripe_token\" : \"cake\" } response = self . client . post ( self . url , data ) self . assertEqual ( response . status_code , status . HTTP_400_BAD_REQUEST ) tests . test_contrib . test_views . RestSubscriptionTest . test_create_subscription_incorrect_data ( self ) Test a POST to the SubscriptionRestView. Should return a 400 when a the serializer is invalid. Source code in tests/test_contrib/test_views.py def test_create_subscription_incorrect_data ( self ): \"\"\"Test a POST to the SubscriptionRestView. Should return a 400 when a the serializer is invalid. \"\"\" data = { \"foo\" : \"bar\" } response = self . client . post ( self . url , data ) self . assertEqual ( response . status_code , status . HTTP_400_BAD_REQUEST ) tests . test_contrib . test_views . RestSubscriptionTest . test_get_subscription ( self ) Test a GET to the SubscriptionRestView. Should return the correct data. Source code in tests/test_contrib/test_views.py def test_get_subscription ( self ): \"\"\"Test a GET to the SubscriptionRestView. Should return the correct data. \"\"\" with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) subscription = Subscription . sync_from_stripe_data ( deepcopy ( FAKE_SUBSCRIPTION )) response = self . client . get ( self . url ) self . assertEqual ( response . status_code , status . HTTP_200_OK ) self . assertEqual ( response . data [ \"plan\" ], plan . pk ) self . assertEqual ( response . data [ \"status\" ], subscription . status ) self . assertEqual ( response . data [ \"cancel_at_period_end\" ], subscription . cancel_at_period_end )","title":"Classes"},{"location":"reference/project/#tests.test_coupon","text":"","title":"test_coupon"},{"location":"reference/project/#tests.test_coupon.HumanReadableCouponTest","text":"tests . test_coupon . HumanReadableCouponTest . test_human_readable_eur_off_forever ( self ) Source code in tests/test_coupon.py def test_human_readable_eur_off_forever ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-amount-off-forever\" , amount_off = 10 , currency = \"eur\" , duration = \"forever\" , ) self . assertEqual ( coupon . human_readable , \"\u20ac10.00 EUR off forever\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_integer_percent_off_forever ( self ) Source code in tests/test_coupon.py def test_human_readable_integer_percent_off_forever ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-percent-off-forever\" , percent_off = 10 , currency = \"usd\" , duration = \"forever\" , ) self . assertEqual ( coupon . human_readable , \"10 % o ff forever\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_percent_off_forever ( self ) Source code in tests/test_coupon.py def test_human_readable_percent_off_forever ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-percent-off-forever\" , percent_off = 10.25 , currency = \"usd\" , duration = \"forever\" , ) self . assertEqual ( coupon . human_readable , \"10.25 % o ff forever\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_percent_off_once ( self ) Source code in tests/test_coupon.py def test_human_readable_percent_off_once ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-percent-off-once\" , percent_off = 10.25 , currency = \"usd\" , duration = \"once\" , ) self . assertEqual ( coupon . human_readable , \"10.25 % o ff once\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_percent_off_one_month ( self ) Source code in tests/test_coupon.py def test_human_readable_percent_off_one_month ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-percent-off-1month\" , percent_off = 10.25 , currency = \"usd\" , duration = \"repeating\" , duration_in_months = 1 , ) self . assertEqual ( coupon . human_readable , \"10.25 % o ff for 1 month\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_percent_off_three_months ( self ) Source code in tests/test_coupon.py def test_human_readable_percent_off_three_months ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-percent-off-3month\" , percent_off = 10.25 , currency = \"usd\" , duration = \"repeating\" , duration_in_months = 3 , ) self . assertEqual ( coupon . human_readable , \"10.25 % o ff for 3 months\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_human_readable_usd_off_forever ( self ) Source code in tests/test_coupon.py def test_human_readable_usd_off_forever ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-amount-off-forever\" , amount_off = 10 , currency = \"usd\" , duration = \"forever\" , ) self . assertEqual ( coupon . human_readable , \"$10.00 USD off forever\" ) self . assertEqual ( str ( coupon ), coupon . human_readable ) tests . test_coupon . HumanReadableCouponTest . test_str_name ( self ) Source code in tests/test_coupon.py def test_str_name ( self ): coupon = Coupon . objects . create ( id = \"coupon-test-amount-off-forever\" , amount_off = 10 , currency = \"usd\" , duration = \"forever\" , name = \"Test coupon\" , ) self . assertEqual ( str ( coupon ), \"Test coupon\" )","title":"HumanReadableCouponTest"},{"location":"reference/project/#tests.test_coupon.TransferTest","text":"tests . test_coupon . TransferTest . test_retrieve_coupon ( self ) Source code in tests/test_coupon.py def test_retrieve_coupon ( self ): coupon_data = deepcopy ( FAKE_COUPON ) coupon = Coupon . sync_from_stripe_data ( coupon_data ) self . assertEqual ( coupon . id , FAKE_COUPON [ \"id\" ])","title":"TransferTest"},{"location":"reference/project/#tests.test_coupon.test_blank_coupon_str","text":"Source code in tests/test_coupon.py def test_blank_coupon_str (): coupon = Coupon () assert str ( coupon ) . strip () == \"(invalid amount) off\"","title":"test_blank_coupon_str()"},{"location":"reference/project/#tests.test_customer","text":"Customer Model Tests.","title":"test_customer"},{"location":"reference/project/#tests.test_customer-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_customer.TestCustomer","text":"","title":"TestCustomer"},{"location":"reference/project/#tests.test_customer.TestCustomer-methods","text":"tests . test_customer . TestCustomer . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_customer.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . payment_method , _ = DjstripePaymentMethod . _get_or_create_source ( FAKE_CARD , \"card\" ) self . card = self . payment_method . resolve () self . customer . default_source = self . payment_method self . customer . save () self . account = default_account () tests . test_customer . TestCustomer . test_add_card_set_default_false ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_add_card_set_default_false ( self , customer_retrieve_mock ): self . customer . add_card ( FAKE_CARD [ \"id\" ], set_default = False ) self . customer . add_card ( FAKE_CARD_V [ \"id\" ], set_default = False ) self . assertEqual ( 2 , Card . objects . count ()) self . assertEqual ( FAKE_CARD [ \"id\" ], self . customer . default_source . id ) tests . test_customer . TestCustomer . test_add_card_set_default_false_with_single_card_still_becomes_default ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_add_card_set_default_false_with_single_card_still_becomes_default ( self , customer_retrieve_mock ): self . customer . add_card ( FAKE_CARD [ \"id\" ], set_default = False ) self . assertEqual ( 2 , Card . objects . count ()) self . assertEqual ( FAKE_CARD [ \"id\" ], self . customer . default_source . id ) tests . test_customer . TestCustomer . test_add_card_set_default_true ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_add_card_set_default_true ( self , customer_retrieve_mock ): self . customer . add_card ( FAKE_CARD [ \"id\" ]) self . customer . add_card ( FAKE_CARD_V [ \"id\" ]) self . assertEqual ( 2 , Card . objects . count ()) self . assertEqual ( FAKE_CARD_V [ \"id\" ], self . customer . default_source . id ) tests . test_customer . TestCustomer . test_add_coupon_by_id ( self , customer_retrieve_mock , coupon_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Coupon.retrieve\" , return_value = deepcopy ( FAKE_COUPON ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_add_coupon_by_id ( self , customer_retrieve_mock , coupon_retrieve_mock ): self . assertEqual ( self . customer . coupon , None ) self . customer . add_coupon ( FAKE_COUPON [ \"id\" ]) customer_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = ANY , id = FAKE_CUSTOMER [ \"id\" ], stripe_account = None , ) tests . test_customer . TestCustomer . test_add_coupon_by_object ( self , customer_retrieve_mock , coupon_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Coupon.retrieve\" , return_value = deepcopy ( FAKE_COUPON ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_add_coupon_by_object ( self , customer_retrieve_mock , coupon_retrieve_mock ): self . assertEqual ( self . customer . coupon , None ) coupon = Coupon . sync_from_stripe_data ( FAKE_COUPON ) fake_discount = deepcopy ( FAKE_DISCOUNT_CUSTOMER ) def fake_customer_save ( self , * args , ** kwargs ): # fake the api coupon update behaviour coupon = self . pop ( \"coupon\" , None ) if coupon : self [ \"discount\" ] = fake_discount else : self [ \"discount\" ] = None return self with patch ( \"tests.CustomerDict.save\" , new = fake_customer_save ): self . customer . add_coupon ( coupon ) customer_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = ANY , id = FAKE_CUSTOMER [ \"id\" ], stripe_account = None , ) self . customer . refresh_from_db () self . assert_fks ( self . customer , expected_blank_fks = { \"djstripe.Customer.default_payment_method\" }, ) tests . test_customer . TestCustomer . test_add_invoice_item ( self , invoiceitem_create_mock , invoiceitem_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.InvoiceItem.sync_from_stripe_data\" , return_value = \"pancakes\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.InvoiceItem.create\" , return_value = deepcopy ( FAKE_INVOICEITEM ), autospec = True , ) def test_add_invoice_item ( self , invoiceitem_create_mock , invoiceitem_sync_mock ): invoiceitem = self . customer . add_invoice_item ( amount = decimal . Decimal ( \"50.00\" ), currency = \"eur\" , description = \"test\" , invoice = 77 , subscription = 25 , ) self . assertEqual ( \"pancakes\" , invoiceitem ) invoiceitem_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , amount = 5000 , customer = self . customer . id , currency = \"eur\" , description = \"test\" , discountable = None , invoice = 77 , metadata = None , subscription = 25 , ) tests . test_customer . TestCustomer . test_add_invoice_item_bad_decimal ( self ) Source code in tests/test_customer.py def test_add_invoice_item_bad_decimal ( self ): with self . assertRaisesMessage ( ValueError , \"You must supply a decimal value representing dollars.\" ): self . customer . add_invoice_item ( amount = 5000 , currency = \"usd\" ) tests . test_customer . TestCustomer . test_add_invoice_item_djstripe_objects ( self , invoiceitem_create_mock , invoiceitem_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.InvoiceItem.sync_from_stripe_data\" , return_value = \"pancakes\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.InvoiceItem.create\" , return_value = deepcopy ( FAKE_INVOICEITEM ), autospec = True , ) def test_add_invoice_item_djstripe_objects ( self , invoiceitem_create_mock , invoiceitem_sync_mock ): invoiceitem = self . customer . add_invoice_item ( amount = decimal . Decimal ( \"50.00\" ), currency = \"eur\" , description = \"test\" , invoice = Invoice ( id = 77 ), subscription = Subscription ( id = 25 ), ) self . assertEqual ( \"pancakes\" , invoiceitem ) invoiceitem_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , amount = 5000 , customer = self . customer . id , currency = \"eur\" , description = \"test\" , discountable = None , invoice = 77 , metadata = None , subscription = 25 , ) tests . test_customer . TestCustomer . test_add_payment_method_obj ( self , attach_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_add_payment_method_obj ( self , attach_mock , customer_retrieve_mock ): self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 0 , ) payment_method = PaymentMethod . sync_from_stripe_data ( FAKE_PAYMENT_METHOD_I ) payment_method = self . customer . add_payment_method ( payment_method ) self . assertEqual ( payment_method . customer . id , self . customer . id ) self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 1 , ) self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . first (), self . customer . default_payment_method , ) self . assertEqual ( self . customer . default_payment_method . id , self . customer . invoice_settings [ \"default_payment_method\" ], ) self . assert_fks ( self . customer , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_customer . TestCustomer . test_add_payment_method_set_default_false ( self , attach_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_add_payment_method_set_default_false ( self , attach_mock , customer_retrieve_mock ): # clear default source so we can check can_charge() fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"default_source\" ] = None customer_retrieve_mock . return_value = fake_customer self . customer . default_source = None self . customer . save () self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 0 , ) payment_method = self . customer . add_payment_method ( FAKE_PAYMENT_METHOD_I [ \"id\" ], set_default = False ) self . assertEqual ( payment_method . customer . id , self . customer . id ) self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 1 , ) self . assertFalse ( self . customer . can_charge (), \"Expect not to be able to charge since we've not set a \" \"default_payment_method\" , ) self . assert_fks ( self . customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , }, ) tests . test_customer . TestCustomer . test_add_payment_method_set_default_true ( self , attach_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_add_payment_method_set_default_true ( self , attach_mock , customer_retrieve_mock ): # clear default source so we can check can_charge() fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"default_source\" ] = None customer_retrieve_mock . return_value = fake_customer self . customer . default_source = None self . customer . save () self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 0 , ) payment_method = self . customer . add_payment_method ( FAKE_PAYMENT_METHOD_I [ \"id\" ]) self . assertEqual ( payment_method . customer . id , self . customer . id ) self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . count (), 1 , ) self . assertEqual ( self . customer . payment_methods . filter ( id = FAKE_PAYMENT_METHOD_I [ \"id\" ] ) . first (), self . customer . default_payment_method , ) self . assertEqual ( self . customer . default_payment_method . id , self . customer . invoice_settings [ \"default_payment_method\" ], ) self . assertTrue ( self . customer . can_charge (), \"Expect to be able to charge since we've set a default_payment_method\" , ) self . assert_fks ( self . customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_source\" , }, ) tests . test_customer . TestCustomer . test_balance ( self ) Source code in tests/test_customer.py def test_balance ( self ): self . assertEqual ( self . customer . balance , 0 ) self . assertEqual ( self . customer . credits , 0 ) self . customer . balance = 1000 self . assertEqual ( self . customer . balance , 1000 ) self . assertEqual ( self . customer . credits , 0 ) self . assertEqual ( self . customer . pending_charges , 1000 ) self . customer . balance = - 1000 self . assertEqual ( self . customer . balance , - 1000 ) self . assertEqual ( self . customer . credits , 1000 ) self . assertEqual ( self . customer . pending_charges , 0 ) tests . test_customer . TestCustomer . test_calculate_refund_above_max_refund ( self ) Source code in tests/test_customer.py def test_calculate_refund_above_max_refund ( self ): charge = Charge ( id = \"ch_111111\" , customer = self . customer , amount = decimal . Decimal ( \"500.00\" ) ) self . assertEqual ( charge . _calculate_refund_amount ( amount = decimal . Decimal ( \"600.00\" )), 50000 ) tests . test_customer . TestCustomer . test_calculate_refund_amount_partial_refund ( self ) Source code in tests/test_customer.py def test_calculate_refund_amount_partial_refund ( self ): charge = Charge ( id = \"ch_111111\" , customer = self . customer , amount = decimal . Decimal ( \"500.00\" ) ) self . assertEqual ( charge . _calculate_refund_amount ( amount = decimal . Decimal ( \"300.00\" )), 30000 ) tests . test_customer . TestCustomer . test_can_charge ( self ) Source code in tests/test_customer.py def test_can_charge ( self ): self . assertTrue ( self . customer . can_charge ()) tests . test_customer . TestCustomer . test_cannot_charge ( self , customer_retrieve_fake ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_cannot_charge ( self , customer_retrieve_fake ): self . customer . delete () self . assertFalse ( self . customer . can_charge ()) tests . test_customer . TestCustomer . test_charge_accepts_only_decimals ( self ) Source code in tests/test_customer.py def test_charge_accepts_only_decimals ( self ): with self . assertRaises ( ValueError ): self . customer . charge ( 10 ) tests . test_customer . TestCustomer . test_charge_card_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.create\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_charge_card_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"invoice\" : None }) charge_create_mock . return_value = fake_charge_copy charge_retrieve_mock . return_value = fake_charge_copy fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent self . customer . charge ( amount = decimal . Decimal ( \"10.00\" ), source = self . card ) tests . test_customer . TestCustomer . test_charge_converts_dollars_into_cents ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.create\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_charge_converts_dollars_into_cents ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"invoice\" : None , \"amount\" : 1000 }) charge_create_mock . return_value = fake_charge_copy charge_retrieve_mock . return_value = fake_charge_copy fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent self . customer . charge ( amount = decimal . Decimal ( \"10.00\" )) _ , kwargs = charge_create_mock . call_args self . assertEqual ( kwargs [ \"amount\" ], 1000 ) tests . test_customer . TestCustomer . test_charge_doesnt_require_invoice ( self , subscription_retrieve_mock , product_retrieve_mock , invoice_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.create\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_charge_doesnt_require_invoice ( self , subscription_retrieve_mock , product_retrieve_mock , invoice_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ( { \"invoice\" : FAKE_INVOICE [ \"id\" ], \"amount\" : FAKE_INVOICE [ \"amount_due\" ]} ) fake_invoice_copy = deepcopy ( FAKE_INVOICE ) charge_create_mock . return_value = fake_charge_copy charge_retrieve_mock . return_value = fake_charge_copy invoice_retrieve_mock . return_value = fake_invoice_copy try : self . customer . charge ( amount = decimal . Decimal ( \"20.00\" )) except Invoice . DoesNotExist : self . fail ( msg = \"Stripe Charge shouldn't throw Invoice DoesNotExist.\" ) tests . test_customer . TestCustomer . test_charge_passes_extra_arguments ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.create\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_charge_passes_extra_arguments ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"invoice\" : None }) charge_create_mock . return_value = fake_charge_copy charge_retrieve_mock . return_value = fake_charge_copy fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent self . customer . charge ( amount = decimal . Decimal ( \"10.00\" ), capture = True , destination = FAKE_ACCOUNT [ \"id\" ], ) _ , kwargs = charge_create_mock . call_args self . assertEqual ( kwargs [ \"capture\" ], True ) self . assertEqual ( kwargs [ \"destination\" ], FAKE_ACCOUNT [ \"id\" ]) tests . test_customer . TestCustomer . test_charge_string_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.create\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_charge_string_source ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_create_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_copy = deepcopy ( FAKE_CHARGE ) fake_charge_copy . update ({ \"invoice\" : None }) charge_create_mock . return_value = fake_charge_copy charge_retrieve_mock . return_value = fake_charge_copy fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent self . customer . charge ( amount = decimal . Decimal ( \"10.00\" ), source = self . card . id ) tests . test_customer . TestCustomer . test_customer_create_metadata_disabled ( self , customer_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.create\" , autospec = True ) def test_customer_create_metadata_disabled ( self , customer_mock ): user = get_user_model () . objects . create_user ( username = \"test_user_create_metadata_disabled\" ) fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"id\" ] = \"cus_test_create_metadata_disabled\" customer_mock . return_value = fake_customer djstripe_settings . SUBSCRIBER_CUSTOMER_KEY = \"\" customer = Customer . create ( user ) djstripe_settings . SUBSCRIBER_CUSTOMER_KEY = \"djstripe_subscriber\" customer_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , email = \"\" , idempotency_key = None , metadata = {}, stripe_account = None , ) self . assertEqual ( customer . metadata , None ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , }, ) tests . test_customer . TestCustomer . test_customer_dashboard_url ( self ) Source code in tests/test_customer.py def test_customer_dashboard_url ( self ): expected_url = \"https://dashboard.stripe.com/test/customers/ {} \" . format ( self . customer . id ) self . assertEqual ( self . customer . get_stripe_dashboard_url (), expected_url ) self . customer . livemode = True expected_url = \"https://dashboard.stripe.com/customers/ {} \" . format ( self . customer . id ) self . assertEqual ( self . customer . get_stripe_dashboard_url (), expected_url ) unsaved_customer = Customer () self . assertEqual ( unsaved_customer . get_stripe_dashboard_url (), \"\" ) tests . test_customer . TestCustomer . test_customer_delete_raises_unexpected_exception ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) def test_customer_delete_raises_unexpected_exception ( self , customer_retrieve_mock ): customer_retrieve_mock . side_effect = InvalidRequestError ( \"Unexpected Exception\" , \"blah\" ) with self . assertRaisesMessage ( InvalidRequestError , \"Unexpected Exception\" ): self . customer . purge () customer_retrieve_mock . assert_called_once_with ( id = self . customer . id , api_key = STRIPE_SECRET_KEY , expand = ANY , stripe_account = None , ) tests . test_customer . TestCustomer . test_customer_delete_same_as_purge ( self , customer_retrieve_fake ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) def test_customer_delete_same_as_purge ( self , customer_retrieve_fake ): self . customer . delete () customer = Customer . objects . get ( id = self . customer . id ) self . assertTrue ( customer . subscriber is None ) self . assertTrue ( customer . default_source is None ) self . assertTrue ( not customer . legacy_cards . all ()) self . assertTrue ( not customer . sources . all ()) self . assertTrue ( get_user_model () . objects . filter ( pk = self . user . pk ) . exists ()) tests . test_customer . TestCustomer . test_customer_purge_deletes_idempotency_key ( self , customer_api_create_fake ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.create\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True ) def test_customer_purge_deletes_idempotency_key ( self , customer_api_create_fake ): # We need to call Customer.get_or_create (which setUp doesn't) # to get an idempotency key user = get_user_model () . objects . create_user ( username = \"blah\" , email = FAKE_CUSTOMER_II [ \"email\" ] ) idempotency_key_action = \"customer:create: {} \" . format ( user . pk ) self . assertFalse ( IdempotencyKey . objects . filter ( action = idempotency_key_action ) . exists () ) customer , created = Customer . get_or_create ( user ) self . assertTrue ( IdempotencyKey . objects . filter ( action = idempotency_key_action ) . exists () ) with patch ( \"stripe.Customer.retrieve\" , autospec = True ): customer . purge () self . assertFalse ( IdempotencyKey . objects . filter ( action = idempotency_key_action ) . exists () ) tests . test_customer . TestCustomer . test_customer_purge_detaches_sources ( self , customer_api_create_fake ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.create\" , autospec = True ) def test_customer_purge_detaches_sources ( self , customer_api_create_fake ): fake_customer = deepcopy ( FAKE_CUSTOMER_III ) customer_api_create_fake . return_value = fake_customer user = get_user_model () . objects . create_user ( username = \"blah\" , email = FAKE_CUSTOMER_III [ \"email\" ] ) Customer . get_or_create ( user ) customer = Customer . sync_from_stripe_data ( deepcopy ( FAKE_CUSTOMER_III )) self . assertIsNotNone ( customer . default_source ) self . assertNotEqual ( customer . sources . count (), 0 ) with patch ( \"stripe.Customer.retrieve\" , autospec = True ), patch ( \"stripe.Source.retrieve\" , return_value = deepcopy ( FAKE_SOURCE ), autospec = True ): customer . purge () self . assertIsNone ( customer . default_source ) self . assertEqual ( customer . sources . count (), 0 ) tests . test_customer . TestCustomer . test_customer_purge_leaves_customer_record ( self , customer_retrieve_fake ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) def test_customer_purge_leaves_customer_record ( self , customer_retrieve_fake ): self . customer . purge () customer = Customer . objects . get ( id = self . customer . id ) self . assertTrue ( customer . subscriber is None ) self . assertTrue ( customer . default_source is None ) self . assertTrue ( not customer . legacy_cards . all ()) self . assertTrue ( not customer . sources . all ()) self . assertTrue ( get_user_model () . objects . filter ( pk = self . user . pk ) . exists ()) tests . test_customer . TestCustomer . test_customer_purge_raises_customer_exception ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) def test_customer_purge_raises_customer_exception ( self , customer_retrieve_mock ): customer_retrieve_mock . side_effect = InvalidRequestError ( \"No such customer:\" , \"blah\" ) self . customer . purge () customer = Customer . objects . get ( id = self . customer . id ) self . assertTrue ( customer . subscriber is None ) self . assertTrue ( customer . default_source is None ) self . assertTrue ( not customer . legacy_cards . all ()) self . assertTrue ( not customer . sources . all ()) self . assertTrue ( get_user_model () . objects . filter ( pk = self . user . pk ) . exists ()) customer_retrieve_mock . assert_called_with ( id = self . customer . id , api_key = STRIPE_SECRET_KEY , expand = ANY , stripe_account = None , ) self . assertEqual ( 3 , customer_retrieve_mock . call_count ) tests . test_customer . TestCustomer . test_customer_sync_add_tax_id_to_existing_customer ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_WITH_TAX_ID )) def test_customer_sync_add_tax_id_to_existing_customer ( self , customer_retrieve_mock ): customer = Customer . sync_from_stripe_data ( deepcopy ( FAKE_CUSTOMER_BEFORE_TAX_ID )) self . assertEqual ( customer . tax_ids . count (), 0 ) Customer . sync_from_stripe_data ( deepcopy ( FAKE_CUSTOMER_WITH_TAX_ID )) self . assertEqual ( customer . tax_ids . count (), 1 ) self . assertEqual ( customer . tax_ids . last () . value , \"DE123456789\" ) self . assertEqual ( customer . tax_ids . last () . type , \"eu_vat\" ) tests . test_customer . TestCustomer . test_customer_sync_bank_account_source ( self , bank_account_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.BankAccount.retrieve\" , return_value = FAKE_CUSTOMER_IV [ \"default_source\" ], autospec = True , ) def test_customer_sync_bank_account_source ( self , bank_account_retrieve_mock ): fake_customer = deepcopy ( FAKE_CUSTOMER_IV ) user = get_user_model () . objects . create_user ( username = \"test_user_sync_bank_account_source\" ) customer = fake_customer . create_for_user ( user ) self . assertEqual ( customer . sources . count (), 0 ) self . assertEqual ( customer . legacy_cards . count (), 0 ) self . assertEqual ( customer . bank_account . count (), 1 ) self . assertEqual ( customer . default_source . id , fake_customer [ \"default_source\" ][ \"id\" ] ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_create_customer_and_tax_ids ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_WITH_TAX_ID )) def test_customer_sync_create_customer_and_tax_ids ( self , customer_retrieve_mock ): customer = Customer . sync_from_stripe_data ( customer_retrieve_mock . return_value ) self . assertEqual ( customer . tax_ids . count (), 1 ) self . assertEqual ( customer . tax_ids . last () . value , \"DE123456789\" ) self . assertEqual ( customer . tax_ids . last () . type , \"eu_vat\" ) tests . test_customer . TestCustomer . test_customer_sync_default_payment_method_string ( self , attach_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I ) ) def test_customer_sync_default_payment_method_string ( self , attach_mock , customer_retrieve_mock ): Customer . objects . all () . delete () PaymentMethod . objects . all () . delete () customer_fake = deepcopy ( FAKE_CUSTOMER ) customer_fake [ \"invoice_settings\" ][ \"default_payment_method\" ] = FAKE_PAYMENT_METHOD_I [ \"id\" ] customer_retrieve_mock . return_value = customer_fake customer = Customer . sync_from_stripe_data ( customer_fake ) self . assertEqual ( customer . default_payment_method . id , customer_fake [ \"invoice_settings\" ][ \"default_payment_method\" ], ) self . assertEqual ( customer . payment_methods . count (), 1 ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.subscriber\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_default_source_string ( self ) Source code in tests/test_customer.py def test_customer_sync_default_source_string ( self ): Customer . objects . all () . delete () Card . objects . all () . delete () customer_fake = deepcopy ( FAKE_CUSTOMER ) customer_fake [ \"default_source\" ] = customer_fake [ \"sources\" ][ \"data\" ][ 0 ][ \"id\" ] = \"card_sync_source_string\" customer = Customer . sync_from_stripe_data ( customer_fake ) self . assertEqual ( customer . default_source . id , customer_fake [ \"default_source\" ]) self . assertEqual ( customer . legacy_cards . count (), 2 ) self . assertEqual ( len ( list ( customer . customer_payment_methods )), 2 ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_has_bad_subscriber_metadata ( self ) Source code in tests/test_customer.py def test_customer_sync_has_bad_subscriber_metadata ( self ): fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"id\" ] = \"cus_sync_has_bad_subscriber_metadata\" fake_customer [ \"metadata\" ] = { \"djstripe_subscriber\" : \"does_not_exist\" } customer = Customer . sync_from_stripe_data ( fake_customer ) self . assertEqual ( customer . subscriber , None ) self . assertEqual ( customer . metadata , { \"djstripe_subscriber\" : \"does_not_exist\" }) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_has_subscriber_metadata ( self ) Source code in tests/test_customer.py def test_customer_sync_has_subscriber_metadata ( self ): user = get_user_model () . objects . create ( username = \"test_metadata\" , id = 12345 ) fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"id\" ] = \"cus_sync_has_subscriber_metadata\" fake_customer [ \"metadata\" ] = { \"djstripe_subscriber\" : \"12345\" } customer = Customer . sync_from_stripe_data ( fake_customer ) self . assertEqual ( customer . subscriber , user ) self . assertEqual ( customer . metadata , { \"djstripe_subscriber\" : \"12345\" }) tests . test_customer . TestCustomer . test_customer_sync_has_subscriber_metadata_disabled ( self ) Source code in tests/test_customer.py def test_customer_sync_has_subscriber_metadata_disabled ( self ): user = get_user_model () . objects . create ( username = \"test_metadata_disabled\" , id = 98765 ) fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"id\" ] = \"cus_test_metadata_disabled\" fake_customer [ \"metadata\" ] = { \"djstripe_subscriber\" : \"98765\" } with patch ( \"djstripe.settings.SUBSCRIBER_CUSTOMER_KEY\" , return_value = \"\" , autospec = True ): customer = Customer . sync_from_stripe_data ( fake_customer ) self . assertNotEqual ( customer . subscriber , user ) self . assertNotEqual ( customer . subscriber_id , 98765 ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_no_sources ( self , customer_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.create\" , autospec = True ) def test_customer_sync_no_sources ( self , customer_mock ): fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"id\" ] = \"cus_test_sync_no_sources\" fake_customer [ \"default_source\" ] = None fake_customer [ \"sources\" ] = None customer_mock . return_value = fake_customer user = get_user_model () . objects . create_user ( username = \"test_user_sync_non_local_card\" ) customer = Customer . create ( user ) self . assertEqual ( customer_mock . call_args_list [ 0 ][ 1 ] . get ( \"metadata\" ), { \"djstripe_subscriber\" : user . pk }, ) self . assertEqual ( customer . sources . count (), 0 ) self . assertEqual ( customer . legacy_cards . count (), 0 ) self . assertEqual ( customer . default_source , None ) self . assert_fks ( customer , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.default_source\" , }, ) tests . test_customer . TestCustomer . test_customer_sync_non_local_card ( self , card_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Card.retrieve\" , return_value = FAKE_CUSTOMER_II [ \"default_source\" ], autospec = True , ) def test_customer_sync_non_local_card ( self , card_retrieve_mock ): fake_customer = deepcopy ( FAKE_CUSTOMER_II ) fake_customer [ \"id\" ] = fake_customer [ \"sources\" ][ \"data\" ][ 0 ][ \"customer\" ] = \"cus_test_sync_non_local_card\" user = get_user_model () . objects . create_user ( username = \"test_user_sync_non_local_card\" ) customer = fake_customer . create_for_user ( user ) self . assertEqual ( customer . sources . count (), 0 ) self . assertEqual ( customer . legacy_cards . count (), 1 ) self . assertEqual ( customer . default_source . id , fake_customer [ \"default_source\" ][ \"id\" ] ) tests . test_customer . TestCustomer . test_customer_sync_unsupported_source ( self ) Source code in tests/test_customer.py def test_customer_sync_unsupported_source ( self ): fake_customer = deepcopy ( FAKE_CUSTOMER_II ) fake_customer [ \"default_source\" ][ \"object\" ] = fake_customer [ \"sources\" ][ \"data\" ][ 0 ][ \"object\" ] = \"fish\" user = get_user_model () . objects . create_user ( username = \"test_user_sync_unsupported_source\" ) synced_customer = fake_customer . create_for_user ( user ) self . assertEqual ( 0 , synced_customer . legacy_cards . count ()) self . assertEqual ( 0 , synced_customer . sources . count ()) self . assertEqual ( synced_customer . default_source , DjstripePaymentMethod . objects . get ( id = fake_customer [ \"default_source\" ][ \"id\" ]), ) tests . test_customer . TestCustomer . test_delete_subscriber_without_customer_is_noop ( self , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) def test_delete_subscriber_without_customer_is_noop ( self , customer_retrieve_mock ): self . user . delete () for customer in self . user . djstripe_customers . all (): self . assertIsNone ( customer . date_purged ) tests . test_customer . TestCustomer . test_has_active_subscription_with_unspecified_price_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_has_active_subscription_with_unspecified_price_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . assert_fks ( price , expected_blank_fks = {}) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_fake_duplicate = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake_duplicate [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_fake_duplicate [ \"id\" ] = \"sub_6lsC8pt7IcF8jd\" subscription_create_mock . side_effect = [ subscription_fake , subscription_fake_duplicate , ] self . customer . subscribe ( price = price , charge_immediately = False ) self . customer . subscribe ( price = price , charge_immediately = False ) self . assertEqual ( 2 , self . customer . subscriptions . count ()) with self . assertRaises ( TypeError ): self . customer . has_active_subscription () tests . test_customer . TestCustomer . test_is_subscribed_to_with_product ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_is_subscribed_to_with_product ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) product = Product . sync_from_stripe_data ( deepcopy ( FAKE_PRODUCT )) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_create_mock . return_value = subscription_fake self . customer . subscribe ( price = price , charge_immediately = False ) assert self . customer . is_subscribed_to ( product ) tests . test_customer . TestCustomer . test_is_subscribed_to_with_product_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_is_subscribed_to_with_product_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) product = Product . sync_from_stripe_data ( deepcopy ( FAKE_PRODUCT )) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_create_mock . return_value = subscription_fake self . customer . subscribe ( price = price , charge_immediately = False ) assert self . customer . is_subscribed_to ( product . id ) tests . test_customer . TestCustomer . test_refund_charge ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_refund_charge ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_no_invoice = deepcopy ( FAKE_CHARGE ) fake_charge_no_invoice . update ({ \"invoice\" : None }) charge_retrieve_mock . return_value = fake_charge_no_invoice fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent charge , created = Charge . _get_or_create_from_stripe_object ( fake_charge_no_invoice ) self . assertTrue ( created ) self . assert_fks ( charge , expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , }, ) charge . refund () refunded_charge , created2 = Charge . _get_or_create_from_stripe_object ( fake_charge_no_invoice ) self . assertFalse ( created2 ) self . assertEqual ( refunded_charge . refunded , True ) self . assertEqual ( refunded_charge . amount_refunded , decimal . Decimal ( \"20.00\" )) self . assert_fks ( refunded_charge , expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , }, ) tests . test_customer . TestCustomer . test_refund_charge_object_returned ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) def test_refund_charge_object_returned ( self , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_charge_no_invoice = deepcopy ( FAKE_CHARGE ) fake_charge_no_invoice . update ({ \"invoice\" : None }) charge_retrieve_mock . return_value = fake_charge_no_invoice fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent . update ({ \"invoice\" : None }) payment_intent_retrieve_mock . return_value = fake_payment_intent charge , created = Charge . _get_or_create_from_stripe_object ( fake_charge_no_invoice ) self . assertTrue ( created ) self . assert_fks ( charge , expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , }, ) refunded_charge = charge . refund () self . assertEqual ( refunded_charge . refunded , True ) self . assertEqual ( refunded_charge . amount_refunded , decimal . Decimal ( \"20.00\" )) self . assert_fks ( refunded_charge , expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_invoice (related name)\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.invoice\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , }, ) tests . test_customer . TestCustomer . test_retry_unpaid_invoices ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_INVOICE ), deepcopy ( FAKE_INVOICE_III )] ), autospec = True , ) @patch ( \"djstripe.models.Invoice.retry\" , autospec = True ) def test_retry_unpaid_invoices ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account self . customer . retry_unpaid_invoices () invoice = Invoice . objects . get ( id = FAKE_INVOICE_III [ \"id\" ]) invoice_retry_mock . assert_called_once_with ( invoice ) tests . test_customer . TestCustomer . test_retry_unpaid_invoices_expected_exception ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_INVOICE_III )]), ) @patch ( \"djstripe.models.Invoice.retry\" , autospec = True ) def test_retry_unpaid_invoices_expected_exception ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_retry_mock . side_effect = InvalidRequestError ( \"Invoice is already paid\" , \"blah\" ) try : self . customer . retry_unpaid_invoices () except Exception : self . fail ( \"Exception was unexpectedly raised.\" ) tests . test_customer . TestCustomer . test_retry_unpaid_invoices_none_unpaid ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_INVOICE )]), autospec = True , ) @patch ( \"djstripe.models.Invoice.retry\" , autospec = True ) def test_retry_unpaid_invoices_none_unpaid ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account self . customer . retry_unpaid_invoices () self . assertFalse ( invoice_retry_mock . called ) tests . test_customer . TestCustomer . test_retry_unpaid_invoices_unexpected_exception ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , default_account_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_INVOICE_III )]), ) @patch ( \"djstripe.models.Invoice.retry\" , autospec = True ) def test_retry_unpaid_invoices_unexpected_exception ( self , invoice_retry_mock , invoice_list_mock , product_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_retry_mock . side_effect = InvalidRequestError ( \"This should fail!\" , \"blah\" ) with self . assertRaisesMessage ( InvalidRequestError , \"This should fail!\" ): self . customer . retry_unpaid_invoices () tests . test_customer . TestCustomer . test_send_invoice_failure ( self , invoice_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Invoice.create\" , autospec = True ) def test_send_invoice_failure ( self , invoice_create_mock ): invoice_create_mock . side_effect = InvalidRequestError ( \"Invoice creation failed.\" , \"blah\" ) return_status = self . customer . send_invoice () self . assertFalse ( return_status ) invoice_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , customer = self . customer . id ) tests . test_customer . TestCustomer . test_send_invoice_success ( self , invoice_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Invoice.create\" , autospec = True ) def test_send_invoice_success ( self , invoice_create_mock ): return_status = self . customer . send_invoice () self . assertTrue ( return_status ) invoice_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , customer = self . customer . id ) tests . test_customer . TestCustomer . test_str ( self ) Source code in tests/test_customer.py def test_str ( self ): self . assertEqual ( str ( self . customer ), str ( self . user )) self . customer . subscriber = None self . assertEqual ( str ( self . customer ), self . customer . description ) tests . test_customer . TestCustomer . test_subscribe_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . assert_fks ( price , expected_blank_fks = {}) self . customer . subscribe ( price = price , charge_immediately = True ) self . assertTrue ( send_invoice_mock . called ) tests . test_customer . TestCustomer . test_subscribe_not_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_not_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . customer . subscribe ( price = price , charge_immediately = False ) self . assertFalse ( send_invoice_mock . called ) tests . test_customer . TestCustomer . test_subscribe_price_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_price_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . assert_fks ( price , expected_blank_fks = {}) self . customer . subscribe ( price = price . id , charge_immediately = True ) self . assertTrue ( send_invoice_mock . called ) tests . test_customer . TestCustomer . test_subscription_shortcut_with_invalid_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscription_shortcut_with_invalid_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . assert_fks ( price , expected_blank_fks = {}) fake_subscriptions = [ deepcopy ( FAKE_SUBSCRIPTION ), deepcopy ( FAKE_SUBSCRIPTION ), deepcopy ( FAKE_SUBSCRIPTION ), ] # update the status of all but one to be invalid, # we need to also change the id for sync to work fake_subscriptions [ 1 ][ \"status\" ] = \"canceled\" fake_subscriptions [ 1 ][ \"id\" ] = fake_subscriptions [ 1 ][ \"id\" ] + \"foo1\" fake_subscriptions [ 2 ][ \"status\" ] = \"incomplete_expired\" fake_subscriptions [ 2 ][ \"id\" ] = fake_subscriptions [ 2 ][ \"id\" ] + \"foo2\" for fake_subscription in fake_subscriptions : with patch ( \"stripe.Subscription.create\" , autospec = True , side_effect = [ fake_subscription ], ): self . customer . subscribe ( price = price , charge_immediately = False ) self . assertEqual ( 3 , self . customer . subscriptions . count ()) self . assertEqual ( 1 , len ( self . customer . valid_subscriptions )) self . assertEqual ( self . customer . valid_subscriptions [ 0 ], self . customer . subscription ) self . assertEqual ( fake_subscriptions [ 0 ][ \"id\" ], self . customer . subscription . id ) tests . test_customer . TestCustomer . test_subscription_shortcut_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscription_shortcut_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): price = Price . sync_from_stripe_data ( deepcopy ( FAKE_PRICE )) self . assert_fks ( price , expected_blank_fks = {}) subscription_fake_duplicate = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake_duplicate [ \"id\" ] = \"sub_6lsC8pt7IcF8jd\" subscription_create_mock . side_effect = [ deepcopy ( FAKE_SUBSCRIPTION ), subscription_fake_duplicate , ] self . customer . subscribe ( price = price , charge_immediately = False ) self . customer . subscribe ( price = price , charge_immediately = False ) self . assertEqual ( 2 , self . customer . subscriptions . count ()) self . assertEqual ( 2 , len ( self . customer . valid_subscriptions )) with self . assertRaises ( MultipleSubscriptionException ): self . customer . subscription tests . test_customer . TestCustomer . test_sync_charges ( self , customer_retrieve_mock , charge_list_mock , charge_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Charge.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Charge.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_CHARGE )]), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_charges ( self , customer_retrieve_mock , charge_list_mock , charge_sync_mock ): self . customer . _sync_charges () self . assertEqual ( 1 , charge_sync_mock . call_count ) tests . test_customer . TestCustomer . test_sync_charges_none ( self , customer_retrieve_mock , charge_list_mock , charge_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Charge.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Charge.list\" , return_value = StripeList ( data = []), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_charges_none ( self , customer_retrieve_mock , charge_list_mock , charge_sync_mock ): self . customer . _sync_charges () self . assertEqual ( 0 , charge_sync_mock . call_count ) tests . test_customer . TestCustomer . test_sync_customer_delete_discount ( self ) Source code in tests/test_customer.py def test_sync_customer_delete_discount ( self ): test_coupon = Coupon . sync_from_stripe_data ( FAKE_COUPON ) self . customer . coupon = test_coupon self . customer . save () self . assertEqual ( self . customer . coupon . id , FAKE_COUPON [ \"id\" ]) customer = Customer . sync_from_stripe_data ( FAKE_CUSTOMER ) self . assertEqual ( customer . coupon , None ) tests . test_customer . TestCustomer . test_sync_customer_discount_already_present ( self , coupon_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Coupon.retrieve\" , return_value = deepcopy ( FAKE_COUPON ), autospec = True ) def test_sync_customer_discount_already_present ( self , coupon_retrieve_mock ): fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"discount\" ] = deepcopy ( FAKE_DISCOUNT_CUSTOMER ) # Set the customer's coupon to be what we'll sync customer = Customer . objects . get ( id = FAKE_CUSTOMER [ \"id\" ]) customer . coupon = Coupon . sync_from_stripe_data ( FAKE_COUPON ) customer . save () customer = Customer . sync_from_stripe_data ( fake_customer ) self . assertEqual ( customer . coupon . id , FAKE_COUPON [ \"id\" ]) tests . test_customer . TestCustomer . test_sync_customer_with_discount ( self , coupon_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Coupon.retrieve\" , return_value = deepcopy ( FAKE_COUPON ), autospec = True ) def test_sync_customer_with_discount ( self , coupon_retrieve_mock ): self . assertIsNone ( self . customer . coupon ) fake_customer = deepcopy ( FAKE_CUSTOMER ) fake_customer [ \"discount\" ] = deepcopy ( FAKE_DISCOUNT_CUSTOMER ) customer = Customer . sync_from_stripe_data ( fake_customer ) self . assertEqual ( customer . coupon . id , FAKE_COUPON [ \"id\" ]) self . assertIsNotNone ( customer . coupon_start ) self . assertIsNone ( customer . coupon_end ) tests . test_customer . TestCustomer . test_sync_invoices ( self , customer_retrieve_mock , invoice_list_mock , invoice_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Invoice.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_INVOICE ), deepcopy ( FAKE_INVOICE_III )] ), ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_invoices ( self , customer_retrieve_mock , invoice_list_mock , invoice_sync_mock ): self . customer . _sync_invoices () self . assertEqual ( 2 , invoice_sync_mock . call_count ) tests . test_customer . TestCustomer . test_sync_invoices_none ( self , customer_retrieve_mock , invoice_list_mock , invoice_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Invoice.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Invoice.list\" , return_value = StripeList ( data = []), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_invoices_none ( self , customer_retrieve_mock , invoice_list_mock , invoice_sync_mock ): self . customer . _sync_invoices () self . assertEqual ( 0 , invoice_sync_mock . call_count ) tests . test_customer . TestCustomer . test_sync_subscriptions ( self , customer_retrieve_mock , subscription_list_mock , subscription_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Subscription.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Subscription.list\" , return_value = StripeList ( data = [ deepcopy ( FAKE_SUBSCRIPTION ), deepcopy ( FAKE_SUBSCRIPTION_II )] ), ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_subscriptions ( self , customer_retrieve_mock , subscription_list_mock , subscription_sync_mock ): self . customer . _sync_subscriptions () self . assertEqual ( 2 , subscription_sync_mock . call_count ) tests . test_customer . TestCustomer . test_sync_subscriptions_none ( self , customer_retrieve_mock , subscription_list_mock , subscription_sync_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Subscription.sync_from_stripe_data\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Subscription.list\" , return_value = StripeList ( data = []), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_subscriptions_none ( self , customer_retrieve_mock , subscription_list_mock , subscription_sync_mock ): self . customer . _sync_subscriptions () self . assertEqual ( 0 , subscription_sync_mock . call_count ) tests . test_customer . TestCustomer . test_upcoming_invoice_plan ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.upcoming\" , return_value = deepcopy ( FAKE_UPCOMING_INVOICE ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_upcoming_invoice_plan ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): invoice = self . customer . upcoming_invoice () self . assertIsNotNone ( invoice ) self . assertIsNone ( invoice . id ) self . assertIsNone ( invoice . save ()) subscription_retrieve_mock . assert_called_once_with ( api_key = ANY , expand = ANY , id = FAKE_SUBSCRIPTION [ \"id\" ], stripe_account = None ) plan_retrieve_mock . assert_not_called () items = invoice . invoiceitems . all () self . assertEqual ( 1 , len ( items )) self . assertEqual ( FAKE_SUBSCRIPTION [ \"id\" ], items [ 0 ] . id ) self . assertIsNotNone ( invoice . plan ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) invoice . _invoiceitems = [] items = invoice . invoiceitems . all () self . assertEqual ( 0 , len ( items )) self . assertIsNotNone ( invoice . plan )","title":"Methods"},{"location":"reference/project/#tests.test_customer.TestCustomerLegacy","text":"","title":"TestCustomerLegacy"},{"location":"reference/project/#tests.test_customer.TestCustomerLegacy-methods","text":"tests . test_customer . TestCustomerLegacy . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_customer.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . payment_method , _ = DjstripePaymentMethod . _get_or_create_source ( FAKE_CARD , \"card\" ) self . card = self . payment_method . resolve () self . customer . default_source = self . payment_method self . customer . save () self . account = default_account () tests . test_customer . TestCustomerLegacy . test_has_active_subscription_with_plan ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_has_active_subscription_with_plan ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_create_mock . return_value = subscription_fake self . customer . subscribe ( plan = plan , charge_immediately = False ) self . customer . has_active_subscription ( plan = plan ) tests . test_customer . TestCustomerLegacy . test_has_active_subscription_with_plan_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_has_active_subscription_with_plan_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_create_mock . return_value = subscription_fake self . customer . subscribe ( plan = plan , charge_immediately = False ) self . customer . has_active_subscription ( plan = plan . id ) tests . test_customer . TestCustomerLegacy . test_has_active_subscription_with_unspecified_plan_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_has_active_subscription_with_unspecified_plan_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . assert_fks ( plan , expected_blank_fks = {}) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_fake_duplicate = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake_duplicate [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () + timezone . timedelta ( days = 7 ) ) subscription_fake_duplicate [ \"id\" ] = \"sub_6lsC8pt7IcF8jd\" subscription_create_mock . side_effect = [ subscription_fake , subscription_fake_duplicate , ] self . customer . subscribe ( plan = plan , charge_immediately = False ) self . customer . subscribe ( plan = plan , charge_immediately = False ) self . assertEqual ( 2 , self . customer . subscriptions . count ()) with self . assertRaises ( TypeError ): self . customer . has_active_subscription () tests . test_customer . TestCustomerLegacy . test_subscribe_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . assert_fks ( plan , expected_blank_fks = {}) self . customer . subscribe ( plan = plan , charge_immediately = True ) self . assertTrue ( send_invoice_mock . called ) tests . test_customer . TestCustomerLegacy . test_subscribe_not_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_not_charge_immediately ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . customer . subscribe ( plan = plan , charge_immediately = False ) self . assertFalse ( send_invoice_mock . called ) tests . test_customer . TestCustomerLegacy . test_subscribe_plan_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock ) Source code in tests/test_customer.py @patch ( \"djstripe.models.Customer.send_invoice\" , autospec = True ) @patch ( \"stripe.Subscription.create\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscribe_plan_string ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock , send_invoice_mock , ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . assert_fks ( plan , expected_blank_fks = {}) self . customer . subscribe ( plan = plan . id , charge_immediately = True ) self . assertTrue ( send_invoice_mock . called ) tests . test_customer . TestCustomerLegacy . test_subscription_shortcut_with_invalid_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscription_shortcut_with_invalid_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . assert_fks ( plan , expected_blank_fks = {}) fake_subscriptions = [ deepcopy ( FAKE_SUBSCRIPTION ), deepcopy ( FAKE_SUBSCRIPTION ), deepcopy ( FAKE_SUBSCRIPTION ), ] # update the status of all but one to be invalid, # we need to also change the id for sync to work fake_subscriptions [ 1 ][ \"status\" ] = \"canceled\" fake_subscriptions [ 1 ][ \"id\" ] = fake_subscriptions [ 1 ][ \"id\" ] + \"foo1\" fake_subscriptions [ 2 ][ \"status\" ] = \"incomplete_expired\" fake_subscriptions [ 2 ][ \"id\" ] = fake_subscriptions [ 2 ][ \"id\" ] + \"foo2\" for fake_subscription in fake_subscriptions : with patch ( \"stripe.Subscription.create\" , autospec = True , side_effect = [ fake_subscription ], ): self . customer . subscribe ( plan = plan , charge_immediately = False ) self . assertEqual ( 3 , self . customer . subscriptions . count ()) self . assertEqual ( 1 , len ( self . customer . valid_subscriptions )) self . assertEqual ( self . customer . valid_subscriptions [ 0 ], self . customer . subscription ) self . assertEqual ( fake_subscriptions [ 0 ][ \"id\" ], self . customer . subscription . id ) tests . test_customer . TestCustomerLegacy . test_subscription_shortcut_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Subscription.create\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_subscription_shortcut_with_multiple_subscriptions ( self , product_retrieve_mock , customer_retrieve_mock , subscription_create_mock ): plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) self . assert_fks ( plan , expected_blank_fks = {}) subscription_fake_duplicate = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake_duplicate [ \"id\" ] = \"sub_6lsC8pt7IcF8jd\" subscription_create_mock . side_effect = [ deepcopy ( FAKE_SUBSCRIPTION ), subscription_fake_duplicate , ] self . customer . subscribe ( plan = plan , charge_immediately = False ) self . customer . subscribe ( plan = plan , charge_immediately = False ) self . assertEqual ( 2 , self . customer . subscriptions . count ()) self . assertEqual ( 2 , len ( self . customer . valid_subscriptions )) with self . assertRaises ( MultipleSubscriptionException ): self . customer . subscription tests . test_customer . TestCustomerLegacy . test_upcoming_invoice ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_customer.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.upcoming\" , return_value = deepcopy ( FAKE_UPCOMING_INVOICE ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_upcoming_invoice ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): invoice = self . customer . upcoming_invoice () self . assertIsNotNone ( invoice ) self . assertIsNone ( invoice . id ) self . assertIsNone ( invoice . save ()) subscription_retrieve_mock . assert_called_once_with ( api_key = ANY , expand = ANY , id = FAKE_SUBSCRIPTION [ \"id\" ], stripe_account = None ) plan_retrieve_mock . assert_not_called () items = invoice . invoiceitems . all () self . assertEqual ( 1 , len ( items )) self . assertEqual ( FAKE_SUBSCRIPTION [ \"id\" ], items [ 0 ] . id ) self . assertIsNotNone ( invoice . plan ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) invoice . _invoiceitems = [] items = invoice . invoiceitems . all () self . assertEqual ( 0 , len ( items )) self . assertIsNotNone ( invoice . plan )","title":"Methods"},{"location":"reference/project/#tests.test_decorators","text":"dj-stripe Decorator Tests.","title":"test_decorators"},{"location":"reference/project/#tests.test_decorators-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_decorators.TestSubscriptionPaymentRequired","text":"","title":"TestSubscriptionPaymentRequired"},{"location":"reference/project/#tests.test_decorators.TestSubscriptionPaymentRequired-methods","text":"tests . test_decorators . TestSubscriptionPaymentRequired . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_decorators.py def setUp ( self ): self . settings ( ROOT_URLCONF = \"tests.urls\" ) self . factory = RequestFactory () @subscription_payment_required def test_view ( request ): return HttpResponse () @subscription_payment_required ( pay_page = None ) def test_view_bad ( request ): return HttpResponse () self . test_view = test_view self . test_view_bad = test_view_bad tests . test_decorators . TestSubscriptionPaymentRequired . test_anonymous ( self ) Source code in tests/test_decorators.py def test_anonymous ( self ): request = self . factory . get ( \"/account/\" ) request . user = AnonymousUser () with self . assertRaises ( ImproperlyConfigured ): self . test_view ( request ) tests . test_decorators . TestSubscriptionPaymentRequired . test_direct ( self ) Source code in tests/test_decorators.py def test_direct ( self ): subscription_payment_required ( function = None ) tests . test_decorators . TestSubscriptionPaymentRequired . test_user_active_subscription ( self , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_decorators.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_user_active_subscription ( self , product_retrieve_mock , plan_retrieve_mock ): user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER . create_for_user ( user ) subscription = Subscription . sync_from_stripe_data ( deepcopy ( FAKE_SUBSCRIPTION )) subscription . current_period_end = FUTURE_DATE subscription . save () request = self . factory . get ( \"/account/\" ) request . user = user response = self . test_view ( request ) self . assertEqual ( response . status_code , 200 ) tests . test_decorators . TestSubscriptionPaymentRequired . test_user_unpaid ( self ) Source code in tests/test_decorators.py def test_user_unpaid ( self ): user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER . create_for_user ( user ) request = self . factory . get ( \"/account/\" ) request . user = user response = self . test_view ( request ) self . assertEqual ( response . status_code , 302 ) with self . assertRaises ( ImproperlyConfigured ): self . test_view_bad ( request )","title":"Methods"},{"location":"reference/project/#tests.test_django","text":"","title":"test_django"},{"location":"reference/project/#tests.test_django.TestRunManagePyCheck","text":"tests . test_django . TestRunManagePyCheck . test_manage_py_check ( self ) Source code in tests/test_django.py def test_manage_py_check ( self ): call_command ( \"check\" )","title":"TestRunManagePyCheck"},{"location":"reference/project/#tests.test_enums","text":"","title":"test_enums"},{"location":"reference/project/#tests.test_enums.TestEnumMetaClass","text":"tests . test_enums . TestEnumMetaClass . test_python2_prepare ( self ) Source code in tests/test_enums.py def test_python2_prepare ( self ): # Python 2 hack to ensure __prepare__ is called... self . assertEqual ( EnumMetaClass . __prepare__ ( None , None ), OrderedDict ())","title":"TestEnumMetaClass"},{"location":"reference/project/#tests.test_event","text":"dj-stripe Event Model Tests.","title":"test_event"},{"location":"reference/project/#tests.test_event-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_event.EventRaceConditionTest","text":"tests . test_event . EventRaceConditionTest . test_process_event_race_condition ( self , transfer_retrieve_mock ) Source code in tests/test_event.py @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) def test_process_event_race_condition ( self , transfer_retrieve_mock ): transfer = Transfer . sync_from_stripe_data ( deepcopy ( FAKE_TRANSFER )) transfer_retrieve_mock . reset_mock () event_data = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) # emulate the race condition in _get_or_create_from_stripe_object where # an object is created by a different request during the call # # Sequence of events: # 1) first Transfer.stripe_objects.get fails with DoesNotExist # (due to it not existing in reality, but due to our side_effect in the test) # 2) object is really created by a different request in reality # 3) Transfer._create_from_stripe_object fails with IntegrityError due to # duplicate id # 4) second Transfer.stripe_objects.get succeeds # (due to being created by step 2 in reality, due to side effect in the test) side_effect = [ Transfer . DoesNotExist (), transfer ] with patch ( \"djstripe.models.Transfer.stripe_objects.get\" , side_effect = side_effect , autospec = True , ) as transfer_objects_get_mock : Event . process ( event_data ) self . assertEqual ( transfer_objects_get_mock . call_count , 2 ) self . assertEqual ( transfer_retrieve_mock . call_count , 1 )","title":"EventRaceConditionTest"},{"location":"reference/project/#tests.test_event.EventTest","text":"","title":"EventTest"},{"location":"reference/project/#tests.test_event.EventTest-methods","text":"tests . test_event . EventTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_event.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) patcher = patch . object ( webhooks , \"call_handlers\" ) self . addCleanup ( patcher . stop ) self . call_handlers = patcher . start () tests . test_event . EventTest . test_invoke_webhook_handlers_event_when_invalid ( self ) Source code in tests/test_event.py def test_invoke_webhook_handlers_event_when_invalid ( self ): event = self . _create_event ( FAKE_EVENT_TRANSFER_CREATED ) event . valid = False event . invoke_webhook_handlers () tests . test_event . EventTest . test_invoke_webhook_handlers_event_with_log_stripe_error ( self ) Source code in tests/test_event.py def test_invoke_webhook_handlers_event_with_log_stripe_error ( self ): event = self . _create_event ( FAKE_EVENT_TRANSFER_CREATED ) self . call_handlers . side_effect = StripeError ( \"Boom!\" ) with self . assertRaises ( StripeError ): event . invoke_webhook_handlers () tests . test_event . EventTest . test_invoke_webhook_handlers_event_with_raise_stripe_error ( self ) Source code in tests/test_event.py def test_invoke_webhook_handlers_event_with_raise_stripe_error ( self ): event = self . _create_event ( FAKE_EVENT_TRANSFER_CREATED ) self . call_handlers . side_effect = StripeError ( \"Boom!\" ) with self . assertRaises ( StripeError ): event . invoke_webhook_handlers () tests . test_event . EventTest . test_process_event ( self , mock_objects , mock__create_from_stripe_object , mock_atomic ) Test that process event creates a new event and invokes webhooks when the event doesn't already exist. Source code in tests/test_event.py @patch ( target = \"djstripe.models.core.transaction.atomic\" , autospec = True ) @patch . object ( target = Event , attribute = \"_create_from_stripe_object\" , autospec = True ) @patch . object ( target = Event , attribute = \"objects\" , autospec = True ) def test_process_event ( self , mock_objects , mock__create_from_stripe_object , mock_atomic ): \"\"\"Test that process event creates a new event and invokes webhooks when the event doesn't already exist. \"\"\" # Set up mocks mock_objects . filter . return_value . exists . return_value = False mock_data = { \"id\" : \"foo_id\" , \"other_stuff\" : \"more_things\" } result = Event . process ( data = mock_data ) # Check that all the expected work was performed mock_objects . filter . assert_called_once_with ( id = mock_data [ \"id\" ]) mock_objects . filter . return_value . exists . assert_called_once_with () mock_atomic . return_value . __enter__ . assert_called_once_with () mock__create_from_stripe_object . assert_called_once_with ( mock_data ) ( mock__create_from_stripe_object . return_value . invoke_webhook_handlers ) . assert_called_once_with () # Make sure the event was returned. self . assertEqual ( mock__create_from_stripe_object . return_value , result ) tests . test_event . EventTest . test_process_event_exists ( self , mock_objects , mock__create_from_stripe_object , mock_atomic ) Test that process event returns the existing event and skips webhook processing when the event already exists. Source code in tests/test_event.py @patch ( target = \"djstripe.models.core.transaction.atomic\" , autospec = True ) @patch . object ( target = Event , attribute = \"_create_from_stripe_object\" , autospec = True ) @patch . object ( target = Event , attribute = \"objects\" , autospec = True ) def test_process_event_exists ( self , mock_objects , mock__create_from_stripe_object , mock_atomic ): \"\"\" Test that process event returns the existing event and skips webhook processing when the event already exists. \"\"\" # Set up mocks mock_objects . filter . return_value . exists . return_value = True mock_data = { \"id\" : \"foo_id\" , \"other_stuff\" : \"more_things\" } result = Event . process ( data = mock_data ) # Make sure that the db was queried and the existing results used. mock_objects . filter . assert_called_once_with ( id = mock_data [ \"id\" ]) mock_objects . filter . return_value . exists . assert_called_once_with () mock_objects . filter . return_value . first . assert_called_once_with () # Make sure the webhook actions and event object creation were not performed. mock_atomic . return_value . __enter__ . assert_not_called () mock__create_from_stripe_object . assert_not_called () ( mock__create_from_stripe_object . return_value . invoke_webhook_handlers ) . assert_not_called () # Make sure the existing event was returned. self . assertEqual ( mock_objects . filter . return_value . first . return_value , result ) tests . test_event . EventTest . test_process_event_failure_rolls_back ( self , invoke_webhook_handlers_mock ) Test that process event rolls back event creation on error Source code in tests/test_event.py @patch ( \"djstripe.models.Event.invoke_webhook_handlers\" , autospec = True ) def test_process_event_failure_rolls_back ( self , invoke_webhook_handlers_mock ): \"\"\"Test that process event rolls back event creation on error\"\"\" class HandlerException ( Exception ): pass invoke_webhook_handlers_mock . side_effect = HandlerException real_create_from_stripe_object = Event . _create_from_stripe_object def side_effect ( * args , ** kwargs ): return real_create_from_stripe_object ( * args , ** kwargs ) event_data = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) self . assertFalse ( Event . objects . filter ( id = FAKE_EVENT_TRANSFER_CREATED [ \"id\" ]) . exists () ) with self . assertRaises ( HandlerException ), patch ( \"djstripe.models.Event._create_from_stripe_object\" , side_effect = side_effect , autospec = True , ) as create_from_stripe_object_mock : Event . process ( data = event_data ) create_from_stripe_object_mock . assert_called_once_with ( event_data ) self . assertFalse ( Event . objects . filter ( id = FAKE_EVENT_TRANSFER_CREATED [ \"id\" ]) . exists () ) tests . test_event . EventTest . test_str ( self ) Source code in tests/test_event.py def test_str ( self ): event = self . _create_event ( FAKE_EVENT_TRANSFER_CREATED ) self . assertEqual ( \"<type= {type} , id= {id} >\" . format ( type = FAKE_EVENT_TRANSFER_CREATED [ \"type\" ], id = FAKE_EVENT_TRANSFER_CREATED [ \"id\" ], ), str ( event ), )","title":"Methods"},{"location":"reference/project/#tests.test_event_handlers","text":"dj-stripe Event Handler tests","title":"test_event_handlers"},{"location":"reference/project/#tests.test_event_handlers-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_event_handlers.EventTestCase","text":"","title":"EventTestCase"},{"location":"reference/project/#tests.test_event_handlers.TestAccountEvents","text":"tests . test_event_handlers . TestAccountEvents . test_account_deauthorized_event ( self , event_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_account_deauthorized_event ( self , event_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_ACCOUNT_APPLICATION_DEAUTHORIZED ) event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers ()","title":"TestAccountEvents"},{"location":"reference/project/#tests.test_event_handlers.TestChargeEvents","text":"","title":"TestChargeEvents"},{"location":"reference/project/#tests.test_event_handlers.TestChargeEvents-methods","text":"tests . test_event_handlers . TestChargeEvents . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_event_handlers.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) tests . test_event_handlers . TestChargeEvents . test_charge_created ( self , subscription_retrieve_mock , product_retrieve_mock , invoice_retrieve_mock , event_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), ) @patch ( \"stripe.Charge.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) def test_charge_created ( self , subscription_retrieve_mock , product_retrieve_mock , invoice_retrieve_mock , event_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , balance_transaction_retrieve_mock , account_mock , ): FAKE_CUSTOMER . create_for_user ( self . user ) fake_stripe_event = deepcopy ( FAKE_EVENT_CHARGE_SUCCEEDED ) event_retrieve_mock . return_value = fake_stripe_event charge_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] account_mock . return_value = default_account () event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () charge = Charge . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( charge . amount , fake_stripe_event [ \"data\" ][ \"object\" ][ \"amount\" ] / Decimal ( \"100\" ), ) self . assertEqual ( charge . status , fake_stripe_event [ \"data\" ][ \"object\" ][ \"status\" ])","title":"Methods"},{"location":"reference/project/#tests.test_event_handlers.TestCustomerEvents","text":"","title":"TestCustomerEvents"},{"location":"reference/project/#tests.test_event_handlers.TestCustomerEvents-methods","text":"tests . test_event_handlers . TestCustomerEvents . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_event_handlers.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_event_handlers . TestCustomerEvents . test_customer_bogus_event_type ( self , event_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Customer.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_customer_bogus_event_type ( self , event_retrieve_mock , customer_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_CREATED ) fake_stripe_event [ \"data\" ][ \"object\" ][ \"customer\" ] = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] fake_stripe_event [ \"type\" ] = \"customer.praised\" event_retrieve_mock . return_value = fake_stripe_event customer_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () tests . test_event_handlers . TestCustomerEvents . test_customer_card_created ( self , event_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Customer.retrieve\" , return_value = FAKE_CUSTOMER , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_customer_card_created ( self , event_retrieve_mock , customer_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_SOURCE_CREATED ) event_retrieve_mock . return_value = fake_stripe_event event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () card = Card . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertIn ( card , self . customer . legacy_cards . all ()) self . assertEqual ( card . brand , fake_stripe_event [ \"data\" ][ \"object\" ][ \"brand\" ]) self . assertEqual ( card . last4 , fake_stripe_event [ \"data\" ][ \"object\" ][ \"last4\" ]) tests . test_event_handlers . TestCustomerEvents . test_customer_created ( self , event_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Customer.retrieve\" , return_value = FAKE_CUSTOMER , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_customer_created ( self , event_retrieve_mock , customer_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_CREATED ) event_retrieve_mock . return_value = fake_stripe_event event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () customer = Customer . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( customer . balance , fake_stripe_event [ \"data\" ][ \"object\" ][ \"balance\" ] ) self . assertEqual ( customer . currency , fake_stripe_event [ \"data\" ][ \"object\" ][ \"currency\" ] ) tests . test_event_handlers . TestCustomerEvents . test_customer_default_source_deleted ( self ) Source code in tests/test_event_handlers.py def test_customer_default_source_deleted ( self ): self . customer . default_source = DjstripePaymentMethod . objects . get ( id = FAKE_CARD [ \"id\" ] ) self . customer . save () self . assertIsNotNone ( self . customer . default_source ) self . assertTrue ( self . customer . has_valid_source ()) event = self . _create_event ( FAKE_EVENT_CUSTOMER_SOURCE_DELETED ) event . invoke_webhook_handlers () customer = Customer . objects . get ( id = FAKE_CUSTOMER [ \"id\" ]) self . assertIsNone ( customer . default_source ) self . assertFalse ( customer . has_valid_source ()) tests . test_event_handlers . TestCustomerEvents . test_customer_deleted ( self , customer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Customer.retrieve\" , return_value = FAKE_CUSTOMER , autospec = True ) def test_customer_deleted ( self , customer_retrieve_mock ): FAKE_CUSTOMER . create_for_user ( self . user ) event = self . _create_event ( FAKE_EVENT_CUSTOMER_CREATED ) event . invoke_webhook_handlers () event = self . _create_event ( FAKE_EVENT_CUSTOMER_DELETED ) event . invoke_webhook_handlers () customer = Customer . objects . get ( id = FAKE_CUSTOMER [ \"id\" ]) self . assertIsNotNone ( customer . date_purged ) tests . test_event_handlers . TestCustomerEvents . test_customer_discount_created ( self , event_retrieve_mock , coupon_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Coupon.retrieve\" , return_value = FAKE_COUPON , autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = FAKE_EVENT_CUSTOMER_DISCOUNT_CREATED , autospec = True , ) def test_customer_discount_created ( self , event_retrieve_mock , coupon_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_DISCOUNT_CREATED ) event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () self . assertIsNotNone ( event . customer ) self . assertEqual ( event . customer . id , FAKE_CUSTOMER [ \"id\" ]) self . assertIsNotNone ( event . customer . coupon ) tests . test_event_handlers . TestCustomerEvents . test_customer_discount_deleted ( self , event_retrieve_mock , coupon_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Coupon.retrieve\" , return_value = FAKE_COUPON , autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = FAKE_EVENT_CUSTOMER_DISCOUNT_DELETED , autospec = True , ) def test_customer_discount_deleted ( self , event_retrieve_mock , coupon_retrieve_mock ): coupon = Coupon . sync_from_stripe_data ( FAKE_COUPON ) self . customer . coupon = coupon fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_DISCOUNT_DELETED ) event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () self . assertIsNotNone ( event . customer ) self . assertEqual ( event . customer . id , FAKE_CUSTOMER [ \"id\" ]) self . assertIsNone ( event . customer . coupon ) tests . test_event_handlers . TestCustomerEvents . test_customer_source_double_delete ( self ) Source code in tests/test_event_handlers.py def test_customer_source_double_delete ( self ): event = self . _create_event ( FAKE_EVENT_CUSTOMER_SOURCE_DELETED ) event . invoke_webhook_handlers () event = self . _create_event ( FAKE_EVENT_CUSTOMER_SOURCE_DELETED_DUPE ) event . invoke_webhook_handlers () tests . test_event_handlers . TestCustomerEvents . test_customer_subscription_created ( self , event_retrieve_mock , product_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_customer_subscription_created ( self , event_retrieve_mock , product_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock , ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED ) event_retrieve_mock . return_value = fake_stripe_event event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () subscription = Subscription . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assertIn ( subscription , self . customer . subscriptions . all ()) self . assertEqual ( subscription . status , fake_stripe_event [ \"data\" ][ \"object\" ][ \"status\" ] ) self . assertEqual ( subscription . quantity , fake_stripe_event [ \"data\" ][ \"object\" ][ \"quantity\" ] ) tests . test_event_handlers . TestCustomerEvents . test_customer_subscription_deleted ( self , customer_retrieve_mock , product_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_customer_subscription_deleted ( self , customer_retrieve_mock , product_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock , ): event = self . _create_event ( FAKE_EVENT_CUSTOMER_SUBSCRIPTION_CREATED ) event . invoke_webhook_handlers () sub = Subscription . objects . get ( id = FAKE_SUBSCRIPTION [ \"id\" ]) self . assertEqual ( sub . status , SubscriptionStatus . active ) subscription_retrieve_mock . return_value = deepcopy ( FAKE_SUBSCRIPTION_CANCELED ) event = self . _create_event ( FAKE_EVENT_CUSTOMER_SUBSCRIPTION_DELETED ) event . invoke_webhook_handlers () sub = Subscription . objects . get ( id = FAKE_SUBSCRIPTION [ \"id\" ]) # Check that Subscription is canceled and not deleted self . assertEqual ( sub . status , SubscriptionStatus . canceled ) self . assertIsNotNone ( sub . canceled_at ) tests . test_event_handlers . TestCustomerEvents . test_customer_unknown_source_created ( self , event_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_customer_unknown_source_created ( self , event_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_CUSTOMER_SOURCE_CREATED ) fake_stripe_event [ \"data\" ][ \"object\" ][ \"object\" ] = \"unknown\" fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] = \"card_xxx_test_customer_unk_source_created\" event_retrieve_mock . return_value = fake_stripe_event FAKE_CUSTOMER . create_for_user ( self . user ) event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () self . assertFalse ( Card . objects . filter ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) . exists () )","title":"Methods"},{"location":"reference/project/#tests.test_event_handlers.TestDisputeEvents","text":"tests . test_event_handlers . TestDisputeEvents . test_dispute_created ( self , event_retrieve_mock , dispute_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Dispute.retrieve\" , return_value = deepcopy ( FAKE_DISPUTE ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_DISPUTE_CREATED ), autospec = True , ) def test_dispute_created ( self , event_retrieve_mock , dispute_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_DISPUTE_CREATED ) event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () dispute = Dispute . objects . get () self . assertEqual ( dispute . id , FAKE_DISPUTE [ \"id\" ])","title":"TestDisputeEvents"},{"location":"reference/project/#tests.test_event_handlers.TestInvoiceEvents","text":"tests . test_event_handlers . TestInvoiceEvents . test_invoice_created ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , event_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_created ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , event_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = default_account () user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER . create_for_user ( user ) fake_stripe_event = deepcopy ( FAKE_EVENT_INVOICE_CREATED ) event_retrieve_mock . return_value = fake_stripe_event invoice_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () invoice = Invoice . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( invoice . amount_due , fake_stripe_event [ \"data\" ][ \"object\" ][ \"amount_due\" ] / Decimal ( \"100\" ), ) self . assertEqual ( invoice . paid , fake_stripe_event [ \"data\" ][ \"object\" ][ \"paid\" ]) tests . test_event_handlers . TestInvoiceEvents . test_invoice_created_no_existing_customer ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , event_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_created_no_existing_customer ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , event_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = default_account () fake_stripe_event = deepcopy ( FAKE_EVENT_INVOICE_CREATED ) event_retrieve_mock . return_value = fake_stripe_event invoice_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () self . assertEqual ( Customer . objects . count (), 1 ) customer = Customer . objects . get () self . assertEqual ( customer . subscriber , None ) tests . test_event_handlers . TestInvoiceEvents . test_invoice_deleted ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_deleted ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , invoice_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = default_account () user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER . create_for_user ( user ) event = self . _create_event ( FAKE_EVENT_INVOICE_CREATED ) event . invoke_webhook_handlers () Invoice . objects . get ( id = FAKE_INVOICE [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_INVOICE_DELETED ) event . invoke_webhook_handlers () with self . assertRaises ( Invoice . DoesNotExist ): Invoice . objects . get ( id = FAKE_INVOICE [ \"id\" ]) tests . test_event_handlers . TestInvoiceEvents . test_invoice_upcoming ( self ) Source code in tests/test_event_handlers.py def test_invoice_upcoming ( self ): # Ensure that invoice upcoming events are processed - No actual # process occurs so the operation is an effective no-op. event = self . _create_event ( FAKE_EVENT_INVOICE_UPCOMING ) event . invoke_webhook_handlers ()","title":"TestInvoiceEvents"},{"location":"reference/project/#tests.test_event_handlers.TestInvoiceItemEvents","text":"tests . test_event_handlers . TestInvoiceItemEvents . test_invoiceitem_created ( self , product_retrieve_mock , event_retrieve_mock , invoiceitem_retrieve_mock , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) @patch ( \"stripe.InvoiceItem.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoiceitem_created ( self , product_retrieve_mock , event_retrieve_mock , invoiceitem_retrieve_mock , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = default_account () user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER_II . create_for_user ( user ) fake_stripe_event = deepcopy ( FAKE_EVENT_INVOICEITEM_CREATED ) event_retrieve_mock . return_value = fake_stripe_event invoiceitem_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () invoiceitem = InvoiceItem . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assertEqual ( invoiceitem . amount , fake_stripe_event [ \"data\" ][ \"object\" ][ \"amount\" ] / Decimal ( \"100\" ), ) tests . test_event_handlers . TestInvoiceItemEvents . test_invoiceitem_deleted ( self , product_retrieve_mock , invoiceitem_retrieve_mock , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_event_handlers.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) @patch ( \"stripe.InvoiceItem.retrieve\" , return_value = deepcopy ( FAKE_INVOICEITEM ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoiceitem_deleted ( self , product_retrieve_mock , invoiceitem_retrieve_mock , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = default_account () user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) FAKE_CUSTOMER_II . create_for_user ( user ) event = self . _create_event ( FAKE_EVENT_INVOICEITEM_CREATED ) event . invoke_webhook_handlers () InvoiceItem . objects . get ( id = FAKE_INVOICEITEM [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_INVOICEITEM_DELETED ) event . invoke_webhook_handlers () with self . assertRaises ( InvoiceItem . DoesNotExist ): InvoiceItem . objects . get ( id = FAKE_INVOICEITEM [ \"id\" ])","title":"TestInvoiceItemEvents"},{"location":"reference/project/#tests.test_event_handlers.TestPaymentIntentEvents","text":"Test case for payment intent event handling.","title":"TestPaymentIntentEvents"},{"location":"reference/project/#tests.test_event_handlers.TestPaymentIntentEvents-methods","text":"tests . test_event_handlers . TestPaymentIntentEvents . test_payment_intent_succeeded_with_destination_charge ( self , customer_retrieve_mock , account_retrieve_mock , file_upload_retrieve_mock , payment_intent_retrieve_mock , payment_method_retrieve_mock ) Test that the payment intent succeeded event can create all related objects. This should exercise the machinery to set stripe_account when recursing into objects related to a connect Account . Source code in tests/test_event_handlers.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Account.retrieve\" , return_value = deepcopy ( FAKE_ACCOUNT ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.FileUpload.retrieve\" , side_effect = ( deepcopy ( FAKE_FILEUPLOAD_ICON ), deepcopy ( FAKE_FILEUPLOAD_LOGO )), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_DESTINATION_CHARGE ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I ), autospec = True , ) def test_payment_intent_succeeded_with_destination_charge ( self , customer_retrieve_mock , account_retrieve_mock , file_upload_retrieve_mock , payment_intent_retrieve_mock , payment_method_retrieve_mock , ): \"\"\"Test that the payment intent succeeded event can create all related objects. This should exercise the machinery to set `stripe_account` when recursing into objects related to a connect `Account`. \"\"\" event = self . _create_event ( FAKE_EVENT_PAYMENT_INTENT_SUCCEEDED_DESTINATION_CHARGE ) event . invoke_webhook_handlers () # Make sure the file uploads were retrieved using the account ID. file_upload_retrieve_mock . assert_has_calls ( ( call ( id = FAKE_FILEUPLOAD_ICON [ \"id\" ], api_key = ANY , expand = ANY , stripe_account = FAKE_ACCOUNT [ \"id\" ], ), call ( id = FAKE_FILEUPLOAD_LOGO [ \"id\" ], api_key = ANY , expand = ANY , stripe_account = FAKE_ACCOUNT [ \"id\" ], ), ) )","title":"Methods"},{"location":"reference/project/#tests.test_event_handlers.TestPaymentMethodEvents","text":"","title":"TestPaymentMethodEvents"},{"location":"reference/project/#tests.test_event_handlers.TestPaymentMethodEvents-methods","text":"tests . test_event_handlers . TestPaymentMethodEvents . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_event_handlers.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"fake_customer_1\" , email = FAKE_CUSTOMER [ \"email\" ] ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_event_handlers . TestPaymentMethodEvents . test_card_payment_method_attached ( self , event_retrieve_mock , payment_method_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.PaymentMethod.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_card_payment_method_attached ( self , event_retrieve_mock , payment_method_retrieve_mock ): # Attach of a legacy id=\"card_xxx\" payment method should behave exactly # as per a normal \"native\" id=\"pm_yyy\" payment_method. fake_stripe_event = deepcopy ( FAKE_EVENT_CARD_PAYMENT_METHOD_ATTACHED ) event_retrieve_mock . return_value = fake_stripe_event payment_method_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () payment_method = PaymentMethod . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_event_handlers . TestPaymentMethodEvents . test_card_payment_method_detached ( self , event_retrieve_mock , payment_method_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.PaymentMethod.retrieve\" , side_effect = InvalidRequestError ( message = \"No such payment_method: card_xxxx\" , param = \"payment_method\" , code = \"resource_missing\" , ), autospec = True , ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_card_payment_method_detached ( self , event_retrieve_mock , payment_method_retrieve_mock ): # Detach of a legacy id=\"card_xxx\" payment method is handled specially, # since the card is deleted by Stripe and therefore PaymetMethod.retrieve fails fake_stripe_event = deepcopy ( FAKE_EVENT_CARD_PAYMENT_METHOD_DETACHED ) event_retrieve_mock . return_value = fake_stripe_event payment_method_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () self . assertEqual ( PaymentMethod . objects . filter ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) . count (), 0 , \"Detach of a 'card_' payment_method should delete it\" , ) tests . test_event_handlers . TestPaymentMethodEvents . test_payment_method_attached ( self , event_retrieve_mock , payment_method_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.PaymentMethod.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_payment_method_attached ( self , event_retrieve_mock , payment_method_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_PAYMENT_METHOD_ATTACHED ) event_retrieve_mock . return_value = fake_stripe_event payment_method_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () payment_method = PaymentMethod . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_event_handlers . TestPaymentMethodEvents . test_payment_method_detached ( self , event_retrieve_mock , payment_method_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.PaymentMethod.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_payment_method_detached ( self , event_retrieve_mock , payment_method_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_PAYMENT_METHOD_DETACHED ) event_retrieve_mock . return_value = fake_stripe_event payment_method_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () payment_method = PaymentMethod . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assertIsNone ( payment_method . customer , \"Detach of a payment_method should set customer to null\" , ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.PaymentMethod.customer\" } )","title":"Methods"},{"location":"reference/project/#tests.test_event_handlers.TestPlanEvents","text":"tests . test_event_handlers . TestPlanEvents . test_plan_created ( self , product_retrieve_mock , event_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_plan_created ( self , product_retrieve_mock , event_retrieve_mock , plan_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_PLAN_CREATED ) event_retrieve_mock . return_value = fake_stripe_event plan_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () plan = Plan . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( plan . nickname , fake_stripe_event [ \"data\" ][ \"object\" ][ \"nickname\" ]) tests . test_event_handlers . TestPlanEvents . test_plan_deleted ( self , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Plan.retrieve\" , return_value = FAKE_PLAN , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_plan_deleted ( self , product_retrieve_mock , plan_retrieve_mock ): event = self . _create_event ( FAKE_EVENT_PLAN_CREATED ) event . invoke_webhook_handlers () Plan . objects . get ( id = FAKE_PLAN [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_PLAN_DELETED ) event . invoke_webhook_handlers () with self . assertRaises ( Plan . DoesNotExist ): Plan . objects . get ( id = FAKE_PLAN [ \"id\" ]) tests . test_event_handlers . TestPlanEvents . test_plan_updated_request_object ( self , product_retrieve_mock , event_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Plan.retrieve\" , return_value = FAKE_PLAN , autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = FAKE_EVENT_PLAN_REQUEST_IS_OBJECT , autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_plan_updated_request_object ( self , product_retrieve_mock , event_retrieve_mock , plan_retrieve_mock ): plan_retrieve_mock . return_value = FAKE_EVENT_PLAN_REQUEST_IS_OBJECT [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( FAKE_EVENT_PLAN_REQUEST_IS_OBJECT ) event . invoke_webhook_handlers () plan = Plan . objects . get ( id = FAKE_EVENT_PLAN_REQUEST_IS_OBJECT [ \"data\" ][ \"object\" ][ \"id\" ] ) self . assertEqual ( plan . nickname , FAKE_EVENT_PLAN_REQUEST_IS_OBJECT [ \"data\" ][ \"object\" ][ \"nickname\" ], )","title":"TestPlanEvents"},{"location":"reference/project/#tests.test_event_handlers.TestPriceEvents","text":"tests . test_event_handlers . TestPriceEvents . test_price_created ( self , product_retrieve_mock , event_retrieve_mock , price_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Price.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_price_created ( self , product_retrieve_mock , event_retrieve_mock , price_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_PRICE_CREATED ) event_retrieve_mock . return_value = fake_stripe_event price_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () price = Price . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( price . nickname , fake_stripe_event [ \"data\" ][ \"object\" ][ \"nickname\" ] ) tests . test_event_handlers . TestPriceEvents . test_price_deleted ( self , product_retrieve_mock , price_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Price.retrieve\" , return_value = FAKE_PRICE , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_price_deleted ( self , product_retrieve_mock , price_retrieve_mock ): event = self . _create_event ( FAKE_EVENT_PRICE_CREATED ) event . invoke_webhook_handlers () Price . objects . get ( id = FAKE_PRICE [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_PRICE_DELETED ) event . invoke_webhook_handlers () with self . assertRaises ( Price . DoesNotExist ): Price . objects . get ( id = FAKE_PRICE [ \"id\" ]) tests . test_event_handlers . TestPriceEvents . test_price_updated ( self , product_retrieve_mock , event_retrieve_mock , price_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Price.retrieve\" , return_value = FAKE_PRICE , autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = FAKE_EVENT_PRICE_UPDATED , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_price_updated ( self , product_retrieve_mock , event_retrieve_mock , price_retrieve_mock ): price_retrieve_mock . return_value = FAKE_EVENT_PRICE_UPDATED [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( FAKE_EVENT_PRICE_UPDATED ) event . invoke_webhook_handlers () price = Price . objects . get ( id = FAKE_EVENT_PRICE_UPDATED [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( price . unit_amount , FAKE_EVENT_PRICE_UPDATED [ \"data\" ][ \"object\" ][ \"unit_amount\" ], ) self . assertEqual ( price . unit_amount_decimal , Decimal ( FAKE_EVENT_PRICE_UPDATED [ \"data\" ][ \"object\" ][ \"unit_amount_decimal\" ]), )","title":"TestPriceEvents"},{"location":"reference/project/#tests.test_event_handlers.TestSubscriptionScheduleEvents","text":"tests . test_event_handlers . TestSubscriptionScheduleEvents . test_subscription_schedule_canceled ( self , customer_retrieve_mock , schedule_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.SubscriptionSchedule.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) def test_subscription_schedule_canceled ( self , customer_retrieve_mock , schedule_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED ) fake_stripe_event [ \"data\" ][ \"object\" ][ \"canceled_at\" ] = 1605058030 fake_stripe_event [ \"data\" ][ \"object\" ][ \"status\" ] = \"canceled\" fake_stripe_event [ \"data\" ][ \"previous_attributes\" ] = { \"canceled_at\" : None , \"status\" : \"not_started\" , } schedule_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () schedule = SubscriptionSchedule . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) assert schedule . status == \"canceled\" assert schedule . canceled_at is not None schedule_retrieve_mock . return_value = FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CANCELED [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CANCELED ) event . invoke_webhook_handlers () schedule . refresh_from_db () assert schedule . status == \"canceled\" assert schedule . canceled_at is not None tests . test_event_handlers . TestSubscriptionScheduleEvents . test_subscription_schedule_created ( self , customer_retrieve_mock , schedule_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.SubscriptionSchedule.retrieve\" , return_value = FAKE_SUBSCRIPTION_SCHEDULE , autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) def test_subscription_schedule_created ( self , customer_retrieve_mock , schedule_retrieve_mock ): event = Event . sync_from_stripe_data ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED ) event . invoke_webhook_handlers () schedule = SubscriptionSchedule . objects . get ( id = FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED [ \"data\" ][ \"object\" ][ \"id\" ] ) assert ( schedule . id == FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED [ \"data\" ][ \"object\" ][ \"id\" ] ) assert schedule . status == \"not_started\" tests . test_event_handlers . TestSubscriptionScheduleEvents . test_subscription_schedule_released ( self , customer_retrieve_mock , schedule_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.SubscriptionSchedule.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) def test_subscription_schedule_released ( self , customer_retrieve_mock , schedule_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED ) fake_stripe_event [ \"data\" ][ \"object\" ][ \"released_at\" ] = 1605058030 fake_stripe_event [ \"data\" ][ \"object\" ][ \"status\" ] = \"released\" fake_stripe_event [ \"data\" ][ \"previous_attributes\" ] = { \"released_at\" : None , \"status\" : \"not_started\" , } schedule_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () schedule = SubscriptionSchedule . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) assert schedule . status == \"released\" assert schedule . released_at is not None schedule_retrieve_mock . return_value = FAKE_EVENT_SUBSCRIPTION_SCHEDULE_RELEASED [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_RELEASED ) event . invoke_webhook_handlers () schedule . refresh_from_db () assert schedule . status == \"released\" assert schedule . released_at is not None tests . test_event_handlers . TestSubscriptionScheduleEvents . test_subscription_schedule_updated ( self , customer_retrieve_mock , schedule_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.SubscriptionSchedule.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) def test_subscription_schedule_updated ( self , customer_retrieve_mock , schedule_retrieve_mock ): schedule_retrieve_mock . return_value = FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED ) event . invoke_webhook_handlers () schedule = SubscriptionSchedule . objects . get ( id = FAKE_EVENT_SUBSCRIPTION_SCHEDULE_CREATED [ \"data\" ][ \"object\" ][ \"id\" ] ) assert schedule . status == \"not_started\" assert schedule . released_at is None fake_stripe_event = deepcopy ( FAKE_EVENT_SUBSCRIPTION_SCHEDULE_UPDATED ) fake_stripe_event [ \"data\" ][ \"object\" ][ \"released_at\" ] = 1605058030 fake_stripe_event [ \"data\" ][ \"object\" ][ \"status\" ] = \"released\" fake_stripe_event [ \"data\" ][ \"previous_attributes\" ] = { \"released_at\" : None , \"status\" : \"not_started\" , } schedule_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () schedule = SubscriptionSchedule . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ] ) assert schedule . status == \"released\" assert schedule . released_at is not None","title":"TestSubscriptionScheduleEvents"},{"location":"reference/project/#tests.test_event_handlers.TestTransferEvents","text":"tests . test_event_handlers . TestTransferEvents . test_transfer_created ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Transfer.retrieve\" , autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_transfer_created ( self , event_retrieve_mock , transfer_retrieve_mock ): fake_stripe_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) event_retrieve_mock . return_value = fake_stripe_event transfer_retrieve_mock . return_value = fake_stripe_event [ \"data\" ][ \"object\" ] event = Event . sync_from_stripe_data ( fake_stripe_event ) event . invoke_webhook_handlers () transfer = Transfer . objects . get ( id = fake_stripe_event [ \"data\" ][ \"object\" ][ \"id\" ]) self . assertEqual ( transfer . amount , fake_stripe_event [ \"data\" ][ \"object\" ][ \"amount\" ] / Decimal ( \"100\" ), ) tests . test_event_handlers . TestTransferEvents . test_transfer_deleted ( self , transfer_retrieve_mock ) Source code in tests/test_event_handlers.py @patch ( \"stripe.Transfer.retrieve\" , return_value = FAKE_TRANSFER , autospec = True ) def test_transfer_deleted ( self , transfer_retrieve_mock ): event = self . _create_event ( FAKE_EVENT_TRANSFER_CREATED ) event . invoke_webhook_handlers () Transfer . objects . get ( id = FAKE_TRANSFER [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_TRANSFER_DELETED ) event . invoke_webhook_handlers () with self . assertRaises ( Transfer . DoesNotExist ): Transfer . objects . get ( id = FAKE_TRANSFER [ \"id\" ]) event = self . _create_event ( FAKE_EVENT_TRANSFER_DELETED ) event . invoke_webhook_handlers ()","title":"TestTransferEvents"},{"location":"reference/project/#tests.test_fields","text":"dj-stripe Custom Field Tests.","title":"test_fields"},{"location":"reference/project/#tests.test_fields.TestStripeCurrencyField","text":"tests . test_fields . TestStripeCurrencyField . noval tests . test_fields . TestStripeCurrencyField . test_stripe_to_db_none_val ( self ) Source code in tests/test_fields.py def test_stripe_to_db_none_val ( self ): self . assertEqual ( None , self . noval . stripe_to_db ({ \"noval\" : None }))","title":"TestStripeCurrencyField"},{"location":"reference/project/#tests.test_file_upload","text":"","title":"test_file_upload"},{"location":"reference/project/#tests.test_file_upload-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.test_file_upload.test_file_upload_api_retrieve","text":"Expect file_upload to use the ID of the account referring to it to retrieve itself. Source code in tests/test_file_upload.py @pytest . mark . django_db @patch ( target = \"stripe.FileUpload.retrieve\" , autospec = True , return_value = deepcopy ( FAKE_FILEUPLOAD_ICON ), ) def test_file_upload_api_retrieve ( mock_file_upload_retrieve ): \"\"\"Expect file_upload to use the ID of the account referring to it to retrieve itself. \"\"\" # Create files icon_file = FileUpload . _get_or_create_from_stripe_object ( data = FAKE_FILEUPLOAD_ICON )[ 0 ] logo_file = FileUpload . _get_or_create_from_stripe_object ( data = FAKE_FILEUPLOAD_LOGO )[ 0 ] # Create account to associate the files to it account = Account . _get_or_create_from_stripe_object ( data = FAKE_ACCOUNT )[ 0 ] # Call the API retrieve methods. icon_file . api_retrieve () logo_file . api_retrieve () # Ensure the correct Account ID was used in retrieval mock_file_upload_retrieve . assert_has_calls ( ( call ( id = icon_file . id , api_key = ANY , expand = ANY , stripe_account = account . id ), call ( id = logo_file . id , api_key = ANY , expand = ANY , stripe_account = account . id ), ) )","title":"test_file_upload_api_retrieve()"},{"location":"reference/project/#tests.test_idempotency_keys","text":"","title":"test_idempotency_keys"},{"location":"reference/project/#tests.test_idempotency_keys.IdempotencyKeyTest","text":"tests . test_idempotency_keys . IdempotencyKeyTest . test_clear_expired_idempotency_keys ( self ) Source code in tests/test_idempotency_keys.py def test_clear_expired_idempotency_keys ( self ): expired_key = get_idempotency_key ( \"customer\" , \"create:1\" , False ) expired_key_obj = IdempotencyKey . objects . get ( uuid = expired_key ) expired_key_obj . created = now () - timedelta ( hours = 25 ) expired_key_obj . save () valid_key = get_idempotency_key ( \"customer\" , \"create:2\" , False ) self . assertEqual ( IdempotencyKey . objects . count (), 2 ) clear_expired_idempotency_keys () self . assertEqual ( IdempotencyKey . objects . count (), 1 ) self . assertEqual ( str ( IdempotencyKey . objects . get () . uuid ), valid_key ) tests . test_idempotency_keys . IdempotencyKeyTest . test_generate_idempotency_key ( self ) Source code in tests/test_idempotency_keys.py def test_generate_idempotency_key ( self ): key1 = get_idempotency_key ( \"customer\" , \"create:1\" , False ) key2 = get_idempotency_key ( \"customer\" , \"create:1\" , False ) self . assertTrue ( key1 == key2 ) key3 = get_idempotency_key ( \"customer\" , \"create:2\" , False ) self . assertTrue ( key1 != key3 ) key4 = get_idempotency_key ( \"charge\" , \"create:1\" , False ) self . assertTrue ( key1 != key4 ) self . assertEqual ( IdempotencyKey . objects . count (), 3 ) key1_obj = IdempotencyKey . objects . get ( action = \"customer:create:1\" , livemode = False ) self . assertFalse ( key1_obj . is_expired ) self . assertEqual ( str ( key1_obj ), str ( key1_obj . uuid ))","title":"IdempotencyKeyTest"},{"location":"reference/project/#tests.test_integrations","text":"","title":"test_integrations"},{"location":"reference/project/#tests.test_invoice","text":"dj-stripe Invoice Model Tests.","title":"test_invoice"},{"location":"reference/project/#tests.test_invoice-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_invoice.InvoiceTest","text":"","title":"InvoiceTest"},{"location":"reference/project/#tests.test_invoice.InvoiceTest-methods","text":"tests . test_invoice . InvoiceTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_invoice.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . default_expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Invoice.default_payment_method\" , \"djstripe.Invoice.default_source\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , \"djstripe.Subscription.default_payment_method\" , \"djstripe.Subscription.default_source\" , \"djstripe.Subscription.pending_setup_intent\" , \"djstripe.Subscription.schedule\" , } tests . test_invoice . InvoiceTest . test_billing_reason_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_billing_reason_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_invoice = deepcopy ( FAKE_INVOICE ) for billing_reason in ( \"subscription_cycle\" , \"subscription_create\" , \"subscription_update\" , \"subscription\" , \"manual\" , \"upcoming\" , \"subscription_threshold\" , ): fake_invoice [ \"billing_reason\" ] = billing_reason invoice = Invoice . sync_from_stripe_data ( fake_invoice ) self . assertEqual ( invoice . billing_reason , billing_reason ) # trigger model field validation (including enum value choices check) invoice . full_clean () tests . test_invoice . InvoiceTest . test_invoice_plan_from_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_plan_from_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertIsNotNone ( invoice . plan ) # retrieved from invoice item self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_invoice_plan_from_subscription ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_plan_from_subscription ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data [ \"lines\" ][ \"data\" ][ 0 ][ \"plan\" ] = None invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertIsNotNone ( invoice . plan ) # retrieved from subscription self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_invoice_status_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_status_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_invoice = deepcopy ( FAKE_INVOICE ) for status in ( \"draft\" , \"open\" , \"paid\" , \"uncollectible\" , \"void\" , ): fake_invoice [ \"status\" ] = status invoice = Invoice . sync_from_stripe_data ( fake_invoice ) self . assertEqual ( invoice . status , status ) # trigger model field validation (including enum value choices check) invoice . full_clean () tests . test_invoice . InvoiceTest . test_invoice_with_no_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_with_no_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data [ \"lines\" ] = [] invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertIsNotNone ( invoice . plan ) # retrieved from invoice item self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_invoice_with_non_subscription_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_with_non_subscription_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data [ \"lines\" ][ \"data\" ] . append ( deepcopy ( FAKE_INVOICEITEM_II )) invoice_data [ \"lines\" ][ \"total_count\" ] += 1 invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertIsNotNone ( invoice ) self . assertEqual ( 2 , len ( invoice . invoiceitems . all ())) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_invoice_with_subscription_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_with_subscription_invoice_items ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice = Invoice . sync_from_stripe_data ( invoice_data ) items = invoice . invoiceitems . all () self . assertEqual ( 1 , len ( items )) # Previously the test asserted item_id=\"{invoice_id}-{subscription_id}\", # but this doesn't match what I'm seeing from Stripe # I'm not sure if it's possible to predict the whole item id now, # sli seems to not reference anything item_id_prefix = \" {invoice_id} -il_\" . format ( invoice_id = invoice . id ) self . assertTrue ( items [ 0 ] . id . startswith ( item_id_prefix )) self . assertEqual ( items [ 0 ] . subscription . id , FAKE_SUBSCRIPTION [ \"id\" ]) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_invoice_without_plan ( self , product_retrieve_mock , charge_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_invoice_without_plan ( self , product_retrieve_mock , charge_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data [ \"lines\" ][ \"data\" ][ 0 ][ \"plan\" ] = None invoice_data [ \"lines\" ][ \"data\" ][ 0 ][ \"subscription\" ] = None invoice_data [ \"subscription\" ] = None invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertIsNone ( invoice . plan ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Invoice.subscription\" }, ) tests . test_invoice . InvoiceTest . test_no_upcoming_invoices ( self , invoice_upcoming_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Invoice.upcoming\" , side_effect = InvalidRequestError ( \"Nothing to invoice for customer\" , None ), ) def test_no_upcoming_invoices ( self , invoice_upcoming_mock ): invoice = Invoice . upcoming () self . assertIsNone ( invoice ) tests . test_invoice . InvoiceTest . test_retry_false ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , invoice_retrieve_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_retry_false ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , invoice_retrieve_mock , ): default_account_mock . return_value = self . account fake_invoice = deepcopy ( FAKE_INVOICE ) invoice_retrieve_mock . return_value = fake_invoice invoice = Invoice . sync_from_stripe_data ( fake_invoice ) return_value = invoice . retry () self . assertFalse ( invoice_retrieve_mock . called ) self . assertFalse ( return_value ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_retry_true ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , invoice_retrieve_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_retry_true ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , invoice_retrieve_mock , ): default_account_mock . return_value = self . account fake_invoice = deepcopy ( FAKE_INVOICE ) fake_invoice . update ({ \"paid\" : False , \"status\" : \"open\" }) fake_invoice . update ({ \"auto_advance\" : True }) invoice_retrieve_mock . return_value = fake_invoice invoice = Invoice . sync_from_stripe_data ( fake_invoice ) return_value = invoice . retry () invoice_retrieve_mock . assert_called_once_with ( id = invoice . id , api_key = STRIPE_SECRET_KEY , expand = [], stripe_account = None ) self . assertTrue ( return_value ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_status_draft ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_draft ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data . update ({ \"paid\" : False , \"status\" : \"draft\" }) invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertEqual ( InvoiceStatus . draft , invoice . status ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_status_open ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_open ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data . update ({ \"paid\" : False , \"status\" : \"open\" }) invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertEqual ( InvoiceStatus . open , invoice . status ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_status_paid ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_paid ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice = Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) self . assertEqual ( InvoiceStatus . paid , invoice . status ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_status_uncollectible ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_uncollectible ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data . update ({ \"paid\" : False , \"status\" : \"uncollectible\" }) invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertEqual ( InvoiceStatus . uncollectible , invoice . status ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_status_void ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_void ( self , product_retrieve_mock , paymentmethod_card_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data . update ({ \"paid\" : False , \"status\" : \"void\" }) invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertEqual ( InvoiceStatus . void , invoice . status ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_sync_from_stripe_data ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_sync_from_stripe_data ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice = Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) self . assertEqual ( invoice . get_stripe_dashboard_url (), self . customer . get_stripe_dashboard_url () ) self . assertEqual ( str ( invoice ), \"Invoice # {} \" . format ( FAKE_INVOICE [ \"number\" ])) self . assertGreater ( len ( invoice . status_transitions . keys ()), 1 ) self . assertTrue ( bool ( invoice . account_country )) self . assertTrue ( bool ( invoice . account_name )) self . assertTrue ( bool ( invoice . collection_method )) self . assertEqual ( invoice . default_tax_rates . count (), 1 ) self . assertEqual ( invoice . default_tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( invoice . total_tax_amounts . count (), 1 ) first_tax_amount = invoice . total_tax_amounts . first () self . assertEqual ( first_tax_amount . tax_rate . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( first_tax_amount . inclusive , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"inclusive\" ] ) self . assertEqual ( first_tax_amount . amount , 261 ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_sync_from_stripe_data_default_payment_method ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_sync_from_stripe_data_default_payment_method ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account fake_invoice = deepcopy ( FAKE_INVOICE ) fake_invoice [ \"default_payment_method\" ] = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ) invoice = Invoice . sync_from_stripe_data ( fake_invoice ) self . assertEqual ( invoice . default_payment_method . id , FAKE_CARD_AS_PAYMENT_METHOD [ \"id\" ] ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks - { \"djstripe.Invoice.default_payment_method\" }, ) tests . test_invoice . InvoiceTest . test_sync_from_stripe_data_update_total_tax_amounts ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_sync_from_stripe_data_update_total_tax_amounts ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice = Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) # as per basic sync test self . assertEqual ( invoice . default_tax_rates . count (), 1 ) self . assertEqual ( invoice . default_tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( invoice . total_tax_amounts . count (), 1 ) first_tax_amount = invoice . total_tax_amounts . first () self . assertEqual ( first_tax_amount . tax_rate . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( first_tax_amount . inclusive , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"inclusive\" ] ) self . assertEqual ( first_tax_amount . amount , 261 ) self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks ) # Now update with a different tax rate # TODO - should update tax rate in invoice items etc as well, # but here we're mainly testing that invoice.total_tax_rates is # correctly updated fake_updated_invoice = deepcopy ( FAKE_INVOICE ) fake_tax_rate_2 = deepcopy ( FAKE_TAX_RATE_EXAMPLE_2_SALES ) new_tax_amount = int ( fake_updated_invoice [ \"total\" ] * fake_tax_rate_2 [ \"percentage\" ] / 100 ) fake_updated_invoice . update ( { \"default_tax_rates\" : [ fake_tax_rate_2 ], \"tax\" : new_tax_amount , \"total\" : fake_updated_invoice [ \"total\" ] + new_tax_amount , \"total_tax_amounts\" : [ { \"amount\" : new_tax_amount , \"inclusive\" : False , \"tax_rate\" : fake_tax_rate_2 [ \"id\" ], } ], } ) invoice_updated = Invoice . sync_from_stripe_data ( fake_updated_invoice ) self . assertEqual ( invoice_updated . default_tax_rates . count (), 1 ) self . assertEqual ( invoice_updated . default_tax_rates . first () . id , fake_tax_rate_2 [ \"id\" ] ) self . assertEqual ( invoice_updated . total_tax_amounts . count (), 1 ) first_tax_amount = invoice_updated . total_tax_amounts . first () self . assertEqual ( first_tax_amount . tax_rate . id , fake_tax_rate_2 [ \"id\" ]) self . assertEqual ( first_tax_amount . inclusive , fake_tax_rate_2 [ \"inclusive\" ]) self . assertEqual ( first_tax_amount . amount , new_tax_amount ) self . assert_fks ( invoice_updated , expected_blank_fks = self . default_expected_blank_fks ) tests . test_invoice . InvoiceTest . test_sync_no_subscription ( self , product_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoice.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_sync_no_subscription ( self , product_retrieve_mock , payment_intent_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , plan_retrieve_mock , paymentmethod_card_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoice_data = deepcopy ( FAKE_INVOICE ) invoice_data . update ({ \"subscription\" : None }) invoice_data [ \"lines\" ][ \"data\" ][ 0 ][ \"subscription\" ] = None invoice = Invoice . sync_from_stripe_data ( invoice_data ) self . assertEqual ( None , invoice . subscription ) self . assertEqual ( FAKE_CHARGE [ \"id\" ], invoice . charge . id ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) # charge_retrieve_mock.assert_not_called() plan_retrieve_mock . assert_not_called () subscription_retrieve_mock . assert_not_called () self . assert_fks ( invoice , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Invoice.subscription\" }, ) tests . test_invoice . InvoiceTest . test_upcoming_invoice ( self , product_retrieve_mock , invoice_upcoming_mock , subscription_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.upcoming\" , return_value = deepcopy ( FAKE_UPCOMING_INVOICE ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_upcoming_invoice ( self , product_retrieve_mock , invoice_upcoming_mock , subscription_retrieve_mock , plan_retrieve_mock , ): invoice = UpcomingInvoice . upcoming () self . assertIsNotNone ( invoice ) self . assertIsNone ( invoice . id ) self . assertIsNone ( invoice . save ()) self . assertEqual ( invoice . get_stripe_dashboard_url (), \"\" ) invoice . id = \"foo\" self . assertIsNone ( invoice . id ) subscription_retrieve_mock . assert_called_once_with ( api_key = ANY , expand = ANY , id = FAKE_SUBSCRIPTION [ \"id\" ], stripe_account = None ) plan_retrieve_mock . assert_not_called () items = invoice . invoiceitems . all () self . assertEqual ( 1 , len ( items )) self . assertEqual ( FAKE_SUBSCRIPTION [ \"id\" ], items [ 0 ] . id ) # delete/update should do nothing self . assertEqual ( invoice . invoiceitems . update (), 0 ) self . assertEqual ( invoice . invoiceitems . delete (), 0 ) self . assertIsNotNone ( invoice . plan ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) invoice . _invoiceitems = [] items = invoice . invoiceitems . all () self . assertEqual ( 0 , len ( items )) self . assertIsNotNone ( invoice . plan ) self . assertEqual ( invoice . default_tax_rates . count (), 1 ) self . assertEqual ( invoice . default_tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( invoice . total_tax_amounts . count (), 1 ) first_tax_amount = invoice . total_tax_amounts . first () self . assertEqual ( first_tax_amount . tax_rate . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assertEqual ( first_tax_amount . inclusive , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"inclusive\" ] ) self . assertEqual ( first_tax_amount . amount , 261 ) tests . test_invoice . InvoiceTest . test_upcoming_invoice_error ( self , invoice_upcoming_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Invoice.upcoming\" , side_effect = InvalidRequestError ( \"Some other error\" , None ), ) def test_upcoming_invoice_error ( self , invoice_upcoming_mock ): with self . assertRaises ( InvalidRequestError ): Invoice . upcoming () tests . test_invoice . InvoiceTest . test_upcoming_invoice_with_subscription ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.upcoming\" , return_value = deepcopy ( FAKE_UPCOMING_INVOICE ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_upcoming_invoice_with_subscription ( self , invoice_upcoming_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): invoice = Invoice . upcoming ( subscription = Subscription ( id = FAKE_SUBSCRIPTION [ \"id\" ]) ) self . assertIsNotNone ( invoice ) self . assertIsNone ( invoice . id ) self . assertIsNone ( invoice . save ()) subscription_retrieve_mock . assert_called_once_with ( api_key = ANY , expand = ANY , id = FAKE_SUBSCRIPTION [ \"id\" ], stripe_account = None ) plan_retrieve_mock . assert_not_called () self . assertIsNotNone ( invoice . plan ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id ) tests . test_invoice . InvoiceTest . test_upcoming_invoice_with_subscription_plan ( self , product_retrieve_mock , invoice_upcoming_mock , subscription_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_invoice.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Invoice.upcoming\" , return_value = deepcopy ( FAKE_UPCOMING_INVOICE ), autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_upcoming_invoice_with_subscription_plan ( self , product_retrieve_mock , invoice_upcoming_mock , subscription_retrieve_mock , plan_retrieve_mock , ): invoice = Invoice . upcoming ( subscription_plan = Plan ( id = FAKE_PLAN [ \"id\" ])) self . assertIsNotNone ( invoice ) self . assertIsNone ( invoice . id ) self . assertIsNone ( invoice . save ()) subscription_retrieve_mock . assert_called_once_with ( api_key = ANY , expand = ANY , id = FAKE_SUBSCRIPTION [ \"id\" ], stripe_account = None ) plan_retrieve_mock . assert_not_called () self . assertIsNotNone ( invoice . plan ) self . assertEqual ( FAKE_PLAN [ \"id\" ], invoice . plan . id )","title":"Methods"},{"location":"reference/project/#tests.test_invoiceitem","text":"dj-stripe InvoiceItem Model Tests.","title":"test_invoiceitem"},{"location":"reference/project/#tests.test_invoiceitem-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_invoiceitem.InvoiceItemTest","text":"","title":"InvoiceItemTest"},{"location":"reference/project/#tests.test_invoiceitem.InvoiceItemTest-methods","text":"tests . test_invoiceitem . InvoiceItemTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_invoiceitem.py def setUp ( self ): self . account = default_account () self . default_expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , \"djstripe.Invoice.default_payment_method\" , \"djstripe.Invoice.default_source\" , \"djstripe.Invoice.payment_intent\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , \"djstripe.Subscription.default_payment_method\" , \"djstripe.Subscription.default_source\" , \"djstripe.Subscription.pending_setup_intent\" , \"djstripe.Subscription.schedule\" , } tests . test_invoiceitem . InvoiceItemTest . test_str ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) def test_str ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM ) invoiceitem_data [ \"plan\" ] = FAKE_PLAN_II invoiceitem_data [ \"price\" ] = FAKE_PRICE_II invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assertEqual ( invoiceitem . get_stripe_dashboard_url (), invoiceitem . invoice . get_stripe_dashboard_url (), ) assert str ( invoiceitem ) == invoiceitem . description tests . test_invoiceitem . InvoiceItemTest . test_sync_expanded_invoice_with_subscription ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) def test_sync_expanded_invoice_with_subscription ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM ) # Expand the Invoice data invoiceitem_data . update ( { \"subscription\" : FAKE_SUBSCRIPTION_III [ \"id\" ], \"invoice\" : deepcopy ( dict ( FAKE_INVOICE_II )), } ) invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.InvoiceItem.plan\" , \"djstripe.InvoiceItem.price\" , } self . assert_fks ( invoiceitem , expected_blank_fks = expected_blank_fks ) # Coverage of sync of existing data invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assert_fks ( invoiceitem , expected_blank_fks = expected_blank_fks ) tests . test_invoiceitem . InvoiceItemTest . test_sync_null_invoice ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , price_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Price.retrieve\" , return_value = deepcopy ( FAKE_PRICE_II ), autospec = True ) @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN_II ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , autospec = True ) def test_sync_null_invoice ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , price_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM ) invoiceitem_data . update ( { \"proration\" : True , \"plan\" : FAKE_PLAN_II [ \"id\" ], \"price\" : FAKE_PRICE_II [ \"id\" ], \"invoice\" : None , } ) invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assertEqual ( FAKE_PLAN_II [ \"id\" ], invoiceitem . plan . id ) self . assertEqual ( FAKE_PRICE_II [ \"id\" ], invoiceitem . price . id ) self . assert_fks ( invoiceitem , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.InvoiceItem.invoice\" , \"djstripe.InvoiceItem.subscription\" }, ) tests . test_invoiceitem . InvoiceItemTest . test_sync_proration ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , price_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Price.retrieve\" , return_value = deepcopy ( FAKE_PRICE_II ), autospec = True ) @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN_II ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) def test_sync_proration ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , price_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM ) invoiceitem_data . update ( { \"proration\" : True , \"plan\" : FAKE_PLAN_II [ \"id\" ], \"price\" : FAKE_PRICE_II [ \"id\" ], } ) invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assertEqual ( FAKE_PLAN_II [ \"id\" ], invoiceitem . plan . id ) self . assertEqual ( FAKE_PRICE_II [ \"id\" ], invoiceitem . price . id ) self . assert_fks ( invoiceitem , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.InvoiceItem.subscription\" }, ) tests . test_invoiceitem . InvoiceItemTest . test_sync_with_subscription ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) def test_sync_with_subscription ( self , invoice_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM ) invoiceitem_data . update ({ \"subscription\" : FAKE_SUBSCRIPTION_III [ \"id\" ]}) invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.InvoiceItem.plan\" , \"djstripe.InvoiceItem.price\" , } self . assert_fks ( invoiceitem , expected_blank_fks = expected_blank_fks ) # Coverage of sync of existing data invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assert_fks ( invoiceitem , expected_blank_fks = expected_blank_fks ) invoice_retrieve_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , expand = [], id = FAKE_INVOICE_II [ \"id\" ], stripe_account = None , ) tests . test_invoiceitem . InvoiceItemTest . test_sync_with_taxes ( self , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_invoiceitem.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_III ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE_II ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_II ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_II ), autospec = True , ) @patch ( \"stripe.Invoice.retrieve\" , return_value = deepcopy ( FAKE_INVOICE_II ), autospec = True ) def test_sync_with_taxes ( self , invoice_retrieve_mock , paymentintent_retrieve_mock , paymentmethod_retrieve_mock , charge_retrieve_mock , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account invoiceitem_data = deepcopy ( FAKE_INVOICEITEM_III ) invoiceitem_data [ \"plan\" ] = FAKE_PLAN_II invoiceitem_data [ \"price\" ] = FAKE_PRICE_II invoiceitem = InvoiceItem . sync_from_stripe_data ( invoiceitem_data ) self . assertEqual ( invoiceitem . tax_rates . count (), 1 ) self . assertEqual ( invoiceitem . tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] )","title":"Methods"},{"location":"reference/project/#tests.test_managers","text":"dj-stripe Model Manager Tests.","title":"test_managers"},{"location":"reference/project/#tests.test_managers-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_managers.ChargeManagerTest","text":"","title":"ChargeManagerTest"},{"location":"reference/project/#tests.test_managers.ChargeManagerTest-methods","text":"tests . test_managers . ChargeManagerTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_managers.py def setUp ( self ): customer = Customer . objects . create ( id = \"cus_XXXXXXX\" , livemode = False , balance = 0 , delinquent = False ) self . march_charge = Charge . objects . create ( id = \"ch_XXXXMAR1\" , customer = customer , created = datetime . datetime ( 2015 , 3 , 31 , tzinfo = timezone . utc ), amount = 0 , amount_refunded = 0 , currency = \"usd\" , status = \"pending\" , ) self . april_charge_1 = Charge . objects . create ( id = \"ch_XXXXAPR1\" , customer = customer , created = datetime . datetime ( 2015 , 4 , 1 , tzinfo = timezone . utc ), amount = decimal . Decimal ( \"20.15\" ), amount_refunded = 0 , currency = \"usd\" , status = \"succeeded\" , paid = True , ) self . april_charge_2 = Charge . objects . create ( id = \"ch_XXXXAPR2\" , customer = customer , created = datetime . datetime ( 2015 , 4 , 18 , tzinfo = timezone . utc ), amount = decimal . Decimal ( \"10.35\" ), amount_refunded = decimal . Decimal ( \"5.35\" ), currency = \"usd\" , status = \"succeeded\" , paid = True , ) self . april_charge_3 = Charge . objects . create ( id = \"ch_XXXXAPR3\" , customer = customer , created = datetime . datetime ( 2015 , 4 , 30 , tzinfo = timezone . utc ), amount = decimal . Decimal ( \"100.00\" ), amount_refunded = decimal . Decimal ( \"80.00\" ), currency = \"usd\" , status = \"pending\" , paid = False , ) self . may_charge = Charge . objects . create ( id = \"ch_XXXXMAY1\" , customer = customer , created = datetime . datetime ( 2015 , 5 , 1 , tzinfo = timezone . utc ), amount = 0 , amount_refunded = 0 , currency = \"usd\" , status = \"pending\" , ) self . november_charge = Charge . objects . create ( id = \"ch_XXXXNOV1\" , customer = customer , created = datetime . datetime ( 2015 , 11 , 16 , tzinfo = timezone . utc ), amount = 0 , amount_refunded = 0 , currency = \"usd\" , status = \"pending\" , ) self . charge_2014 = Charge . objects . create ( id = \"ch_XXXX20141\" , customer = customer , created = datetime . datetime ( 2014 , 12 , 31 , tzinfo = timezone . utc ), amount = 0 , amount_refunded = 0 , currency = \"usd\" , status = \"pending\" , ) self . charge_2016 = Charge . objects . create ( id = \"ch_XXXX20161\" , customer = customer , created = datetime . datetime ( 2016 , 1 , 1 , tzinfo = timezone . utc ), amount = 0 , amount_refunded = 0 , currency = \"usd\" , status = \"pending\" , ) tests . test_managers . ChargeManagerTest . test_get_paid_totals_for_april_2015 ( self ) Source code in tests/test_managers.py def test_get_paid_totals_for_april_2015 ( self ): paid_totals = Charge . objects . paid_totals_for ( year = 2015 , month = 4 ) self . assertEqual ( decimal . Decimal ( \"30.50\" ), paid_totals [ \"total_amount\" ], \"Total amount is not correct.\" , ) self . assertEqual ( decimal . Decimal ( \"5.35\" ), paid_totals [ \"total_refunded\" ], \"Total amount refunded is not correct.\" , ) tests . test_managers . ChargeManagerTest . test_is_during_april_2015 ( self ) Source code in tests/test_managers.py def test_is_during_april_2015 ( self ): raw_charges = Charge . objects . during ( year = 2015 , month = 4 ) charges = [ charge . id for charge in raw_charges ] self . assertIn ( self . april_charge_1 . id , charges , \"April charge 1 not in charges.\" ) self . assertIn ( self . april_charge_2 . id , charges , \"April charge 2 not in charges.\" ) self . assertIn ( self . april_charge_3 . id , charges , \"April charge 3 not in charges.\" ) self . assertNotIn ( self . march_charge . id , charges , \"March charge unexpectedly in charges.\" ) self . assertNotIn ( self . may_charge . id , charges , \"May charge unexpectedly in charges.\" ) self . assertNotIn ( self . november_charge . id , charges , \"November charge unexpectedly in charges.\" ) self . assertNotIn ( self . charge_2014 . id , charges , \"2014 charge unexpectedly in charges.\" ) self . assertNotIn ( self . charge_2016 . id , charges , \"2016 charge unexpectedly in charges.\" )","title":"Methods"},{"location":"reference/project/#tests.test_managers.SubscriptionManagerTest","text":"","title":"SubscriptionManagerTest"},{"location":"reference/project/#tests.test_managers.SubscriptionManagerTest-methods","text":"tests . test_managers . SubscriptionManagerTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_managers.py def setUp ( self ): # create customers and current subscription records period_start = datetime . datetime ( 2013 , 4 , 1 , tzinfo = timezone . utc ) period_end = datetime . datetime ( 2013 , 4 , 30 , tzinfo = timezone . utc ) start = datetime . datetime ( 2013 , 1 , 1 , 0 , 0 , 1 , tzinfo = timezone . utc ) # more realistic start with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . plan = Plan . sync_from_stripe_data ( FAKE_PLAN ) self . plan2 = Plan . sync_from_stripe_data ( FAKE_PLAN_II ) for i in range ( 10 ): user = get_user_model () . objects . create_user ( username = \"patrick {0} \" . format ( i ), email = \"patrick {0} @example.com\" . format ( i ), ) customer = Customer . objects . create ( subscriber = user , id = \"cus_xxxxxxxxxxxxxx {0} \" . format ( i ), livemode = False , balance = 0 , delinquent = False , ) Subscription . objects . create ( id = \"sub_xxxxxxxxxxxxxx {0} \" . format ( i ), customer = customer , plan = self . plan , current_period_start = period_start , current_period_end = period_end , status = \"active\" , start_date = start , quantity = 1 , ) user = get_user_model () . objects . create_user ( username = \"patrick {0} \" . format ( 11 ), email = \"patrick {0} @example.com\" . format ( 11 ) ) customer = Customer . objects . create ( subscriber = user , id = \"cus_xxxxxxxxxxxxxx {0} \" . format ( 11 ), livemode = False , balance = 0 , delinquent = False , ) Subscription . objects . create ( id = \"sub_xxxxxxxxxxxxxx {0} \" . format ( 11 ), customer = customer , plan = self . plan , current_period_start = period_start , current_period_end = period_end , status = \"canceled\" , canceled_at = period_end , start_date = start , quantity = 1 , ) user = get_user_model () . objects . create_user ( username = \"patrick {0} \" . format ( 12 ), email = \"patrick {0} @example.com\" . format ( 12 ) ) customer = Customer . objects . create ( subscriber = user , id = \"cus_xxxxxxxxxxxxxx {0} \" . format ( 12 ), livemode = False , balance = 0 , delinquent = False , ) Subscription . objects . create ( id = \"sub_xxxxxxxxxxxxxx {0} \" . format ( 12 ), customer = customer , plan = self . plan2 , current_period_start = period_start , current_period_end = period_end , status = \"active\" , start_date = start , quantity = 1 , ) tests . test_managers . SubscriptionManagerTest . test_active_all ( self ) Source code in tests/test_managers.py def test_active_all ( self ): self . assertEqual ( Subscription . objects . active () . count (), 11 ) tests . test_managers . SubscriptionManagerTest . test_active_plan_summary ( self ) Source code in tests/test_managers.py def test_active_plan_summary ( self ): for plan in Subscription . objects . active_plan_summary (): if plan [ \"plan\" ] == self . plan : self . assertEqual ( plan [ \"count\" ], 10 ) if plan [ \"plan\" ] == self . plan2 : self . assertEqual ( plan [ \"count\" ], 1 ) tests . test_managers . SubscriptionManagerTest . test_canceled_all ( self ) Source code in tests/test_managers.py def test_canceled_all ( self ): self . assertEqual ( Subscription . objects . canceled () . count (), 1 ) tests . test_managers . SubscriptionManagerTest . test_canceled_during ( self ) Source code in tests/test_managers.py def test_canceled_during ( self ): self . assertEqual ( Subscription . objects . canceled_during ( 2013 , 4 ) . count (), 1 ) tests . test_managers . SubscriptionManagerTest . test_canceled_plan_summary ( self ) Source code in tests/test_managers.py def test_canceled_plan_summary ( self ): for plan in Subscription . objects . canceled_plan_summary_for ( 2013 , 1 ): if plan [ \"plan\" ] == self . plan : self . assertEqual ( plan [ \"count\" ], 1 ) if plan [ \"plan\" ] == self . plan2 : self . assertEqual ( plan [ \"count\" ], 0 ) tests . test_managers . SubscriptionManagerTest . test_churn ( self ) Source code in tests/test_managers.py def test_churn ( self ): self . assertEqual ( Subscription . objects . churn (), decimal . Decimal ( \"1\" ) / decimal . Decimal ( \"11\" ) ) tests . test_managers . SubscriptionManagerTest . test_started_during_has_records ( self ) Source code in tests/test_managers.py def test_started_during_has_records ( self ): self . assertEqual ( Subscription . objects . started_during ( 2013 , 1 ) . count (), 12 ) tests . test_managers . SubscriptionManagerTest . test_started_during_no_records ( self ) Source code in tests/test_managers.py def test_started_during_no_records ( self ): self . assertEqual ( Subscription . objects . started_during ( 2013 , 4 ) . count (), 0 ) tests . test_managers . SubscriptionManagerTest . test_started_plan_summary ( self ) Source code in tests/test_managers.py def test_started_plan_summary ( self ): for plan in Subscription . objects . started_plan_summary_for ( 2013 , 1 ): if plan [ \"plan\" ] == self . plan : self . assertEqual ( plan [ \"count\" ], 11 ) if plan [ \"plan\" ] == self . plan2 : self . assertEqual ( plan [ \"count\" ], 1 )","title":"Methods"},{"location":"reference/project/#tests.test_managers.TransferManagerTest","text":"tests . test_managers . TransferManagerTest . test_transfer_summary ( self ) Source code in tests/test_managers.py def test_transfer_summary ( self ): Transfer . sync_from_stripe_data ( deepcopy ( FAKE_TRANSFER )) Transfer . sync_from_stripe_data ( deepcopy ( FAKE_TRANSFER_II )) Transfer . sync_from_stripe_data ( deepcopy ( FAKE_TRANSFER_III )) self . assertEqual ( Transfer . objects . during ( 2015 , 8 ) . count (), 2 ) totals = Transfer . objects . paid_totals_for ( 2015 , 12 ) self . assertEqual ( totals [ \"total_amount\" ], decimal . Decimal ( \"190.10\" ))","title":"TransferManagerTest"},{"location":"reference/project/#tests.test_middleware","text":"dj-stripe Middleware Tests.","title":"test_middleware"},{"location":"reference/project/#tests.test_middleware-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_middleware.MiddlewareLogicTest","text":"tests . test_middleware . MiddlewareLogicTest . urlconf","title":"MiddlewareLogicTest"},{"location":"reference/project/#tests.test_middleware.MiddlewareLogicTest-methods","text":"tests . test_middleware . MiddlewareLogicTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_middleware.py def setUp ( self ): self . settings ( ROOT_URLCONF = self . urlconf ) self . factory = RequestFactory () self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = Customer . sync_from_stripe_data ( FAKE_CUSTOMER ) self . customer . subscriber = self . user self . customer . save () with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . subscription = Subscription . sync_from_stripe_data ( FAKE_SUBSCRIPTION ) self . middleware = SubscriptionPaymentMiddleware ( lambda r : r ) tests . test_middleware . MiddlewareLogicTest . test_anonymous ( self ) Source code in tests/test_middleware.py def test_anonymous ( self ): request = self . factory . get ( \"/djstripe/webhook/\" ) request . user = AnonymousUser () request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareLogicTest . test_customer_has_active_subscription ( self ) Source code in tests/test_middleware.py def test_customer_has_active_subscription ( self ): self . subscription . current_period_end = FUTURE_DATE self . subscription . save () request = self . factory . get ( \"/testapp_content/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareLogicTest . test_customer_has_inactive_subscription ( self ) Source code in tests/test_middleware.py def test_customer_has_inactive_subscription ( self ): with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . subscription = Subscription . sync_from_stripe_data ( FAKE_SUBSCRIPTION_NOT_PERIOD_CURRENT ) request = self . factory . get ( \"/testapp_content/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response . status_code , 302 ) tests . test_middleware . MiddlewareLogicTest . test_is_staff ( self ) Source code in tests/test_middleware.py def test_is_staff ( self ): self . user . is_staff = True self . user . save () request = self . factory . get ( \"/djstripe/webhook/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareLogicTest . test_is_superuser ( self ) Source code in tests/test_middleware.py def test_is_superuser ( self ): self . user . is_superuser = True self . user . save () request = self . factory . get ( \"/djstripe/webhook/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None )","title":"Methods"},{"location":"reference/project/#tests.test_middleware.MiddlewareURLTest","text":"tests . test_middleware . MiddlewareURLTest . urlconf","title":"MiddlewareURLTest"},{"location":"reference/project/#tests.test_middleware.MiddlewareURLTest-methods","text":"tests . test_middleware . MiddlewareURLTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_middleware.py def setUp ( self ): self . settings ( ROOT_URLCONF = self . urlconf ) self . factory = RequestFactory () self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . middleware = SubscriptionPaymentMiddleware ( lambda r : r ) tests . test_middleware . MiddlewareURLTest . test_appname ( self ) Source code in tests/test_middleware.py def test_appname ( self ): request = self . factory . get ( \"/admin/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareURLTest . test_djdt ( self ) Source code in tests/test_middleware.py @override_settings ( DEBUG = True ) def test_djdt ( self ): request = self . factory . get ( \"/__debug__/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareURLTest . test_fnmatch ( self ) Source code in tests/test_middleware.py def test_fnmatch ( self ): request = self . factory . get ( \"/test_fnmatch/extra_text/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareURLTest . test_middleware_loads ( self ) Check that the middleware can be loaded by django's middleware handlers. This is to check for compatibility across the change to django's middleware class structure. See https://docs.djangoproject.com/en/1.10/topics/http/middleware/#upgrading-pre-django-1-10-style-middleware Source code in tests/test_middleware.py @override_settings ( DEBUG = True ) @modify_settings ( MIDDLEWARE = { \"append\" : [ \"djstripe.middleware.SubscriptionPaymentMiddleware\" ]} ) def test_middleware_loads ( self ): \"\"\"Check that the middleware can be loaded by django's middleware handlers. This is to check for compatibility across the change to django's middleware class structure. See https://docs.djangoproject.com/en/1.10/topics/http/middleware/#upgrading-pre-django-1-10-style-middleware \"\"\" self . client . get ( \"/__debug__\" ) tests . test_middleware . MiddlewareURLTest . test_namespace ( self ) Source code in tests/test_middleware.py def test_namespace ( self ): request = self . factory . get ( \"/djstripe/webhook/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareURLTest . test_namespace_and_url ( self ) Source code in tests/test_middleware.py def test_namespace_and_url ( self ): request = self . factory . get ( \"/testapp_namespaced/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None ) tests . test_middleware . MiddlewareURLTest . test_url ( self ) Source code in tests/test_middleware.py def test_url ( self ): request = self . factory . get ( \"/testapp/\" ) request . user = self . user request . urlconf = self . urlconf response = self . middleware . process_request ( request ) self . assertEqual ( response , None )","title":"Methods"},{"location":"reference/project/#tests.test_mixins","text":"dj-stripe Mixin Tests.","title":"test_mixins"},{"location":"reference/project/#tests.test_mixins-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_mixins.TestPaymentsContextMixin","text":"tests . test_mixins . TestPaymentsContextMixin . test_get_context_data ( self ) Source code in tests/test_mixins.py def test_get_context_data ( self ): class TestSuperView ( object ): def get_context_data ( self ): return {} class TestView ( PaymentsContextMixin , TestSuperView ): pass context = TestView () . get_context_data () self . assertIn ( \"STRIPE_PUBLIC_KEY\" , context , \"STRIPE_PUBLIC_KEY missing from context.\" ) self . assertEqual ( context [ \"STRIPE_PUBLIC_KEY\" ], STRIPE_PUBLIC_KEY , \"Incorrect STRIPE_PUBLIC_KEY.\" , ) self . assertIn ( \"plans\" , context , \"pans missing from context.\" ) self . assertEqual ( list ( Plan . objects . all ()), list ( context [ \"plans\" ]), \"Incorrect plans.\" )","title":"TestPaymentsContextMixin"},{"location":"reference/project/#tests.test_mixins.TestSubscriptionMixin","text":"","title":"TestSubscriptionMixin"},{"location":"reference/project/#tests.test_mixins.TestSubscriptionMixin-methods","text":"tests . test_mixins . TestSubscriptionMixin . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_mixins.py def setUp ( self ): with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN )) Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN_II )) tests . test_mixins . TestSubscriptionMixin . test_get_context_data ( self , stripe_create_customer_mock ) Source code in tests/test_mixins.py @patch ( \"stripe.Customer.create\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_get_context_data ( self , stripe_create_customer_mock ): class TestSuperView ( object ): def get_context_data ( self ): return {} class TestView ( SubscriptionMixin , TestSuperView ): pass test_view = TestView () test_view . request = RequestFactory () test_view . request . user = get_user_model () . objects . create ( username = \"x\" , email = \"user@test.com\" ) context = test_view . get_context_data () self . assertIn ( \"is_plans_plural\" , context , \"is_plans_plural missing from context.\" ) self . assertTrue ( context [ \"is_plans_plural\" ], \"Incorrect is_plans_plural.\" ) self . assertIn ( \"customer\" , context , \"customer missing from context.\" )","title":"Methods"},{"location":"reference/project/#tests.test_payment_intent","text":"dj-stripe PaymentIntent Model Tests.","title":"test_payment_intent"},{"location":"reference/project/#tests.test_payment_intent.PaymentIntentTest","text":"tests . test_payment_intent . PaymentIntentTest . test_canceled_intent ( self , customer_retrieve_mock ) Source code in tests/test_payment_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_canceled_intent ( self , customer_retrieve_mock ): fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) fake_payment_intent [ \"status\" ] = \"canceled\" fake_payment_intent [ \"canceled_at\" ] = 1567524169 for reason in ( None , \"duplicate\" , \"fraudulent\" , \"requested_by_customer\" , \"abandoned\" , \"failed_invoice\" , \"void_invoice\" , \"automatic\" , ): fake_payment_intent [ \"cancellation_reason\" ] = reason payment_intent = PaymentIntent . sync_from_stripe_data ( fake_payment_intent ) if reason is None : # enums nulls are coerced to \"\" by StripeModel._stripe_object_to_record self . assertEqual ( payment_intent . cancellation_reason , \"\" ) else : self . assertEqual ( payment_intent . cancellation_reason , reason ) # trigger model field validation (including enum value choices check) payment_intent . full_clean () tests . test_payment_intent . PaymentIntentTest . test_status_enum ( self , customer_retrieve_mock ) Source code in tests/test_payment_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_status_enum ( self , customer_retrieve_mock ): fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) for status in ( \"requires_payment_method\" , \"requires_confirmation\" , \"requires_action\" , \"processing\" , \"requires_capture\" , \"canceled\" , \"succeeded\" , ): fake_payment_intent [ \"status\" ] = status payment_intent = PaymentIntent . sync_from_stripe_data ( fake_payment_intent ) # trigger model field validation (including enum value choices check) payment_intent . full_clean () tests . test_payment_intent . PaymentIntentTest . test_sync_from_stripe_data ( self , customer_retrieve_mock ) Source code in tests/test_payment_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_from_stripe_data ( self , customer_retrieve_mock ): fake_payment_intent = deepcopy ( FAKE_PAYMENT_INTENT_I ) payment_intent = PaymentIntent . sync_from_stripe_data ( fake_payment_intent ) self . assert_fks ( payment_intent , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , }, ) # TODO - PaymentIntent should probably sync invoice (reverse OneToOneField) # self.assertIsNotNone(payment_intent.invoice)","title":"PaymentIntentTest"},{"location":"reference/project/#tests.test_payment_method","text":"dj-stripe PaymenthMethod Model Tests.","title":"test_payment_method"},{"location":"reference/project/#tests.test_payment_method-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_payment_method.PaymentMethodTest","text":"","title":"PaymentMethodTest"},{"location":"reference/project/#tests.test_payment_method.PaymentMethodTest-methods","text":"tests . test_payment_method . PaymentMethodTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_payment_method.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"testuser\" , email = \"djstripe@example.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_payment_method . PaymentMethodTest . test_attach ( self , attach_mock ) Source code in tests/test_payment_method.py @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_attach ( self , attach_mock ): payment_method = PaymentMethod . attach ( FAKE_PAYMENT_METHOD_I [ \"id\" ], customer = FAKE_CUSTOMER [ \"id\" ] ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_payment_method . PaymentMethodTest . test_attach_obj ( self , attach_mock ) Source code in tests/test_payment_method.py @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_attach_obj ( self , attach_mock ): pm = PaymentMethod . sync_from_stripe_data ( FAKE_PAYMENT_METHOD_I ) payment_method = PaymentMethod . attach ( pm , customer = self . customer ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_payment_method . PaymentMethodTest . test_attach_synced ( self , attach_mock ) Source code in tests/test_payment_method.py @patch ( \"stripe.PaymentMethod.attach\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I )) def test_attach_synced ( self , attach_mock ): fake_payment_method = deepcopy ( FAKE_PAYMENT_METHOD_I ) fake_payment_method [ \"customer\" ] = None payment_method = PaymentMethod . sync_from_stripe_data ( fake_payment_method ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.PaymentMethod.customer\" } ) payment_method = PaymentMethod . attach ( payment_method . id , customer = FAKE_CUSTOMER [ \"id\" ] ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_payment_method . PaymentMethodTest . test_detach ( self ) Source code in tests/test_payment_method.py def test_detach ( self ): original_detach = PaymentMethodDict . detach def mocked_detach ( * args , ** kwargs ): return original_detach ( * args , ** kwargs ) with patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I ), autospec = True , ): PaymentMethod . sync_from_stripe_data ( deepcopy ( FAKE_PAYMENT_METHOD_I )) self . assertEqual ( 1 , self . customer . payment_methods . count ()) payment_method = self . customer . payment_methods . first () with patch ( \"tests.PaymentMethodDict.detach\" , side_effect = mocked_detach , autospec = True ) as mock_detach , patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I ), autospec = True , ): self . assertTrue ( payment_method . detach ()) self . assertEqual ( 0 , self . customer . payment_methods . count ()) self . assertIsNone ( self . customer . default_payment_method ) self . assertIsNone ( payment_method . customer ) if sys . version_info >= ( 3 , 6 ): # this mock isn't working on py34, py35, but it's not strictly necessary # for the test mock_detach . assert_called () self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.PaymentMethod.customer\" } ) with patch ( \"tests.PaymentMethodDict.detach\" , side_effect = InvalidRequestError ( message = \"A source must be attached to a customer to be used \" \"as a `payment_method`\" , param = \"payment_method\" , ), autospec = True , ) as mock_detach , patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_METHOD_I ), autospec = True , ) as payment_method_retrieve_mock : payment_method_retrieve_mock . return_value [ \"customer\" ] = None self . assertFalse ( payment_method . detach (), \"Second call to detach should return false\" ) tests . test_payment_method . PaymentMethodTest . test_detach_card ( self ) Source code in tests/test_payment_method.py def test_detach_card ( self ): original_detach = PaymentMethodDict . detach # \"card_\" payment methods are deleted after detach deleted_card_exception = InvalidRequestError ( message = \"No such payment_method: card_xxxx\" , param = \"payment_method\" , code = \"resource_missing\" , ) def mocked_detach ( * args , ** kwargs ): return original_detach ( * args , ** kwargs ) with patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ): PaymentMethod . sync_from_stripe_data ( deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD )) self . assertEqual ( 1 , self . customer . payment_methods . count ()) payment_method = self . customer . payment_methods . first () self . assertTrue ( payment_method . id . startswith ( \"card_\" ), \"We expect this to be a 'card_'\" ) with patch ( \"tests.PaymentMethodDict.detach\" , side_effect = mocked_detach , autospec = True ) as mock_detach , patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ): self . assertTrue ( payment_method . detach ()) self . assertEqual ( 0 , self . customer . payment_methods . count ()) self . assertIsNone ( self . customer . default_payment_method ) self . assertEqual ( PaymentMethod . objects . filter ( id = payment_method . id ) . count (), 0 , \"We expect PaymentMethod id = card_* to be deleted\" , ) if sys . version_info >= ( 3 , 6 ): # this mock isn't working on py34, py35, but it's not strictly necessary # for the test mock_detach . assert_called () with patch ( \"tests.PaymentMethodDict.detach\" , side_effect = InvalidRequestError ( message = \"A source must be attached to a customer to be used \" \"as a `payment_method`\" , param = \"payment_method\" , ), autospec = True , ) as mock_detach , patch ( \"stripe.PaymentMethod.retrieve\" , side_effect = deleted_card_exception , autospec = True , ) as payment_method_retrieve_mock : payment_method_retrieve_mock . return_value [ \"customer\" ] = None self . assertFalse ( payment_method . detach (), \"Second call to detach should return false\" ) tests . test_payment_method . PaymentMethodTest . test_sync_null_customer ( self ) Source code in tests/test_payment_method.py def test_sync_null_customer ( self ): payment_method = PaymentMethod . sync_from_stripe_data ( deepcopy ( FAKE_PAYMENT_METHOD_I ) ) self . assertIsNotNone ( payment_method . customer ) # simulate remote detach fake_payment_method_no_customer = deepcopy ( FAKE_PAYMENT_METHOD_I ) fake_payment_method_no_customer [ \"customer\" ] = None payment_method = PaymentMethod . sync_from_stripe_data ( fake_payment_method_no_customer ) self . assertIsNone ( payment_method . customer ) self . assert_fks ( payment_method , expected_blank_fks = { \"djstripe.PaymentMethod.customer\" } )","title":"Methods"},{"location":"reference/project/#tests.test_plan","text":"dj-stripe Plan Model Tests.","title":"test_plan"},{"location":"reference/project/#tests.test_plan-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_plan.HumanReadablePlanTest","text":"tests . test_plan . HumanReadablePlanTest . test_human_readable_10_usd_2weeks ( self ) Source code in tests/test_plan.py def test_human_readable_10_usd_2weeks ( self ): plan = Plan . objects . create ( id = \"plan-test-10-usd-2w\" , active = True , amount = 10 , currency = \"usd\" , interval = \"week\" , interval_count = 2 , ) self . assertEqual ( plan . human_readable_price , \"$10.00 USD every 2 weeks\" ) tests . test_plan . HumanReadablePlanTest . test_human_readable_10_usd_weekly ( self ) Source code in tests/test_plan.py def test_human_readable_10_usd_weekly ( self ): plan = Plan . objects . create ( id = \"plan-test-10-usd-weekly\" , active = True , amount = 10 , currency = \"usd\" , interval = \"week\" , interval_count = 1 , ) self . assertEqual ( plan . human_readable_price , \"$10.00 USD/week\" ) tests . test_plan . HumanReadablePlanTest . test_human_readable_10_usd_yearly ( self ) Source code in tests/test_plan.py def test_human_readable_10_usd_yearly ( self ): plan = Plan . objects . create ( id = \"plan-test-10-usd-yearly\" , active = True , amount = 10 , currency = \"usd\" , interval = \"year\" , interval_count = 1 , ) self . assertEqual ( plan . human_readable_price , \"$10.00 USD/year\" ) tests . test_plan . HumanReadablePlanTest . test_human_readable_25_usd_6months ( self ) Source code in tests/test_plan.py def test_human_readable_25_usd_6months ( self ): plan = Plan . objects . create ( id = \"plan-test-25-usd-6m\" , active = True , amount = 25 , currency = \"usd\" , interval = \"month\" , interval_count = 6 , ) self . assertEqual ( plan . human_readable_price , \"$25.00 USD every 6 months\" ) tests . test_plan . HumanReadablePlanTest . test_human_readable_499_usd_monthly ( self ) Source code in tests/test_plan.py def test_human_readable_499_usd_monthly ( self ): plan = Plan . objects . create ( id = \"plan-test-499-usd-monthly\" , active = True , amount = Decimal ( \"4.99\" ), currency = \"usd\" , interval = \"month\" , interval_count = 1 , ) self . assertEqual ( plan . human_readable_price , \"$4.99 USD/month\" ) tests . test_plan . HumanReadablePlanTest . test_human_readable_free_usd_daily ( self ) Source code in tests/test_plan.py def test_human_readable_free_usd_daily ( self ): plan = Plan . objects . create ( id = \"plan-test-free-usd-daily\" , active = True , amount = 0 , currency = \"usd\" , interval = \"day\" , interval_count = 1 , ) self . assertEqual ( plan . human_readable_price , \"$0.00 USD/day\" )","title":"HumanReadablePlanTest"},{"location":"reference/project/#tests.test_plan.PlanCreateTest","text":"","title":"PlanCreateTest"},{"location":"reference/project/#tests.test_plan.PlanCreateTest-methods","text":"tests . test_plan . PlanCreateTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_plan.py def setUp ( self ): with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . stripe_product = Product ( id = FAKE_PRODUCT [ \"id\" ]) . api_retrieve () tests . test_plan . PlanCreateTest . test_create_from_djstripe_product ( self , plan_create_mock , product_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Plan.create\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) def test_create_from_djstripe_product ( self , plan_create_mock , product_retrieve_mock ): fake_plan = deepcopy ( FAKE_PLAN ) fake_plan [ \"product\" ] = Product . sync_from_stripe_data ( self . stripe_product ) fake_plan [ \"amount\" ] = fake_plan [ \"amount\" ] / 100 self . assertIsInstance ( fake_plan [ \"product\" ], Product ) plan = Plan . create ( ** fake_plan ) plan_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** FAKE_PLAN ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_plan . PlanCreateTest . test_create_from_product_id ( self , plan_create_mock , product_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Plan.create\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) def test_create_from_product_id ( self , plan_create_mock , product_retrieve_mock ): fake_plan = deepcopy ( FAKE_PLAN ) fake_plan [ \"amount\" ] = fake_plan [ \"amount\" ] / 100 self . assertIsInstance ( fake_plan [ \"product\" ], str ) plan = Plan . create ( ** fake_plan ) expected_create_kwargs = deepcopy ( FAKE_PLAN ) expected_create_kwargs [ \"api_key\" ] = STRIPE_SECRET_KEY plan_create_mock . assert_called_once_with ( ** expected_create_kwargs ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_plan . PlanCreateTest . test_create_from_stripe_product ( self , plan_create_mock , product_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Plan.create\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) def test_create_from_stripe_product ( self , plan_create_mock , product_retrieve_mock ): fake_plan = deepcopy ( FAKE_PLAN ) fake_plan [ \"product\" ] = self . stripe_product fake_plan [ \"amount\" ] = fake_plan [ \"amount\" ] / 100 self . assertIsInstance ( fake_plan [ \"product\" ], dict ) plan = Plan . create ( ** fake_plan ) expected_create_kwargs = deepcopy ( FAKE_PLAN ) expected_create_kwargs [ \"product\" ] = self . stripe_product plan_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** expected_create_kwargs ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_plan . PlanCreateTest . test_create_with_metadata ( self , plan_create_mock , product_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Plan.create\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) def test_create_with_metadata ( self , plan_create_mock , product_retrieve_mock ): metadata = { \"other_data\" : \"more_data\" } fake_plan = deepcopy ( FAKE_PLAN ) fake_plan [ \"amount\" ] = fake_plan [ \"amount\" ] / 100 fake_plan [ \"metadata\" ] = metadata self . assertIsInstance ( fake_plan [ \"product\" ], str ) plan = Plan . create ( ** fake_plan ) expected_create_kwargs = deepcopy ( FAKE_PLAN ) expected_create_kwargs [ \"metadata\" ] = metadata plan_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** expected_create_kwargs ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" })","title":"Methods"},{"location":"reference/project/#tests.test_plan.PlanTest","text":"","title":"PlanTest"},{"location":"reference/project/#tests.test_plan.PlanTest-methods","text":"tests . test_plan . PlanTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_plan.py def setUp ( self ): self . plan_data = deepcopy ( FAKE_PLAN ) with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . plan = Plan . sync_from_stripe_data ( self . plan_data ) tests . test_plan . PlanTest . test_str ( self ) Source code in tests/test_plan.py def test_str ( self ): self . assertEqual ( str ( self . plan ), self . plan_data [ \"nickname\" ]) tests . test_plan . PlanTest . test_stripe_metered_plan ( self , plan_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) def test_stripe_metered_plan ( self , plan_retrieve_mock ): plan_data = deepcopy ( FAKE_PLAN_METERED ) plan = Plan . sync_from_stripe_data ( plan_data ) self . assertEqual ( plan . id , plan_data [ \"id\" ]) self . assertEqual ( plan . usage_type , PriceUsageType . metered ) self . assertIsNotNone ( plan . amount ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_plan . PlanTest . test_stripe_plan ( self , plan_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Plan.retrieve\" , return_value = FAKE_PLAN , autospec = True ) def test_stripe_plan ( self , plan_retrieve_mock ): stripe_plan = self . plan . api_retrieve () plan_retrieve_mock . assert_called_once_with ( id = self . plan_data [ \"id\" ], api_key = STRIPE_SECRET_KEY , expand = [], stripe_account = None , ) plan = Plan . sync_from_stripe_data ( stripe_plan ) assert plan . amount_in_cents == plan . amount * 100 assert isinstance ( plan . amount_in_cents , int ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_plan . PlanTest . test_stripe_plan_null_product ( self , product_retrieve_mock ) assert that plan.Product can be null for backwards compatibility though note that it is a Stripe required field Source code in tests/test_plan.py @patch ( \"stripe.Product.retrieve\" , autospec = True ) def test_stripe_plan_null_product ( self , product_retrieve_mock ): \"\"\" assert that plan.Product can be null for backwards compatibility though note that it is a Stripe required field \"\"\" plan_data = deepcopy ( FAKE_PLAN_II ) del plan_data [ \"product\" ] plan = Plan . sync_from_stripe_data ( plan_data ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Plan.product\" }, ) tests . test_plan . PlanTest . test_stripe_tier_plan ( self , plan_retrieve_mock ) Source code in tests/test_plan.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) def test_stripe_tier_plan ( self , plan_retrieve_mock ): tier_plan_data = deepcopy ( FAKE_TIER_PLAN ) plan = Plan . sync_from_stripe_data ( tier_plan_data ) self . assertEqual ( plan . id , tier_plan_data [ \"id\" ]) self . assertIsNone ( plan . amount ) self . assertIsNotNone ( plan . tiers ) self . assert_fks ( plan , expected_blank_fks = { \"djstripe.Customer.coupon\" })","title":"Methods"},{"location":"reference/project/#tests.test_price","text":"dj-stripe Price model tests","title":"test_price"},{"location":"reference/project/#tests.test_price-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_price.HumanReadablePriceTest","text":"","title":"HumanReadablePriceTest"},{"location":"reference/project/#tests.test_price.HumanReadablePriceTest-methods","text":"tests . test_price . HumanReadablePriceTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_price.py def setUp ( self ): product_data = deepcopy ( FAKE_PRODUCT ) self . stripe_product = Product . sync_from_stripe_data ( product_data ) tests . test_price . HumanReadablePriceTest . test_human_readable_10_usd_2weeks ( self ) Source code in tests/test_price.py def test_human_readable_10_usd_2weeks ( self ): price = Price . objects . create ( id = \"price-test-10-usd-2w\" , active = True , unit_amount = 1000 , currency = \"usd\" , product = self . stripe_product , recurring = { \"interval\" : \"week\" , \"interval_count\" : 2 , }, ) assert price . human_readable_price == \"$10.00 USD every 2 weeks\" tests . test_price . HumanReadablePriceTest . test_human_readable_10_usd_weekly ( self ) Source code in tests/test_price.py def test_human_readable_10_usd_weekly ( self ): price = Price . objects . create ( id = \"price-test-10-usd-weekly\" , active = True , unit_amount = 1000 , currency = \"usd\" , product = self . stripe_product , recurring = dict ( interval = \"week\" , interval_count = 1 , ), ) assert price . human_readable_price == \"$10.00 USD/week\" tests . test_price . HumanReadablePriceTest . test_human_readable_10_usd_yearly ( self ) Source code in tests/test_price.py def test_human_readable_10_usd_yearly ( self ): price = Price . objects . create ( id = \"price-test-10-usd-yearly\" , active = True , unit_amount = 1000 , currency = \"usd\" , product = self . stripe_product , recurring = dict ( interval = \"year\" , interval_count = 1 , ), ) assert price . human_readable_price == \"$10.00 USD/year\" tests . test_price . HumanReadablePriceTest . test_human_readable_25_usd_6months ( self ) Source code in tests/test_price.py def test_human_readable_25_usd_6months ( self ): price = Price . objects . create ( id = \"price-test-25-usd-6m\" , active = True , unit_amount = 2500 , currency = \"usd\" , product = self . stripe_product , recurring = dict ( interval = \"month\" , interval_count = 6 , ), ) assert price . human_readable_price == \"$25.00 USD every 6 months\" tests . test_price . HumanReadablePriceTest . test_human_readable_499_usd_monthly ( self ) Source code in tests/test_price.py def test_human_readable_499_usd_monthly ( self ): price = Price . objects . create ( id = \"price-test-499-usd-monthly\" , active = True , unit_amount = 499 , currency = \"usd\" , product = self . stripe_product , recurring = dict ( interval = \"month\" , interval_count = 1 , ), ) assert price . human_readable_price == \"$4.99 USD/month\" tests . test_price . HumanReadablePriceTest . test_human_readable_free_usd_daily ( self ) Source code in tests/test_price.py def test_human_readable_free_usd_daily ( self ): price = Price . objects . create ( id = \"price-test-free-usd-daily\" , active = True , unit_amount = 0 , currency = \"usd\" , product = self . stripe_product , recurring = dict ( interval = \"day\" , interval_count = 1 , ), ) assert price . human_readable_price == \"$0.00 USD/day\" tests . test_price . HumanReadablePriceTest . test_human_readable_one_time ( self ) Source code in tests/test_price.py def test_human_readable_one_time ( self ): price = Price . objects . create ( id = \"price-test-one-time\" , active = True , unit_amount = 2000 , currency = \"usd\" , product = self . stripe_product , ) assert price . human_readable_price == \"$20.00 USD (one time)\"","title":"Methods"},{"location":"reference/project/#tests.test_price.PriceCreateTest","text":"","title":"PriceCreateTest"},{"location":"reference/project/#tests.test_price.PriceCreateTest-methods","text":"tests . test_price . PriceCreateTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_price.py def setUp ( self ): with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . stripe_product = Product ( id = FAKE_PRODUCT [ \"id\" ]) . api_retrieve () tests . test_price . PriceCreateTest . test_create_from_djstripe_product ( self , price_create_mock , product_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Price.create\" , return_value = deepcopy ( FAKE_PRICE ), autospec = True ) def test_create_from_djstripe_product ( self , price_create_mock , product_retrieve_mock ): fake_price = deepcopy ( FAKE_PRICE ) fake_price [ \"product\" ] = Product . sync_from_stripe_data ( self . stripe_product ) fake_price [ \"unit_amount\" ] /= 100 assert isinstance ( fake_price [ \"product\" ], Product ) price = Price . create ( ** fake_price ) price_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** FAKE_PRICE ) self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_price . PriceCreateTest . test_create_from_product_id ( self , price_create_mock , product_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Price.create\" , return_value = deepcopy ( FAKE_PRICE ), autospec = True ) def test_create_from_product_id ( self , price_create_mock , product_retrieve_mock ): fake_price = deepcopy ( FAKE_PRICE ) fake_price [ \"unit_amount\" ] /= 100 assert isinstance ( fake_price [ \"product\" ], str ) price = Price . create ( ** fake_price ) expected_create_kwargs = deepcopy ( FAKE_PRICE ) expected_create_kwargs [ \"api_key\" ] = STRIPE_SECRET_KEY price_create_mock . assert_called_once_with ( ** expected_create_kwargs ) self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_price . PriceCreateTest . test_create_from_stripe_product ( self , price_create_mock , product_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Price.create\" , return_value = deepcopy ( FAKE_PRICE ), autospec = True ) def test_create_from_stripe_product ( self , price_create_mock , product_retrieve_mock ): fake_price = deepcopy ( FAKE_PRICE ) fake_price [ \"product\" ] = self . stripe_product fake_price [ \"unit_amount\" ] /= 100 assert isinstance ( fake_price [ \"product\" ], dict ) price = Price . create ( ** fake_price ) expected_create_kwargs = deepcopy ( FAKE_PRICE ) expected_create_kwargs [ \"product\" ] = self . stripe_product price_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** expected_create_kwargs ) self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_price . PriceCreateTest . test_create_with_metadata ( self , price_create_mock , product_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Price.create\" , return_value = deepcopy ( FAKE_PRICE ), autospec = True ) def test_create_with_metadata ( self , price_create_mock , product_retrieve_mock ): metadata = { \"other_data\" : \"more_data\" } fake_price = deepcopy ( FAKE_PRICE ) fake_price [ \"unit_amount\" ] /= 100 fake_price [ \"metadata\" ] = metadata assert isinstance ( fake_price [ \"product\" ], str ) price = Price . create ( ** fake_price ) expected_create_kwargs = deepcopy ( FAKE_PRICE ) expected_create_kwargs [ \"metadata\" ] = metadata price_create_mock . assert_called_once_with ( api_key = STRIPE_SECRET_KEY , ** expected_create_kwargs ) self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" })","title":"Methods"},{"location":"reference/project/#tests.test_price.PriceTest","text":"","title":"PriceTest"},{"location":"reference/project/#tests.test_price.PriceTest-methods","text":"tests . test_price . PriceTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_price.py def setUp ( self ): self . price_data = deepcopy ( FAKE_PRICE ) with patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True , ): self . price = Price . sync_from_stripe_data ( self . price_data ) tests . test_price . PriceTest . test_price_name ( self ) Source code in tests/test_price.py def test_price_name ( self ): price = Price ( id = \"price_xxxx\" , nickname = \"Price Test\" ) assert str ( price ) == \"Price Test\" price . nickname = \"\" assert str ( price ) == \"price_xxxx\" tests . test_price . PriceTest . test_str ( self ) Source code in tests/test_price.py def test_str ( self ): assert str ( self . price ) == self . price_data [ \"nickname\" ] tests . test_price . PriceTest . test_stripe_metered_price ( self , price_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Price.retrieve\" , autospec = True ) def test_stripe_metered_price ( self , price_retrieve_mock ): price_data = deepcopy ( FAKE_PRICE_METERED ) price = Price . sync_from_stripe_data ( price_data ) assert price . id == price_data [ \"id\" ] assert price . recurring [ \"usage_type\" ] == PriceUsageType . metered assert price . unit_amount is not None self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_price . PriceTest . test_stripe_onetime_price ( self , price_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Price.retrieve\" , autospec = True ) def test_stripe_onetime_price ( self , price_retrieve_mock ): price_data = deepcopy ( FAKE_PRICE_ONETIME ) price = Price . sync_from_stripe_data ( price_data ) assert price . id == price_data [ \"id\" ] assert price . unit_amount is not None assert not price . recurring assert price . type == PriceType . one_time self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) tests . test_price . PriceTest . test_stripe_price ( self , price_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Price.retrieve\" , return_value = FAKE_PRICE , autospec = True ) def test_stripe_price ( self , price_retrieve_mock ): stripe_price = self . price . api_retrieve () price_retrieve_mock . assert_called_once_with ( id = self . price_data [ \"id\" ], api_key = STRIPE_SECRET_KEY , expand = [ \"tiers\" ], stripe_account = None , ) price = Price . sync_from_stripe_data ( stripe_price ) self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" }) assert price . human_readable_price == \"$20.00 USD/month\" tests . test_price . PriceTest . test_stripe_tier_price ( self , price_retrieve_mock ) Source code in tests/test_price.py @patch ( \"stripe.Price.retrieve\" , autospec = True ) def test_stripe_tier_price ( self , price_retrieve_mock ): price_data = deepcopy ( FAKE_PRICE_TIER ) price = Price . sync_from_stripe_data ( price_data ) assert price . id == price_data [ \"id\" ] assert price . unit_amount is None assert price . tiers is not None self . assert_fks ( price , expected_blank_fks = { \"djstripe.Customer.coupon\" })","title":"Methods"},{"location":"reference/project/#tests.test_refund","text":"dj-stripe Charge Model Tests.","title":"test_refund"},{"location":"reference/project/#tests.test_refund-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_refund.RefundTest","text":"","title":"RefundTest"},{"location":"reference/project/#tests.test_refund.RefundTest-methods","text":"tests . test_refund . RefundTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_refund.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . default_expected_blank_fks = { \"djstripe.Account.branding_logo\" , \"djstripe.Account.branding_icon\" , \"djstripe.Charge.application_fee\" , \"djstripe.Charge.dispute\" , \"djstripe.Charge.latest_upcominginvoice (related name)\" , \"djstripe.Charge.on_behalf_of\" , \"djstripe.Charge.refund\" , \"djstripe.Charge.source_transfer\" , \"djstripe.Charge.transfer\" , \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Invoice.default_payment_method\" , \"djstripe.Invoice.default_source\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , \"djstripe.Subscription.default_payment_method\" , \"djstripe.Subscription.default_source\" , \"djstripe.Subscription.pending_setup_intent\" , \"djstripe.Subscription.schedule\" , \"djstripe.Refund.failure_balance_transaction\" , } tests . test_refund . RefundTest . test_reason_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_refund.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_reason_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account # TODO - remove invoice sync Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) balance_transaction_retrieve_mock . return_value = deepcopy ( FAKE_BALANCE_TRANSACTION_REFUND ) fake_refund = deepcopy ( FAKE_REFUND ) for reason in ( \"duplicate\" , \"fraudulent\" , \"requested_by_customer\" , \"expired_uncaptured_charge\" , ): fake_refund [ \"reason\" ] = reason refund = Refund . sync_from_stripe_data ( fake_refund ) self . assertEqual ( refund . reason , reason ) # trigger model field validation (including enum value choices check) refund . full_clean () self . assert_fks ( refund , expected_blank_fks = self . default_expected_blank_fks ) tests . test_refund . RefundTest . test_status_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_refund.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_status_enum ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account # TODO - remove invoice sync Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) balance_transaction_retrieve_mock . return_value = deepcopy ( FAKE_BALANCE_TRANSACTION_REFUND ) fake_refund = deepcopy ( FAKE_REFUND ) for status in ( \"pending\" , \"succeeded\" , \"failed\" , \"canceled\" , ): fake_refund [ \"status\" ] = status refund = Refund . sync_from_stripe_data ( fake_refund ) self . assertEqual ( refund . status , status ) # trigger model field validation (including enum value choices check) refund . full_clean () self . assert_fks ( refund , expected_blank_fks = self . default_expected_blank_fks ) tests . test_refund . RefundTest . test_sync_from_stripe_data ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock ) Source code in tests/test_refund.py @patch ( \"djstripe.models.Account.get_default_account\" , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.BalanceTransaction.retrieve\" , return_value = deepcopy ( FAKE_BALANCE_TRANSACTION ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Charge.retrieve\" , return_value = deepcopy ( FAKE_CHARGE ), autospec = True ) @patch ( \"stripe.PaymentMethod.retrieve\" , return_value = deepcopy ( FAKE_CARD_AS_PAYMENT_METHOD ), autospec = True , ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_sync_from_stripe_data ( self , product_retrieve_mock , payment_intent_retrieve_mock , paymentmethod_card_retrieve_mock , charge_retrieve_mock , subscription_retrieve_mock , balance_transaction_retrieve_mock , default_account_mock , ): default_account_mock . return_value = self . account # TODO - remove invoice sync Invoice . sync_from_stripe_data ( deepcopy ( FAKE_INVOICE )) fake_refund = deepcopy ( FAKE_REFUND ) balance_transaction_retrieve_mock . return_value = deepcopy ( FAKE_BALANCE_TRANSACTION_REFUND ) refund = Refund . sync_from_stripe_data ( fake_refund ) self . assert_fks ( refund , expected_blank_fks = self . default_expected_blank_fks )","title":"Methods"},{"location":"reference/project/#tests.test_session","text":"dj-stripe Session Model Tests.","title":"test_session"},{"location":"reference/project/#tests.test_session.SessionTest","text":"tests . test_session . SessionTest . test_sync_from_stripe_data ( self , payment_intent_retrieve_mock , customer_retrieve_mock ) Source code in tests/test_session.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.PaymentIntent.retrieve\" , return_value = deepcopy ( FAKE_PAYMENT_INTENT_I ), autospec = True , ) def test_sync_from_stripe_data ( self , payment_intent_retrieve_mock , customer_retrieve_mock ): fake_payment_intent = deepcopy ( FAKE_SESSION_I ) session = Session . sync_from_stripe_data ( fake_payment_intent ) self . assert_fks ( session , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Customer.subscriber\" , \"djstripe.PaymentIntent.invoice (related name)\" , \"djstripe.PaymentIntent.on_behalf_of\" , \"djstripe.PaymentIntent.payment_method\" , \"djstripe.PaymentIntent.upcominginvoice (related name)\" , \"djstripe.Session.subscription\" , }, )","title":"SessionTest"},{"location":"reference/project/#tests.test_settings","text":"dj-stripe Settings Tests.","title":"test_settings"},{"location":"reference/project/#tests.test_settings.TestGetStripeApiVersion","text":"tests . test_settings . TestGetStripeApiVersion . test_with_default ( self ) Source code in tests/test_settings.py def test_with_default ( self ): self . assertEqual ( djstripe_settings . DEFAULT_STRIPE_API_VERSION , get_stripe_api_version () ) tests . test_settings . TestGetStripeApiVersion . test_with_override ( self ) Source code in tests/test_settings.py @override_settings ( STRIPE_API_VERSION = \"2016-03-07\" ) def test_with_override ( self ): self . assertEqual ( \"2016-03-07\" , get_stripe_api_version ())","title":"TestGetStripeApiVersion"},{"location":"reference/project/#tests.test_settings.TestSetStripeApiVersion","text":"tests . test_settings . TestSetStripeApiVersion . test_with_default ( self ) Source code in tests/test_settings.py def test_with_default ( self ): djstripe_settings . set_stripe_api_version () self . assertEqual ( djstripe_settings . DEFAULT_STRIPE_API_VERSION , stripe . api_version ) tests . test_settings . TestSetStripeApiVersion . test_with_invalid_date ( self ) Source code in tests/test_settings.py def test_with_invalid_date ( self ): with self . assertRaises ( ValueError ): set_stripe_api_version ( version = \"foobar\" ) tests . test_settings . TestSetStripeApiVersion . test_with_invalid_date_and_no_validation ( self ) Source code in tests/test_settings.py def test_with_invalid_date_and_no_validation ( self ): set_stripe_api_version ( version = \"foobar\" , validate = False ) self . assertEqual ( \"foobar\" , stripe . api_version ) tests . test_settings . TestSetStripeApiVersion . test_with_valid_date ( self ) Source code in tests/test_settings.py def test_with_valid_date ( self ): djstripe_settings . set_stripe_api_version ( version = \"2016-03-07\" ) self . assertEqual ( \"2016-03-07\" , stripe . api_version )","title":"TestSetStripeApiVersion"},{"location":"reference/project/#tests.test_settings.TestSubscriberModelRetrievalMethod","text":"tests . test_settings . TestSubscriberModelRetrievalMethod . test_bad_callback ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.Organization\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = 5 , ) def test_bad_callback ( self ): self . assertRaisesMessage ( ImproperlyConfigured , \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be callable.\" , get_subscriber_model , ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_bad_model_name ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testappStaticEmailOrganization\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = ( lambda request : request . org ), ) def test_bad_model_name ( self ): self . assertRaisesMessage ( ImproperlyConfigured , \"DJSTRIPE_SUBSCRIBER_MODEL must be of the form 'app_label.model_name'.\" , get_subscriber_model , ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_get_callback_function_ ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_TEST_CALLBACK = \"foo.non_existant_callback\" ) def test_get_callback_function_ ( self ): with self . assertRaises ( ImportError ): get_callback_function ( \"DJSTRIPE_TEST_CALLBACK\" ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_get_callback_function_import_error ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_TEST_CALLBACK = \"foo.non_existant_callback\" ) def test_get_callback_function_import_error ( self ): with self . assertRaises ( ImportError ): get_callback_function ( \"DJSTRIPE_TEST_CALLBACK\" ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_get_callback_function_with_non_callable_string ( self , import_string_mock ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_TEST_CALLBACK = \"foo.invalid_callback\" ) @patch . object ( djstripe_settings , \"import_string\" , return_value = \"not_callable\" ) def test_get_callback_function_with_non_callable_string ( self , import_string_mock ): with self . assertRaises ( ImproperlyConfigured ): get_callback_function ( \"DJSTRIPE_TEST_CALLBACK\" ) import_string_mock . assert_called_with ( \"foo.invalid_callback\" ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_get_callback_function_with_valid_func_callable ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_TEST_CALLBACK = ( lambda : \"ok\" )) def test_get_callback_function_with_valid_func_callable ( self ): func = get_callback_function ( \"DJSTRIPE_TEST_CALLBACK\" ) self . assertEqual ( \"ok\" , func ()) tests . test_settings . TestSubscriberModelRetrievalMethod . test_get_callback_function_with_valid_string_callable ( self , import_string_mock ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_TEST_CALLBACK = \"foo.valid_callback\" ) @patch . object ( djstripe_settings , \"import_string\" , return_value = ( lambda : \"ok\" )) def test_get_callback_function_with_valid_string_callable ( self , import_string_mock ): func = get_callback_function ( \"DJSTRIPE_TEST_CALLBACK\" ) self . assertEqual ( \"ok\" , func ()) import_string_mock . assert_called_with ( \"foo.valid_callback\" ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_no_callback ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.Organization\" ) def test_no_callback ( self ): self . assertRaisesMessage ( ImproperlyConfigured , \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be implemented \" \"if a DJSTRIPE_SUBSCRIBER_MODEL is defined.\" , get_subscriber_model , ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_no_email_model ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.NoEmailOrganization\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = ( lambda request : request . org ), ) def test_no_email_model ( self ): self . assertRaisesMessage ( ImproperlyConfigured , \"DJSTRIPE_SUBSCRIBER_MODEL must have an email attribute.\" , get_subscriber_model , ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_unknown_model ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.UnknownModel\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = ( lambda request : request . org ), ) def test_unknown_model ( self ): self . assertRaisesMessage ( ImproperlyConfigured , \"DJSTRIPE_SUBSCRIBER_MODEL refers to model 'testapp.UnknownModel' \" \"that has not been installed.\" , get_subscriber_model , ) tests . test_settings . TestSubscriberModelRetrievalMethod . test_with_org ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.Organization\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = ( lambda request : request . org ), ) def test_with_org ( self ): org_model = get_subscriber_model () self . assertTrue ( isinstance ( org_model , ModelBase )) tests . test_settings . TestSubscriberModelRetrievalMethod . test_with_org_static ( self ) Source code in tests/test_settings.py @override_settings ( DJSTRIPE_SUBSCRIBER_MODEL = \"testapp.StaticEmailOrganization\" , DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK = ( lambda request : request . org ), ) def test_with_org_static ( self ): org_model = get_subscriber_model () self . assertTrue ( isinstance ( org_model , ModelBase )) tests . test_settings . TestSubscriberModelRetrievalMethod . test_with_user ( self ) Source code in tests/test_settings.py def test_with_user ( self ): user_model = get_subscriber_model () self . assertTrue ( isinstance ( user_model , ModelBase ))","title":"TestSubscriberModelRetrievalMethod"},{"location":"reference/project/#tests.test_setup_intent","text":"dj-stripe SetupIntent Model Tests.","title":"test_setup_intent"},{"location":"reference/project/#tests.test_setup_intent.SetupIntentTest","text":"tests . test_setup_intent . SetupIntentTest . test_canceled_intent ( self , customer_retrieve_mock ) Source code in tests/test_setup_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_canceled_intent ( self , customer_retrieve_mock ): fake_setup_intent = deepcopy ( FAKE_SETUP_INTENT_I ) fake_setup_intent [ \"status\" ] = \"canceled\" fake_setup_intent [ \"canceled_at\" ] = 1567524169 for reason in ( None , \"abandoned\" , \"requested_by_customer\" , \"duplicate\" ): fake_setup_intent [ \"cancellation_reason\" ] = reason setup_intent = SetupIntent . sync_from_stripe_data ( fake_setup_intent ) if reason is None : # enums nulls are coerced to \"\" by StripeModel._stripe_object_to_record self . assertEqual ( setup_intent . cancellation_reason , \"\" ) else : self . assertEqual ( setup_intent . cancellation_reason , reason ) # trigger model field validation (including enum value choices check) setup_intent . full_clean () tests . test_setup_intent . SetupIntentTest . test_status_enum ( self , customer_retrieve_mock ) Source code in tests/test_setup_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_status_enum ( self , customer_retrieve_mock ): fake_setup_intent = deepcopy ( FAKE_SETUP_INTENT_I ) for status in ( \"requires_payment_method\" , \"requires_confirmation\" , \"requires_action\" , \"processing\" , \"canceled\" , \"succeeded\" , ): fake_setup_intent [ \"status\" ] = status setup_intent = SetupIntent . sync_from_stripe_data ( fake_setup_intent ) # trigger model field validation (including enum value choices check) setup_intent . full_clean () tests . test_setup_intent . SetupIntentTest . test_sync_from_stripe_data ( self , customer_retrieve_mock ) Source code in tests/test_setup_intent.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_from_stripe_data ( self , customer_retrieve_mock ): fake_payment_intent = deepcopy ( FAKE_SETUP_INTENT_I ) setup_intent = SetupIntent . sync_from_stripe_data ( fake_payment_intent ) self . assertEqual ( setup_intent . payment_method_types , [ \"card\" ]) self . assert_fks ( setup_intent , expected_blank_fks = { \"djstripe.SetupIntent.customer\" , \"djstripe.SetupIntent.on_behalf_of\" , \"djstripe.SetupIntent.payment_method\" , }, )","title":"SetupIntentTest"},{"location":"reference/project/#tests.test_source","text":"dj-stripe Card Model Tests.","title":"test_source"},{"location":"reference/project/#tests.test_source-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_source.SourceTest","text":"","title":"SourceTest"},{"location":"reference/project/#tests.test_source.SourceTest-methods","text":"tests . test_source . SourceTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_source.py def setUp ( self ): self . account = default_account () self . user = get_user_model () . objects . create_user ( username = \"testuser\" , email = \"djstripe@example.com\" ) self . customer = FAKE_CUSTOMER_III . create_for_user ( self . user ) self . customer . sources . all () . delete () self . customer . legacy_cards . all () . delete () tests . test_source . SourceTest . test_attach_objects_hook_without_customer ( self ) Source code in tests/test_source.py def test_attach_objects_hook_without_customer ( self ): source = Source . sync_from_stripe_data ( deepcopy ( FAKE_SOURCE_II )) self . assertEqual ( source . customer , None ) self . assert_fks ( source , expected_blank_fks = { \"djstripe.Source.customer\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_source . SourceTest . test_detach ( self , source_retrieve_mock ) Source code in tests/test_source.py @patch ( \"stripe.Source.retrieve\" , return_value = deepcopy ( FAKE_SOURCE ), autospec = True ) def test_detach ( self , source_retrieve_mock ): original_detach = SourceDict . detach def mocked_detach ( self ): return original_detach ( self ) Source . sync_from_stripe_data ( deepcopy ( FAKE_SOURCE )) self . assertEqual ( 0 , self . customer . legacy_cards . count ()) self . assertEqual ( 1 , self . customer . sources . count ()) source = self . customer . sources . first () with patch ( \"tests.SourceDict.detach\" , side_effect = mocked_detach , autospec = True ) as mock_detach : source . detach () self . assertEqual ( 0 , self . customer . sources . count ()) # need to refresh_from_db since default_source was cleared with a query self . customer . refresh_from_db () self . assertIsNone ( self . customer . default_source ) # need to refresh_from_db due to the implementation of Source.detach() - # see TODO in method source . refresh_from_db () self . assertIsNone ( source . customer ) self . assertEqual ( source . status , \"consumed\" ) if sys . version_info >= ( 3 , 6 ): # this mock isn't working on py34, py35, but it's not strictly necessary # for the test mock_detach . assert_called () self . assert_fks ( source , expected_blank_fks = { \"djstripe.Source.customer\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_source . SourceTest . test_str ( self ) Source code in tests/test_source.py def test_str ( self ): fake_source = deepcopy ( FAKE_SOURCE ) source = Source . sync_from_stripe_data ( fake_source ) self . assertEqual ( \"<id= {} >\" . format ( fake_source [ \"id\" ]), str ( source )) self . assert_fks ( source , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, ) tests . test_source . SourceTest . test_sync_source_finds_customer ( self ) Source code in tests/test_source.py def test_sync_source_finds_customer ( self ): source = Source . sync_from_stripe_data ( deepcopy ( FAKE_SOURCE )) self . assertEqual ( self . customer , source . customer ) self . assert_fks ( source , expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , }, )","title":"Methods"},{"location":"reference/project/#tests.test_stripe_model","text":"dj-stripe StripeModel Model Tests.","title":"test_stripe_model"},{"location":"reference/project/#tests.test_stripe_model-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_stripe_model.StripeModelExceptionsTest","text":"tests . test_stripe_model . StripeModelExceptionsTest . test_bad_object_value ( self ) Source code in tests/test_stripe_model.py def test_bad_object_value ( self ): with self . assertRaises ( ValueError ): # Errors because the object is not correct Customer . _stripe_object_to_record ( { \"id\" : \"test_XXXXXXXX\" , \"livemode\" : False , \"object\" : \"not_a_customer\" } ) tests . test_stripe_model . StripeModelExceptionsTest . test_no_object_value ( self ) Source code in tests/test_stripe_model.py def test_no_object_value ( self ): # Instantiate a stripeobject model class class BasicModel ( StripeModel ): pass with self . assertRaises ( ValueError ): # Errors because there's no object value BasicModel . _stripe_object_to_record ( { \"id\" : \"test_XXXXXXXX\" , \"livemode\" : False } )","title":"StripeModelExceptionsTest"},{"location":"reference/project/#tests.test_stripe_model.TestStripeModel","text":"TestStripeModel(djstripe_id, id, djstripe_owner_account, livemode, created, metadata, description, djstripe_created, djstripe_updated) tests . test_stripe_model . TestStripeModel . djstripe_owner_account : Optional [ djstripe . fields . StripeForeignKey ] tests.test_stripe_model.TestStripeModel.DoesNotExist tests.test_stripe_model.TestStripeModel.MultipleObjectsReturned tests . test_stripe_model . TestStripeModel . get_next_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = True , ** kwargs ) Source code in tests/test_stripe_model.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) tests . test_stripe_model . TestStripeModel . get_next_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = True , ** kwargs ) Source code in tests/test_stripe_model.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) tests . test_stripe_model . TestStripeModel . get_previous_by_djstripe_created ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_created > , is_next = False , ** kwargs ) Source code in tests/test_stripe_model.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords ) tests . test_stripe_model . TestStripeModel . get_previous_by_djstripe_updated ( self , * , field =< django . db . models . fields . DateTimeField : djstripe_updated > , is_next = False , ** kwargs ) Source code in tests/test_stripe_model.py def _method ( cls_or_self , / , * args , ** keywords ): keywords = { ** self . keywords , ** keywords } return self . func ( cls_or_self , * self . args , * args , ** keywords )","title":"TestStripeModel"},{"location":"reference/project/#tests.test_stripe_model-functions","text":"","title":"Functions"},{"location":"reference/project/#tests.test_stripe_model.test__api_delete","text":"Test that API delete properly uses the passed in parameters. Source code in tests/test_stripe_model.py @pytest . mark . parametrize ( \"stripe_account\" , ( None , \"acct_fakefakefakefake001\" )) @pytest . mark . parametrize ( \"api_key, expected_api_key\" , (( None , STRIPE_SECRET_KEY ), ( \"sk_fakefakefake01\" , \"sk_fakefakefake01\" )), ) @pytest . mark . parametrize ( \"extra_kwargs\" , ({}, { \"foo\" : \"bar\" })) @patch . object ( target = StripeModel , attribute = \"api_retrieve\" , autospec = True ) def test__api_delete ( mock_api_retrieve , stripe_account , api_key , expected_api_key , extra_kwargs ): \"\"\"Test that API delete properly uses the passed in parameters.\"\"\" test_model = TestStripeModel () test_model . _api_delete ( api_key = api_key , stripe_account = stripe_account , ** extra_kwargs ) # Assert the chained calls happened as expected, since it should # call api_retrieve() followed by delete() assert ( mock_api_retrieve . mock_calls == call ( test_model , api_key = expected_api_key , stripe_account = stripe_account ) . delete ( ** extra_kwargs ) . call_list () )","title":"test__api_delete()"},{"location":"reference/project/#tests.test_stripe_model.test_api_retrieve","text":"Test that API delete properly uses the passed in parameters. Source code in tests/test_stripe_model.py @pytest . mark . parametrize ( \"stripe_account\" , ( None , \"acct_fakefakefakefake001\" )) @pytest . mark . parametrize ( \"api_key, expected_api_key\" , (( None , STRIPE_SECRET_KEY ), ( \"sk_fakefakefake01\" , \"sk_fakefakefake01\" )), ) @pytest . mark . parametrize ( \"expand_fields\" , ([], [ \"foo\" , \"bar\" ])) @patch . object ( target = StripeModel , attribute = \"stripe_class\" ) def test_api_retrieve ( mock_stripe_class , stripe_account , api_key , expected_api_key , expand_fields ): \"\"\"Test that API delete properly uses the passed in parameters.\"\"\" test_model = TestStripeModel () mock_id = \"id_fakefakefakefake01\" test_model . id = mock_id test_model . expand_fields = expand_fields test_model . api_retrieve ( api_key = api_key , stripe_account = stripe_account ) mock_stripe_class . retrieve . assert_called_once_with ( id = mock_id , api_key = expected_api_key , stripe_account = stripe_account , expand = expand_fields , )","title":"test_api_retrieve()"},{"location":"reference/project/#tests.test_stripe_model.test_api_retrieve_reverse_foreign_key_lookup","text":"Test that the reverse foreign key lookup finds the correct fields. Source code in tests/test_stripe_model.py @patch . object ( target = StripeModel , attribute = \"stripe_class\" ) def test_api_retrieve_reverse_foreign_key_lookup ( mock_stripe_class ): \"\"\"Test that the reverse foreign key lookup finds the correct fields.\"\"\" # Set up some mock fields that shouldn't be used for reverse lookups mock_field_1 = MagicMock () mock_field_1 . is_relation = False mock_field_2 = MagicMock () mock_field_2 . is_relation = True mock_field_2 . one_to_many = False # Set up a mock reverse foreign key field mock_reverse_foreign_key = MagicMock () mock_reverse_foreign_key . is_relation = True mock_reverse_foreign_key . one_to_many = True mock_reverse_foreign_key . related_model = Account mock_reverse_foreign_key . get_accessor_name . return_value = \"foo_account_reverse_attr\" # Set up a mock account for the reverse foreign key query to return. mock_account = MagicMock () mock_account_reverse_manager = MagicMock () # Make first return the mock account. mock_account_reverse_manager . first . return_value = mock_account test_model = TestStripeModel () mock_id = \"id_fakefakefakefake01\" test_model . id = mock_id # Set mock reverse manager on the model. test_model . foo_account_reverse_attr = mock_account_reverse_manager # Set the mocked _meta.get_fields to return some mock fields, including the mock # reverse foreign key above. test_model . _meta = MagicMock () test_model . _meta . get_fields . return_value = ( mock_field_1 , mock_field_2 , mock_reverse_foreign_key , ) # Call the function with API key set because we mocked _meta mock_api_key = \"sk_fakefakefakefake01\" test_model . api_retrieve ( api_key = mock_api_key ) # Expect the retrieve to be done with the reverse look up of the Account ID. mock_stripe_class . retrieve . assert_called_once_with ( id = mock_id , api_key = mock_api_key , stripe_account = mock_account . id , expand = [] ) mock_reverse_foreign_key . get_accessor_name . assert_called_once_with () mock_account_reverse_manager . first . assert_called_once_with ()","title":"test_api_retrieve_reverse_foreign_key_lookup()"},{"location":"reference/project/#tests.test_subscription","text":"dj-stripe Subscription Model Tests.","title":"test_subscription"},{"location":"reference/project/#tests.test_subscription-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_subscription.SubscriptionTest","text":"","title":"SubscriptionTest"},{"location":"reference/project/#tests.test_subscription.SubscriptionTest-methods","text":"tests . test_subscription . SubscriptionTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_subscription.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) self . default_expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.Subscription.default_payment_method\" , \"djstripe.Subscription.default_source\" , \"djstripe.Subscription.pending_setup_intent\" , \"djstripe.Subscription.schedule\" , } tests . test_subscription . SubscriptionTest . test_cancel_already_canceled ( self , subscription_retrieve_mock , product_retrieve_mock , subscription_delete_mock ) Source code in tests/test_subscription.py @patch ( \"djstripe.models.Subscription._api_delete\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_CANCELED ), ) def test_cancel_already_canceled ( self , subscription_retrieve_mock , product_retrieve_mock , subscription_delete_mock , ): subscription_delete_mock . side_effect = InvalidRequestError ( \"No such subscription: sub_xxxx\" , \"blah\" ) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertEqual ( Subscription . objects . filter ( status = \"canceled\" ) . count (), 0 ) subscription . cancel ( at_period_end = False ) self . assertEqual ( Subscription . objects . filter ( status = \"canceled\" ) . count (), 1 ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_cancel_and_reactivate ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_cancel_and_reactivate ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . current_period_end = current_period_end subscription . save () canceled_subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) canceled_subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( current_period_end ) canceled_subscription_fake [ \"canceled_at\" ] = datetime_to_unix ( timezone . now ()) subscription_retrieve_mock . return_value = canceled_subscription_fake self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) new_subscription = subscription . cancel ( at_period_end = True ) self . assertEqual ( new_subscription . cancel_at_period_end , True ) new_subscription . reactivate () subscription_reactivate_fake = deepcopy ( FAKE_SUBSCRIPTION ) reactivated_subscription = Subscription . sync_from_stripe_data ( subscription_reactivate_fake ) self . assertEqual ( reactivated_subscription . cancel_at_period_end , False ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_cancel_at_period_end ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_cancel_at_period_end ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . current_period_end = current_period_end subscription . save () canceled_subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) canceled_subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( current_period_end ) canceled_subscription_fake [ \"canceled_at\" ] = datetime_to_unix ( timezone . now ()) subscription_retrieve_mock . return_value = ( canceled_subscription_fake # retrieve().delete() ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assertEqual ( self . customer . active_subscriptions . count (), 1 ) self . assertTrue ( subscription in self . customer . active_subscriptions ) new_subscription = subscription . cancel ( at_period_end = True ) self . assertEqual ( self . customer . active_subscriptions . count (), 1 ) self . assertTrue ( new_subscription in self . customer . active_subscriptions ) self . assertEqual ( SubscriptionStatus . active , new_subscription . status ) self . assertEqual ( True , new_subscription . cancel_at_period_end ) self . assertNotEqual ( new_subscription . canceled_at , new_subscription . ended_at ) self . assertTrue ( new_subscription . is_valid ()) self . assertTrue ( new_subscription . is_status_temporarily_current ()) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_cancel_during_trial_sets_at_period_end ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_cancel_during_trial_sets_at_period_end ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . trial_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription . save () cancel_timestamp = datetime_to_unix ( timezone . now ()) canceled_subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) canceled_subscription_fake [ \"status\" ] = SubscriptionStatus . canceled canceled_subscription_fake [ \"canceled_at\" ] = cancel_timestamp canceled_subscription_fake [ \"ended_at\" ] = cancel_timestamp subscription_retrieve_mock . return_value = ( canceled_subscription_fake # retrieve().delete() ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) new_subscription = subscription . cancel ( at_period_end = False ) self . assertEqual ( SubscriptionStatus . canceled , new_subscription . status ) self . assertEqual ( False , new_subscription . cancel_at_period_end ) self . assertEqual ( new_subscription . canceled_at , new_subscription . ended_at ) self . assertFalse ( new_subscription . is_valid ()) self . assertFalse ( self . customer . has_active_subscription ()) self . assertFalse ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertFalse ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_cancel_error_in_cancel ( self , product_retrieve_mock , subscription_delete_mock ) Source code in tests/test_subscription.py @patch ( \"djstripe.models.Subscription._api_delete\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_cancel_error_in_cancel ( self , product_retrieve_mock , subscription_delete_mock ): subscription_delete_mock . side_effect = InvalidRequestError ( \"Unexpected error\" , \"blah\" ) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) with self . assertRaises ( InvalidRequestError ): subscription . cancel ( at_period_end = False ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_cancel_now ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_cancel_now ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription . save () cancel_timestamp = datetime_to_unix ( timezone . now ()) canceled_subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) canceled_subscription_fake [ \"status\" ] = SubscriptionStatus . canceled canceled_subscription_fake [ \"canceled_at\" ] = cancel_timestamp canceled_subscription_fake [ \"ended_at\" ] = cancel_timestamp subscription_retrieve_mock . return_value = ( canceled_subscription_fake # retrieve().delete() ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertEqual ( self . customer . active_subscriptions . count (), 1 ) self . assertTrue ( self . customer . has_any_active_subscription ()) new_subscription = subscription . cancel ( at_period_end = False ) self . assertEqual ( SubscriptionStatus . canceled , new_subscription . status ) self . assertEqual ( False , new_subscription . cancel_at_period_end ) self . assertEqual ( new_subscription . canceled_at , new_subscription . ended_at ) self . assertFalse ( new_subscription . is_valid ()) self . assertFalse ( new_subscription . is_status_temporarily_current ()) self . assertFalse ( new_subscription in self . customer . active_subscriptions ) self . assertFalse ( self . customer . has_active_subscription ()) self . assertFalse ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertFalse ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_extend ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_extend ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"current_period_end\" ] = datetime_to_unix ( timezone . now () - timezone . timedelta ( days = 20 ) ) subscription_retrieve_mock . return_value = subscription_fake subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertFalse ( subscription in self . customer . active_subscriptions ) self . assertEqual ( self . customer . active_subscriptions . count (), 0 ) delta = timezone . timedelta ( days = 30 ) extended_subscription = subscription . extend ( delta ) product = Product . sync_from_stripe_data ( deepcopy ( FAKE_PRODUCT )) self . assertNotEqual ( None , extended_subscription . trial_end ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( product )) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_extend_negative_delta ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_extend_negative_delta ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_NOT_PERIOD_CURRENT ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) with self . assertRaises ( ValueError ): subscription . extend ( timezone . timedelta ( days =- 30 )) self . assertFalse ( self . customer . has_active_subscription ()) self . assertFalse ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertFalse ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_extend_with_trial ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_extend_with_trial ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . trial_end = timezone . now () + timezone . timedelta ( days = 5 ) subscription . save () delta = timezone . timedelta ( days = 30 ) new_trial_end = subscription . trial_end + delta extended_subscription = subscription . extend ( delta ) self . assertEqual ( new_trial_end . replace ( microsecond = 0 ), extended_subscription . trial_end ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_is_status_temporarily_current ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_is_status_temporarily_current ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ): product = Product . sync_from_stripe_data ( deepcopy ( FAKE_PRODUCT )) subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . canceled_at = timezone . now () + timezone . timedelta ( days = 7 ) subscription . current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription . cancel_at_period_end = True subscription . save () self . assertTrue ( subscription . is_status_current ()) self . assertTrue ( subscription . is_status_temporarily_current ()) self . assertTrue ( subscription . is_valid ()) self . assertTrue ( subscription in self . customer . active_subscriptions ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( product )) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_is_status_temporarily_current_false ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_is_status_temporarily_current_false ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription . save () self . assertTrue ( subscription . is_status_current ()) self . assertFalse ( subscription . is_status_temporarily_current ()) self . assertTrue ( subscription . is_valid ()) self . assertTrue ( subscription in self . customer . active_subscriptions ) self . assertTrue ( self . customer . has_active_subscription ()) self . assertTrue ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertTrue ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_is_status_temporarily_current_false_and_canceled ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_is_status_temporarily_current_false_and_canceled ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) subscription . status = SubscriptionStatus . canceled subscription . current_period_end = timezone . now () + timezone . timedelta ( days = 7 ) subscription . save () self . assertFalse ( subscription . is_status_current ()) self . assertFalse ( subscription . is_status_temporarily_current ()) self . assertFalse ( subscription . is_valid ()) self . assertFalse ( subscription in self . customer . active_subscriptions ) self . assertFalse ( self . customer . has_active_subscription ()) self . assertFalse ( self . customer . is_subscribed_to ( FAKE_PRODUCT [ \"id\" ])) self . assertFalse ( self . customer . has_any_active_subscription ()) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_remove_all_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ), ) def test_remove_all_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertIsNone ( subscription . plan ) self . assertIsNone ( subscription . quantity ) items = subscription . items . all () self . assertEqual ( 2 , len ( items )) # Simulate a webhook received with no more plan del subscription_fake [ \"items\" ][ \"data\" ][ 1 ] del subscription_fake [ \"items\" ][ \"data\" ][ 0 ] subscription_fake [ \"items\" ][ \"total_count\" ] = 0 subscription = Subscription . sync_from_stripe_data ( subscription_fake ) items = subscription . items . all () self . assertEqual ( 0 , len ( items )) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Customer.subscriber\" , \"djstripe.Subscription.plan\" }, ) tests . test_subscription . SubscriptionTest . test_sync_from_stripe_data ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_from_stripe_data ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake [ \"cancel_at\" ] = 1624553655 subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertEqual ( str ( subscription ), f \" { self . user } on { subscription . plan } \" ) self . assertEqual ( subscription . default_tax_rates . count (), 1 ) self . assertEqual ( subscription . default_tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) self . assertEqual ( datetime_to_unix ( subscription . cancel_at ), 1624553655 ) tests . test_subscription . SubscriptionTest . test_sync_items_with_tax_rates ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN_II ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_items_with_tax_rates ( self , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_II ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) self . assertEqual ( subscription . default_tax_rates . count (), 0 ) first_item = subscription . items . first () self . assertEqual ( first_item . tax_rates . count (), 1 ) self . assertEqual ( first_item . tax_rates . first () . id , FAKE_TAX_RATE_EXAMPLE_1_VAT [ \"id\" ] ) tests . test_subscription . SubscriptionTest . test_sync_metered_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_METERED ) ) def test_sync_metered_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_METERED ) self . assertNotIn ( \"quantity\" , subscription_fake [ \"items\" ][ \"data\" ], \"Expect Metered plan SubscriptionItem to have no quantity\" , ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) items = subscription . items . all () self . assertEqual ( 1 , len ( items )) item = items [ 0 ] self . assertEqual ( subscription . quantity , 1 ) # Note that subscription.quantity is 1, # but item.quantity isn't set on metered plans self . assertIsNone ( item . quantity ) self . assertEqual ( item . plan . id , FAKE_PLAN_METERED [ \"id\" ]) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_sync_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ), ) def test_sync_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertIsNone ( subscription . plan ) self . assertIsNone ( subscription . quantity ) items = subscription . items . all () self . assertEqual ( 2 , len ( items )) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Customer.subscriber\" , \"djstripe.Subscription.plan\" }, ) tests . test_subscription . SubscriptionTest . test_update ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_update ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertEqual ( 1 , subscription . quantity ) new_subscription = subscription . update ( quantity = 4 ) self . assertEqual ( 4 , new_subscription . quantity ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_update_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ), ) def test_update_multi_plan ( self , subscription_retrieve_mock , customer_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION_MULTI_PLAN ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertIsNone ( subscription . plan ) self . assertIsNone ( subscription . quantity ) items = subscription . items . all () self . assertEqual ( 2 , len ( items )) # Simulate a webhook received with one plan that has been removed del subscription_fake [ \"items\" ][ \"data\" ][ 1 ] subscription_fake [ \"items\" ][ \"total_count\" ] = 1 subscription = Subscription . sync_from_stripe_data ( subscription_fake ) items = subscription . items . all () self . assertEqual ( 1 , len ( items )) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks | { \"djstripe.Customer.subscriber\" , \"djstripe.Subscription.plan\" }, ) tests . test_subscription . SubscriptionTest . test_update_set_empty_value ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_update_set_empty_value ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription_fake . update ({ \"tax_percent\" : Decimal ( 20.0 )}) subscription_retrieve_mock . return_value = subscription_fake subscription = Subscription . sync_from_stripe_data ( subscription_fake ) self . assertEqual ( Decimal ( 20.0 ), subscription . tax_percent ) new_subscription = subscription . update ( tax_percent = Decimal ( 0.0 )) self . assertEqual ( Decimal ( 0.0 ), new_subscription . tax_percent ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) tests . test_subscription . SubscriptionTest . test_update_with_plan_model ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock ) Source code in tests/test_subscription.py @patch ( \"stripe.Plan.retrieve\" , return_value = deepcopy ( FAKE_PLAN ), autospec = True ) @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) @patch ( \"stripe.Subscription.retrieve\" , return_value = deepcopy ( FAKE_SUBSCRIPTION ), autospec = True , ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_update_with_plan_model ( self , customer_retrieve_mock , subscription_retrieve_mock , product_retrieve_mock , plan_retrieve_mock , ): subscription_fake = deepcopy ( FAKE_SUBSCRIPTION ) subscription = Subscription . sync_from_stripe_data ( subscription_fake ) new_plan = Plan . sync_from_stripe_data ( deepcopy ( FAKE_PLAN_II )) self . assertEqual ( FAKE_PLAN [ \"id\" ], subscription . plan . id ) new_subscription = subscription . update ( plan = new_plan ) self . assertEqual ( FAKE_PLAN_II [ \"id\" ], new_subscription . plan . id ) self . assert_fks ( subscription , expected_blank_fks = self . default_expected_blank_fks ) self . assert_fks ( new_plan , expected_blank_fks = {})","title":"Methods"},{"location":"reference/project/#tests.test_subscription_schedule","text":"dj-stripe SubscriptionSchedule model tests.","title":"test_subscription_schedule"},{"location":"reference/project/#tests.test_subscription_schedule-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_subscription_schedule.SubscriptionScheduleTest","text":"","title":"SubscriptionScheduleTest"},{"location":"reference/project/#tests.test_subscription_schedule.SubscriptionScheduleTest-methods","text":"tests . test_subscription_schedule . SubscriptionScheduleTest . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_subscription_schedule.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER_II . create_for_user ( self . user ) self . default_expected_blank_fks = { \"djstripe.Customer.coupon\" , \"djstripe.Customer.default_payment_method\" , \"djstripe.SubscriptionSchedule.released_subscription\" , } tests . test_subscription_schedule . SubscriptionScheduleTest . test_sync_from_stripe_data ( self , customer_retrieve_mock ) Source code in tests/test_subscription_schedule.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_II ), autospec = True , ) def test_sync_from_stripe_data ( self , customer_retrieve_mock ): canceled_schedule_fake = deepcopy ( FAKE_SUBSCRIPTION_SCHEDULE ) canceled_schedule_fake [ \"canceled_at\" ] = 1624553655 canceled_schedule_fake [ \"status\" ] = SubscriptionScheduleStatus . canceled schedule = SubscriptionSchedule . sync_from_stripe_data ( canceled_schedule_fake ) self . assert_fks ( schedule , expected_blank_fks = self . default_expected_blank_fks ) self . assertEqual ( datetime_to_unix ( schedule . canceled_at ), 1624553655 )","title":"Methods"},{"location":"reference/project/#tests.test_sync","text":"dj-stripe Sync Method Tests.","title":"test_sync"},{"location":"reference/project/#tests.test_sync-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_sync.TestSyncSubscriber","text":"","title":"TestSyncSubscriber"},{"location":"reference/project/#tests.test_sync.TestSyncSubscriber-methods","text":"tests . test_sync . TestSyncSubscriber . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_sync.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"testuser\" , email = \"test@example.com\" , password = \"123\" ) tests . test_sync . TestSyncSubscriber . test_sync_fail ( self , stripe_customer_create_mock , api_retrieve_mock ) Source code in tests/test_sync.py @patch ( \"djstripe.models.Customer.api_retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True , ) @patch ( \"stripe.Customer.create\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_fail ( self , stripe_customer_create_mock , api_retrieve_mock ): api_retrieve_mock . side_effect = InvalidRequestError ( \"No such customer:\" , \"blah\" ) with capture_stdout () as stdout : sync_subscriber ( self . user ) self . assertEqual ( \"ERROR: No such customer:\" , stdout . getvalue () . strip ()) tests . test_sync . TestSyncSubscriber . test_sync_success ( self , stripe_customer_create_mock , api_retrieve_mock , _sync_subscriptions_mock , _sync_invoices_mock , _sync_charges_mock ) Source code in tests/test_sync.py @patch ( \"djstripe.models.Customer._sync_charges\" , autospec = True ) @patch ( \"djstripe.models.Customer._sync_invoices\" , autospec = True ) @patch ( \"djstripe.models.Customer._sync_subscriptions\" , autospec = True ) @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) @patch ( \"stripe.Customer.create\" , return_value = deepcopy ( FAKE_CUSTOMER ), autospec = True ) def test_sync_success ( self , stripe_customer_create_mock , api_retrieve_mock , _sync_subscriptions_mock , _sync_invoices_mock , _sync_charges_mock , ): sync_subscriber ( self . user ) self . assertEqual ( 1 , Customer . objects . count ()) self . assertEqual ( FAKE_CUSTOMER [ \"id\" ], Customer . objects . get ( subscriber = self . user ) . api_retrieve ()[ \"id\" ], ) _sync_subscriptions_mock . assert_called_once_with ( Customer . objects . first ()) _sync_invoices_mock . assert_called_once_with ( Customer . objects . first ()) _sync_charges_mock . assert_called_once_with ( Customer . objects . first ())","title":"Methods"},{"location":"reference/project/#tests.test_sync.capture_stdout","text":"Source code in tests/test_sync.py @contextlib . contextmanager def capture_stdout (): import sys from io import StringIO old_stdout = sys . stdout sys . stdout = StringIO () try : yield sys . stdout finally : sys . stdout = old_stdout","title":"capture_stdout()"},{"location":"reference/project/#tests.test_tax_ids","text":"dj-stripe TaxId Model Tests.","title":"test_tax_ids"},{"location":"reference/project/#tests.test_tax_ids.TaxIdTest","text":"tests . test_tax_ids . TaxIdTest . test_api_list_invalid ( self ) Source code in tests/test_tax_ids.py def test_api_list_invalid ( self ): with pytest . raises ( StripeObjectManipulationException ) as e : TaxId . api_list ( customer = \"Iamastring\" ) assert ( str ( e . value ) == \"TaxIds must be manipulated through a Customer. Pass a Customer object into this call.\" ) tests . test_tax_ids . TaxIdTest . test_api_list_success ( self , customer_mock ) Source code in tests/test_tax_ids.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_WITH_TAX_ID )) def test_api_list_success ( self , customer_mock ): customer = Customer . sync_from_stripe_data ( customer_mock . return_value ) self . assertEqual ( customer . tax_ids . count (), 1 ) tax_ids = TaxId . api_list ( customer = customer ) self . assertEqual ( customer . tax_ids . last () . value , tax_ids [ \"data\" ][ 0 ][ \"value\" ]) tests . test_tax_ids . TaxIdTest . test_sync_from_stripe_data ( self , customer_mock ) Source code in tests/test_tax_ids.py @patch ( \"stripe.Customer.retrieve\" , return_value = deepcopy ( FAKE_CUSTOMER_WITHOUT_TAX_ID ) ) def test_sync_from_stripe_data ( self , customer_mock ): customer = Customer . sync_from_stripe_data ( FAKE_CUSTOMER_WITHOUT_TAX_ID ) self . assertEqual ( customer . tax_ids . count (), 0 ) tax_id = TaxId . sync_from_stripe_data ( deepcopy ( FAKE_TAX_ID )) self . assertEqual ( tax_id . type , \"eu_vat\" ) self . assertEqual ( tax_id . value , \"DE123456789\" ) self . assertEqual ( customer . tax_ids . last (), tax_id )","title":"TaxIdTest"},{"location":"reference/project/#tests.test_tax_rates","text":"dj-stripe SetupIntent Model Tests.","title":"test_tax_rates"},{"location":"reference/project/#tests.test_tax_rates.TaxRateTest","text":"tests . test_tax_rates . TaxRateTest . test_sync_from_stripe_data ( self ) Source code in tests/test_tax_rates.py def test_sync_from_stripe_data ( self ): tax_rate = TaxRate . sync_from_stripe_data ( deepcopy ( FAKE_TAX_RATE_EXAMPLE_1_VAT )) # need to refresh to load percentage as decimal tax_rate . refresh_from_db () self . assertIsInstance ( tax_rate . percentage , Decimal ) self . assertEqual ( tax_rate . percentage , Decimal ( \"15.0\" )) tests . test_tax_rates . TaxRateTest . test_sync_from_stripe_data_non_integer ( self ) Source code in tests/test_tax_rates.py def test_sync_from_stripe_data_non_integer ( self ): # an example non-integer taxrate tax_rate = TaxRate . sync_from_stripe_data ( deepcopy ( FAKE_TAX_RATE_EXAMPLE_2_SALES ) ) # need to refresh to load percentage as decimal tax_rate . refresh_from_db () self . assertIsInstance ( tax_rate . percentage , Decimal ) self . assertEqual ( tax_rate . percentage , Decimal ( \"4.25\" ))","title":"TaxRateTest"},{"location":"reference/project/#tests.test_utils","text":"dj-stripe Utilities Tests.","title":"test_utils"},{"location":"reference/project/#tests.test_utils.TZ_IS_UTC","text":"","title":"TZ_IS_UTC"},{"location":"reference/project/#tests.test_utils-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_utils.TestGetSupportedCurrencyChoices","text":"tests . test_utils . TestGetSupportedCurrencyChoices . test_get_choices ( self , stripe_account_retrieve_mock , stripe_countryspec_retrieve_mock ) Source code in tests/test_utils.py @patch ( \"stripe.CountrySpec.retrieve\" , return_value = { \"supported_payment_currencies\" : [ \"usd\" , \"cad\" , \"eur\" ]}, ) @patch ( \"stripe.Account.retrieve\" , return_value = { \"country\" : \"US\" }, autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) def test_get_choices ( self , stripe_account_retrieve_mock , stripe_countryspec_retrieve_mock ): # Simple test to test sure that at least one currency choice tuple is returned. currency_choices = get_supported_currency_choices ( None ) stripe_account_retrieve_mock . assert_called_once_with () stripe_countryspec_retrieve_mock . assert_called_once_with ( \"US\" ) self . assertGreaterEqual ( len ( currency_choices ), 1 , \"Currency choices pull returned an empty list.\" ) self . assertEqual ( tuple , type ( currency_choices [ 0 ]), \"Currency choices are not tuples.\" ) self . assertIn (( \"usd\" , \"USD\" ), currency_choices , \"USD not in currency choices.\" )","title":"TestGetSupportedCurrencyChoices"},{"location":"reference/project/#tests.test_utils.TestTimestampConversion","text":"tests . test_utils . TestTimestampConversion . test_conversion ( self ) Source code in tests/test_utils.py def test_conversion ( self ): stamp = convert_tstamp ( 1365567407 ) self . assertEqual ( stamp , datetime ( 2013 , 4 , 10 , 4 , 16 , 47 , tzinfo = timezone . utc )) tests . test_utils . TestTimestampConversion . test_conversion_no_tz ( self ) Source code in tests/test_utils.py @skipIf ( not TZ_IS_UTC , \"Skipped because timezone is not UTC.\" ) @override_settings ( USE_TZ = False ) def test_conversion_no_tz ( self ): stamp = convert_tstamp ( 1365567407 ) self . assertEqual ( stamp , datetime ( 2013 , 4 , 10 , 4 , 16 , 47 ))","title":"TestTimestampConversion"},{"location":"reference/project/#tests.test_utils.TestUserHasActiveSubscription","text":"","title":"TestUserHasActiveSubscription"},{"location":"reference/project/#tests.test_utils.TestUserHasActiveSubscription-methods","text":"tests . test_utils . TestUserHasActiveSubscription . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_utils.py def setUp ( self ): self . user = get_user_model () . objects . create_user ( username = \"pydanny\" , email = \"pydanny@gmail.com\" ) self . customer = FAKE_CUSTOMER . create_for_user ( self . user ) tests . test_utils . TestUserHasActiveSubscription . test_anonymous_user ( self ) This needs to throw an ImproperlyConfigured error so the developer can be guided to properly protect the subscription content. Source code in tests/test_utils.py def test_anonymous_user ( self ): \"\"\" This needs to throw an ImproperlyConfigured error so the developer can be guided to properly protect the subscription content. \"\"\" anon_user = AnonymousUser () with self . assertRaises ( ImproperlyConfigured ): subscriber_has_active_subscription ( anon_user ) tests . test_utils . TestUserHasActiveSubscription . test_custom_subscriber ( self ) subscriber_has_active_subscription attempts to create a customer object for the current user. This causes a ValueError in this test because the database has already been established with auth.User. Source code in tests/test_utils.py def test_custom_subscriber ( self ): \"\"\" ``subscriber_has_active_subscription`` attempts to create a customer object for the current user. This causes a ValueError in this test because the database has already been established with auth.User. \"\"\" subscriber = Organization . objects . create ( email = \"email@test.com\" ) self . assertRaises ( ValueError , subscriber_has_active_subscription , subscriber ) tests . test_utils . TestUserHasActiveSubscription . test_staff_user ( self ) Source code in tests/test_utils.py def test_staff_user ( self ): self . user . is_staff = True self . user . save () self . assertTrue ( subscriber_has_active_subscription ( self . user )) tests . test_utils . TestUserHasActiveSubscription . test_superuser ( self ) Source code in tests/test_utils.py def test_superuser ( self ): self . user . is_superuser = True self . user . save () self . assertTrue ( subscriber_has_active_subscription ( self . user )) tests . test_utils . TestUserHasActiveSubscription . test_user_has_active_subscription ( self , product_retrieve_mock ) Source code in tests/test_utils.py @patch ( \"stripe.Product.retrieve\" , return_value = deepcopy ( FAKE_PRODUCT ), autospec = True ) def test_user_has_active_subscription ( self , product_retrieve_mock ): subscription = Subscription . sync_from_stripe_data ( deepcopy ( FAKE_SUBSCRIPTION )) subscription . current_period_end = timezone . now () + timezone . timedelta ( days = 10 ) subscription . save () # Assert that the customer's subscription is valid self . assertTrue ( subscriber_has_active_subscription ( self . user )) tests . test_utils . TestUserHasActiveSubscription . test_user_has_inactive_subscription ( self ) Source code in tests/test_utils.py def test_user_has_inactive_subscription ( self ): self . assertFalse ( subscriber_has_active_subscription ( self . user ))","title":"Methods"},{"location":"reference/project/#tests.test_utils.TestUtils","text":"tests . test_utils . TestUtils . test_get_friendly_currency_amount ( self ) Source code in tests/test_utils.py def test_get_friendly_currency_amount ( self ): self . assertEqual ( get_friendly_currency_amount ( Decimal ( \"1.001\" ), \"usd\" ), \"$1.00 USD\" ) self . assertEqual ( get_friendly_currency_amount ( Decimal ( \"10\" ), \"usd\" ), \"$10.00 USD\" ) self . assertEqual ( get_friendly_currency_amount ( Decimal ( \"10.50\" ), \"usd\" ), \"$10.50 USD\" ) self . assertEqual ( get_friendly_currency_amount ( Decimal ( \"10.51\" ), \"cad\" ), \"$10.51 CAD\" ) self . assertEqual ( get_friendly_currency_amount ( Decimal ( \"9.99\" ), \"eur\" ), \"\u20ac9.99 EUR\" )","title":"TestUtils"},{"location":"reference/project/#tests.test_webhooks","text":"dj-stripe Webhook Tests.","title":"test_webhooks"},{"location":"reference/project/#tests.test_webhooks-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_webhooks.TestWebhook","text":"","title":"TestWebhook"},{"location":"reference/project/#tests.test_webhooks.TestWebhook-methods","text":"tests . test_webhooks . TestWebhook . tearDown ( self ) Hook method for deconstructing the test fixture after testing it. Source code in tests/test_webhooks.py def tearDown ( self ): reload ( djstripe_settings ) tests . test_webhooks . TestWebhook . test_webhook_error ( self , event_retrieve_mock , transfer_retrieve_mock , mock_invoke_webhook_handlers ) Test the case where webhook processing fails to ensure we rollback and do not commit the Event object to the database. Source code in tests/test_webhooks.py @patch . object ( target = Event , attribute = \"invoke_webhook_handlers\" , autospec = True ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_webhook_error ( self , event_retrieve_mock , transfer_retrieve_mock , mock_invoke_webhook_handlers ): \"\"\"Test the case where webhook processing fails to ensure we rollback and do not commit the Event object to the database. \"\"\" mock_invoke_webhook_handlers . side_effect = KeyError ( \"Test error\" ) djstripe_settings . WEBHOOK_SECRET = \"\" fake_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) event_retrieve_mock . return_value = fake_event with self . assertRaises ( KeyError ): self . _send_event ( fake_event ) self . assertEqual ( Event . objects . count (), 0 ) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertEqual ( event_trigger . is_test_event , False ) self . assertEqual ( event_trigger . exception , \"'Test error'\" ) tests . test_webhooks . TestWebhook . test_webhook_good ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_webhooks.py @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_webhook_good ( self , event_retrieve_mock , transfer_retrieve_mock ): djstripe_settings . WEBHOOK_SECRET = \"\" fake_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) event_retrieve_mock . return_value = fake_event resp = self . _send_event ( fake_event ) self . assertEqual ( resp . status_code , 200 ) self . assertEqual ( Event . objects . count (), 1 ) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertEqual ( event_trigger . is_test_event , False ) tests . test_webhooks . TestWebhook . test_webhook_invalid_verify_signature_fail ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_webhooks.py @override_settings ( DJSTRIPE_WEBHOOK_VALIDATION = \"verify_signature\" , DJSTRIPE_WEBHOOK_SECRET = \"whsec_XXXXX\" , ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ), autospec = True , ) def test_webhook_invalid_verify_signature_fail ( self , event_retrieve_mock , transfer_retrieve_mock ): reload ( djstripe_settings ) invalid_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) invalid_event [ \"id\" ] = \"evt_invalid\" invalid_event [ \"data\" ][ \"valid\" ] = \"not really\" resp = self . _send_event ( invalid_event ) self . assertEqual ( resp . status_code , 400 ) self . assertFalse ( Event . objects . filter ( id = \"evt_invalid\" ) . exists ()) tests . test_webhooks . TestWebhook . test_webhook_no_signature ( self ) Source code in tests/test_webhooks.py def test_webhook_no_signature ( self ): self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) resp = Client () . post ( reverse ( \"djstripe:webhook\" ), \" {} \" , content_type = \"application/json\" ) self . assertEqual ( resp . status_code , 400 ) self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) tests . test_webhooks . TestWebhook . test_webhook_no_validation_pass ( self , event_retrieve_mock , transfer_retrieve_mock , verify_header_mock ) Source code in tests/test_webhooks.py @override_settings ( DJSTRIPE_WEBHOOK_VALIDATION = None ) @patch ( \"stripe.WebhookSignature.verify_header\" , autospec = True ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ), autospec = True , ) def test_webhook_no_validation_pass ( self , event_retrieve_mock , transfer_retrieve_mock , verify_header_mock ): reload ( djstripe_settings ) invalid_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) invalid_event [ \"id\" ] = \"evt_invalid\" invalid_event [ \"data\" ][ \"valid\" ] = \"not really\" resp = self . _send_event ( invalid_event ) self . assertEqual ( resp . status_code , 200 ) self . assertTrue ( Event . objects . filter ( id = \"evt_invalid\" ) . exists ()) event_retrieve_mock . assert_not_called () verify_header_mock . assert_not_called () tests . test_webhooks . TestWebhook . test_webhook_remote_addr_is_empty_string ( self ) Source code in tests/test_webhooks.py def test_webhook_remote_addr_is_empty_string ( self ): self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) with warnings . catch_warnings (): warnings . simplefilter ( \"ignore\" ) Client () . post ( reverse ( \"djstripe:webhook\" ), \" {} \" , content_type = \"application/json\" , HTTP_STRIPE_SIGNATURE = \"PLACEHOLDER\" , REMOTE_ADDR = \"\" , ) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertEqual ( event_trigger . remote_ip , \"0.0.0.0\" ) tests . test_webhooks . TestWebhook . test_webhook_remote_addr_is_none ( self ) Source code in tests/test_webhooks.py def test_webhook_remote_addr_is_none ( self ): self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) with warnings . catch_warnings (): warnings . simplefilter ( \"ignore\" ) Client () . post ( reverse ( \"djstripe:webhook\" ), \" {} \" , content_type = \"application/json\" , HTTP_STRIPE_SIGNATURE = \"PLACEHOLDER\" , REMOTE_ADDR = None , ) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertEqual ( event_trigger . remote_ip , \"0.0.0.0\" ) tests . test_webhooks . TestWebhook . test_webhook_reraise_exception ( self , webhook_event_process_mock , webhook_event_validate_mock ) Source code in tests/test_webhooks.py @patch ( \"djstripe.models.WebhookEventTrigger.validate\" , return_value = True , autospec = True ) @patch ( \"djstripe.models.WebhookEventTrigger.process\" , autospec = True ) def test_webhook_reraise_exception ( self , webhook_event_process_mock , webhook_event_validate_mock ): class ProcessException ( Exception ): pass exception_message = \"process fail\" webhook_event_process_mock . side_effect = ProcessException ( exception_message ) self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) fake_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) with self . assertRaisesMessage ( ProcessException , exception_message ): self . _send_event ( fake_event ) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertEqual ( event_trigger . exception , exception_message ) tests . test_webhooks . TestWebhook . test_webhook_retrieve_event_fail ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_webhooks.py @override_settings ( DJSTRIPE_WEBHOOK_VALIDATION = \"retrieve_event\" ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ), autospec = True , ) def test_webhook_retrieve_event_fail ( self , event_retrieve_mock , transfer_retrieve_mock ): reload ( djstripe_settings ) invalid_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) invalid_event [ \"id\" ] = \"evt_invalid\" invalid_event [ \"data\" ][ \"valid\" ] = \"not really\" resp = self . _send_event ( invalid_event ) self . assertEqual ( resp . status_code , 400 ) self . assertFalse ( Event . objects . filter ( id = \"evt_invalid\" ) . exists ()) tests . test_webhooks . TestWebhook . test_webhook_retrieve_event_pass ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_webhooks.py @override_settings ( DJSTRIPE_WEBHOOK_VALIDATION = \"retrieve_event\" ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ), autospec = True , ) def test_webhook_retrieve_event_pass ( self , event_retrieve_mock , transfer_retrieve_mock ): reload ( djstripe_settings ) resp = self . _send_event ( FAKE_EVENT_TRANSFER_CREATED ) self . assertEqual ( resp . status_code , 200 ) event_retrieve_mock . assert_called_once_with ( api_key = djstripe_settings . STRIPE_SECRET_KEY , id = FAKE_EVENT_TRANSFER_CREATED [ \"id\" ], ) tests . test_webhooks . TestWebhook . test_webhook_test_event ( self ) Source code in tests/test_webhooks.py def test_webhook_test_event ( self ): self . assertEqual ( WebhookEventTrigger . objects . count (), 0 ) resp = self . _send_event ( FAKE_EVENT_TEST_CHARGE_SUCCEEDED ) self . assertEqual ( resp . status_code , 200 ) self . assertFalse ( Event . objects . filter ( id = TEST_EVENT_ID ) . exists ()) self . assertEqual ( WebhookEventTrigger . objects . count (), 1 ) event_trigger = WebhookEventTrigger . objects . first () self . assertTrue ( event_trigger . is_test_event ) tests . test_webhooks . TestWebhook . test_webhook_verify_signature_pass ( self , event_retrieve_mock , transfer_retrieve_mock , verify_header_mock ) Source code in tests/test_webhooks.py @override_settings ( DJSTRIPE_WEBHOOK_VALIDATION = \"verify_signature\" , DJSTRIPE_WEBHOOK_SECRET = \"whsec_XXXXX\" , ) @patch ( \"stripe.WebhookSignature.verify_header\" , return_value = True , autospec = IS_STATICMETHOD_AUTOSPEC_SUPPORTED , ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , return_value = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ), autospec = True , ) def test_webhook_verify_signature_pass ( self , event_retrieve_mock , transfer_retrieve_mock , verify_header_mock ): reload ( djstripe_settings ) resp = self . _send_event ( FAKE_EVENT_TRANSFER_CREATED ) self . assertEqual ( resp . status_code , 200 ) self . assertFalse ( Event . objects . filter ( id = \"evt_invalid\" ) . exists ()) verify_header_mock . assert_called_once_with ( json . dumps ( FAKE_EVENT_TRANSFER_CREATED ), \"PLACEHOLDER\" , djstripe_settings . WEBHOOK_SECRET , djstripe_settings . WEBHOOK_TOLERANCE , ) event_retrieve_mock . assert_not_called () tests . test_webhooks . TestWebhook . test_webhook_with_custom_callback ( self , event_retrieve_mock , transfer_retrieve_mock , webhook_event_callback_mock ) Source code in tests/test_webhooks.py @patch . object ( djstripe_settings , \"WEBHOOK_EVENT_CALLBACK\" , return_value = mock_webhook_handler ) @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_webhook_with_custom_callback ( self , event_retrieve_mock , transfer_retrieve_mock , webhook_event_callback_mock ): fake_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) event_retrieve_mock . return_value = fake_event djstripe_settings . WEBHOOK_SECRET = \"\" resp = self . _send_event ( fake_event ) self . assertEqual ( resp . status_code , 200 ) webhook_event_trigger = WebhookEventTrigger . objects . get () webhook_event_callback_mock . called_once_with ( webhook_event_trigger ) tests . test_webhooks . TestWebhook . test_webhook_with_transfer_event_duplicate ( self , event_retrieve_mock , transfer_retrieve_mock ) Source code in tests/test_webhooks.py @patch ( \"stripe.Transfer.retrieve\" , return_value = deepcopy ( FAKE_TRANSFER ), autospec = True ) @patch ( \"stripe.Event.retrieve\" , autospec = True ) def test_webhook_with_transfer_event_duplicate ( self , event_retrieve_mock , transfer_retrieve_mock ): fake_event = deepcopy ( FAKE_EVENT_TRANSFER_CREATED ) event_retrieve_mock . return_value = fake_event djstripe_settings . WEBHOOK_SECRET = \"\" resp = self . _send_event ( fake_event ) self . assertEqual ( resp . status_code , 200 ) self . assertTrue ( Event . objects . filter ( type = \"transfer.created\" ) . exists ()) self . assertEqual ( 1 , Event . objects . filter ( type = \"transfer.created\" ) . count ()) # Duplication resp = self . _send_event ( fake_event ) self . assertEqual ( resp . status_code , 200 ) self . assertEqual ( 1 , Event . objects . filter ( type = \"transfer.created\" ) . count ())","title":"Methods"},{"location":"reference/project/#tests.test_webhooks.TestWebhookHandlers","text":"","title":"TestWebhookHandlers"},{"location":"reference/project/#tests.test_webhooks.TestWebhookHandlers-methods","text":"tests . test_webhooks . TestWebhookHandlers . setUp ( self ) Hook method for setting up the test fixture before exercising it. Source code in tests/test_webhooks.py def setUp ( self ): # Reset state of registrations per test patcher = patch . object ( webhooks , \"registrations\" , new_callable = ( lambda : defaultdict ( list )) ) self . addCleanup ( patcher . stop ) self . registrations = patcher . start () patcher = patch . object ( webhooks , \"registrations_global\" , new_callable = list ) self . addCleanup ( patcher . stop ) self . registrations_global = patcher . start () tests . test_webhooks . TestWebhookHandlers . test_event_handle_registation_with_list_of_strings ( self ) Source code in tests/test_webhooks.py def test_event_handle_registation_with_list_of_strings ( self ): func_mock = Mock () handler ( \"foo\" , \"bar\" )( func_mock ) event1 = self . _call_handlers ( \"foo.bar\" , { \"data\" : \"foo\" }) # handled event2 = self . _call_handlers ( \"bar.foo\" , { \"data\" : \"bar\" }) # handled self . assertEqual ( 2 , func_mock . call_count ) func_mock . assert_has_calls ([ call ( event = event1 ), call ( event = event2 )]) tests . test_webhooks . TestWebhookHandlers . test_event_handle_registation_with_string ( self ) Source code in tests/test_webhooks.py def test_event_handle_registation_with_string ( self ): func_mock = Mock () handler ( \"foo\" )( func_mock ) event = self . _call_handlers ( \"foo.bar\" , { \"data\" : \"foo\" }) # handled self . assertEqual ( 1 , func_mock . call_count ) func_mock . assert_called_with ( event = event ) tests . test_webhooks . TestWebhookHandlers . test_event_handler_registration ( self ) Source code in tests/test_webhooks.py def test_event_handler_registration ( self ): global_func_mock = Mock () handler_all ()( global_func_mock ) func_mock = Mock () handler ( \"foo\" )( func_mock ) event = self . _call_handlers ( \"foo.bar\" , { \"data\" : \"foo\" }) # handled self . _call_handlers ( \"bar.foo\" , { \"data\" : \"foo\" }) # not handled self . assertEqual ( 2 , global_func_mock . call_count ) # called each time self . assertEqual ( 1 , func_mock . call_count ) func_mock . assert_called_with ( event = event ) tests . test_webhooks . TestWebhookHandlers . test_event_subtype_handler_registration ( self ) Source code in tests/test_webhooks.py def test_event_subtype_handler_registration ( self ): global_func_mock = Mock () handler_all ()( global_func_mock ) func_mock = Mock () handler ( \"foo.bar\" )( func_mock ) event1 = self . _call_handlers ( \"foo.bar\" , { \"data\" : \"foo\" }) # handled event2 = self . _call_handlers ( \"foo.bar.wib\" , { \"data\" : \"foo\" }) # handled self . _call_handlers ( \"foo.baz\" , { \"data\" : \"foo\" }) # not handled self . assertEqual ( 3 , global_func_mock . call_count ) # called each time self . assertEqual ( 2 , func_mock . call_count ) func_mock . assert_has_calls ([ call ( event = event1 ), call ( event = event2 )]) tests . test_webhooks . TestWebhookHandlers . test_global_handler_registration ( self ) Source code in tests/test_webhooks.py def test_global_handler_registration ( self ): func_mock = Mock () handler_all ()( func_mock ) event = self . _call_handlers ( \"wib.ble\" , { \"data\" : \"foo\" }) # handled self . assertEqual ( 1 , func_mock . call_count ) func_mock . assert_called_with ( event = event ) tests . test_webhooks . TestWebhookHandlers . test_global_handler_registration_with_function ( self ) Source code in tests/test_webhooks.py def test_global_handler_registration_with_function ( self ): func_mock = Mock () handler_all ( func_mock ) event = self . _call_handlers ( \"wib.ble\" , { \"data\" : \"foo\" }) # handled self . assertEqual ( 1 , func_mock . call_count ) func_mock . assert_called_with ( event = event ) tests . test_webhooks . TestWebhookHandlers . test_webhook_event_trigger_invalid_body ( self ) Source code in tests/test_webhooks.py def test_webhook_event_trigger_invalid_body ( self ): trigger = WebhookEventTrigger ( remote_ip = \"127.0.0.1\" , body = \"invalid json\" ) assert not trigger . json_body","title":"Methods"},{"location":"reference/project/#tests.test_webhooks.mock_webhook_handler","text":"Source code in tests/test_webhooks.py def mock_webhook_handler ( webhook_event_trigger ): webhook_event_trigger . process ()","title":"mock_webhook_handler()"},{"location":"reference/project/#tests.test_zz_jsonfield","text":"Tests for JSONField Due to their nature messing with subclassing, these tests must be run last.","title":"test_zz_jsonfield"},{"location":"reference/project/#tests.test_zz_jsonfield-classes","text":"","title":"Classes"},{"location":"reference/project/#tests.test_zz_jsonfield.TestFallbackJSONField","text":"","title":"TestFallbackJSONField"},{"location":"reference/project/#tests.test_zz_jsonfield.TestFallbackJSONField-methods","text":"tests . test_zz_jsonfield . TestFallbackJSONField . tearDown ( self ) Hook method for deconstructing the test fixture after testing it. Source code in tests/test_zz_jsonfield.py def tearDown ( self ): reload ( djstripe_settings ) reload ( fields ) tests . test_zz_jsonfield . TestFallbackJSONField . test_jsonfield_inheritance ( self ) Source code in tests/test_zz_jsonfield.py def test_jsonfield_inheritance ( self ): reload ( djstripe_settings ) reload ( fields ) self . assertTrue ( issubclass ( fields . JSONField , UglyJSONField ))","title":"Methods"},{"location":"reference/project/#tests.test_zz_jsonfield.TestNativeJSONField","text":"","title":"TestNativeJSONField"},{"location":"reference/project/#tests.test_zz_jsonfield.TestNativeJSONField-methods","text":"tests . test_zz_jsonfield . TestNativeJSONField . tearDown ( self ) Hook method for deconstructing the test fixture after testing it. Source code in tests/test_zz_jsonfield.py def tearDown ( self ): reload ( djstripe_settings ) reload ( fields ) tests . test_zz_jsonfield . TestNativeJSONField . test_jsonfield_inheritance ( self ) Source code in tests/test_zz_jsonfield.py def test_jsonfield_inheritance ( self ): reload ( djstripe_settings ) reload ( fields ) self . assertTrue ( issubclass ( fields . JSONField , DjangoJSONField ))","title":"Methods"},{"location":"reference/project/#tests.urls","text":"","title":"urls"},{"location":"reference/project/#tests.urls.urlpatterns","text":"","title":"urlpatterns"},{"location":"reference/project/#tests.urls.empty_view","text":"Source code in tests/urls.py def empty_view ( request ): return HttpResponse ()","title":"empty_view()"},{"location":"reference/settings/","text":"Settings STRIPE_API_VERSION (='2020-08-27') The API version used to communicate with the Stripe API is configurable, and defaults to the latest version that has been tested as working. Using a value other than the default is allowed, as a string in the format of YYYY-MM-DD. For example, you can specify \"2020-03-02\" to use that API version: STRIPE_API_VERSION = \"2020-03-02\" However you do so at your own risk, as using a value other than the default might result in incompatibilities between Stripe and this library, especially if Stripe has labelled the differences between API versions as \"Major\". Even small differences such as a new enumeration value might cause issues. For this reason it is best to assume that only the default version is supported. For more information on API versioning, see the stripe documentation . See also API Versions . DJSTRIPE_FOREIGN_KEY_TO_FIELD (Introduced in 2.4.0) DJSTRIPE_FOREIGN_KEY_TO_FIELD is a setting introduced in dj-stripe version 2.4.0. You are required to set it in 2.4.0: It does not have a default value. In 3.0.0, the default will be \"id\", and we recommend setting it to \"id\" for new installations. Older installations should set it to \"djstripe_id\". Explanation below. In dj-stripe 2.3 and before, foreign keys for Stripe models were set to point to the foreign model's djstripe_id field, a numeric integer generated by the local database. This new setting allows dj-stripe users to change it to use the \"id\" field, which is the upstream, non-numeric Stripe identifier. When using the Stripe identifier as a foreign key, synchronization between Stripe and dj-stripe can be made far more efficient and robust. Furthermore, it removes the per-installation instability of a critical value. The plan is to get rid of djstripe_id altogether for the 3.0 release (we may retain the field itself until 4.0, but it will no longer be a primary key). How to migrate older installations from \"djstripe_id\" to \"id\"? Such a migration path has not been designed at the moment. Currently if you want to switch an older installation to \"id\", the easiest way is to wipe the djstripe db and sync again from scratch. This is obviously not ideal, and we will design a proper migration path before 3.0. DJSTRIPE_IDEMPOTENCY_KEY_CALLBACK (=djstripe.settings._get_idempotency_key) A function which will return an idempotency key for a particular object_type and action pair. By default, this is set to a function which will create a djstripe.IdempotencyKey object and return its uuid . You may want to customize this if you want to give your idempotency keys a different lifecycle than they normally would get. The function takes the following signature: def get_idempotency_key ( object_type : str , action : str , livemode : bool ): return \"<idempotency key>\" The function MUST return a string suitably random for the object_type/action pair, and usable in the Stripe Idempotency-Key HTTP header. For more information, see the stripe documentation . DJSTRIPE_PRORATION_POLICY (=False) By default, plans are not prorated in dj-stripe. Concretely, this is how this translates: If a customer cancels their plan during a trial, the cancellation is effective right away. If a customer cancels their plan outside of a trial, their subscription remains active until the subscription's period end, and they do not receive a refund. If a customer switches from one plan to another, the new plan becomes effective right away, and the customer is billed for the new plan's amount. Assigning True to DJSTRIPE_PRORATION_POLICY reverses the functioning of item 2 (plan cancellation) by making a cancellation effective right away and refunding the unused balance to the customer, and affects the functioning of item 3 (plan change) by prorating the previous customer's plan towards their new plan's amount. DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS (=()) Warning This functionality is deprecated. Used by djstripe.middleware.SubscriptionPaymentMiddleware Rules: \"(app_name)\" means everything from this app is exempt \"[namespace]\" means everything with this name is exempt \"namespace:name\" means this namespaced URL is exempt \"name\" means this URL is exempt The entire djstripe namespace is exempt If settings.DEBUG is True, then django-debug-toolbar is exempt Example: DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS = ( \"(allauth)\" , # anything in the django-allauth URLConf \"[blogs]\" , # Anything in the blogs namespace \"products:detail\" , # A ProductDetail view you want shown to non-payers \"home\" , # Site homepage ) Note Adding app_names to applications. To make the (allauth) work, you may need to define an app_name in the include() function in the URLConf. For example: # in urls.py url ( r '^accounts/' , include ( 'allauth.urls' , app_name = \"allauth\" )), DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY (=\"djstripe_subscriber\") Every Customer object created in Stripe is tagged with metadata This setting controls what the name of the key in Stripe should be. The key name must be a string no more than 40 characters long. You may set this to None or \"\" to disable that behaviour altogether. This is probably not something you want to do, though. DJSTRIPE_SUBSCRIBER_MODEL (=settings.AUTH_USER_MODEL) If the AUTH_USER_MODEL doesn't represent the object your application's subscription holder, you may define a subscriber model to use here. It should be a string in the form of 'app.model'. Note DJSTRIPE_SUBSCRIBER_MODEL must have an email field. If your existing model has no email field, add an email property that defines an email address to use. Example Model: class Organization ( models . Model ): name = CharField ( max_length = 200 , unique = True ) admin = ForeignKey ( settings . AUTH_USER_MODEL , on_delete = CASCADE ) @property def email ( self ): return self . admin . email DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (=\"__first__\") If the model referenced in DJSTRIPE_SUBSCRIBER_MODEL is not created in the __first__ migration of an app you can specify the migration name to depend on here. For example: \"0003_here_the_subscriber_model_was_added\" DJSTRIPE_USE_NATIVE_JSONFIELD (=False) Setting this to True will make the various dj-stripe JSON fields use the native Django JSONField model instead of the jsonfield library. On Django 3.0 and older : The django.contrib.postgres.fields.JSONField field will always be used. A Postgres backend is required (uses jsonb internally). On Django 3.1 and newer : django.models.JSONField will always be used. This field type is compatible with all database backends. Setting this to True is highly recommended. However, if you have already migrated with the old fields, migrating to the native JSONField has to be done manually and is not currently supported by dj-stripe. We will eventaully move to exclusively using the native JSONField. The native Django JSONField uses the postgres jsonb column type, which efficiently stores JSON and can be queried far moreconveniently. Django also supports querying JSONField with the ORM. DJSTRIPE_WEBHOOK_URL (=r\"^webhook/\\$\") This is where you can tell Stripe to send webhook responses. You can set this to what you want to prevent unnecessary hijinks from unfriendly people. As this is embedded in the URLConf, this must be a resolvable regular expression. DJSTRIPE_WEBHOOK_SECRET (=\"\") If this is set to a non-empty value, webhook signatures will be verified. Learn more about webhook signature verification . DJSTRIPE_WEBHOOK_VALIDATION= (=\"verify_signature\") This setting controls which type of validation is done on webhooks. Value can be \"verify_signature\" for signature verification (recommended default), \"retrieve_event\" for event retrieval (makes an extra HTTP request), or None for no validation at all. DJSTRIPE_WEBHOOK_TOLERANCE (=300) Controls the milliseconds tolerance which wards against replay attacks. Leave this to its default value unless you know what you're doing. DJSTRIPE_WEBHOOK_EVENT_CALLBACK (=None) Webhook event callbacks allow an application to take control of what happens when an event from Stripe is received. It must be a callable or importable string to a callable that takes an event object. One suggestion is to put the event onto a task queue (such as celery) for asynchronous processing. Examples: # callbacks.py def webhook_event_callback ( event ): \"\"\" Dispatches the event to celery for processing. \"\"\" from . import tasks # Ansychronous hand-off to celery so that we can continue immediately tasks . process_webhook_event . s ( event . pk ) . apply_async () # tasks.py from djstripe.models import WebhookEventTrigger from stripe.error import StripeError @shared_task ( bind = True ) def process_webhook_event ( self , pk ): \"\"\" Processes events from Stripe asynchronously. \"\"\" logger . info ( f \"Processing Stripe event: { pk } \" ) try : # get the event obj = WebhookEventTrigger . objects . get ( pk = pk ) # process the event. # internally, this creates a Stripe WebhookEvent Object and invokes the respective Webhooks event = obj . process () except StripeError as exc : logger . error ( f \"Failed to process Stripe event: { pk } . Retrying in 60 seconds.\" ) raise self . retry ( exc = exc , countdown = 60 ) # retry after 60 seconds except WebhookEventTrigger . DoesNotExist as exc : # This can happen in case the celery task got executed before the actual model got saved to the DB raise self . retry ( exc = exc , countdown = 10 ) # retry after 10 seconds return event . type or \"Stripe Event Processed\" # settings.py DJSTRIPE_WEBHOOK_EVENT_CALLBACK = 'callbacks.webhook_event_callback' STRIPE_API_HOST (= unset) If set, this sets the base API host for Stripe. You may want to set this to, for example, \"http://localhost:12111\" if you are running stripe-mock . If this is set in production (DEBUG=False), a warning will be raised on manage.py check . Source Code dj-stripe settings djstripe . settings . CANCELLATION_AT_PERIOD_END djstripe . settings . DEFAULT_STRIPE_API_VERSION djstripe . settings . DJSTRIPE_WEBHOOK_URL djstripe . settings . LIVE_API_KEY djstripe . settings . PRORATION_POLICY djstripe . settings . STRIPE_LIVE_MODE djstripe . settings . SUBSCRIBER_CUSTOMER_KEY djstripe . settings . SUBSCRIPTION_REDIRECT djstripe . settings . SUBSCRIPTION_REQUIRED_EXCEPTION_URLS djstripe . settings . TEST_API_KEY djstripe . settings . USE_NATIVE_JSONFIELD djstripe . settings . WEBHOOK_EVENT_CALLBACK djstripe . settings . WEBHOOK_SECRET djstripe . settings . WEBHOOK_TOLERANCE djstripe . settings . WEBHOOK_VALIDATION djstripe . settings . ZERO_DECIMAL_CURRENCIES Functions djstripe . settings . get_callback_function ( setting_name , default = None ) Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string ( str / unicode ) :param default: The default to return if setting isn't populated. :type default: bool :returns: The resolved callback function (if any). :type: callable Source code in djstripe/settings.py def get_callback_function ( setting_name , default = None ): \"\"\" Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string (``str``/``unicode``) :param default: The default to return if setting isn't populated. :type default: ``bool`` :returns: The resolved callback function (if any). :type: ``callable`` \"\"\" func = getattr ( settings , setting_name , None ) if not func : return default if callable ( func ): return func if isinstance ( func , str ): func = import_string ( func ) if not callable ( func ): raise ImproperlyConfigured ( \" {name} must be callable.\" . format ( name = setting_name )) return func djstripe . settings . get_default_api_key ( livemode ) Returns the default API key for a value of livemode . Source code in djstripe/settings.py def get_default_api_key ( livemode ): \"\"\" Returns the default API key for a value of `livemode`. \"\"\" if livemode is None : # Livemode is unknown. Use the default secret key. return STRIPE_SECRET_KEY elif livemode : # Livemode is true, use the live secret key return LIVE_API_KEY or STRIPE_SECRET_KEY else : # Livemode is false, use the test secret key return TEST_API_KEY or STRIPE_SECRET_KEY djstripe . settings . get_idempotency_key ( object_type , action , livemode ) Source code in djstripe/settings.py def _get_idempotency_key ( object_type , action , livemode ): from .models import IdempotencyKey action = \" {} : {} \" . format ( object_type , action ) idempotency_key , _created = IdempotencyKey . objects . get_or_create ( action = action , livemode = livemode ) return str ( idempotency_key . uuid ) djstripe . settings . get_stripe_api_version () Get the desired API version to use for Stripe requests. Source code in djstripe/settings.py def get_stripe_api_version (): \"\"\"Get the desired API version to use for Stripe requests.\"\"\" version = getattr ( settings , \"STRIPE_API_VERSION\" , stripe . api_version ) return version or DEFAULT_STRIPE_API_VERSION djstripe . settings . get_subscriber_model () Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. Source code in djstripe/settings.py def get_subscriber_model (): \"\"\" Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. \"\"\" model_name = get_subscriber_model_string () # Attempt a Django 1.7 app lookup try : subscriber_model = django_apps . get_model ( model_name ) except ValueError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must be of the form 'app_label.model_name'.\" ) except LookupError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL refers to model ' {model} ' \" \"that has not been installed.\" . format ( model = model_name ) ) if ( \"email\" not in [ field_ . name for field_ in subscriber_model . _meta . get_fields ()] ) and not hasattr ( subscriber_model , \"email\" ): raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must have an email attribute.\" ) if model_name != settings . AUTH_USER_MODEL : # Custom user model detected. Make sure the callback is configured. func = get_callback_function ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" ) if not func : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be implemented \" \"if a DJSTRIPE_SUBSCRIBER_MODEL is defined.\" ) return subscriber_model djstripe . settings . get_subscriber_model_string () Get the configured subscriber model as a module path string. Source code in djstripe/settings.py def get_subscriber_model_string (): \"\"\"Get the configured subscriber model as a module path string.\"\"\" return getattr ( settings , \"DJSTRIPE_SUBSCRIBER_MODEL\" , settings . AUTH_USER_MODEL ) djstripe . settings . set_stripe_api_version ( version = None , validate = True ) Set the desired API version to use for Stripe requests. :param version: The version to set for the Stripe API. :type version: str :param validate: If True validate the value for the specified version). :type validate: bool Source code in djstripe/settings.py def set_stripe_api_version ( version = None , validate = True ): \"\"\" Set the desired API version to use for Stripe requests. :param version: The version to set for the Stripe API. :type version: ``str`` :param validate: If True validate the value for the specified version). :type validate: ``bool`` \"\"\" version = version or get_stripe_api_version () if validate : valid = validate_stripe_api_version ( version ) if not valid : raise ValueError ( \"Bad stripe API version: {} \" . format ( version )) stripe . api_version = version djstripe . settings . subscriber_request_callback ( request ) Source code in djstripe/settings.py \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" , default = ( lambda request : request . user )","title":"Settings"},{"location":"reference/settings/#settings","text":"","title":"Settings"},{"location":"reference/settings/#stripe_api_version-2020-08-27","text":"The API version used to communicate with the Stripe API is configurable, and defaults to the latest version that has been tested as working. Using a value other than the default is allowed, as a string in the format of YYYY-MM-DD. For example, you can specify \"2020-03-02\" to use that API version: STRIPE_API_VERSION = \"2020-03-02\" However you do so at your own risk, as using a value other than the default might result in incompatibilities between Stripe and this library, especially if Stripe has labelled the differences between API versions as \"Major\". Even small differences such as a new enumeration value might cause issues. For this reason it is best to assume that only the default version is supported. For more information on API versioning, see the stripe documentation . See also API Versions .","title":"STRIPE_API_VERSION (='2020-08-27')"},{"location":"reference/settings/#djstripe_foreign_key_to_field","text":"(Introduced in 2.4.0) DJSTRIPE_FOREIGN_KEY_TO_FIELD is a setting introduced in dj-stripe version 2.4.0. You are required to set it in 2.4.0: It does not have a default value. In 3.0.0, the default will be \"id\", and we recommend setting it to \"id\" for new installations. Older installations should set it to \"djstripe_id\". Explanation below. In dj-stripe 2.3 and before, foreign keys for Stripe models were set to point to the foreign model's djstripe_id field, a numeric integer generated by the local database. This new setting allows dj-stripe users to change it to use the \"id\" field, which is the upstream, non-numeric Stripe identifier. When using the Stripe identifier as a foreign key, synchronization between Stripe and dj-stripe can be made far more efficient and robust. Furthermore, it removes the per-installation instability of a critical value. The plan is to get rid of djstripe_id altogether for the 3.0 release (we may retain the field itself until 4.0, but it will no longer be a primary key). How to migrate older installations from \"djstripe_id\" to \"id\"? Such a migration path has not been designed at the moment. Currently if you want to switch an older installation to \"id\", the easiest way is to wipe the djstripe db and sync again from scratch. This is obviously not ideal, and we will design a proper migration path before 3.0.","title":"DJSTRIPE_FOREIGN_KEY_TO_FIELD"},{"location":"reference/settings/#djstripe_idempotency_key_callback-djstripesettings_get_idempotency_key","text":"A function which will return an idempotency key for a particular object_type and action pair. By default, this is set to a function which will create a djstripe.IdempotencyKey object and return its uuid . You may want to customize this if you want to give your idempotency keys a different lifecycle than they normally would get. The function takes the following signature: def get_idempotency_key ( object_type : str , action : str , livemode : bool ): return \"<idempotency key>\" The function MUST return a string suitably random for the object_type/action pair, and usable in the Stripe Idempotency-Key HTTP header. For more information, see the stripe documentation .","title":"DJSTRIPE_IDEMPOTENCY_KEY_CALLBACK (=djstripe.settings._get_idempotency_key)"},{"location":"reference/settings/#djstripe_proration_policy-false","text":"By default, plans are not prorated in dj-stripe. Concretely, this is how this translates: If a customer cancels their plan during a trial, the cancellation is effective right away. If a customer cancels their plan outside of a trial, their subscription remains active until the subscription's period end, and they do not receive a refund. If a customer switches from one plan to another, the new plan becomes effective right away, and the customer is billed for the new plan's amount. Assigning True to DJSTRIPE_PRORATION_POLICY reverses the functioning of item 2 (plan cancellation) by making a cancellation effective right away and refunding the unused balance to the customer, and affects the functioning of item 3 (plan change) by prorating the previous customer's plan towards their new plan's amount.","title":"DJSTRIPE_PRORATION_POLICY (=False)"},{"location":"reference/settings/#djstripe_subscription_required_exception_urls","text":"Warning This functionality is deprecated. Used by djstripe.middleware.SubscriptionPaymentMiddleware Rules: \"(app_name)\" means everything from this app is exempt \"[namespace]\" means everything with this name is exempt \"namespace:name\" means this namespaced URL is exempt \"name\" means this URL is exempt The entire djstripe namespace is exempt If settings.DEBUG is True, then django-debug-toolbar is exempt Example: DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS = ( \"(allauth)\" , # anything in the django-allauth URLConf \"[blogs]\" , # Anything in the blogs namespace \"products:detail\" , # A ProductDetail view you want shown to non-payers \"home\" , # Site homepage ) Note Adding app_names to applications. To make the (allauth) work, you may need to define an app_name in the include() function in the URLConf. For example: # in urls.py url ( r '^accounts/' , include ( 'allauth.urls' , app_name = \"allauth\" )),","title":"DJSTRIPE_SUBSCRIPTION_REQUIRED_EXCEPTION_URLS (=())"},{"location":"reference/settings/#djstripe_subscriber_customer_key-djstripe_subscriber","text":"Every Customer object created in Stripe is tagged with metadata This setting controls what the name of the key in Stripe should be. The key name must be a string no more than 40 characters long. You may set this to None or \"\" to disable that behaviour altogether. This is probably not something you want to do, though.","title":"DJSTRIPE_SUBSCRIBER_CUSTOMER_KEY (=\"djstripe_subscriber\")"},{"location":"reference/settings/#djstripe_subscriber_model-settingsauth_user_model","text":"If the AUTH_USER_MODEL doesn't represent the object your application's subscription holder, you may define a subscriber model to use here. It should be a string in the form of 'app.model'. Note DJSTRIPE_SUBSCRIBER_MODEL must have an email field. If your existing model has no email field, add an email property that defines an email address to use. Example Model: class Organization ( models . Model ): name = CharField ( max_length = 200 , unique = True ) admin = ForeignKey ( settings . AUTH_USER_MODEL , on_delete = CASCADE ) @property def email ( self ): return self . admin . email","title":"DJSTRIPE_SUBSCRIBER_MODEL (=settings.AUTH_USER_MODEL)"},{"location":"reference/settings/#djstripe_subscriber_model_migration_dependency-__first__","text":"If the model referenced in DJSTRIPE_SUBSCRIBER_MODEL is not created in the __first__ migration of an app you can specify the migration name to depend on here. For example: \"0003_here_the_subscriber_model_was_added\"","title":"DJSTRIPE_SUBSCRIBER_MODEL_MIGRATION_DEPENDENCY (=\"__first__\")"},{"location":"reference/settings/#djstripe_use_native_jsonfield-false","text":"Setting this to True will make the various dj-stripe JSON fields use the native Django JSONField model instead of the jsonfield library. On Django 3.0 and older : The django.contrib.postgres.fields.JSONField field will always be used. A Postgres backend is required (uses jsonb internally). On Django 3.1 and newer : django.models.JSONField will always be used. This field type is compatible with all database backends. Setting this to True is highly recommended. However, if you have already migrated with the old fields, migrating to the native JSONField has to be done manually and is not currently supported by dj-stripe. We will eventaully move to exclusively using the native JSONField. The native Django JSONField uses the postgres jsonb column type, which efficiently stores JSON and can be queried far moreconveniently. Django also supports querying JSONField with the ORM.","title":"DJSTRIPE_USE_NATIVE_JSONFIELD (=False)"},{"location":"reference/settings/#djstripe_webhook_url-rwebhook","text":"This is where you can tell Stripe to send webhook responses. You can set this to what you want to prevent unnecessary hijinks from unfriendly people. As this is embedded in the URLConf, this must be a resolvable regular expression.","title":"DJSTRIPE_WEBHOOK_URL (=r\"^webhook/\\$\")"},{"location":"reference/settings/#djstripe_webhook_secret","text":"If this is set to a non-empty value, webhook signatures will be verified. Learn more about webhook signature verification .","title":"DJSTRIPE_WEBHOOK_SECRET (=\"\")"},{"location":"reference/settings/#djstripe_webhook_validation-verify_signature","text":"This setting controls which type of validation is done on webhooks. Value can be \"verify_signature\" for signature verification (recommended default), \"retrieve_event\" for event retrieval (makes an extra HTTP request), or None for no validation at all.","title":"DJSTRIPE_WEBHOOK_VALIDATION= (=\"verify_signature\")"},{"location":"reference/settings/#djstripe_webhook_tolerance-300","text":"Controls the milliseconds tolerance which wards against replay attacks. Leave this to its default value unless you know what you're doing.","title":"DJSTRIPE_WEBHOOK_TOLERANCE (=300)"},{"location":"reference/settings/#djstripe_webhook_event_callback-none","text":"Webhook event callbacks allow an application to take control of what happens when an event from Stripe is received. It must be a callable or importable string to a callable that takes an event object. One suggestion is to put the event onto a task queue (such as celery) for asynchronous processing. Examples: # callbacks.py def webhook_event_callback ( event ): \"\"\" Dispatches the event to celery for processing. \"\"\" from . import tasks # Ansychronous hand-off to celery so that we can continue immediately tasks . process_webhook_event . s ( event . pk ) . apply_async () # tasks.py from djstripe.models import WebhookEventTrigger from stripe.error import StripeError @shared_task ( bind = True ) def process_webhook_event ( self , pk ): \"\"\" Processes events from Stripe asynchronously. \"\"\" logger . info ( f \"Processing Stripe event: { pk } \" ) try : # get the event obj = WebhookEventTrigger . objects . get ( pk = pk ) # process the event. # internally, this creates a Stripe WebhookEvent Object and invokes the respective Webhooks event = obj . process () except StripeError as exc : logger . error ( f \"Failed to process Stripe event: { pk } . Retrying in 60 seconds.\" ) raise self . retry ( exc = exc , countdown = 60 ) # retry after 60 seconds except WebhookEventTrigger . DoesNotExist as exc : # This can happen in case the celery task got executed before the actual model got saved to the DB raise self . retry ( exc = exc , countdown = 10 ) # retry after 10 seconds return event . type or \"Stripe Event Processed\" # settings.py DJSTRIPE_WEBHOOK_EVENT_CALLBACK = 'callbacks.webhook_event_callback'","title":"DJSTRIPE_WEBHOOK_EVENT_CALLBACK (=None)"},{"location":"reference/settings/#stripe_api_host-unset","text":"If set, this sets the base API host for Stripe. You may want to set this to, for example, \"http://localhost:12111\" if you are running stripe-mock . If this is set in production (DEBUG=False), a warning will be raised on manage.py check .","title":"STRIPE_API_HOST (= unset)"},{"location":"reference/settings/#source-code","text":"dj-stripe settings","title":"Source Code"},{"location":"reference/settings/#djstripe.settings.CANCELLATION_AT_PERIOD_END","text":"","title":"CANCELLATION_AT_PERIOD_END"},{"location":"reference/settings/#djstripe.settings.DEFAULT_STRIPE_API_VERSION","text":"","title":"DEFAULT_STRIPE_API_VERSION"},{"location":"reference/settings/#djstripe.settings.DJSTRIPE_WEBHOOK_URL","text":"","title":"DJSTRIPE_WEBHOOK_URL"},{"location":"reference/settings/#djstripe.settings.LIVE_API_KEY","text":"","title":"LIVE_API_KEY"},{"location":"reference/settings/#djstripe.settings.PRORATION_POLICY","text":"","title":"PRORATION_POLICY"},{"location":"reference/settings/#djstripe.settings.STRIPE_LIVE_MODE","text":"","title":"STRIPE_LIVE_MODE"},{"location":"reference/settings/#djstripe.settings.SUBSCRIBER_CUSTOMER_KEY","text":"","title":"SUBSCRIBER_CUSTOMER_KEY"},{"location":"reference/settings/#djstripe.settings.SUBSCRIPTION_REDIRECT","text":"","title":"SUBSCRIPTION_REDIRECT"},{"location":"reference/settings/#djstripe.settings.SUBSCRIPTION_REQUIRED_EXCEPTION_URLS","text":"","title":"SUBSCRIPTION_REQUIRED_EXCEPTION_URLS"},{"location":"reference/settings/#djstripe.settings.TEST_API_KEY","text":"","title":"TEST_API_KEY"},{"location":"reference/settings/#djstripe.settings.USE_NATIVE_JSONFIELD","text":"","title":"USE_NATIVE_JSONFIELD"},{"location":"reference/settings/#djstripe.settings.WEBHOOK_EVENT_CALLBACK","text":"","title":"WEBHOOK_EVENT_CALLBACK"},{"location":"reference/settings/#djstripe.settings.WEBHOOK_SECRET","text":"","title":"WEBHOOK_SECRET"},{"location":"reference/settings/#djstripe.settings.WEBHOOK_TOLERANCE","text":"","title":"WEBHOOK_TOLERANCE"},{"location":"reference/settings/#djstripe.settings.WEBHOOK_VALIDATION","text":"","title":"WEBHOOK_VALIDATION"},{"location":"reference/settings/#djstripe.settings.ZERO_DECIMAL_CURRENCIES","text":"","title":"ZERO_DECIMAL_CURRENCIES"},{"location":"reference/settings/#djstripe.settings-functions","text":"","title":"Functions"},{"location":"reference/settings/#djstripe.settings.get_callback_function","text":"Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string ( str / unicode ) :param default: The default to return if setting isn't populated. :type default: bool :returns: The resolved callback function (if any). :type: callable Source code in djstripe/settings.py def get_callback_function ( setting_name , default = None ): \"\"\" Resolve a callback function based on a setting name. If the setting value isn't set, default is returned. If the setting value is already a callable function, that value is used - If the setting value is a string, an attempt is made to import it. Anything else will result in a failed import causing ImportError to be raised. :param setting_name: The name of the setting to resolve a callback from. :type setting_name: string (``str``/``unicode``) :param default: The default to return if setting isn't populated. :type default: ``bool`` :returns: The resolved callback function (if any). :type: ``callable`` \"\"\" func = getattr ( settings , setting_name , None ) if not func : return default if callable ( func ): return func if isinstance ( func , str ): func = import_string ( func ) if not callable ( func ): raise ImproperlyConfigured ( \" {name} must be callable.\" . format ( name = setting_name )) return func","title":"get_callback_function()"},{"location":"reference/settings/#djstripe.settings.get_default_api_key","text":"Returns the default API key for a value of livemode . Source code in djstripe/settings.py def get_default_api_key ( livemode ): \"\"\" Returns the default API key for a value of `livemode`. \"\"\" if livemode is None : # Livemode is unknown. Use the default secret key. return STRIPE_SECRET_KEY elif livemode : # Livemode is true, use the live secret key return LIVE_API_KEY or STRIPE_SECRET_KEY else : # Livemode is false, use the test secret key return TEST_API_KEY or STRIPE_SECRET_KEY","title":"get_default_api_key()"},{"location":"reference/settings/#djstripe.settings.get_idempotency_key","text":"Source code in djstripe/settings.py def _get_idempotency_key ( object_type , action , livemode ): from .models import IdempotencyKey action = \" {} : {} \" . format ( object_type , action ) idempotency_key , _created = IdempotencyKey . objects . get_or_create ( action = action , livemode = livemode ) return str ( idempotency_key . uuid )","title":"get_idempotency_key()"},{"location":"reference/settings/#djstripe.settings.get_stripe_api_version","text":"Get the desired API version to use for Stripe requests. Source code in djstripe/settings.py def get_stripe_api_version (): \"\"\"Get the desired API version to use for Stripe requests.\"\"\" version = getattr ( settings , \"STRIPE_API_VERSION\" , stripe . api_version ) return version or DEFAULT_STRIPE_API_VERSION","title":"get_stripe_api_version()"},{"location":"reference/settings/#djstripe.settings.get_subscriber_model","text":"Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. Source code in djstripe/settings.py def get_subscriber_model (): \"\"\" Attempt to pull settings.DJSTRIPE_SUBSCRIBER_MODEL. Users have the option of specifying a custom subscriber model via the DJSTRIPE_SUBSCRIBER_MODEL setting. This methods falls back to AUTH_USER_MODEL if DJSTRIPE_SUBSCRIBER_MODEL is not set. Returns the subscriber model that is active in this project. \"\"\" model_name = get_subscriber_model_string () # Attempt a Django 1.7 app lookup try : subscriber_model = django_apps . get_model ( model_name ) except ValueError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must be of the form 'app_label.model_name'.\" ) except LookupError : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL refers to model ' {model} ' \" \"that has not been installed.\" . format ( model = model_name ) ) if ( \"email\" not in [ field_ . name for field_ in subscriber_model . _meta . get_fields ()] ) and not hasattr ( subscriber_model , \"email\" ): raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL must have an email attribute.\" ) if model_name != settings . AUTH_USER_MODEL : # Custom user model detected. Make sure the callback is configured. func = get_callback_function ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" ) if not func : raise ImproperlyConfigured ( \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK must be implemented \" \"if a DJSTRIPE_SUBSCRIBER_MODEL is defined.\" ) return subscriber_model","title":"get_subscriber_model()"},{"location":"reference/settings/#djstripe.settings.get_subscriber_model_string","text":"Get the configured subscriber model as a module path string. Source code in djstripe/settings.py def get_subscriber_model_string (): \"\"\"Get the configured subscriber model as a module path string.\"\"\" return getattr ( settings , \"DJSTRIPE_SUBSCRIBER_MODEL\" , settings . AUTH_USER_MODEL )","title":"get_subscriber_model_string()"},{"location":"reference/settings/#djstripe.settings.set_stripe_api_version","text":"Set the desired API version to use for Stripe requests. :param version: The version to set for the Stripe API. :type version: str :param validate: If True validate the value for the specified version). :type validate: bool Source code in djstripe/settings.py def set_stripe_api_version ( version = None , validate = True ): \"\"\" Set the desired API version to use for Stripe requests. :param version: The version to set for the Stripe API. :type version: ``str`` :param validate: If True validate the value for the specified version). :type validate: ``bool`` \"\"\" version = version or get_stripe_api_version () if validate : valid = validate_stripe_api_version ( version ) if not valid : raise ValueError ( \"Bad stripe API version: {} \" . format ( version )) stripe . api_version = version","title":"set_stripe_api_version()"},{"location":"reference/settings/#djstripe.settings.subscriber_request_callback","text":"Source code in djstripe/settings.py \"DJSTRIPE_SUBSCRIBER_MODEL_REQUEST_CALLBACK\" , default = ( lambda request : request . user )","title":"subscriber_request_callback()"},{"location":"reference/utils/","text":"Utilities Utility functions related to the djstripe app. djstripe . utils . ANONYMOUS_USER_ERROR_MSG djstripe . utils . CURRENCY_SIGILS Classes djstripe.utils.QuerySetMock A mocked QuerySet class that does not handle updates. Used by UpcomingInvoice.invoiceitems. Methods djstripe . utils . QuerySetMock . delete ( self ) Delete the records in the current QuerySet. Source code in djstripe/utils.py def delete ( self ): return 0 djstripe . utils . QuerySetMock . from_iterable ( model , iterable ) classmethod Source code in djstripe/utils.py @classmethod def from_iterable ( cls , model , iterable ): instance = cls ( model ) instance . _result_cache = list ( iterable ) instance . _prefetch_done = True return instance djstripe . utils . QuerySetMock . update ( self ) Update all elements in the current QuerySet, setting all the given fields to the appropriate values. Source code in djstripe/utils.py def update ( self ): return 0 Functions djstripe . utils . clear_expired_idempotency_keys () Source code in djstripe/utils.py def clear_expired_idempotency_keys (): from .models import IdempotencyKey threshold = timezone . now () - datetime . timedelta ( hours = 24 ) IdempotencyKey . objects . filter ( created__lt = threshold ) . delete () djstripe . utils . convert_tstamp ( response ) Convert a Stripe API timestamp response (unix epoch) to a native datetime. Source code in djstripe/utils.py def convert_tstamp ( response ) -> Optional [ datetime . datetime ]: \"\"\" Convert a Stripe API timestamp response (unix epoch) to a native datetime. \"\"\" if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz ) djstripe . utils . get_friendly_currency_amount ( amount , currency ) Source code in djstripe/utils.py def get_friendly_currency_amount ( amount , currency : str ) -> str : currency = currency . upper () sigil = CURRENCY_SIGILS . get ( currency , \"\" ) return \" {sigil}{amount:.2f} {currency} \" . format ( sigil = sigil , amount = amount , currency = currency ) djstripe . utils . get_supported_currency_choices ( api_key ) Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str Source code in djstripe/utils.py def get_supported_currency_choices ( api_key ): \"\"\" Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str \"\"\" import stripe stripe . api_key = api_key account = stripe . Account . retrieve () supported_payment_currencies = stripe . CountrySpec . retrieve ( account [ \"country\" ])[ \"supported_payment_currencies\" ] return [( currency , currency . upper ()) for currency in supported_payment_currencies ] djstripe . utils . subscriber_has_active_subscription ( subscriber , price = None , plan = None ) Helper function to check if a subscriber has an active subscription. Throws TypeError if both price and plan are defined. Throws improperlyConfigured if the subscriber is an instance of AUTH_USER_MODEL and get_user_model().is_anonymous == True. Activate subscription rules (or): * customer has active subscription If the subscriber is an instance of AUTH_USER_MODEL, active subscription rules (or): * customer has active subscription * user.is_superuser * user.is_staff If price and plan are None and there exists only one subscription, this method will check if that subscription is active. Calling this method with no price, no plan and multiple subscriptions will throw an exception. :param subscriber: The subscriber for which to check for an active subscription. :type subscriber: dj-stripe subscriber :param price: The price for which to check for an active subscription. :type price: Price or string (price ID) :param plan: The plan for which to check for an active subscription. :type plan: Plan or string (plan ID) Source code in djstripe/utils.py def subscriber_has_active_subscription ( subscriber , price = None , plan = None ): \"\"\" Helper function to check if a subscriber has an active subscription. Throws TypeError if both price and plan are defined. Throws improperlyConfigured if the subscriber is an instance of AUTH_USER_MODEL and get_user_model().is_anonymous == True. Activate subscription rules (or): * customer has active subscription If the subscriber is an instance of AUTH_USER_MODEL, active subscription rules (or): * customer has active subscription * user.is_superuser * user.is_staff If price and plan are None and there exists only one subscription, this method will check if that subscription is active. Calling this method with no price, no plan and multiple subscriptions will throw an exception. :param subscriber: The subscriber for which to check for an active subscription. :type subscriber: dj-stripe subscriber :param price: The price for which to check for an active subscription. :type price: Price or string (price ID) :param plan: The plan for which to check for an active subscription. :type plan: Plan or string (plan ID) \"\"\" warnings . warn ( \"The subscriber_has_active_subscription utility function, and \" \"SubscriptionPaymentMiddleware, will be removed in dj-stripe 2.5.0.\" , DeprecationWarning , ) if price and plan : raise TypeError ( \"price and plan arguments cannot both be defined.\" ) price = price or plan try : if subscriber . is_anonymous : raise ImproperlyConfigured ( ANONYMOUS_USER_ERROR_MSG ) except AttributeError : pass if isinstance ( subscriber , get_user_model ()): if subscriber . is_superuser or subscriber . is_staff : return True from .models import Customer customer , created = Customer . get_or_create ( subscriber ) if created or not customer . has_active_subscription ( price ): return False return True","title":"Utilities"},{"location":"reference/utils/#utilities","text":"Utility functions related to the djstripe app.","title":"Utilities"},{"location":"reference/utils/#djstripe.utils.ANONYMOUS_USER_ERROR_MSG","text":"","title":"ANONYMOUS_USER_ERROR_MSG"},{"location":"reference/utils/#djstripe.utils.CURRENCY_SIGILS","text":"","title":"CURRENCY_SIGILS"},{"location":"reference/utils/#djstripe.utils-classes","text":"","title":"Classes"},{"location":"reference/utils/#djstripe.utils.QuerySetMock","text":"A mocked QuerySet class that does not handle updates. Used by UpcomingInvoice.invoiceitems.","title":"QuerySetMock"},{"location":"reference/utils/#djstripe.utils.QuerySetMock-methods","text":"","title":"Methods"},{"location":"reference/utils/#djstripe.utils.QuerySetMock.delete","text":"Delete the records in the current QuerySet. Source code in djstripe/utils.py def delete ( self ): return 0","title":"delete()"},{"location":"reference/utils/#djstripe.utils.QuerySetMock.from_iterable","text":"Source code in djstripe/utils.py @classmethod def from_iterable ( cls , model , iterable ): instance = cls ( model ) instance . _result_cache = list ( iterable ) instance . _prefetch_done = True return instance","title":"from_iterable()"},{"location":"reference/utils/#djstripe.utils.QuerySetMock.update","text":"Update all elements in the current QuerySet, setting all the given fields to the appropriate values. Source code in djstripe/utils.py def update ( self ): return 0","title":"update()"},{"location":"reference/utils/#djstripe.utils-functions","text":"","title":"Functions"},{"location":"reference/utils/#djstripe.utils.clear_expired_idempotency_keys","text":"Source code in djstripe/utils.py def clear_expired_idempotency_keys (): from .models import IdempotencyKey threshold = timezone . now () - datetime . timedelta ( hours = 24 ) IdempotencyKey . objects . filter ( created__lt = threshold ) . delete ()","title":"clear_expired_idempotency_keys()"},{"location":"reference/utils/#djstripe.utils.convert_tstamp","text":"Convert a Stripe API timestamp response (unix epoch) to a native datetime. Source code in djstripe/utils.py def convert_tstamp ( response ) -> Optional [ datetime . datetime ]: \"\"\" Convert a Stripe API timestamp response (unix epoch) to a native datetime. \"\"\" if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )","title":"convert_tstamp()"},{"location":"reference/utils/#djstripe.utils.get_friendly_currency_amount","text":"Source code in djstripe/utils.py def get_friendly_currency_amount ( amount , currency : str ) -> str : currency = currency . upper () sigil = CURRENCY_SIGILS . get ( currency , \"\" ) return \" {sigil}{amount:.2f} {currency} \" . format ( sigil = sigil , amount = amount , currency = currency )","title":"get_friendly_currency_amount()"},{"location":"reference/utils/#djstripe.utils.get_supported_currency_choices","text":"Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str Source code in djstripe/utils.py def get_supported_currency_choices ( api_key ): \"\"\" Pull a stripe account's supported currencies and returns a choices tuple of those supported currencies. :param api_key: The api key associated with the account from which to pull data. :type api_key: str \"\"\" import stripe stripe . api_key = api_key account = stripe . Account . retrieve () supported_payment_currencies = stripe . CountrySpec . retrieve ( account [ \"country\" ])[ \"supported_payment_currencies\" ] return [( currency , currency . upper ()) for currency in supported_payment_currencies ]","title":"get_supported_currency_choices()"},{"location":"reference/utils/#djstripe.utils.subscriber_has_active_subscription","text":"Helper function to check if a subscriber has an active subscription. Throws TypeError if both price and plan are defined. Throws improperlyConfigured if the subscriber is an instance of AUTH_USER_MODEL and get_user_model().is_anonymous == True. Activate subscription rules (or): * customer has active subscription If the subscriber is an instance of AUTH_USER_MODEL, active subscription rules (or): * customer has active subscription * user.is_superuser * user.is_staff If price and plan are None and there exists only one subscription, this method will check if that subscription is active. Calling this method with no price, no plan and multiple subscriptions will throw an exception. :param subscriber: The subscriber for which to check for an active subscription. :type subscriber: dj-stripe subscriber :param price: The price for which to check for an active subscription. :type price: Price or string (price ID) :param plan: The plan for which to check for an active subscription. :type plan: Plan or string (plan ID) Source code in djstripe/utils.py def subscriber_has_active_subscription ( subscriber , price = None , plan = None ): \"\"\" Helper function to check if a subscriber has an active subscription. Throws TypeError if both price and plan are defined. Throws improperlyConfigured if the subscriber is an instance of AUTH_USER_MODEL and get_user_model().is_anonymous == True. Activate subscription rules (or): * customer has active subscription If the subscriber is an instance of AUTH_USER_MODEL, active subscription rules (or): * customer has active subscription * user.is_superuser * user.is_staff If price and plan are None and there exists only one subscription, this method will check if that subscription is active. Calling this method with no price, no plan and multiple subscriptions will throw an exception. :param subscriber: The subscriber for which to check for an active subscription. :type subscriber: dj-stripe subscriber :param price: The price for which to check for an active subscription. :type price: Price or string (price ID) :param plan: The plan for which to check for an active subscription. :type plan: Plan or string (plan ID) \"\"\" warnings . warn ( \"The subscriber_has_active_subscription utility function, and \" \"SubscriptionPaymentMiddleware, will be removed in dj-stripe 2.5.0.\" , DeprecationWarning , ) if price and plan : raise TypeError ( \"price and plan arguments cannot both be defined.\" ) price = price or plan try : if subscriber . is_anonymous : raise ImproperlyConfigured ( ANONYMOUS_USER_ERROR_MSG ) except AttributeError : pass if isinstance ( subscriber , get_user_model ()): if subscriber . is_superuser or subscriber . is_staff : return True from .models import Customer customer , created = Customer . get_or_create ( subscriber ) if created or not customer . has_active_subscription ( price ): return False return True","title":"subscriber_has_active_subscription()"},{"location":"usage/creating_individual_charges/","text":"Creating individual charges On the subscriber's customer object, use the charge method to generate a Stripe charge. In this example, we're using the user named admin as the subscriber. from decimal import Decimal from django.contrib.auth import get_user_model from djstripe.models import Customer user = get_user_model () . objects . get ( username = \"admin\" ) customer , created = Customer . get_or_create ( subscriber = user ) customer . charge ( Decimal ( \"10.00\" ), currency = \"usd\" ) # Create charge for 10.00 USD","title":"Creating individual charges"},{"location":"usage/creating_individual_charges/#creating-individual-charges","text":"On the subscriber's customer object, use the charge method to generate a Stripe charge. In this example, we're using the user named admin as the subscriber. from decimal import Decimal from django.contrib.auth import get_user_model from djstripe.models import Customer user = get_user_model () . objects . get ( username = \"admin\" ) customer , created = Customer . get_or_create ( subscriber = user ) customer . charge ( Decimal ( \"10.00\" ), currency = \"usd\" ) # Create charge for 10.00 USD","title":"Creating individual charges"},{"location":"usage/managing_subscriptions/","text":"Managing subscriptions and payment sources Extending subscriptions For your convenience, dj-stripe provides a Subscription.extend(*delta*) method Subscriptions can be extended by using the Subscription.extend method, which takes a positive timedelta as its only property. This method is useful if you want to offer time-cards, gift-cards, or some other external way of subscribing users or extending subscriptions, while keeping the billing handling within Stripe. Warning Subscription extensions are achieved by manipulating the trial_end of the subscription instance, which means that Stripe will change the status to trialing .","title":"Managing subscriptions and payment sources"},{"location":"usage/managing_subscriptions/#managing-subscriptions-and-payment-sources","text":"","title":"Managing subscriptions and payment sources"},{"location":"usage/managing_subscriptions/#extending-subscriptions","text":"For your convenience, dj-stripe provides a Subscription.extend(*delta*) method Subscriptions can be extended by using the Subscription.extend method, which takes a positive timedelta as its only property. This method is useful if you want to offer time-cards, gift-cards, or some other external way of subscribing users or extending subscriptions, while keeping the billing handling within Stripe. Warning Subscription extensions are achieved by manipulating the trial_end of the subscription instance, which means that Stripe will change the status to trialing .","title":"Extending subscriptions"},{"location":"usage/manually_syncing_with_stripe/","text":"Manually syncing data with Stripe If you're using dj-stripe's webhook handlers then data will be automatically synced from Stripe to the Django database, but in some circumstances you may want to manually sync Stripe API data as well. Command line You can sync your database with stripe using the manage command djstripe_sync_models , e.g. to populate an empty database from an existing Stripe account. ./manage.py djstripe_sync_models With no arguments this will sync all supported models, or a list of models to sync can be provided. ./manage.py djstripe_sync_models Invoice Subscription Note that this may be redundant since we recursively sync related objects. You can manually reprocess events using the management commands djstripe_process_events . By default this processes all events, but options can be passed to limit the events processed. Note the Stripe API documents a limitation where events are only guaranteed to be available for 30 days. # all events ./manage.py djstripe_process_events # failed events (events with pending webhooks or where all webhook delivery attempts failed) ./manage.py djstripe_process_events --failed # filter by event type (all payment_intent events in this example) ./manage.py djstripe_process_events --type payment_intent.* # specific events by ID ./manage.py djstripe_process_events --ids evt_foo evt_bar # more output for debugging processing failures ./manage.py djstripe_process_events -v 2 In Code To sync in code, for example if you write to the Stripe API and want to work with the resulting dj-stripe object without having to wait for the webhook trigger. This can be done using the classmethod sync_from_stripe_data that exists on all dj-stripe model classes. E.g. creating a product using the Stripe API, and then syncing the API return data to Django using dj-stripe:","title":"Manually syncing data with Stripe"},{"location":"usage/manually_syncing_with_stripe/#manually-syncing-data-with-stripe","text":"If you're using dj-stripe's webhook handlers then data will be automatically synced from Stripe to the Django database, but in some circumstances you may want to manually sync Stripe API data as well.","title":"Manually syncing data with Stripe"},{"location":"usage/manually_syncing_with_stripe/#command-line","text":"You can sync your database with stripe using the manage command djstripe_sync_models , e.g. to populate an empty database from an existing Stripe account. ./manage.py djstripe_sync_models With no arguments this will sync all supported models, or a list of models to sync can be provided. ./manage.py djstripe_sync_models Invoice Subscription Note that this may be redundant since we recursively sync related objects. You can manually reprocess events using the management commands djstripe_process_events . By default this processes all events, but options can be passed to limit the events processed. Note the Stripe API documents a limitation where events are only guaranteed to be available for 30 days. # all events ./manage.py djstripe_process_events # failed events (events with pending webhooks or where all webhook delivery attempts failed) ./manage.py djstripe_process_events --failed # filter by event type (all payment_intent events in this example) ./manage.py djstripe_process_events --type payment_intent.* # specific events by ID ./manage.py djstripe_process_events --ids evt_foo evt_bar # more output for debugging processing failures ./manage.py djstripe_process_events -v 2","title":"Command line"},{"location":"usage/manually_syncing_with_stripe/#in-code","text":"To sync in code, for example if you write to the Stripe API and want to work with the resulting dj-stripe object without having to wait for the webhook trigger. This can be done using the classmethod sync_from_stripe_data that exists on all dj-stripe model classes. E.g. creating a product using the Stripe API, and then syncing the API return data to Django using dj-stripe:","title":"In Code"},{"location":"usage/subscribing_customers/","text":"Subscribing a customer to a price (or plan) For your convenience, dj-stripe provides a djstripe.models.Customer.subscribe method that will try to charge the customer immediately unless you specify charge_immediately=False Recommended Approach # Recommended Approach to use items dict with Prices ## This will subscribe <customer> to both <price_1> and <price_2> price_1 = Price . objects . get ( nickname = \"one_price\" ) price_2 = Price . objects . get ( nickname = \"two_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }, { \"price\" : price_2 }]) ## This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }]) Alternate Approach 1 (with legacy Plans) ## (Alternate Approach) This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( price = price_1 ) # If you still use legacy Plans... ## This will subscribe <customer> to both <plan_1> and <plan_2> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) plan_2 = Plan . objects . get ( nickname = \"two_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }, { \"plan\" : plan_2 }]) ## This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }]) Alternate Approach 2 ## (Alternate Approach) This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( plan = plan ) However in some cases subscribe() might not support all the arguments you need for your implementation. When this happens you can just call the official stripe.Customer.subscribe() . Tip Checkout this example and this . Note that PaymentMethods can be used instead of Cards/Source by substituting # Add the payment method customer's default customer . add_payment_method ( payment_method ) instead of # Add the source as the customer's default card customer . add_card ( stripe_source ) in the above example.","title":"Subscribing a customer to a plan"},{"location":"usage/subscribing_customers/#subscribing-a-customer-to-a-price-or-plan","text":"For your convenience, dj-stripe provides a djstripe.models.Customer.subscribe method that will try to charge the customer immediately unless you specify charge_immediately=False","title":"Subscribing a customer to a price (or plan)"},{"location":"usage/subscribing_customers/#recommended-approach","text":"# Recommended Approach to use items dict with Prices ## This will subscribe <customer> to both <price_1> and <price_2> price_1 = Price . objects . get ( nickname = \"one_price\" ) price_2 = Price . objects . get ( nickname = \"two_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }, { \"price\" : price_2 }]) ## This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"price\" : price_1 }])","title":"Recommended Approach"},{"location":"usage/subscribing_customers/#alternate-approach-1-with-legacy-plans","text":"## (Alternate Approach) This will subscribe <customer> to <price_1> price_1 = Price . objects . get ( nickname = \"one_price\" ) customer = Customer . objects . first () customer . subscribe ( price = price_1 ) # If you still use legacy Plans... ## This will subscribe <customer> to both <plan_1> and <plan_2> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) plan_2 = Plan . objects . get ( nickname = \"two_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }, { \"plan\" : plan_2 }]) ## This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( items = [{ \"plan\" : plan_1 }])","title":"Alternate Approach 1 (with legacy Plans)"},{"location":"usage/subscribing_customers/#alternate-approach-2","text":"## (Alternate Approach) This will subscribe <customer> to <plan_1> plan_1 = Plan . objects . get ( nickname = \"one_plan\" ) customer = Customer . objects . first () customer . subscribe ( plan = plan ) However in some cases subscribe() might not support all the arguments you need for your implementation. When this happens you can just call the official stripe.Customer.subscribe() . Tip Checkout this example and this . Note that PaymentMethods can be used instead of Cards/Source by substituting # Add the payment method customer's default customer . add_payment_method ( payment_method ) instead of # Add the source as the customer's default card customer . add_card ( stripe_source ) in the above example.","title":"Alternate Approach 2"},{"location":"usage/webhooks/","text":"Using Stripe Webhooks Available settings dj-stripe provides the following settings to tune how your webhooks work: DJSTRIPE_WEBHOOK_URL DJSTRIPE_WEBHOOK_SECRET DJSTRIPE_WEBHOOK_VALIDATION DJSTRIPE_WEBHOOK_TOLERANCE DJSTRIPE_WEBHOOK_EVENT_CALLBACK Using webhooks in dj-stripe dj-stripe comes with native support for webhooks as event listeners. Events allow you to do things like [sending an email to a customer when his payment has failed or trial period is ending. This is how you use them: from djstripe import webhooks @webhooks . handler ( \"customer.subscription.trial_will_end\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can handle all events related to customers like this: from djstripe import webhooks @webhooks . handler ( \"customer\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can also handle different events in the same handler: from djstripe import webhooks @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): print ( \"Triggered webhook \" + event . type ) Warning In order to get registrations picked up, you need to put them in a module that is imported like models.py or make sure you import it manually. Webhook event creation and processing is now wrapped in a transaction.atomic() block to better handle webhook errors. This will prevent any additional database modifications you may perform in your custom handler from being committed should something in the webhook processing chain fail. You can also take advantage of Django's transaction.on_commit() function to only perform an action if the transaction successfully commits (meaning the Event processing worked): from django.db import transaction from djstripe import webhooks def do_something (): pass # send a mail, invalidate a cache, fire off a Celery task, etc. @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): transaction . on_commit ( do_something ) Official documentation Stripe docs for types of Events: https://stripe.com/docs/api/events/types Stripe docs for Webhooks: https://stripe.com/docs/webhooks Django docs for transactions: https://docs.djangoproject.com/en/dev/topics/db/transactions/#performing-actions-after-commit","title":"Using Stripe Webhooks"},{"location":"usage/webhooks/#using-stripe-webhooks","text":"","title":"Using Stripe Webhooks"},{"location":"usage/webhooks/#available-settings","text":"dj-stripe provides the following settings to tune how your webhooks work: DJSTRIPE_WEBHOOK_URL DJSTRIPE_WEBHOOK_SECRET DJSTRIPE_WEBHOOK_VALIDATION DJSTRIPE_WEBHOOK_TOLERANCE DJSTRIPE_WEBHOOK_EVENT_CALLBACK","title":"Available settings"},{"location":"usage/webhooks/#using-webhooks-in-dj-stripe","text":"dj-stripe comes with native support for webhooks as event listeners. Events allow you to do things like [sending an email to a customer when his payment has failed or trial period is ending. This is how you use them: from djstripe import webhooks @webhooks . handler ( \"customer.subscription.trial_will_end\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can handle all events related to customers like this: from djstripe import webhooks @webhooks . handler ( \"customer\" ) def my_handler ( event , ** kwargs ): print ( \"We should probably notify the user at this point\" ) You can also handle different events in the same handler: from djstripe import webhooks @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): print ( \"Triggered webhook \" + event . type ) Warning In order to get registrations picked up, you need to put them in a module that is imported like models.py or make sure you import it manually. Webhook event creation and processing is now wrapped in a transaction.atomic() block to better handle webhook errors. This will prevent any additional database modifications you may perform in your custom handler from being committed should something in the webhook processing chain fail. You can also take advantage of Django's transaction.on_commit() function to only perform an action if the transaction successfully commits (meaning the Event processing worked): from django.db import transaction from djstripe import webhooks def do_something (): pass # send a mail, invalidate a cache, fire off a Celery task, etc. @webhooks . handler ( \"price\" , \"product\" ) def my_handler ( event , ** kwargs ): transaction . on_commit ( do_something )","title":"Using webhooks in dj-stripe"},{"location":"usage/webhooks/#official-documentation","text":"Stripe docs for types of Events: https://stripe.com/docs/api/events/types Stripe docs for Webhooks: https://stripe.com/docs/webhooks Django docs for transactions: https://docs.djangoproject.com/en/dev/topics/db/transactions/#performing-actions-after-commit","title":"Official documentation"}]}